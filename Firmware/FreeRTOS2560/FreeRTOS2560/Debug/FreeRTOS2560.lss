
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000118  00800200  00004abe  00004b52  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00004abe  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000d01  00800318  00800318  00004c6a  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00004c6a  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000978  00000000  00000000  00004cc6  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00014418  00000000  00000000  0000563e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000039f5  00000000  00000000  00019a56  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00006633  00000000  00000000  0001d44b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00001dd0  00000000  00000000  00023a80  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00004473  00000000  00000000  00025850  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000996e  00000000  00000000  00029cc3  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000009e0  00000000  00000000  00033631  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	f7 c1       	rjmp	.+1006   	; 0x3f0 <__ctors_end>
       2:	00 00       	nop
       4:	25 c2       	rjmp	.+1098   	; 0x450 <__bad_interrupt>
       6:	00 00       	nop
       8:	23 c2       	rjmp	.+1094   	; 0x450 <__bad_interrupt>
       a:	00 00       	nop
       c:	21 c2       	rjmp	.+1090   	; 0x450 <__bad_interrupt>
       e:	00 00       	nop
      10:	1f c2       	rjmp	.+1086   	; 0x450 <__bad_interrupt>
      12:	00 00       	nop
      14:	1d c2       	rjmp	.+1082   	; 0x450 <__bad_interrupt>
      16:	00 00       	nop
      18:	1b c2       	rjmp	.+1078   	; 0x450 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	19 c2       	rjmp	.+1074   	; 0x450 <__bad_interrupt>
      1e:	00 00       	nop
      20:	17 c2       	rjmp	.+1070   	; 0x450 <__bad_interrupt>
      22:	00 00       	nop
      24:	15 c2       	rjmp	.+1066   	; 0x450 <__bad_interrupt>
      26:	00 00       	nop
      28:	13 c2       	rjmp	.+1062   	; 0x450 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	11 c2       	rjmp	.+1058   	; 0x450 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0f c2       	rjmp	.+1054   	; 0x450 <__bad_interrupt>
      32:	00 00       	nop
      34:	0c 94 31 13 	jmp	0x2662	; 0x2662 <__vector_13>
      38:	0b c2       	rjmp	.+1046   	; 0x450 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	09 c2       	rjmp	.+1042   	; 0x450 <__bad_interrupt>
      3e:	00 00       	nop
      40:	07 c2       	rjmp	.+1038   	; 0x450 <__bad_interrupt>
      42:	00 00       	nop
      44:	05 c2       	rjmp	.+1034   	; 0x450 <__bad_interrupt>
      46:	00 00       	nop
      48:	03 c2       	rjmp	.+1030   	; 0x450 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	01 c2       	rjmp	.+1026   	; 0x450 <__bad_interrupt>
      4e:	00 00       	nop
      50:	ff c1       	rjmp	.+1022   	; 0x450 <__bad_interrupt>
      52:	00 00       	nop
      54:	fd c1       	rjmp	.+1018   	; 0x450 <__bad_interrupt>
      56:	00 00       	nop
      58:	fb c1       	rjmp	.+1014   	; 0x450 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	0c 94 7d 1f 	jmp	0x3efa	; 0x3efa <__vector_23>
      60:	f7 c1       	rjmp	.+1006   	; 0x450 <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 b9 1d 	jmp	0x3b72	; 0x3b72 <__vector_25>
      68:	0c 94 f8 1d 	jmp	0x3bf0	; 0x3bf0 <__vector_26>
      6c:	f1 c1       	rjmp	.+994    	; 0x450 <__bad_interrupt>
      6e:	00 00       	nop
      70:	ef c1       	rjmp	.+990    	; 0x450 <__bad_interrupt>
      72:	00 00       	nop
      74:	ed c1       	rjmp	.+986    	; 0x450 <__bad_interrupt>
      76:	00 00       	nop
      78:	eb c1       	rjmp	.+982    	; 0x450 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	e9 c1       	rjmp	.+978    	; 0x450 <__bad_interrupt>
      7e:	00 00       	nop
      80:	e7 c1       	rjmp	.+974    	; 0x450 <__bad_interrupt>
      82:	00 00       	nop
      84:	e5 c1       	rjmp	.+970    	; 0x450 <__bad_interrupt>
      86:	00 00       	nop
      88:	e3 c1       	rjmp	.+966    	; 0x450 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	e1 c1       	rjmp	.+962    	; 0x450 <__bad_interrupt>
      8e:	00 00       	nop
      90:	0c 94 64 1e 	jmp	0x3cc8	; 0x3cc8 <__vector_36>
      94:	0c 94 a3 1e 	jmp	0x3d46	; 0x3d46 <__vector_37>
      98:	db c1       	rjmp	.+950    	; 0x450 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	0c 94 ab 17 	jmp	0x2f56	; 0x2f56 <__vector_39>
      a0:	d7 c1       	rjmp	.+942    	; 0x450 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	d5 c1       	rjmp	.+938    	; 0x450 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	d3 c1       	rjmp	.+934    	; 0x450 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	d1 c1       	rjmp	.+930    	; 0x450 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	cf c1       	rjmp	.+926    	; 0x450 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	0c 94 8f 11 	jmp	0x231e	; 0x231e <__vector_45>
      b8:	cb c1       	rjmp	.+918    	; 0x450 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	c9 c1       	rjmp	.+914    	; 0x450 <__bad_interrupt>
      be:	00 00       	nop
      c0:	c7 c1       	rjmp	.+910    	; 0x450 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	c5 c1       	rjmp	.+906    	; 0x450 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	c3 c1       	rjmp	.+902    	; 0x450 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	c1 c1       	rjmp	.+898    	; 0x450 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	bf c1       	rjmp	.+894    	; 0x450 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	bd c1       	rjmp	.+890    	; 0x450 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	bb c1       	rjmp	.+886    	; 0x450 <__bad_interrupt>
      da:	00 00       	nop
      dc:	b9 c1       	rjmp	.+882    	; 0x450 <__bad_interrupt>
      de:	00 00       	nop
      e0:	b7 c1       	rjmp	.+878    	; 0x450 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	b1 18       	sub	r11, r1
      e6:	b4 18       	sub	r11, r4
      e8:	b4 18       	sub	r11, r4
      ea:	b4 18       	sub	r11, r4
      ec:	b4 18       	sub	r11, r4
      ee:	b4 18       	sub	r11, r4
      f0:	b4 18       	sub	r11, r4
      f2:	b4 18       	sub	r11, r4
      f4:	cb 17       	cp	r28, r27
      f6:	b4 18       	sub	r11, r4
      f8:	b4 18       	sub	r11, r4
      fa:	b4 18       	sub	r11, r4
      fc:	b4 18       	sub	r11, r4
      fe:	b4 18       	sub	r11, r4
     100:	b4 18       	sub	r11, r4
     102:	b4 18       	sub	r11, r4
     104:	cb 17       	cp	r28, r27
     106:	b4 18       	sub	r11, r4
     108:	b4 18       	sub	r11, r4
     10a:	b4 18       	sub	r11, r4
     10c:	b4 18       	sub	r11, r4
     10e:	b4 18       	sub	r11, r4
     110:	b4 18       	sub	r11, r4
     112:	b4 18       	sub	r11, r4
     114:	d3 17       	cp	r29, r19
     116:	b4 18       	sub	r11, r4
     118:	b4 18       	sub	r11, r4
     11a:	b4 18       	sub	r11, r4
     11c:	b4 18       	sub	r11, r4
     11e:	b4 18       	sub	r11, r4
     120:	b4 18       	sub	r11, r4
     122:	b4 18       	sub	r11, r4
     124:	f8 17       	cp	r31, r24
     126:	b4 18       	sub	r11, r4
     128:	b4 18       	sub	r11, r4
     12a:	b4 18       	sub	r11, r4
     12c:	b4 18       	sub	r11, r4
     12e:	b4 18       	sub	r11, r4
     130:	b4 18       	sub	r11, r4
     132:	b4 18       	sub	r11, r4
     134:	d3 17       	cp	r29, r19
     136:	b4 18       	sub	r11, r4
     138:	b4 18       	sub	r11, r4
     13a:	b4 18       	sub	r11, r4
     13c:	b4 18       	sub	r11, r4
     13e:	b4 18       	sub	r11, r4
     140:	b4 18       	sub	r11, r4
     142:	b4 18       	sub	r11, r4
     144:	fd 17       	cp	r31, r29
     146:	b4 18       	sub	r11, r4
     148:	b4 18       	sub	r11, r4
     14a:	b4 18       	sub	r11, r4
     14c:	b4 18       	sub	r11, r4
     14e:	b4 18       	sub	r11, r4
     150:	b4 18       	sub	r11, r4
     152:	b4 18       	sub	r11, r4
     154:	02 18       	sub	r0, r2
     156:	b4 18       	sub	r11, r4
     158:	b4 18       	sub	r11, r4
     15a:	b4 18       	sub	r11, r4
     15c:	b4 18       	sub	r11, r4
     15e:	b4 18       	sub	r11, r4
     160:	b4 18       	sub	r11, r4
     162:	b4 18       	sub	r11, r4
     164:	13 18       	sub	r1, r3
     166:	b4 18       	sub	r11, r4
     168:	b4 18       	sub	r11, r4
     16a:	b4 18       	sub	r11, r4
     16c:	b4 18       	sub	r11, r4
     16e:	b4 18       	sub	r11, r4
     170:	b4 18       	sub	r11, r4
     172:	b4 18       	sub	r11, r4
     174:	3c 18       	sub	r3, r12
     176:	b4 18       	sub	r11, r4
     178:	b4 18       	sub	r11, r4
     17a:	b4 18       	sub	r11, r4
     17c:	b4 18       	sub	r11, r4
     17e:	b4 18       	sub	r11, r4
     180:	b4 18       	sub	r11, r4
     182:	b4 18       	sub	r11, r4
     184:	07 18       	sub	r0, r7
     186:	b4 18       	sub	r11, r4
     188:	b4 18       	sub	r11, r4
     18a:	b4 18       	sub	r11, r4
     18c:	b4 18       	sub	r11, r4
     18e:	b4 18       	sub	r11, r4
     190:	b4 18       	sub	r11, r4
     192:	b4 18       	sub	r11, r4
     194:	21 18       	sub	r2, r1
     196:	b4 18       	sub	r11, r4
     198:	b4 18       	sub	r11, r4
     19a:	b4 18       	sub	r11, r4
     19c:	b4 18       	sub	r11, r4
     19e:	b4 18       	sub	r11, r4
     1a0:	b4 18       	sub	r11, r4
     1a2:	b4 18       	sub	r11, r4
     1a4:	3e 18       	sub	r3, r14
     1a6:	b4 18       	sub	r11, r4
     1a8:	b4 18       	sub	r11, r4
     1aa:	b4 18       	sub	r11, r4
     1ac:	b4 18       	sub	r11, r4
     1ae:	b4 18       	sub	r11, r4
     1b0:	b4 18       	sub	r11, r4
     1b2:	b4 18       	sub	r11, r4
     1b4:	3e 18       	sub	r3, r14
     1b6:	b4 18       	sub	r11, r4
     1b8:	b4 18       	sub	r11, r4
     1ba:	b4 18       	sub	r11, r4
     1bc:	b4 18       	sub	r11, r4
     1be:	b4 18       	sub	r11, r4
     1c0:	b4 18       	sub	r11, r4
     1c2:	b4 18       	sub	r11, r4
     1c4:	3e 18       	sub	r3, r14
     1c6:	b4 18       	sub	r11, r4
     1c8:	b4 18       	sub	r11, r4
     1ca:	b4 18       	sub	r11, r4
     1cc:	b4 18       	sub	r11, r4
     1ce:	b4 18       	sub	r11, r4
     1d0:	b4 18       	sub	r11, r4
     1d2:	b4 18       	sub	r11, r4
     1d4:	3e 18       	sub	r3, r14
     1d6:	b4 18       	sub	r11, r4
     1d8:	b4 18       	sub	r11, r4
     1da:	b4 18       	sub	r11, r4
     1dc:	b4 18       	sub	r11, r4
     1de:	b4 18       	sub	r11, r4
     1e0:	b4 18       	sub	r11, r4
     1e2:	b4 18       	sub	r11, r4
     1e4:	47 18       	sub	r4, r7
     1e6:	b4 18       	sub	r11, r4
     1e8:	b4 18       	sub	r11, r4
     1ea:	b4 18       	sub	r11, r4
     1ec:	b4 18       	sub	r11, r4
     1ee:	b4 18       	sub	r11, r4
     1f0:	b4 18       	sub	r11, r4
     1f2:	b4 18       	sub	r11, r4
     1f4:	78 18       	sub	r7, r8
     1f6:	b4 18       	sub	r11, r4
     1f8:	b4 18       	sub	r11, r4
     1fa:	b4 18       	sub	r11, r4
     1fc:	b4 18       	sub	r11, r4
     1fe:	b4 18       	sub	r11, r4
     200:	b4 18       	sub	r11, r4
     202:	b4 18       	sub	r11, r4
     204:	47 18       	sub	r4, r7
     206:	b4 18       	sub	r11, r4
     208:	b4 18       	sub	r11, r4
     20a:	b4 18       	sub	r11, r4
     20c:	b4 18       	sub	r11, r4
     20e:	b4 18       	sub	r11, r4
     210:	b4 18       	sub	r11, r4
     212:	b4 18       	sub	r11, r4
     214:	78 18       	sub	r7, r8
     216:	b4 18       	sub	r11, r4
     218:	b4 18       	sub	r11, r4
     21a:	b4 18       	sub	r11, r4
     21c:	b4 18       	sub	r11, r4
     21e:	b4 18       	sub	r11, r4
     220:	b4 18       	sub	r11, r4
     222:	b4 18       	sub	r11, r4
     224:	5f 18       	sub	r5, r15
     226:	b4 18       	sub	r11, r4
     228:	b4 18       	sub	r11, r4
     22a:	b4 18       	sub	r11, r4
     22c:	b4 18       	sub	r11, r4
     22e:	b4 18       	sub	r11, r4
     230:	b4 18       	sub	r11, r4
     232:	b4 18       	sub	r11, r4
     234:	7c 18       	sub	r7, r12
     236:	b4 18       	sub	r11, r4
     238:	b4 18       	sub	r11, r4
     23a:	b4 18       	sub	r11, r4
     23c:	b4 18       	sub	r11, r4
     23e:	b4 18       	sub	r11, r4
     240:	b4 18       	sub	r11, r4
     242:	b4 18       	sub	r11, r4
     244:	7c 18       	sub	r7, r12
     246:	b4 18       	sub	r11, r4
     248:	b4 18       	sub	r11, r4
     24a:	b4 18       	sub	r11, r4
     24c:	b4 18       	sub	r11, r4
     24e:	b4 18       	sub	r11, r4
     250:	b4 18       	sub	r11, r4
     252:	b4 18       	sub	r11, r4
     254:	91 18       	sub	r9, r1
     256:	b4 18       	sub	r11, r4
     258:	b4 18       	sub	r11, r4
     25a:	b4 18       	sub	r11, r4
     25c:	b4 18       	sub	r11, r4
     25e:	b4 18       	sub	r11, r4
     260:	b4 18       	sub	r11, r4
     262:	b4 18       	sub	r11, r4
     264:	ab 18       	sub	r10, r11
     266:	b4 18       	sub	r11, r4
     268:	b4 18       	sub	r11, r4
     26a:	b4 18       	sub	r11, r4
     26c:	b4 18       	sub	r11, r4
     26e:	b4 18       	sub	r11, r4
     270:	b4 18       	sub	r11, r4
     272:	b4 18       	sub	r11, r4
     274:	ab 18       	sub	r10, r11
     276:	08 4a       	sbci	r16, 0xA8	; 168
     278:	d7 3b       	cpi	r29, 0xB7	; 183
     27a:	3b ce       	rjmp	.-906    	; 0xfffffef2 <__eeprom_end+0xff7efef2>
     27c:	01 6e       	ori	r16, 0xE1	; 225
     27e:	84 bc       	out	0x24, r8	; 36
     280:	bf fd       	.word	0xfdbf	; ????
     282:	c1 2f       	mov	r28, r17
     284:	3d 6c       	ori	r19, 0xCD	; 205
     286:	74 31       	cpi	r23, 0x14	; 20
     288:	9a bd       	out	0x2a, r25	; 42
     28a:	56 83       	std	Z+6, r21	; 0x06
     28c:	3d da       	rcall	.-2950   	; 0xfffff708 <__eeprom_end+0xff7ef708>
     28e:	3d 00       	.word	0x003d	; ????
     290:	c7 7f       	andi	r28, 0xF7	; 247
     292:	11 be       	out	0x31, r1	; 49
     294:	d9 e4       	ldi	r29, 0x49	; 73
     296:	bb 4c       	sbci	r27, 0xCB	; 203
     298:	3e 91       	ld	r19, -X
     29a:	6b aa       	std	Y+51, r6	; 0x33
     29c:	aa be       	out	0x3a, r10	; 58
     29e:	00 00       	nop
     2a0:	00 80       	ld	r0, Z
     2a2:	3f 00       	.word	0x003f	; ????
     2a4:	ab 20       	and	r10, r11
     2a6:	af 20       	and	r10, r15
     2a8:	99 20       	and	r9, r9
     2aa:	9f 20       	and	r9, r15
     2ac:	a5 20       	and	r10, r5
     2ae:	f4 20       	and	r15, r4
     2b0:	b3 20       	and	r11, r3
     2b2:	b9 20       	and	r11, r9
     2b4:	bf 20       	and	r11, r15
     2b6:	c5 20       	and	r12, r5
     2b8:	cb 20       	and	r12, r11
     2ba:	d1 20       	and	r13, r1
     2bc:	d7 20       	and	r13, r7
     2be:	dd 20       	and	r13, r13
     2c0:	f4 20       	and	r15, r4
     2c2:	e3 20       	and	r14, r3
     2c4:	e9 20       	and	r14, r9
     2c6:	ef 20       	and	r14, r15

000002c8 <__trampolines_end>:
     2c8:	00 00       	nop
     2ca:	0a 0b       	sbc	r16, r26
     2cc:	02 09       	sbc	r16, r2
     2ce:	0c 0d       	add	r16, r12
     2d0:	0e 08       	sbc	r0, r14
     2d2:	07 03       	mulsu	r16, r23
     2d4:	04 01       	movw	r0, r8
	...
     2f2:	00 00       	nop
     2f4:	12 11       	cpse	r17, r2
     2f6:	10 00       	.word	0x0010	; ????
	...

0000030e <digital_pin_to_bit_mask_PGM>:
     30e:	01 02 10 20 20 08 08 10 20 40 10 20 40 80 02 01     ...  ... @. @...
     31e:	02 01 08 04 02 01 01 02 04 08 10 20 40 80 80 40     ........... @..@
     32e:	20 10 08 04 02 01 80 04 02 01 80 40 20 10 08 04      ..........@ ...
     33e:	02 01 08 04 02 01 01 02 04 08 10 20 40 80 01 02     ........... @...
     34e:	04 08 10 20 40 80                                   ... @.

00000354 <digital_pin_to_port_PGM>:
     354:	05 05 05 05 07 05 08 08 08 08 02 02 02 02 0a 0a     ................
     364:	08 08 04 04 04 04 01 01 01 01 01 01 01 01 03 03     ................
     374:	03 03 03 03 03 03 04 07 07 07 0c 0c 0c 0c 0c 0c     ................
     384:	0c 0c 02 02 02 02 06 06 06 06 06 06 06 06 0b 0b     ................
     394:	0b 0b 0b 0b 0b 0b                                   ......

0000039a <port_to_input_PGM>:
     39a:	00 00 20 00 23 00 26 00 29 00 2c 00 2f 00 32 00     .. .#.&.).,./.2.
     3aa:	00 01 00 00 03 01 06 01 09 01                       ..........

000003b4 <port_to_output_PGM>:
     3b4:	00 00 22 00 25 00 28 00 2b 00 2e 00 31 00 34 00     ..".%.(.+...1.4.
     3c4:	02 01 00 00 05 01 08 01 0b 01                       ..........

000003ce <port_to_mode_PGM>:
     3ce:	00 00 21 00 24 00 27 00 2a 00 2d 00 30 00 33 00     ..!.$.'.*.-.0.3.
     3de:	01 01 00 00 04 01 07 01 0a 01                       ..........

000003e8 <__ctors_start>:
     3e8:	31 03       	mulsu	r19, r17
     3ea:	99 19       	sub	r25, r9
     3ec:	21 1e       	adc	r2, r17
     3ee:	cc 1e       	adc	r12, r28

000003f0 <__ctors_end>:
     3f0:	11 24       	eor	r1, r1
     3f2:	1f be       	out	0x3f, r1	; 63
     3f4:	cf ef       	ldi	r28, 0xFF	; 255
     3f6:	d1 e2       	ldi	r29, 0x21	; 33
     3f8:	de bf       	out	0x3e, r29	; 62
     3fa:	cd bf       	out	0x3d, r28	; 61
     3fc:	00 e0       	ldi	r16, 0x00	; 0
     3fe:	0c bf       	out	0x3c, r16	; 60

00000400 <__do_copy_data>:
     400:	13 e0       	ldi	r17, 0x03	; 3
     402:	a0 e0       	ldi	r26, 0x00	; 0
     404:	b2 e0       	ldi	r27, 0x02	; 2
     406:	ee eb       	ldi	r30, 0xBE	; 190
     408:	fa e4       	ldi	r31, 0x4A	; 74
     40a:	00 e0       	ldi	r16, 0x00	; 0
     40c:	0b bf       	out	0x3b, r16	; 59
     40e:	02 c0       	rjmp	.+4      	; 0x414 <__do_copy_data+0x14>
     410:	07 90       	elpm	r0, Z+
     412:	0d 92       	st	X+, r0
     414:	a8 31       	cpi	r26, 0x18	; 24
     416:	b1 07       	cpc	r27, r17
     418:	d9 f7       	brne	.-10     	; 0x410 <__do_copy_data+0x10>

0000041a <__do_clear_bss>:
     41a:	20 e1       	ldi	r18, 0x10	; 16
     41c:	a8 e1       	ldi	r26, 0x18	; 24
     41e:	b3 e0       	ldi	r27, 0x03	; 3
     420:	01 c0       	rjmp	.+2      	; 0x424 <.do_clear_bss_start>

00000422 <.do_clear_bss_loop>:
     422:	1d 92       	st	X+, r1

00000424 <.do_clear_bss_start>:
     424:	a9 31       	cpi	r26, 0x19	; 25
     426:	b2 07       	cpc	r27, r18
     428:	e1 f7       	brne	.-8      	; 0x422 <.do_clear_bss_loop>

0000042a <__do_global_ctors>:
     42a:	13 e0       	ldi	r17, 0x03	; 3
     42c:	c0 ef       	ldi	r28, 0xF0	; 240
     42e:	d3 e0       	ldi	r29, 0x03	; 3
     430:	00 e0       	ldi	r16, 0x00	; 0
     432:	06 c0       	rjmp	.+12     	; 0x440 <__do_global_ctors+0x16>
     434:	22 97       	sbiw	r28, 0x02	; 2
     436:	01 09       	sbc	r16, r1
     438:	fe 01       	movw	r30, r28
     43a:	0b bf       	out	0x3b, r16	; 59
     43c:	0e 94 9d 22 	call	0x453a	; 0x453a <__tablejump_elpm__>
     440:	c8 3e       	cpi	r28, 0xE8	; 232
     442:	d1 07       	cpc	r29, r17
     444:	80 e0       	ldi	r24, 0x00	; 0
     446:	08 07       	cpc	r16, r24
     448:	a9 f7       	brne	.-22     	; 0x434 <__do_global_ctors+0xa>
     44a:	a7 d0       	rcall	.+334    	; 0x59a <main>
     44c:	0c 94 5d 25 	jmp	0x4aba	; 0x4aba <_exit>

00000450 <__bad_interrupt>:
     450:	d7 cd       	rjmp	.-1106   	; 0x0 <__vectors>

00000452 <setup>:
		if (inByte == '0') { //receive 0ACK
			debugPrint("$");
			break;
		}
	}
}
     452:	26 e0       	ldi	r18, 0x06	; 6
     454:	40 e0       	ldi	r20, 0x00	; 0
     456:	52 ec       	ldi	r21, 0xC2	; 194
     458:	61 e0       	ldi	r22, 0x01	; 1
     45a:	70 e0       	ldi	r23, 0x00	; 0
     45c:	86 ed       	ldi	r24, 0xD6	; 214
     45e:	9e e0       	ldi	r25, 0x0E	; 14
     460:	0e 94 55 1d 	call	0x3aaa	; 0x3aaa <_ZN14HardwareSerial5beginEmh>
     464:	84 e8       	ldi	r24, 0x84	; 132
     466:	9e e0       	ldi	r25, 0x0E	; 14
     468:	0e 94 61 19 	call	0x32c2	; 0x32c2 <_ZN7TwoWire5beginEv>
     46c:	42 e0       	ldi	r20, 0x02	; 2
     46e:	63 e0       	ldi	r22, 0x03	; 3
     470:	82 ea       	ldi	r24, 0xA2	; 162
     472:	97 e0       	ldi	r25, 0x07	; 7
     474:	cf d7       	rcall	.+3998   	; 0x1414 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE>
     476:	82 ea       	ldi	r24, 0xA2	; 162
     478:	97 e0       	ldi	r25, 0x07	; 7
     47a:	8b d7       	rcall	.+3862   	; 0x1392 <_ZN3L3G13enableDefaultEv>
     47c:	8e ea       	ldi	r24, 0xAE	; 174
     47e:	97 e0       	ldi	r25, 0x07	; 7
     480:	0e 94 5e 0b 	call	0x16bc	; 0x16bc <_ZN3LPS13enableDefaultEv>
     484:	10 92 1d 07 	sts	0x071D, r1
     488:	10 92 1c 07 	sts	0x071C, r1
     48c:	42 e0       	ldi	r20, 0x02	; 2
     48e:	64 e0       	ldi	r22, 0x04	; 4
     490:	85 eb       	ldi	r24, 0xB5	; 181
     492:	97 e0       	ldi	r25, 0x07	; 7
     494:	0e 94 b3 10 	call	0x2166	; 0x2166 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE>
     498:	85 eb       	ldi	r24, 0xB5	; 181
     49a:	97 e0       	ldi	r25, 0x07	; 7
     49c:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <_ZN6LSM30313enableDefaultEv>
     4a0:	61 e0       	ldi	r22, 0x01	; 1
     4a2:	89 e2       	ldi	r24, 0x29	; 41
     4a4:	0e 94 f5 20 	call	0x41ea	; 0x41ea <pinMode>
     4a8:	60 e0       	ldi	r22, 0x00	; 0
     4aa:	8a e2       	ldi	r24, 0x2A	; 42
     4ac:	0e 94 f5 20 	call	0x41ea	; 0x41ea <pinMode>
     4b0:	61 e0       	ldi	r22, 0x01	; 1
     4b2:	85 e2       	ldi	r24, 0x25	; 37
     4b4:	0e 94 f5 20 	call	0x41ea	; 0x41ea <pinMode>
     4b8:	60 e0       	ldi	r22, 0x00	; 0
     4ba:	84 e2       	ldi	r24, 0x24	; 36
     4bc:	0e 94 f5 20 	call	0x41ea	; 0x41ea <pinMode>
     4c0:	61 e0       	ldi	r22, 0x01	; 1
     4c2:	88 e2       	ldi	r24, 0x28	; 40
     4c4:	0e 94 f5 20 	call	0x41ea	; 0x41ea <pinMode>
     4c8:	60 e0       	ldi	r22, 0x00	; 0
     4ca:	87 e2       	ldi	r24, 0x27	; 39
     4cc:	0e 94 f5 20 	call	0x41ea	; 0x41ea <pinMode>
     4d0:	61 e0       	ldi	r22, 0x01	; 1
     4d2:	8b e2       	ldi	r24, 0x2B	; 43
     4d4:	0e 94 f5 20 	call	0x41ea	; 0x41ea <pinMode>
     4d8:	60 e0       	ldi	r22, 0x00	; 0
     4da:	8c e2       	ldi	r24, 0x2C	; 44
     4dc:	0e 94 f5 20 	call	0x41ea	; 0x41ea <pinMode>
     4e0:	61 e0       	ldi	r22, 0x01	; 1
     4e2:	8a e0       	ldi	r24, 0x0A	; 10
     4e4:	0e 94 f5 20 	call	0x41ea	; 0x41ea <pinMode>
     4e8:	60 e0       	ldi	r22, 0x00	; 0
     4ea:	8b e0       	ldi	r24, 0x0B	; 11
     4ec:	0e 94 f5 20 	call	0x41ea	; 0x41ea <pinMode>
     4f0:	61 e0       	ldi	r22, 0x01	; 1
     4f2:	84 e3       	ldi	r24, 0x34	; 52
     4f4:	0e 94 f5 20 	call	0x41ea	; 0x41ea <pinMode>
     4f8:	86 e0       	ldi	r24, 0x06	; 6
     4fa:	e7 e1       	ldi	r30, 0x17	; 23
     4fc:	f2 e0       	ldi	r31, 0x02	; 2
     4fe:	a7 ec       	ldi	r26, 0xC7	; 199
     500:	b7 e0       	ldi	r27, 0x07	; 7
     502:	01 90       	ld	r0, Z+
     504:	0d 92       	st	X+, r0
     506:	8a 95       	dec	r24
     508:	e1 f7       	brne	.-8      	; 0x502 <setup+0xb0>
     50a:	86 e0       	ldi	r24, 0x06	; 6
     50c:	ed e1       	ldi	r30, 0x1D	; 29
     50e:	f2 e0       	ldi	r31, 0x02	; 2
     510:	a1 ec       	ldi	r26, 0xC1	; 193
     512:	b7 e0       	ldi	r27, 0x07	; 7
     514:	01 90       	ld	r0, Z+
     516:	0d 92       	st	X+, r0
     518:	8a 95       	dec	r24
     51a:	e1 f7       	brne	.-8      	; 0x514 <setup+0xc2>
     51c:	08 95       	ret

0000051e <_Z10sonar_readii>:
     51e:	cf 93       	push	r28
     520:	df 93       	push	r29
     522:	c8 2f       	mov	r28, r24
     524:	d6 2f       	mov	r29, r22
     526:	60 e0       	ldi	r22, 0x00	; 0
     528:	0e 94 33 21 	call	0x4266	; 0x4266 <digitalWrite>
     52c:	82 e0       	ldi	r24, 0x02	; 2
     52e:	90 e0       	ldi	r25, 0x00	; 0
     530:	0e 94 22 20 	call	0x4044	; 0x4044 <delayMicroseconds>
     534:	61 e0       	ldi	r22, 0x01	; 1
     536:	8c 2f       	mov	r24, r28
     538:	0e 94 33 21 	call	0x4266	; 0x4266 <digitalWrite>
     53c:	8a e0       	ldi	r24, 0x0A	; 10
     53e:	90 e0       	ldi	r25, 0x00	; 0
     540:	0e 94 22 20 	call	0x4044	; 0x4044 <delayMicroseconds>
     544:	60 e0       	ldi	r22, 0x00	; 0
     546:	8c 2f       	mov	r24, r28
     548:	0e 94 33 21 	call	0x4266	; 0x4266 <digitalWrite>
     54c:	60 e0       	ldi	r22, 0x00	; 0
     54e:	8d 2f       	mov	r24, r29
     550:	0e 94 f5 20 	call	0x41ea	; 0x41ea <pinMode>
     554:	20 ea       	ldi	r18, 0xA0	; 160
     556:	36 e8       	ldi	r19, 0x86	; 134
     558:	41 e0       	ldi	r20, 0x01	; 1
     55a:	50 e0       	ldi	r21, 0x00	; 0
     55c:	61 e0       	ldi	r22, 0x01	; 1
     55e:	8d 2f       	mov	r24, r29
     560:	0e 94 8c 21 	call	0x4318	; 0x4318 <pulseIn>
     564:	0e 94 01 1b 	call	0x3602	; 0x3602 <__floatunsisf>
     568:	60 93 86 07 	sts	0x0786, r22
     56c:	70 93 87 07 	sts	0x0787, r23
     570:	80 93 88 07 	sts	0x0788, r24
     574:	90 93 89 07 	sts	0x0789, r25
     578:	2d ec       	ldi	r18, 0xCD	; 205
     57a:	3c ec       	ldi	r19, 0xCC	; 204
     57c:	48 e6       	ldi	r20, 0x68	; 104
     57e:	52 e4       	ldi	r21, 0x42	; 66
     580:	0e 94 68 1a 	call	0x34d0	; 0x34d0 <__divsf3>
     584:	60 93 82 07 	sts	0x0782, r22
     588:	70 93 83 07 	sts	0x0783, r23
     58c:	80 93 84 07 	sts	0x0784, r24
     590:	90 93 85 07 	sts	0x0785, r25
     594:	df 91       	pop	r29
     596:	cf 91       	pop	r28
     598:	08 95       	ret

0000059a <main>:
     59a:	af 92       	push	r10
     59c:	bf 92       	push	r11
     59e:	cf 92       	push	r12
     5a0:	df 92       	push	r13
     5a2:	ef 92       	push	r14
     5a4:	ff 92       	push	r15
     5a6:	0f 93       	push	r16
     5a8:	cf 93       	push	r28
     5aa:	df 93       	push	r29
     5ac:	cd b7       	in	r28, 0x3d	; 61
     5ae:	de b7       	in	r29, 0x3e	; 62
     5b0:	28 97       	sbiw	r28, 0x08	; 8
     5b2:	0f b6       	in	r0, 0x3f	; 63
     5b4:	f8 94       	cli
     5b6:	de bf       	out	0x3e, r29	; 62
     5b8:	0f be       	out	0x3f, r0	; 63
     5ba:	cd bf       	out	0x3d, r28	; 61
     5bc:	0e 94 2d 20 	call	0x405a	; 0x405a <init>
     5c0:	48 df       	rcall	.-368    	; 0x452 <setup>
     5c2:	a1 2c       	mov	r10, r1
     5c4:	b1 2c       	mov	r11, r1
     5c6:	c1 2c       	mov	r12, r1
     5c8:	d1 2c       	mov	r13, r1
     5ca:	ce 01       	movw	r24, r28
     5cc:	07 96       	adiw	r24, 0x07	; 7
     5ce:	7c 01       	movw	r14, r24
     5d0:	05 e0       	ldi	r16, 0x05	; 5
     5d2:	20 e0       	ldi	r18, 0x00	; 0
     5d4:	30 e0       	ldi	r19, 0x00	; 0
     5d6:	40 e0       	ldi	r20, 0x00	; 0
     5d8:	51 e0       	ldi	r21, 0x01	; 1
     5da:	6f e2       	ldi	r22, 0x2F	; 47
     5dc:	72 e0       	ldi	r23, 0x02	; 2
     5de:	8d e8       	ldi	r24, 0x8D	; 141
     5e0:	93 e0       	ldi	r25, 0x03	; 3
     5e2:	0e 94 89 13 	call	0x2712	; 0x2712 <xTaskGenericCreate>
     5e6:	ce 01       	movw	r24, r28
     5e8:	05 96       	adiw	r24, 0x05	; 5
     5ea:	7c 01       	movw	r14, r24
     5ec:	07 e0       	ldi	r16, 0x07	; 7
     5ee:	20 e0       	ldi	r18, 0x00	; 0
     5f0:	30 e0       	ldi	r19, 0x00	; 0
     5f2:	40 e8       	ldi	r20, 0x80	; 128
     5f4:	50 e0       	ldi	r21, 0x00	; 0
     5f6:	6c e3       	ldi	r22, 0x3C	; 60
     5f8:	72 e0       	ldi	r23, 0x02	; 2
     5fa:	86 e8       	ldi	r24, 0x86	; 134
     5fc:	94 e0       	ldi	r25, 0x04	; 4
     5fe:	0e 94 89 13 	call	0x2712	; 0x2712 <xTaskGenericCreate>
     602:	ce 01       	movw	r24, r28
     604:	03 96       	adiw	r24, 0x03	; 3
     606:	7c 01       	movw	r14, r24
     608:	06 e0       	ldi	r16, 0x06	; 6
     60a:	20 e0       	ldi	r18, 0x00	; 0
     60c:	30 e0       	ldi	r19, 0x00	; 0
     60e:	40 e8       	ldi	r20, 0x80	; 128
     610:	50 e0       	ldi	r21, 0x00	; 0
     612:	6d e4       	ldi	r22, 0x4D	; 77
     614:	72 e0       	ldi	r23, 0x02	; 2
     616:	8b e6       	ldi	r24, 0x6B	; 107
     618:	93 e0       	ldi	r25, 0x03	; 3
     61a:	0e 94 89 13 	call	0x2712	; 0x2712 <xTaskGenericCreate>
     61e:	ce 01       	movw	r24, r28
     620:	01 96       	adiw	r24, 0x01	; 1
     622:	7c 01       	movw	r14, r24
     624:	05 e0       	ldi	r16, 0x05	; 5
     626:	20 e0       	ldi	r18, 0x00	; 0
     628:	30 e0       	ldi	r19, 0x00	; 0
     62a:	40 e8       	ldi	r20, 0x80	; 128
     62c:	50 e0       	ldi	r21, 0x00	; 0
     62e:	69 e5       	ldi	r22, 0x59	; 89
     630:	72 e0       	ldi	r23, 0x02	; 2
     632:	89 e7       	ldi	r24, 0x79	; 121
     634:	95 e0       	ldi	r25, 0x05	; 5
     636:	0e 94 89 13 	call	0x2712	; 0x2712 <xTaskGenericCreate>
     63a:	0e 94 91 14 	call	0x2922	; 0x2922 <vTaskStartScheduler>
     63e:	80 e0       	ldi	r24, 0x00	; 0
     640:	90 e0       	ldi	r25, 0x00	; 0
     642:	28 96       	adiw	r28, 0x08	; 8
     644:	0f b6       	in	r0, 0x3f	; 63
     646:	f8 94       	cli
     648:	de bf       	out	0x3e, r29	; 62
     64a:	0f be       	out	0x3f, r0	; 63
     64c:	cd bf       	out	0x3d, r28	; 61
     64e:	df 91       	pop	r29
     650:	cf 91       	pop	r28
     652:	0f 91       	pop	r16
     654:	ff 90       	pop	r15
     656:	ef 90       	pop	r14
     658:	df 90       	pop	r13
     65a:	cf 90       	pop	r12
     65c:	bf 90       	pop	r11
     65e:	af 90       	pop	r10
     660:	08 95       	ret

00000662 <_GLOBAL__sub_I_compass>:
     662:	ef 92       	push	r14
     664:	0f 93       	push	r16
     666:	85 eb       	ldi	r24, 0xB5	; 181
     668:	97 e0       	ldi	r25, 0x07	; 7
     66a:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <_ZN6LSM303C1Ev>
     66e:	8e ea       	ldi	r24, 0xAE	; 174
     670:	97 e0       	ldi	r25, 0x07	; 7
     672:	f2 d7       	rcall	.+4068   	; 0x1658 <_ZN3LPSC1Ev>
     674:	82 ea       	ldi	r24, 0xA2	; 162
     676:	97 e0       	ldi	r25, 0x07	; 7
     678:	65 d6       	rcall	.+3274   	; 0x1344 <_ZN3L3GC1Ev>
     67a:	0f 2e       	mov	r0, r31
     67c:	f3 e0       	ldi	r31, 0x03	; 3
     67e:	ef 2e       	mov	r14, r31
     680:	f0 2d       	mov	r31, r0
     682:	04 e0       	ldi	r16, 0x04	; 4
     684:	20 e0       	ldi	r18, 0x00	; 0
     686:	32 e0       	ldi	r19, 0x02	; 2
     688:	43 e0       	ldi	r20, 0x03	; 3
     68a:	52 e0       	ldi	r21, 0x02	; 2
     68c:	67 e0       	ldi	r22, 0x07	; 7
     68e:	72 e0       	ldi	r23, 0x02	; 2
     690:	8e e1       	ldi	r24, 0x1E	; 30
     692:	97 e0       	ldi	r25, 0x07	; 7
     694:	24 d3       	rcall	.+1608   	; 0xcde <_ZN6KeypadC1EPcPhS1_hh>
     696:	0f 91       	pop	r16
     698:	ef 90       	pop	r14
     69a:	08 95       	ret

0000069c <_Z10debugPrintPKc>:
     69c:	bc 01       	movw	r22, r24
     69e:	86 ed       	ldi	r24, 0xD6	; 214
     6a0:	9e e0       	ldi	r25, 0x0E	; 14
     6a2:	0e 94 6d 1f 	call	0x3eda	; 0x3eda <_ZN5Print7printlnEPKc>
     6a6:	86 ed       	ldi	r24, 0xD6	; 214
     6a8:	9e e0       	ldi	r25, 0x0E	; 14
     6aa:	0c 94 ee 1c 	jmp	0x39dc	; 0x39dc <_ZN14HardwareSerial5flushEv>
     6ae:	08 95       	ret

000006b0 <_Z7dprintfPKcz>:
     6b0:	cf 93       	push	r28
     6b2:	df 93       	push	r29
     6b4:	cd b7       	in	r28, 0x3d	; 61
     6b6:	de b7       	in	r29, 0x3e	; 62
     6b8:	fe 01       	movw	r30, r28
     6ba:	36 96       	adiw	r30, 0x06	; 6
     6bc:	61 91       	ld	r22, Z+
     6be:	71 91       	ld	r23, Z+
     6c0:	af 01       	movw	r20, r30
     6c2:	8c e1       	ldi	r24, 0x1C	; 28
     6c4:	93 e0       	ldi	r25, 0x03	; 3
     6c6:	0e 94 a1 22 	call	0x4542	; 0x4542 <vsprintf>
     6ca:	8c e1       	ldi	r24, 0x1C	; 28
     6cc:	93 e0       	ldi	r25, 0x03	; 3
     6ce:	e6 df       	rcall	.-52     	; 0x69c <_Z10debugPrintPKc>
     6d0:	df 91       	pop	r29
     6d2:	cf 91       	pop	r28
     6d4:	08 95       	ret

000006d6 <_Z11task_keypadPv>:
     6d6:	c2 e9       	ldi	r28, 0x92	; 146
     6d8:	d2 e0       	ldi	r29, 0x02	; 2
     6da:	0f 2e       	mov	r0, r31
     6dc:	fa e8       	ldi	r31, 0x8A	; 138
     6de:	ef 2e       	mov	r14, r31
     6e0:	f7 e0       	ldi	r31, 0x07	; 7
     6e2:	ff 2e       	mov	r15, r31
     6e4:	f0 2d       	mov	r31, r0
     6e6:	8e e1       	ldi	r24, 0x1E	; 30
     6e8:	97 e0       	ldi	r25, 0x07	; 7
     6ea:	11 d6       	rcall	.+3106   	; 0x130e <_ZN6Keypad6getKeyEv>
     6ec:	88 23       	and	r24, r24
     6ee:	71 f0       	breq	.+28     	; 0x70c <_Z11task_keypadPv+0x36>
     6f0:	08 2f       	mov	r16, r24
     6f2:	10 e0       	ldi	r17, 0x00	; 0
     6f4:	1f 92       	push	r1
     6f6:	8f 93       	push	r24
     6f8:	df 93       	push	r29
     6fa:	cf 93       	push	r28
     6fc:	d9 df       	rcall	.-78     	; 0x6b0 <_Z7dprintfPKcz>
     6fe:	f7 01       	movw	r30, r14
     700:	11 83       	std	Z+1, r17	; 0x01
     702:	00 83       	st	Z, r16
     704:	0f 90       	pop	r0
     706:	0f 90       	pop	r0
     708:	0f 90       	pop	r0
     70a:	0f 90       	pop	r0
     70c:	80 91 13 02 	lds	r24, 0x0213
     710:	90 91 14 02 	lds	r25, 0x0214
     714:	0e 94 ff 15 	call	0x2bfe	; 0x2bfe <vTaskDelay>
     718:	e6 cf       	rjmp	.-52     	; 0x6e6 <_Z11task_keypadPv+0x10>

0000071a <_Z17task_headingNdistPv>:
     71a:	c7 eb       	ldi	r28, 0xB7	; 183
     71c:	d7 e0       	ldi	r29, 0x07	; 7
     71e:	09 eb       	ldi	r16, 0xB9	; 185
     720:	17 e0       	ldi	r17, 0x07	; 7
     722:	0f 2e       	mov	r0, r31
     724:	fe e8       	ldi	r31, 0x8E	; 142
     726:	2f 2e       	mov	r2, r31
     728:	f7 e0       	ldi	r31, 0x07	; 7
     72a:	3f 2e       	mov	r3, r31
     72c:	f0 2d       	mov	r31, r0
     72e:	85 eb       	ldi	r24, 0xB5	; 181
     730:	97 e0       	ldi	r25, 0x07	; 7
     732:	0e 94 7e 10 	call	0x20fc	; 0x20fc <_ZN6LSM3034readEv>
     736:	85 eb       	ldi	r24, 0xB5	; 181
     738:	97 e0       	ldi	r25, 0x07	; 7
     73a:	0e 94 8f 0e 	call	0x1d1e	; 0x1d1e <_ZN6LSM3037headingEv>
     73e:	60 91 b5 07 	lds	r22, 0x07B5
     742:	70 91 b6 07 	lds	r23, 0x07B6
     746:	88 27       	eor	r24, r24
     748:	77 fd       	sbrc	r23, 7
     74a:	80 95       	com	r24
     74c:	98 2f       	mov	r25, r24
     74e:	0e 94 03 1b 	call	0x3606	; 0x3606 <__floatsisf>
     752:	20 e0       	ldi	r18, 0x00	; 0
     754:	30 e0       	ldi	r19, 0x00	; 0
     756:	40 e8       	ldi	r20, 0x80	; 128
     758:	5d e3       	ldi	r21, 0x3D	; 61
     75a:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <__mulsf3>
     75e:	2b 01       	movw	r4, r22
     760:	3c 01       	movw	r6, r24
     762:	68 81       	ld	r22, Y
     764:	79 81       	ldd	r23, Y+1	; 0x01
     766:	88 27       	eor	r24, r24
     768:	77 fd       	sbrc	r23, 7
     76a:	80 95       	com	r24
     76c:	98 2f       	mov	r25, r24
     76e:	0e 94 03 1b 	call	0x3606	; 0x3606 <__floatsisf>
     772:	20 e0       	ldi	r18, 0x00	; 0
     774:	30 e0       	ldi	r19, 0x00	; 0
     776:	40 e8       	ldi	r20, 0x80	; 128
     778:	5d e3       	ldi	r21, 0x3D	; 61
     77a:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <__mulsf3>
     77e:	4b 01       	movw	r8, r22
     780:	5c 01       	movw	r10, r24
     782:	d8 01       	movw	r26, r16
     784:	8d 91       	ld	r24, X+
     786:	9c 91       	ld	r25, X
     788:	bc 01       	movw	r22, r24
     78a:	88 27       	eor	r24, r24
     78c:	77 fd       	sbrc	r23, 7
     78e:	80 95       	com	r24
     790:	98 2f       	mov	r25, r24
     792:	0e 94 03 1b 	call	0x3606	; 0x3606 <__floatsisf>
     796:	20 e0       	ldi	r18, 0x00	; 0
     798:	30 e0       	ldi	r19, 0x00	; 0
     79a:	40 e8       	ldi	r20, 0x80	; 128
     79c:	5d e3       	ldi	r21, 0x3D	; 61
     79e:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <__mulsf3>
     7a2:	6b 01       	movw	r12, r22
     7a4:	7c 01       	movw	r14, r24
     7a6:	a3 01       	movw	r20, r6
     7a8:	92 01       	movw	r18, r4
     7aa:	c3 01       	movw	r24, r6
     7ac:	b2 01       	movw	r22, r4
     7ae:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <__mulsf3>
     7b2:	2b 01       	movw	r4, r22
     7b4:	3c 01       	movw	r6, r24
     7b6:	a5 01       	movw	r20, r10
     7b8:	94 01       	movw	r18, r8
     7ba:	c5 01       	movw	r24, r10
     7bc:	b4 01       	movw	r22, r8
     7be:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <__mulsf3>
     7c2:	9b 01       	movw	r18, r22
     7c4:	ac 01       	movw	r20, r24
     7c6:	c3 01       	movw	r24, r6
     7c8:	b2 01       	movw	r22, r4
     7ca:	0e 94 9e 19 	call	0x333c	; 0x333c <__addsf3>
     7ce:	20 e0       	ldi	r18, 0x00	; 0
     7d0:	30 e0       	ldi	r19, 0x00	; 0
     7d2:	40 e8       	ldi	r20, 0x80	; 128
     7d4:	5e e3       	ldi	r21, 0x3E	; 62
     7d6:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <__mulsf3>
     7da:	4b 01       	movw	r8, r22
     7dc:	5c 01       	movw	r10, r24
     7de:	a7 01       	movw	r20, r14
     7e0:	96 01       	movw	r18, r12
     7e2:	c7 01       	movw	r24, r14
     7e4:	b6 01       	movw	r22, r12
     7e6:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <__mulsf3>
     7ea:	9b 01       	movw	r18, r22
     7ec:	ac 01       	movw	r20, r24
     7ee:	c5 01       	movw	r24, r10
     7f0:	b4 01       	movw	r22, r8
     7f2:	0e 94 9e 19 	call	0x333c	; 0x333c <__addsf3>
     7f6:	0e 94 4a 1c 	call	0x3894	; 0x3894 <sqrt>
     7fa:	6b 01       	movw	r12, r22
     7fc:	7c 01       	movw	r14, r24
     7fe:	0e 94 c7 1f 	call	0x3f8e	; 0x3f8e <millis>
     802:	4b 01       	movw	r8, r22
     804:	5c 01       	movw	r10, r24
     806:	20 e0       	ldi	r18, 0x00	; 0
     808:	30 e0       	ldi	r19, 0x00	; 0
     80a:	4a e7       	ldi	r20, 0x7A	; 122
     80c:	54 e4       	ldi	r21, 0x44	; 68
     80e:	c7 01       	movw	r24, r14
     810:	b6 01       	movw	r22, r12
     812:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <__gesf2>
     816:	18 16       	cp	r1, r24
     818:	0c f0       	brlt	.+2      	; 0x81c <_Z17task_headingNdistPv+0x102>
     81a:	5e c0       	rjmp	.+188    	; 0x8d8 <_Z17task_headingNdistPv+0x1be>
     81c:	c5 01       	movw	r24, r10
     81e:	b4 01       	movw	r22, r8
     820:	0e 94 01 1b 	call	0x3602	; 0x3602 <__floatunsisf>
     824:	4b 01       	movw	r8, r22
     826:	5c 01       	movw	r10, r24
     828:	20 91 18 03 	lds	r18, 0x0318
     82c:	30 91 19 03 	lds	r19, 0x0319
     830:	40 91 1a 03 	lds	r20, 0x031A
     834:	50 91 1b 03 	lds	r21, 0x031B
     838:	0e 94 9d 19 	call	0x333a	; 0x333a <__subsf3>
     83c:	20 e0       	ldi	r18, 0x00	; 0
     83e:	30 e0       	ldi	r19, 0x00	; 0
     840:	4a ef       	ldi	r20, 0xFA	; 250
     842:	53 e4       	ldi	r21, 0x43	; 67
     844:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <__gesf2>
     848:	88 23       	and	r24, r24
     84a:	0c f4       	brge	.+2      	; 0x84e <_Z17task_headingNdistPv+0x134>
     84c:	45 c0       	rjmp	.+138    	; 0x8d8 <_Z17task_headingNdistPv+0x1be>
     84e:	20 e0       	ldi	r18, 0x00	; 0
     850:	30 e0       	ldi	r19, 0x00	; 0
     852:	44 e0       	ldi	r20, 0x04	; 4
     854:	52 e4       	ldi	r21, 0x42	; 66
     856:	60 91 9e 07 	lds	r22, 0x079E
     85a:	70 91 9f 07 	lds	r23, 0x079F
     85e:	80 91 a0 07 	lds	r24, 0x07A0
     862:	90 91 a1 07 	lds	r25, 0x07A1
     866:	0e 94 9e 19 	call	0x333c	; 0x333c <__addsf3>
     86a:	60 93 9e 07 	sts	0x079E, r22
     86e:	70 93 9f 07 	sts	0x079F, r23
     872:	80 93 a0 07 	sts	0x07A0, r24
     876:	90 93 a1 07 	sts	0x07A1, r25
     87a:	80 91 9c 07 	lds	r24, 0x079C
     87e:	90 91 9d 07 	lds	r25, 0x079D
     882:	01 96       	adiw	r24, 0x01	; 1
     884:	90 93 9d 07 	sts	0x079D, r25
     888:	80 93 9c 07 	sts	0x079C, r24
     88c:	c7 01       	movw	r24, r14
     88e:	b6 01       	movw	r22, r12
     890:	0e 94 d0 1a 	call	0x35a0	; 0x35a0 <__fixsfsi>
     894:	7f 93       	push	r23
     896:	6f 93       	push	r22
     898:	a4 ea       	ldi	r26, 0xA4	; 164
     89a:	b2 e0       	ldi	r27, 0x02	; 2
     89c:	bf 93       	push	r27
     89e:	af 93       	push	r26
     8a0:	07 df       	rcall	.-498    	; 0x6b0 <_Z7dprintfPKcz>
     8a2:	80 91 9d 07 	lds	r24, 0x079D
     8a6:	8f 93       	push	r24
     8a8:	80 91 9c 07 	lds	r24, 0x079C
     8ac:	8f 93       	push	r24
     8ae:	ae ea       	ldi	r26, 0xAE	; 174
     8b0:	b2 e0       	ldi	r27, 0x02	; 2
     8b2:	bf 93       	push	r27
     8b4:	af 93       	push	r26
     8b6:	fc de       	rcall	.-520    	; 0x6b0 <_Z7dprintfPKcz>
     8b8:	80 92 18 03 	sts	0x0318, r8
     8bc:	90 92 19 03 	sts	0x0319, r9
     8c0:	a0 92 1a 03 	sts	0x031A, r10
     8c4:	b0 92 1b 03 	sts	0x031B, r11
     8c8:	8d b7       	in	r24, 0x3d	; 61
     8ca:	9e b7       	in	r25, 0x3e	; 62
     8cc:	08 96       	adiw	r24, 0x08	; 8
     8ce:	0f b6       	in	r0, 0x3f	; 63
     8d0:	f8 94       	cli
     8d2:	9e bf       	out	0x3e, r25	; 62
     8d4:	0f be       	out	0x3f, r0	; 63
     8d6:	8d bf       	out	0x3d, r24	; 61
     8d8:	60 91 9e 07 	lds	r22, 0x079E
     8dc:	70 91 9f 07 	lds	r23, 0x079F
     8e0:	80 91 a0 07 	lds	r24, 0x07A0
     8e4:	90 91 a1 07 	lds	r25, 0x07A1
     8e8:	0e 94 d0 1a 	call	0x35a0	; 0x35a0 <__fixsfsi>
     8ec:	d1 01       	movw	r26, r2
     8ee:	6d 93       	st	X+, r22
     8f0:	7c 93       	st	X, r23
     8f2:	64 e6       	ldi	r22, 0x64	; 100
     8f4:	70 e0       	ldi	r23, 0x00	; 0
     8f6:	80 e0       	ldi	r24, 0x00	; 0
     8f8:	90 e0       	ldi	r25, 0x00	; 0
     8fa:	0e 94 f9 1f 	call	0x3ff2	; 0x3ff2 <delay>
     8fe:	80 91 13 02 	lds	r24, 0x0213
     902:	90 91 14 02 	lds	r25, 0x0214
     906:	0e 94 ff 15 	call	0x2bfe	; 0x2bfe <vTaskDelay>
     90a:	11 cf       	rjmp	.-478    	; 0x72e <_Z17task_headingNdistPv+0x14>

0000090c <_Z15task_poll_sonarPv>:
     90c:	0f 2e       	mov	r0, r31
     90e:	f0 e9       	ldi	r31, 0x90	; 144
     910:	cf 2e       	mov	r12, r31
     912:	f7 e0       	ldi	r31, 0x07	; 7
     914:	df 2e       	mov	r13, r31
     916:	f0 2d       	mov	r31, r0
     918:	0f 2e       	mov	r0, r31
     91a:	f2 e9       	ldi	r31, 0x92	; 146
     91c:	ef 2e       	mov	r14, r31
     91e:	f7 e0       	ldi	r31, 0x07	; 7
     920:	ff 2e       	mov	r15, r31
     922:	f0 2d       	mov	r31, r0
     924:	04 e9       	ldi	r16, 0x94	; 148
     926:	17 e0       	ldi	r17, 0x07	; 7
     928:	c6 e9       	ldi	r28, 0x96	; 150
     92a:	d7 e0       	ldi	r29, 0x07	; 7
     92c:	0f 2e       	mov	r0, r31
     92e:	f8 e9       	ldi	r31, 0x98	; 152
     930:	af 2e       	mov	r10, r31
     932:	f7 e0       	ldi	r31, 0x07	; 7
     934:	bf 2e       	mov	r11, r31
     936:	f0 2d       	mov	r31, r0
     938:	0f 2e       	mov	r0, r31
     93a:	f5 e9       	ldi	r31, 0x95	; 149
     93c:	8f 2e       	mov	r8, r31
     93e:	f2 e0       	ldi	r31, 0x02	; 2
     940:	9f 2e       	mov	r9, r31
     942:	f0 2d       	mov	r31, r0
     944:	6a e2       	ldi	r22, 0x2A	; 42
     946:	70 e0       	ldi	r23, 0x00	; 0
     948:	89 e2       	ldi	r24, 0x29	; 41
     94a:	90 e0       	ldi	r25, 0x00	; 0
     94c:	e8 dd       	rcall	.-1072   	; 0x51e <_Z10sonar_readii>
     94e:	0e 94 d0 1a 	call	0x35a0	; 0x35a0 <__fixsfsi>
     952:	f6 01       	movw	r30, r12
     954:	71 83       	std	Z+1, r23	; 0x01
     956:	60 83       	st	Z, r22
     958:	64 e2       	ldi	r22, 0x24	; 36
     95a:	70 e0       	ldi	r23, 0x00	; 0
     95c:	85 e2       	ldi	r24, 0x25	; 37
     95e:	90 e0       	ldi	r25, 0x00	; 0
     960:	de dd       	rcall	.-1092   	; 0x51e <_Z10sonar_readii>
     962:	0e 94 d0 1a 	call	0x35a0	; 0x35a0 <__fixsfsi>
     966:	f7 01       	movw	r30, r14
     968:	71 83       	std	Z+1, r23	; 0x01
     96a:	60 83       	st	Z, r22
     96c:	67 e2       	ldi	r22, 0x27	; 39
     96e:	70 e0       	ldi	r23, 0x00	; 0
     970:	88 e2       	ldi	r24, 0x28	; 40
     972:	90 e0       	ldi	r25, 0x00	; 0
     974:	d4 dd       	rcall	.-1112   	; 0x51e <_Z10sonar_readii>
     976:	0e 94 d0 1a 	call	0x35a0	; 0x35a0 <__fixsfsi>
     97a:	f8 01       	movw	r30, r16
     97c:	71 83       	std	Z+1, r23	; 0x01
     97e:	60 83       	st	Z, r22
     980:	6c e2       	ldi	r22, 0x2C	; 44
     982:	70 e0       	ldi	r23, 0x00	; 0
     984:	8b e2       	ldi	r24, 0x2B	; 43
     986:	90 e0       	ldi	r25, 0x00	; 0
     988:	ca dd       	rcall	.-1132   	; 0x51e <_Z10sonar_readii>
     98a:	0e 94 d0 1a 	call	0x35a0	; 0x35a0 <__fixsfsi>
     98e:	79 83       	std	Y+1, r23	; 0x01
     990:	68 83       	st	Y, r22
     992:	6b e0       	ldi	r22, 0x0B	; 11
     994:	70 e0       	ldi	r23, 0x00	; 0
     996:	8a e0       	ldi	r24, 0x0A	; 10
     998:	90 e0       	ldi	r25, 0x00	; 0
     99a:	c1 dd       	rcall	.-1150   	; 0x51e <_Z10sonar_readii>
     99c:	0e 94 d0 1a 	call	0x35a0	; 0x35a0 <__fixsfsi>
     9a0:	f5 01       	movw	r30, r10
     9a2:	60 83       	st	Z, r22
     9a4:	71 83       	std	Z+1, r23	; 0x01
     9a6:	7f 93       	push	r23
     9a8:	6f 93       	push	r22
     9aa:	89 81       	ldd	r24, Y+1	; 0x01
     9ac:	8f 93       	push	r24
     9ae:	88 81       	ld	r24, Y
     9b0:	8f 93       	push	r24
     9b2:	f8 01       	movw	r30, r16
     9b4:	81 81       	ldd	r24, Z+1	; 0x01
     9b6:	8f 93       	push	r24
     9b8:	80 81       	ld	r24, Z
     9ba:	8f 93       	push	r24
     9bc:	f7 01       	movw	r30, r14
     9be:	81 81       	ldd	r24, Z+1	; 0x01
     9c0:	8f 93       	push	r24
     9c2:	80 81       	ld	r24, Z
     9c4:	8f 93       	push	r24
     9c6:	f6 01       	movw	r30, r12
     9c8:	81 81       	ldd	r24, Z+1	; 0x01
     9ca:	8f 93       	push	r24
     9cc:	80 81       	ld	r24, Z
     9ce:	8f 93       	push	r24
     9d0:	9f 92       	push	r9
     9d2:	8f 92       	push	r8
     9d4:	6d de       	rcall	.-806    	; 0x6b0 <_Z7dprintfPKcz>
     9d6:	80 91 13 02 	lds	r24, 0x0213
     9da:	90 91 14 02 	lds	r25, 0x0214
     9de:	0e 94 ff 15 	call	0x2bfe	; 0x2bfe <vTaskDelay>
     9e2:	8d b7       	in	r24, 0x3d	; 61
     9e4:	9e b7       	in	r25, 0x3e	; 62
     9e6:	0c 96       	adiw	r24, 0x0c	; 12
     9e8:	0f b6       	in	r0, 0x3f	; 63
     9ea:	f8 94       	cli
     9ec:	9e bf       	out	0x3e, r25	; 62
     9ee:	0f be       	out	0x3f, r0	; 63
     9f0:	8d bf       	out	0x3d, r24	; 61
     9f2:	a8 cf       	rjmp	.-176    	; 0x944 <_Z15task_poll_sonarPv+0x38>

000009f4 <_Z8sendDataPKcz>:

int sendData(const char *fmt, ...){
     9f4:	cf 93       	push	r28
     9f6:	df 93       	push	r29
     9f8:	cd b7       	in	r28, 0x3d	; 61
     9fa:	de b7       	in	r29, 0x3e	; 62
     9fc:	d4 50       	subi	r29, 0x04	; 4
     9fe:	0f b6       	in	r0, 0x3f	; 63
     a00:	f8 94       	cli
     a02:	de bf       	out	0x3e, r29	; 62
     a04:	0f be       	out	0x3f, r0	; 63
     a06:	cd bf       	out	0x3d, r28	; 61
     a08:	fe 01       	movw	r30, r28
     a0a:	ea 5f       	subi	r30, 0xFA	; 250
     a0c:	fb 4f       	sbci	r31, 0xFB	; 251
     a0e:	61 91       	ld	r22, Z+
     a10:	71 91       	ld	r23, Z+
	int inByte;
	char dataBuffer[1024];
	va_list argptr;
		va_start(argptr, fmt);
		vsprintf(debugBuffer, fmt, argptr);
     a12:	af 01       	movw	r20, r30
     a14:	8c e1       	ldi	r24, 0x1C	; 28
     a16:	93 e0       	ldi	r25, 0x03	; 3
     a18:	0e 94 a1 22 	call	0x4542	; 0x4542 <vsprintf>
    virtual void flush(void);
    virtual size_t write(uint8_t);
    inline size_t write(unsigned long n) { return write((uint8_t)n); }
    inline size_t write(long n) { return write((uint8_t)n); }
    inline size_t write(unsigned int n) { return write((uint8_t)n); }
    inline size_t write(int n) { return write((uint8_t)n); }
     a1c:	e0 91 73 0f 	lds	r30, 0x0F73
     a20:	f0 91 74 0f 	lds	r31, 0x0F74
     a24:	01 90       	ld	r0, Z+
     a26:	f0 81       	ld	r31, Z
     a28:	e0 2d       	mov	r30, r0
     a2a:	64 e0       	ldi	r22, 0x04	; 4
     a2c:	83 e7       	ldi	r24, 0x73	; 115
     a2e:	9f e0       	ldi	r25, 0x0F	; 15
     a30:	19 95       	eicall
     a32:	e0 91 73 0f 	lds	r30, 0x0F73
     a36:	f0 91 74 0f 	lds	r31, 0x0F74
     a3a:	01 90       	ld	r0, Z+
     a3c:	f0 81       	ld	r31, Z
     a3e:	e0 2d       	mov	r30, r0
     a40:	60 e0       	ldi	r22, 0x00	; 0
     a42:	83 e7       	ldi	r24, 0x73	; 115
     a44:	9f e0       	ldi	r25, 0x0F	; 15
     a46:	19 95       	eicall
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
    }
    virtual size_t write(const uint8_t *buffer, size_t size);
    size_t write(const char *buffer, size_t size) {
      return write((const uint8_t *)buffer, size);
     a48:	e0 91 73 0f 	lds	r30, 0x0F73
     a4c:	f0 91 74 0f 	lds	r31, 0x0F74
     a50:	02 80       	ldd	r0, Z+2	; 0x02
     a52:	f3 81       	ldd	r31, Z+3	; 0x03
     a54:	e0 2d       	mov	r30, r0
     a56:	40 e0       	ldi	r20, 0x00	; 0
     a58:	54 e0       	ldi	r21, 0x04	; 4
     a5a:	be 01       	movw	r22, r28
     a5c:	6f 5f       	subi	r22, 0xFF	; 255
     a5e:	7f 4f       	sbci	r23, 0xFF	; 255
     a60:	83 e7       	ldi	r24, 0x73	; 115
     a62:	9f e0       	ldi	r25, 0x0F	; 15
     a64:	19 95       	eicall
		Serial1.write(4);
		Serial1.write(0);
		Serial1.write(dataBuffer,sizeof(dataBuffer));
			
	//	Serial1.write("data");
		inByte = Serial1.read();
     a66:	83 e7       	ldi	r24, 0x73	; 115
     a68:	9f e0       	ldi	r25, 0x0F	; 15
     a6a:	0e 94 b9 1c 	call	0x3972	; 0x3972 <_ZN14HardwareSerial4readEv>
		if (inByte == '0') { //receive 0ACK
     a6e:	c0 97       	sbiw	r24, 0x30	; 48
     a70:	a9 f6       	brne	.-86     	; 0xa1c <_Z8sendDataPKcz+0x28>
			//debugPrint("$");
			dprintf("$");
     a72:	87 eb       	ldi	r24, 0xB7	; 183
     a74:	92 e0       	ldi	r25, 0x02	; 2
     a76:	9f 93       	push	r25
     a78:	8f 93       	push	r24
     a7a:	1a de       	rcall	.-972    	; 0x6b0 <_Z7dprintfPKcz>
     a7c:	0f 90       	pop	r0
     a7e:	0f 90       	pop	r0
			break;
		}
	}
	
}
     a80:	dc 5f       	subi	r29, 0xFC	; 252
     a82:	0f b6       	in	r0, 0x3f	; 63
     a84:	f8 94       	cli
     a86:	de bf       	out	0x3e, r29	; 62
     a88:	0f be       	out	0x3f, r0	; 63
     a8a:	cd bf       	out	0x3d, r28	; 61
     a8c:	df 91       	pop	r29
     a8e:	cf 91       	pop	r28
     a90:	08 95       	ret

00000a92 <_Z21handshakenUntilFinishv>:
}

void handshakenUntilFinish() {
	int inByte;
	while (1) {
		if (Serial1.available()){
     a92:	83 e7       	ldi	r24, 0x73	; 115
     a94:	9f e0       	ldi	r25, 0x0F	; 15
     a96:	0e 94 a0 1c 	call	0x3940	; 0x3940 <_ZN14HardwareSerial9availableEv>
     a9a:	89 2b       	or	r24, r25
     a9c:	d1 f3       	breq	.-12     	; 0xa92 <_Z21handshakenUntilFinishv>
			inByte = Serial1.read();
     a9e:	83 e7       	ldi	r24, 0x73	; 115
     aa0:	9f e0       	ldi	r25, 0x0F	; 15
     aa2:	0e 94 b9 1c 	call	0x3972	; 0x3972 <_ZN14HardwareSerial4readEv>
			if (inByte == 2) { // receive 2HELO
     aa6:	02 97       	sbiw	r24, 0x02	; 2
     aa8:	a1 f7       	brne	.-24     	; 0xa92 <_Z21handshakenUntilFinishv>
				debugPrint("!");
     aaa:	89 eb       	ldi	r24, 0xB9	; 185
     aac:	92 e0       	ldi	r25, 0x02	; 2
     aae:	f6 dd       	rcall	.-1044   	; 0x69c <_Z10debugPrintPKc>
     ab0:	e0 91 73 0f 	lds	r30, 0x0F73
     ab4:	f0 91 74 0f 	lds	r31, 0x0F74
     ab8:	01 90       	ld	r0, Z+
     aba:	f0 81       	ld	r31, Z
     abc:	e0 2d       	mov	r30, r0
     abe:	60 e0       	ldi	r22, 0x00	; 0
     ac0:	83 e7       	ldi	r24, 0x73	; 115
     ac2:	9f e0       	ldi	r25, 0x0F	; 15
     ac4:	19 95       	eicall
				Serial1.write(0); // answer 0ACK
				debugPrint("@");
     ac6:	8b eb       	ldi	r24, 0xBB	; 187
     ac8:	92 e0       	ldi	r25, 0x02	; 2
     aca:	e8 dd       	rcall	.-1072   	; 0x69c <_Z10debugPrintPKc>
				break;
			}
		}
	}
	debugPrint("^");
     acc:	8d eb       	ldi	r24, 0xBD	; 189
     ace:	92 e0       	ldi	r25, 0x02	; 2
     ad0:	e5 dd       	rcall	.-1078   	; 0x69c <_Z10debugPrintPKc>
	while (1) {
		inByte = Serial1.read();
     ad2:	83 e7       	ldi	r24, 0x73	; 115
     ad4:	9f e0       	ldi	r25, 0x0F	; 15
     ad6:	0e 94 b9 1c 	call	0x3972	; 0x3972 <_ZN14HardwareSerial4readEv>
		if (inByte == 0) { //receive 0ACK
     ada:	89 2b       	or	r24, r25
     adc:	d1 f7       	brne	.-12     	; 0xad2 <_Z21handshakenUntilFinishv+0x40>
			debugPrint("#");
     ade:	8f eb       	ldi	r24, 0xBF	; 191
     ae0:	92 e0       	ldi	r25, 0x02	; 2
     ae2:	dc dd       	rcall	.-1096   	; 0x69c <_Z10debugPrintPKc>
			handshaken = 1;
     ae4:	81 e0       	ldi	r24, 0x01	; 1
     ae6:	90 e0       	ldi	r25, 0x00	; 0
     ae8:	90 93 1d 07 	sts	0x071D, r25
     aec:	80 93 1c 07 	sts	0x071C, r24
     af0:	08 95       	ret

00000af2 <_Z9task_commPv>:
			data[ID_DATA_DIST],
			data[ID_DATA_SONAR1],
			data[ID_DATA_SONAR2],
			data[ID_DATA_SONAR3],
			data[ID_DATA_SONAR4],
			data[ID_DATA_SONAR5]);
     af2:	0f 2e       	mov	r0, r31
     af4:	f8 e9       	ldi	r31, 0x98	; 152
     af6:	af 2e       	mov	r10, r31
     af8:	f7 e0       	ldi	r31, 0x07	; 7
     afa:	bf 2e       	mov	r11, r31
     afc:	f0 2d       	mov	r31, r0
     afe:	0f 2e       	mov	r0, r31
     b00:	f6 e9       	ldi	r31, 0x96	; 150
     b02:	cf 2e       	mov	r12, r31
     b04:	f7 e0       	ldi	r31, 0x07	; 7
     b06:	df 2e       	mov	r13, r31
     b08:	f0 2d       	mov	r31, r0
     b0a:	0f 2e       	mov	r0, r31
     b0c:	f4 e9       	ldi	r31, 0x94	; 148
     b0e:	ef 2e       	mov	r14, r31
     b10:	f7 e0       	ldi	r31, 0x07	; 7
     b12:	ff 2e       	mov	r15, r31
     b14:	f0 2d       	mov	r31, r0
     b16:	02 e9       	ldi	r16, 0x92	; 146
     b18:	17 e0       	ldi	r17, 0x07	; 7
     b1a:	c0 e9       	ldi	r28, 0x90	; 144
     b1c:	d7 e0       	ldi	r29, 0x07	; 7
     b1e:	0f 2e       	mov	r0, r31
     b20:	fe e8       	ldi	r31, 0x8E	; 142
     b22:	8f 2e       	mov	r8, r31
     b24:	f7 e0       	ldi	r31, 0x07	; 7
     b26:	9f 2e       	mov	r9, r31
     b28:	f0 2d       	mov	r31, r0
     b2a:	0f 2e       	mov	r0, r31
     b2c:	fc e8       	ldi	r31, 0x8C	; 140
     b2e:	6f 2e       	mov	r6, r31
     b30:	f7 e0       	ldi	r31, 0x07	; 7
     b32:	7f 2e       	mov	r7, r31
     b34:	f0 2d       	mov	r31, r0
     b36:	0f 2e       	mov	r0, r31
     b38:	fa e8       	ldi	r31, 0x8A	; 138
     b3a:	4f 2e       	mov	r4, r31
     b3c:	f7 e0       	ldi	r31, 0x07	; 7
     b3e:	5f 2e       	mov	r5, r31
     b40:	f0 2d       	mov	r31, r0
     b42:	0f 2e       	mov	r0, r31
     b44:	f1 ec       	ldi	r31, 0xC1	; 193
     b46:	2f 2e       	mov	r2, r31
     b48:	f2 e0       	ldi	r31, 0x02	; 2
     b4a:	3f 2e       	mov	r3, r31
     b4c:	f0 2d       	mov	r31, r0
}
void task_comm(void* p){
	/* UBaseType_t uxHighWaterMark;
	  uxHighWaterMark = uxTaskGetStackHighWaterMark( NULL );*/
	while(1) {
		Serial.println("");
     b4e:	61 eb       	ldi	r22, 0xB1	; 177
     b50:	72 e0       	ldi	r23, 0x02	; 2
     b52:	86 ed       	ldi	r24, 0xD6	; 214
     b54:	9e e0       	ldi	r25, 0x0E	; 14
     b56:	0e 94 6d 1f 	call	0x3eda	; 0x3eda <_ZN5Print7printlnEPKc>
		Serial.println("");
     b5a:	61 eb       	ldi	r22, 0xB1	; 177
     b5c:	72 e0       	ldi	r23, 0x02	; 2
     b5e:	86 ed       	ldi	r24, 0xD6	; 214
     b60:	9e e0       	ldi	r25, 0x0E	; 14
     b62:	0e 94 6d 1f 	call	0x3eda	; 0x3eda <_ZN5Print7printlnEPKc>
		if (!handshaken) {
     b66:	80 91 1c 07 	lds	r24, 0x071C
     b6a:	90 91 1d 07 	lds	r25, 0x071D
     b6e:	89 2b       	or	r24, r25
     b70:	11 f4       	brne	.+4      	; 0xb76 <_Z9task_commPv+0x84>
			handshakenUntilFinish();
     b72:	8f df       	rcall	.-226    	; 0xa92 <_Z21handshakenUntilFinishv>
     b74:	32 c0       	rjmp	.+100    	; 0xbda <_Z9task_commPv+0xe8>
			data[ID_DATA_DIST],
			data[ID_DATA_SONAR1],
			data[ID_DATA_SONAR2],
			data[ID_DATA_SONAR3],
			data[ID_DATA_SONAR4],
			data[ID_DATA_SONAR5]);
     b76:	f5 01       	movw	r30, r10
     b78:	81 81       	ldd	r24, Z+1	; 0x01
     b7a:	8f 93       	push	r24
     b7c:	80 81       	ld	r24, Z
     b7e:	8f 93       	push	r24
     b80:	f6 01       	movw	r30, r12
     b82:	81 81       	ldd	r24, Z+1	; 0x01
     b84:	8f 93       	push	r24
     b86:	80 81       	ld	r24, Z
     b88:	8f 93       	push	r24
     b8a:	f7 01       	movw	r30, r14
     b8c:	81 81       	ldd	r24, Z+1	; 0x01
     b8e:	8f 93       	push	r24
     b90:	80 81       	ld	r24, Z
     b92:	8f 93       	push	r24
     b94:	f8 01       	movw	r30, r16
     b96:	81 81       	ldd	r24, Z+1	; 0x01
     b98:	8f 93       	push	r24
     b9a:	80 81       	ld	r24, Z
     b9c:	8f 93       	push	r24
     b9e:	89 81       	ldd	r24, Y+1	; 0x01
     ba0:	8f 93       	push	r24
     ba2:	88 81       	ld	r24, Y
     ba4:	8f 93       	push	r24
     ba6:	f4 01       	movw	r30, r8
     ba8:	81 81       	ldd	r24, Z+1	; 0x01
     baa:	8f 93       	push	r24
     bac:	80 81       	ld	r24, Z
     bae:	8f 93       	push	r24
     bb0:	f3 01       	movw	r30, r6
     bb2:	81 81       	ldd	r24, Z+1	; 0x01
     bb4:	8f 93       	push	r24
     bb6:	80 81       	ld	r24, Z
     bb8:	8f 93       	push	r24
     bba:	f2 01       	movw	r30, r4
     bbc:	81 81       	ldd	r24, Z+1	; 0x01
     bbe:	8f 93       	push	r24
     bc0:	80 81       	ld	r24, Z
     bc2:	8f 93       	push	r24
     bc4:	3f 92       	push	r3
     bc6:	2f 92       	push	r2
     bc8:	15 df       	rcall	.-470    	; 0x9f4 <_Z8sendDataPKcz>
     bca:	8d b7       	in	r24, 0x3d	; 61
     bcc:	9e b7       	in	r25, 0x3e	; 62
     bce:	42 96       	adiw	r24, 0x12	; 18
     bd0:	0f b6       	in	r0, 0x3f	; 63
     bd2:	f8 94       	cli
     bd4:	9e bf       	out	0x3e, r25	; 62
     bd6:	0f be       	out	0x3f, r0	; 63
     bd8:	8d bf       	out	0x3d, r24	; 61
		data[ID_DATA_DIST],
		data[ID_DATA_SONAR1],
		data[ID_DATA_SONAR2],
		data[ID_DATA_SONAR3],
		data[ID_DATA_SONAR4],
		data[ID_DATA_SONAR5]);
     bda:	f5 01       	movw	r30, r10
     bdc:	81 81       	ldd	r24, Z+1	; 0x01
     bde:	8f 93       	push	r24
     be0:	80 81       	ld	r24, Z
     be2:	8f 93       	push	r24
     be4:	f6 01       	movw	r30, r12
     be6:	81 81       	ldd	r24, Z+1	; 0x01
     be8:	8f 93       	push	r24
     bea:	80 81       	ld	r24, Z
     bec:	8f 93       	push	r24
     bee:	f7 01       	movw	r30, r14
     bf0:	81 81       	ldd	r24, Z+1	; 0x01
     bf2:	8f 93       	push	r24
     bf4:	80 81       	ld	r24, Z
     bf6:	8f 93       	push	r24
     bf8:	f8 01       	movw	r30, r16
     bfa:	81 81       	ldd	r24, Z+1	; 0x01
     bfc:	8f 93       	push	r24
     bfe:	80 81       	ld	r24, Z
     c00:	8f 93       	push	r24
     c02:	89 81       	ldd	r24, Y+1	; 0x01
     c04:	8f 93       	push	r24
     c06:	88 81       	ld	r24, Y
     c08:	8f 93       	push	r24
     c0a:	f4 01       	movw	r30, r8
     c0c:	81 81       	ldd	r24, Z+1	; 0x01
     c0e:	8f 93       	push	r24
     c10:	80 81       	ld	r24, Z
     c12:	8f 93       	push	r24
     c14:	f3 01       	movw	r30, r6
     c16:	81 81       	ldd	r24, Z+1	; 0x01
     c18:	8f 93       	push	r24
     c1a:	80 81       	ld	r24, Z
     c1c:	8f 93       	push	r24
     c1e:	f2 01       	movw	r30, r4
     c20:	81 81       	ldd	r24, Z+1	; 0x01
     c22:	8f 93       	push	r24
     c24:	80 81       	ld	r24, Z
     c26:	8f 93       	push	r24
     c28:	3f 92       	push	r3
     c2a:	2f 92       	push	r2
     c2c:	41 dd       	rcall	.-1406   	; 0x6b0 <_Z7dprintfPKcz>
		vTaskDelay(taskDelay);
     c2e:	80 91 13 02 	lds	r24, 0x0213
     c32:	90 91 14 02 	lds	r25, 0x0214
     c36:	0e 94 ff 15 	call	0x2bfe	; 0x2bfe <vTaskDelay>
			break;
		}
	}
	
}
void task_comm(void* p){
     c3a:	8d b7       	in	r24, 0x3d	; 61
     c3c:	9e b7       	in	r25, 0x3e	; 62
     c3e:	42 96       	adiw	r24, 0x12	; 18
     c40:	0f b6       	in	r0, 0x3f	; 63
     c42:	f8 94       	cli
     c44:	9e bf       	out	0x3e, r25	; 62
     c46:	0f be       	out	0x3f, r0	; 63
     c48:	8d bf       	out	0x3d, r24	; 61
     c4a:	81 cf       	rjmp	.-254    	; 0xb4e <_Z9task_commPv+0x5c>

00000c4c <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     c4c:	cf 93       	push	r28
     c4e:	df 93       	push	r29
     c50:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     c52:	0e 94 ba 14 	call	0x2974	; 0x2974 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     c56:	80 91 db 07 	lds	r24, 0x07DB
     c5a:	90 91 dc 07 	lds	r25, 0x07DC
     c5e:	89 2b       	or	r24, r25
     c60:	31 f4       	brne	.+12     	; 0xc6e <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     c62:	80 ee       	ldi	r24, 0xE0	; 224
     c64:	97 e0       	ldi	r25, 0x07	; 7
     c66:	90 93 dc 07 	sts	0x07DC, r25
     c6a:	80 93 db 07 	sts	0x07DB, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     c6e:	40 91 dd 07 	lds	r20, 0x07DD
     c72:	50 91 de 07 	lds	r21, 0x07DE
     c76:	9e 01       	movw	r18, r28
     c78:	24 0f       	add	r18, r20
     c7a:	35 1f       	adc	r19, r21
     c7c:	2b 3d       	cpi	r18, 0xDB	; 219
     c7e:	85 e0       	ldi	r24, 0x05	; 5
     c80:	38 07       	cpc	r19, r24
     c82:	70 f4       	brcc	.+28     	; 0xca0 <pvPortMalloc+0x54>
     c84:	42 17       	cp	r20, r18
     c86:	53 07       	cpc	r21, r19
     c88:	70 f4       	brcc	.+28     	; 0xca6 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     c8a:	c0 91 db 07 	lds	r28, 0x07DB
     c8e:	d0 91 dc 07 	lds	r29, 0x07DC
     c92:	c4 0f       	add	r28, r20
     c94:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     c96:	30 93 de 07 	sts	0x07DE, r19
     c9a:	20 93 dd 07 	sts	0x07DD, r18
     c9e:	05 c0       	rjmp	.+10     	; 0xcaa <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     ca0:	c0 e0       	ldi	r28, 0x00	; 0
     ca2:	d0 e0       	ldi	r29, 0x00	; 0
     ca4:	02 c0       	rjmp	.+4      	; 0xcaa <pvPortMalloc+0x5e>
     ca6:	c0 e0       	ldi	r28, 0x00	; 0
     ca8:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     caa:	0e 94 7e 15 	call	0x2afc	; 0x2afc <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     cae:	ce 01       	movw	r24, r28
     cb0:	df 91       	pop	r29
     cb2:	cf 91       	pop	r28
     cb4:	08 95       	ret

00000cb6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     cb6:	08 95       	ret

00000cb8 <_ZN3KeyC1Ev>:
*/
#include <Key.h>


// default constructor
Key::Key() {
     cb8:	fc 01       	movw	r30, r24
	kchar = NO_KEY;
     cba:	10 82       	st	Z, r1
	kstate = IDLE;
     cbc:	13 82       	std	Z+3, r1	; 0x03
	stateChanged = false;
     cbe:	14 82       	std	Z+4, r1	; 0x04
     cc0:	08 95       	ret

00000cc2 <_ZN6Keypad8pin_modeEhh>:
void Keypad::setHoldTime(uint hold) {
    holdTime = hold;
}

void Keypad::addEventListener(void (*listener)(char)){
	keypadEventListener = listener;
     cc2:	86 2f       	mov	r24, r22
     cc4:	64 2f       	mov	r22, r20
     cc6:	0c 94 f5 20 	jmp	0x41ea	; 0x41ea <pinMode>
     cca:	08 95       	ret

00000ccc <_ZN6Keypad9pin_writeEhb>:
     ccc:	86 2f       	mov	r24, r22
     cce:	64 2f       	mov	r22, r20
     cd0:	0c 94 33 21 	jmp	0x4266	; 0x4266 <digitalWrite>
     cd4:	08 95       	ret

00000cd6 <_ZN6Keypad8pin_readEh>:
     cd6:	86 2f       	mov	r24, r22
     cd8:	0c 94 63 21 	jmp	0x42c6	; 0x42c6 <digitalRead>
     cdc:	08 95       	ret

00000cde <_ZN6KeypadC1EPcPhS1_hh>:
     cde:	4f 92       	push	r4
     ce0:	5f 92       	push	r5
     ce2:	6f 92       	push	r6
     ce4:	7f 92       	push	r7
     ce6:	8f 92       	push	r8
     ce8:	9f 92       	push	r9
     cea:	af 92       	push	r10
     cec:	bf 92       	push	r11
     cee:	cf 92       	push	r12
     cf0:	df 92       	push	r13
     cf2:	ef 92       	push	r14
     cf4:	0f 93       	push	r16
     cf6:	cf 93       	push	r28
     cf8:	df 93       	push	r29
     cfa:	ec 01       	movw	r28, r24
     cfc:	4b 01       	movw	r8, r22
     cfe:	3a 01       	movw	r6, r20
     d00:	59 01       	movw	r10, r18
     d02:	02 96       	adiw	r24, 0x02	; 2
     d04:	d9 df       	rcall	.-78     	; 0xcb8 <_ZN3KeyC1Ev>
     d06:	8d ee       	ldi	r24, 0xED	; 237
     d08:	92 e0       	ldi	r25, 0x02	; 2
     d0a:	99 83       	std	Y+1, r25	; 0x01
     d0c:	88 83       	st	Y, r24
     d0e:	2e 01       	movw	r4, r28
     d10:	8b e1       	ldi	r24, 0x1B	; 27
     d12:	48 0e       	add	r4, r24
     d14:	51 1c       	adc	r5, r1
     d16:	62 01       	movw	r12, r4
     d18:	82 e3       	ldi	r24, 0x32	; 50
     d1a:	c8 0e       	add	r12, r24
     d1c:	d1 1c       	adc	r13, r1
     d1e:	c2 01       	movw	r24, r4
     d20:	cb df       	rcall	.-106    	; 0xcb8 <_ZN3KeyC1Ev>
     d22:	85 e0       	ldi	r24, 0x05	; 5
     d24:	48 0e       	add	r4, r24
     d26:	51 1c       	adc	r5, r1
     d28:	4c 14       	cp	r4, r12
     d2a:	5d 04       	cpc	r5, r13
     d2c:	c1 f7       	brne	.-16     	; 0xd1e <_ZN6KeypadC1EPcPhS1_hh+0x40>
     d2e:	fe 01       	movw	r30, r28
     d30:	e9 5a       	subi	r30, 0xA9	; 169
     d32:	ff 4f       	sbci	r31, 0xFF	; 255
     d34:	71 82       	std	Z+1, r7	; 0x01
     d36:	60 82       	st	Z, r6
     d38:	32 96       	adiw	r30, 0x02	; 2
     d3a:	b1 82       	std	Z+1, r11	; 0x01
     d3c:	a0 82       	st	Z, r10
     d3e:	32 96       	adiw	r30, 0x02	; 2
     d40:	00 83       	st	Z, r16
     d42:	31 96       	adiw	r30, 0x01	; 1
     d44:	e0 82       	st	Z, r14
     d46:	37 97       	sbiw	r30, 0x07	; 7
     d48:	91 82       	std	Z+1, r9	; 0x01
     d4a:	80 82       	st	Z, r8
     d4c:	38 96       	adiw	r30, 0x08	; 8
     d4e:	8a e0       	ldi	r24, 0x0A	; 10
     d50:	90 e0       	ldi	r25, 0x00	; 0
     d52:	91 83       	std	Z+1, r25	; 0x01
     d54:	80 83       	st	Z, r24
     d56:	32 96       	adiw	r30, 0x02	; 2
     d58:	84 ef       	ldi	r24, 0xF4	; 244
     d5a:	91 e0       	ldi	r25, 0x01	; 1
     d5c:	91 83       	std	Z+1, r25	; 0x01
     d5e:	80 83       	st	Z, r24
     d60:	33 96       	adiw	r30, 0x03	; 3
     d62:	11 82       	std	Z+1, r1	; 0x01
     d64:	10 82       	st	Z, r1
     d66:	71 97       	sbiw	r30, 0x11	; 17
     d68:	10 82       	st	Z, r1
     d6a:	11 82       	std	Z+1, r1	; 0x01
     d6c:	12 82       	std	Z+2, r1	; 0x02
     d6e:	13 82       	std	Z+3, r1	; 0x03
     d70:	cf 59       	subi	r28, 0x9F	; 159
     d72:	df 4f       	sbci	r29, 0xFF	; 255
     d74:	18 82       	st	Y, r1
     d76:	df 91       	pop	r29
     d78:	cf 91       	pop	r28
     d7a:	0f 91       	pop	r16
     d7c:	ef 90       	pop	r14
     d7e:	df 90       	pop	r13
     d80:	cf 90       	pop	r12
     d82:	bf 90       	pop	r11
     d84:	af 90       	pop	r10
     d86:	9f 90       	pop	r9
     d88:	8f 90       	pop	r8
     d8a:	7f 90       	pop	r7
     d8c:	6f 90       	pop	r6
     d8e:	5f 90       	pop	r5
     d90:	4f 90       	pop	r4
     d92:	08 95       	ret

00000d94 <_ZN6Keypad8scanKeysEv>:
     d94:	2f 92       	push	r2
     d96:	3f 92       	push	r3
     d98:	4f 92       	push	r4
     d9a:	5f 92       	push	r5
     d9c:	6f 92       	push	r6
     d9e:	7f 92       	push	r7
     da0:	8f 92       	push	r8
     da2:	9f 92       	push	r9
     da4:	af 92       	push	r10
     da6:	bf 92       	push	r11
     da8:	cf 92       	push	r12
     daa:	df 92       	push	r13
     dac:	ef 92       	push	r14
     dae:	ff 92       	push	r15
     db0:	0f 93       	push	r16
     db2:	1f 93       	push	r17
     db4:	cf 93       	push	r28
     db6:	df 93       	push	r29
     db8:	ec 01       	movw	r28, r24
     dba:	fc 01       	movw	r30, r24
     dbc:	e5 5a       	subi	r30, 0xA5	; 165
     dbe:	ff 4f       	sbci	r31, 0xFF	; 255
     dc0:	80 81       	ld	r24, Z
     dc2:	88 23       	and	r24, r24
     dc4:	d1 f0       	breq	.+52     	; 0xdfa <_ZN6Keypad8scanKeysEv+0x66>
     dc6:	d1 2c       	mov	r13, r1
     dc8:	7e 01       	movw	r14, r28
     dca:	87 e5       	ldi	r24, 0x57	; 87
     dcc:	e8 0e       	add	r14, r24
     dce:	f1 1c       	adc	r15, r1
     dd0:	8f 01       	movw	r16, r30
     dd2:	88 81       	ld	r24, Y
     dd4:	99 81       	ldd	r25, Y+1	; 0x01
     dd6:	f7 01       	movw	r30, r14
     dd8:	a0 81       	ld	r26, Z
     dda:	b1 81       	ldd	r27, Z+1	; 0x01
     ddc:	ad 0d       	add	r26, r13
     dde:	b1 1d       	adc	r27, r1
     de0:	fc 01       	movw	r30, r24
     de2:	20 81       	ld	r18, Z
     de4:	31 81       	ldd	r19, Z+1	; 0x01
     de6:	42 e0       	ldi	r20, 0x02	; 2
     de8:	6c 91       	ld	r22, X
     dea:	ce 01       	movw	r24, r28
     dec:	f9 01       	movw	r30, r18
     dee:	19 95       	eicall
     df0:	d3 94       	inc	r13
     df2:	d8 01       	movw	r26, r16
     df4:	8c 91       	ld	r24, X
     df6:	d8 16       	cp	r13, r24
     df8:	60 f3       	brcs	.-40     	; 0xdd2 <_ZN6Keypad8scanKeysEv+0x3e>
     dfa:	fe 01       	movw	r30, r28
     dfc:	e4 5a       	subi	r30, 0xA4	; 164
     dfe:	ff 4f       	sbci	r31, 0xFF	; 255
     e00:	80 81       	ld	r24, Z
     e02:	88 23       	and	r24, r24
     e04:	09 f4       	brne	.+2      	; 0xe08 <_ZN6Keypad8scanKeysEv+0x74>
     e06:	98 c0       	rjmp	.+304    	; 0xf38 <_ZN6Keypad8scanKeysEv+0x1a4>
     e08:	41 2c       	mov	r4, r1
     e0a:	3e 01       	movw	r6, r28
     e0c:	b9 e5       	ldi	r27, 0x59	; 89
     e0e:	6b 0e       	add	r6, r27
     e10:	71 1c       	adc	r7, r1
     e12:	8e 01       	movw	r16, r28
     e14:	05 5a       	subi	r16, 0xA5	; 165
     e16:	1f 4f       	sbci	r17, 0xFF	; 255
     e18:	7e 01       	movw	r14, r28
     e1a:	e7 e5       	ldi	r30, 0x57	; 87
     e1c:	ee 0e       	add	r14, r30
     e1e:	f1 1c       	adc	r15, r1
     e20:	1e 01       	movw	r2, r28
     e22:	fc e5       	ldi	r31, 0x5C	; 92
     e24:	2f 0e       	add	r2, r31
     e26:	31 1c       	adc	r3, r1
     e28:	84 2c       	mov	r8, r4
     e2a:	91 2c       	mov	r9, r1
     e2c:	88 81       	ld	r24, Y
     e2e:	99 81       	ldd	r25, Y+1	; 0x01
     e30:	f3 01       	movw	r30, r6
     e32:	a0 81       	ld	r26, Z
     e34:	b1 81       	ldd	r27, Z+1	; 0x01
     e36:	a8 0d       	add	r26, r8
     e38:	b9 1d       	adc	r27, r9
     e3a:	fc 01       	movw	r30, r24
     e3c:	20 81       	ld	r18, Z
     e3e:	31 81       	ldd	r19, Z+1	; 0x01
     e40:	41 e0       	ldi	r20, 0x01	; 1
     e42:	6c 91       	ld	r22, X
     e44:	ce 01       	movw	r24, r28
     e46:	f9 01       	movw	r30, r18
     e48:	19 95       	eicall
     e4a:	88 81       	ld	r24, Y
     e4c:	99 81       	ldd	r25, Y+1	; 0x01
     e4e:	f3 01       	movw	r30, r6
     e50:	a0 81       	ld	r26, Z
     e52:	b1 81       	ldd	r27, Z+1	; 0x01
     e54:	a8 0d       	add	r26, r8
     e56:	b9 1d       	adc	r27, r9
     e58:	fc 01       	movw	r30, r24
     e5a:	22 81       	ldd	r18, Z+2	; 0x02
     e5c:	33 81       	ldd	r19, Z+3	; 0x03
     e5e:	40 e0       	ldi	r20, 0x00	; 0
     e60:	6c 91       	ld	r22, X
     e62:	ce 01       	movw	r24, r28
     e64:	f9 01       	movw	r30, r18
     e66:	19 95       	eicall
     e68:	d8 01       	movw	r26, r16
     e6a:	8c 91       	ld	r24, X
     e6c:	88 23       	and	r24, r24
     e6e:	09 f4       	brne	.+2      	; 0xe72 <_ZN6Keypad8scanKeysEv+0xde>
     e70:	3f c0       	rjmp	.+126    	; 0xef0 <_ZN6Keypad8scanKeysEv+0x15c>
     e72:	81 e0       	ldi	r24, 0x01	; 1
     e74:	90 e0       	ldi	r25, 0x00	; 0
     e76:	a0 e0       	ldi	r26, 0x00	; 0
     e78:	b0 e0       	ldi	r27, 0x00	; 0
     e7a:	04 2c       	mov	r0, r4
     e7c:	04 c0       	rjmp	.+8      	; 0xe86 <_ZN6Keypad8scanKeysEv+0xf2>
     e7e:	88 0f       	add	r24, r24
     e80:	99 1f       	adc	r25, r25
     e82:	aa 1f       	adc	r26, r26
     e84:	bb 1f       	adc	r27, r27
     e86:	0a 94       	dec	r0
     e88:	d2 f7       	brpl	.-12     	; 0xe7e <_ZN6Keypad8scanKeysEv+0xea>
     e8a:	5c 01       	movw	r10, r24
     e8c:	6c 01       	movw	r12, r24
     e8e:	c0 94       	com	r12
     e90:	d0 94       	com	r13
     e92:	51 2c       	mov	r5, r1
     e94:	88 81       	ld	r24, Y
     e96:	99 81       	ldd	r25, Y+1	; 0x01
     e98:	f7 01       	movw	r30, r14
     e9a:	a0 81       	ld	r26, Z
     e9c:	b1 81       	ldd	r27, Z+1	; 0x01
     e9e:	a5 0d       	add	r26, r5
     ea0:	b1 1d       	adc	r27, r1
     ea2:	fc 01       	movw	r30, r24
     ea4:	24 81       	ldd	r18, Z+4	; 0x04
     ea6:	35 81       	ldd	r19, Z+5	; 0x05
     ea8:	6c 91       	ld	r22, X
     eaa:	ce 01       	movw	r24, r28
     eac:	f9 01       	movw	r30, r18
     eae:	19 95       	eicall
     eb0:	89 2b       	or	r24, r25
     eb2:	69 f4       	brne	.+26     	; 0xece <_ZN6Keypad8scanKeysEv+0x13a>
     eb4:	e5 2d       	mov	r30, r5
     eb6:	f0 e0       	ldi	r31, 0x00	; 0
     eb8:	ee 0f       	add	r30, r30
     eba:	ff 1f       	adc	r31, r31
     ebc:	ec 0f       	add	r30, r28
     ebe:	fd 1f       	adc	r31, r29
     ec0:	87 81       	ldd	r24, Z+7	; 0x07
     ec2:	90 85       	ldd	r25, Z+8	; 0x08
     ec4:	8a 29       	or	r24, r10
     ec6:	9b 29       	or	r25, r11
     ec8:	90 87       	std	Z+8, r25	; 0x08
     eca:	87 83       	std	Z+7, r24	; 0x07
     ecc:	0c c0       	rjmp	.+24     	; 0xee6 <_ZN6Keypad8scanKeysEv+0x152>
     ece:	e5 2d       	mov	r30, r5
     ed0:	f0 e0       	ldi	r31, 0x00	; 0
     ed2:	ee 0f       	add	r30, r30
     ed4:	ff 1f       	adc	r31, r31
     ed6:	ec 0f       	add	r30, r28
     ed8:	fd 1f       	adc	r31, r29
     eda:	87 81       	ldd	r24, Z+7	; 0x07
     edc:	90 85       	ldd	r25, Z+8	; 0x08
     ede:	8c 21       	and	r24, r12
     ee0:	9d 21       	and	r25, r13
     ee2:	90 87       	std	Z+8, r25	; 0x08
     ee4:	87 83       	std	Z+7, r24	; 0x07
     ee6:	53 94       	inc	r5
     ee8:	d8 01       	movw	r26, r16
     eea:	8c 91       	ld	r24, X
     eec:	58 16       	cp	r5, r24
     eee:	90 f2       	brcs	.-92     	; 0xe94 <_ZN6Keypad8scanKeysEv+0x100>
     ef0:	88 81       	ld	r24, Y
     ef2:	99 81       	ldd	r25, Y+1	; 0x01
     ef4:	f3 01       	movw	r30, r6
     ef6:	a0 81       	ld	r26, Z
     ef8:	b1 81       	ldd	r27, Z+1	; 0x01
     efa:	a8 0d       	add	r26, r8
     efc:	b9 1d       	adc	r27, r9
     efe:	fc 01       	movw	r30, r24
     f00:	22 81       	ldd	r18, Z+2	; 0x02
     f02:	33 81       	ldd	r19, Z+3	; 0x03
     f04:	41 e0       	ldi	r20, 0x01	; 1
     f06:	6c 91       	ld	r22, X
     f08:	ce 01       	movw	r24, r28
     f0a:	f9 01       	movw	r30, r18
     f0c:	19 95       	eicall
     f0e:	e8 81       	ld	r30, Y
     f10:	f9 81       	ldd	r31, Y+1	; 0x01
     f12:	d3 01       	movw	r26, r6
     f14:	8d 91       	ld	r24, X+
     f16:	9c 91       	ld	r25, X
     f18:	dc 01       	movw	r26, r24
     f1a:	a8 0d       	add	r26, r8
     f1c:	b9 1d       	adc	r27, r9
     f1e:	01 90       	ld	r0, Z+
     f20:	f0 81       	ld	r31, Z
     f22:	e0 2d       	mov	r30, r0
     f24:	40 e0       	ldi	r20, 0x00	; 0
     f26:	6c 91       	ld	r22, X
     f28:	ce 01       	movw	r24, r28
     f2a:	19 95       	eicall
     f2c:	43 94       	inc	r4
     f2e:	f1 01       	movw	r30, r2
     f30:	80 81       	ld	r24, Z
     f32:	48 16       	cp	r4, r24
     f34:	08 f4       	brcc	.+2      	; 0xf38 <_ZN6Keypad8scanKeysEv+0x1a4>
     f36:	78 cf       	rjmp	.-272    	; 0xe28 <_ZN6Keypad8scanKeysEv+0x94>
     f38:	df 91       	pop	r29
     f3a:	cf 91       	pop	r28
     f3c:	1f 91       	pop	r17
     f3e:	0f 91       	pop	r16
     f40:	ff 90       	pop	r15
     f42:	ef 90       	pop	r14
     f44:	df 90       	pop	r13
     f46:	cf 90       	pop	r12
     f48:	bf 90       	pop	r11
     f4a:	af 90       	pop	r10
     f4c:	9f 90       	pop	r9
     f4e:	8f 90       	pop	r8
     f50:	7f 90       	pop	r7
     f52:	6f 90       	pop	r6
     f54:	5f 90       	pop	r5
     f56:	4f 90       	pop	r4
     f58:	3f 90       	pop	r3
     f5a:	2f 90       	pop	r2
     f5c:	08 95       	ret

00000f5e <_ZN6Keypad10findInListEi>:
     f5e:	fc 01       	movw	r30, r24
     f60:	24 8d       	ldd	r18, Z+28	; 0x1c
     f62:	35 8d       	ldd	r19, Z+29	; 0x1d
     f64:	26 17       	cp	r18, r22
     f66:	37 07       	cpc	r19, r23
     f68:	89 f0       	breq	.+34     	; 0xf8c <_ZN6Keypad10findInListEi+0x2e>
     f6a:	b1 96       	adiw	r30, 0x21	; 33
     f6c:	21 e0       	ldi	r18, 0x01	; 1
     f6e:	30 e0       	ldi	r19, 0x00	; 0
     f70:	82 2f       	mov	r24, r18
     f72:	93 2f       	mov	r25, r19
     f74:	40 81       	ld	r20, Z
     f76:	51 81       	ldd	r21, Z+1	; 0x01
     f78:	46 17       	cp	r20, r22
     f7a:	57 07       	cpc	r21, r23
     f7c:	61 f0       	breq	.+24     	; 0xf96 <_ZN6Keypad10findInListEi+0x38>
     f7e:	2f 5f       	subi	r18, 0xFF	; 255
     f80:	3f 4f       	sbci	r19, 0xFF	; 255
     f82:	35 96       	adiw	r30, 0x05	; 5
     f84:	2a 30       	cpi	r18, 0x0A	; 10
     f86:	31 05       	cpc	r19, r1
     f88:	99 f7       	brne	.-26     	; 0xf70 <_ZN6Keypad10findInListEi+0x12>
     f8a:	03 c0       	rjmp	.+6      	; 0xf92 <_ZN6Keypad10findInListEi+0x34>
     f8c:	80 e0       	ldi	r24, 0x00	; 0
     f8e:	90 e0       	ldi	r25, 0x00	; 0
     f90:	08 95       	ret
     f92:	8f ef       	ldi	r24, 0xFF	; 255
     f94:	9f ef       	ldi	r25, 0xFF	; 255
     f96:	08 95       	ret

00000f98 <_ZN6Keypad12transitionToEh8KeyState>:
}

void Keypad::transitionTo(unsigned char idx, KeyState nextState) {
	key[idx].kstate = nextState;
     f98:	26 2f       	mov	r18, r22
     f9a:	30 e0       	ldi	r19, 0x00	; 0
     f9c:	f9 01       	movw	r30, r18
     f9e:	ee 0f       	add	r30, r30
     fa0:	ff 1f       	adc	r31, r31
     fa2:	ee 0f       	add	r30, r30
     fa4:	ff 1f       	adc	r31, r31
     fa6:	e2 0f       	add	r30, r18
     fa8:	f3 1f       	adc	r31, r19
     faa:	e8 0f       	add	r30, r24
     fac:	f9 1f       	adc	r31, r25
     fae:	46 8f       	std	Z+30, r20	; 0x1e
	key[idx].stateChanged = true;
     fb0:	41 e0       	ldi	r20, 0x01	; 1
     fb2:	47 8f       	std	Z+31, r20	; 0x1f

	// Sketch used the getKey() function.
	// Calls keypadEventListener only when the first key in slot 0 changes state.
	if (single_key)  {
     fb4:	fc 01       	movw	r30, r24
     fb6:	ef 59       	subi	r30, 0x9F	; 159
     fb8:	ff 4f       	sbci	r31, 0xFF	; 255
     fba:	40 81       	ld	r20, Z
     fbc:	44 23       	and	r20, r20
     fbe:	69 f0       	breq	.+26     	; 0xfda <_ZN6Keypad12transitionToEh8KeyState+0x42>
	  	if ( (keypadEventListener!=NULL) && (idx==0) )  {
     fc0:	31 96       	adiw	r30, 0x01	; 1
     fc2:	01 90       	ld	r0, Z+
     fc4:	f0 81       	ld	r31, Z
     fc6:	e0 2d       	mov	r30, r0
     fc8:	30 97       	sbiw	r30, 0x00	; 0
     fca:	e1 f0       	breq	.+56     	; 0x1004 <_ZN6Keypad12transitionToEh8KeyState+0x6c>
     fcc:	61 11       	cpse	r22, r1
     fce:	1a c0       	rjmp	.+52     	; 0x1004 <_ZN6Keypad12transitionToEh8KeyState+0x6c>
			keypadEventListener(key[0].kchar);
     fd0:	dc 01       	movw	r26, r24
     fd2:	5b 96       	adiw	r26, 0x1b	; 27
     fd4:	8c 91       	ld	r24, X
     fd6:	19 95       	eicall
     fd8:	08 95       	ret
		}
	}
	// Sketch used the getKeys() function.
	// Calls keypadEventListener on any key that changes state.
	else {
	  	if (keypadEventListener!=NULL)  {
     fda:	fc 01       	movw	r30, r24
     fdc:	ee 59       	subi	r30, 0x9E	; 158
     fde:	ff 4f       	sbci	r31, 0xFF	; 255
     fe0:	01 90       	ld	r0, Z+
     fe2:	f0 81       	ld	r31, Z
     fe4:	e0 2d       	mov	r30, r0
     fe6:	30 97       	sbiw	r30, 0x00	; 0
     fe8:	69 f0       	breq	.+26     	; 0x1004 <_ZN6Keypad12transitionToEh8KeyState+0x6c>
			keypadEventListener(key[idx].kchar);
     fea:	a9 01       	movw	r20, r18
     fec:	44 0f       	add	r20, r20
     fee:	55 1f       	adc	r21, r21
     ff0:	44 0f       	add	r20, r20
     ff2:	55 1f       	adc	r21, r21
     ff4:	24 0f       	add	r18, r20
     ff6:	35 1f       	adc	r19, r21
     ff8:	dc 01       	movw	r26, r24
     ffa:	a2 0f       	add	r26, r18
     ffc:	b3 1f       	adc	r27, r19
     ffe:	5b 96       	adiw	r26, 0x1b	; 27
    1000:	8c 91       	ld	r24, X
    1002:	19 95       	eicall
    1004:	08 95       	ret

00001006 <_ZN6Keypad12nextKeyStateEhb>:
	return anyActivity;
}

// Private
// This function is a state machine but is also used for debouncing the keys.
void Keypad::nextKeyState(unsigned char idx, boolean button) {
    1006:	ef 92       	push	r14
    1008:	ff 92       	push	r15
    100a:	0f 93       	push	r16
    100c:	1f 93       	push	r17
    100e:	cf 93       	push	r28
    1010:	df 93       	push	r29
    1012:	ec 01       	movw	r28, r24
    1014:	f6 2e       	mov	r15, r22
    1016:	e4 2e       	mov	r14, r20
	key[idx].stateChanged = false;
    1018:	86 2f       	mov	r24, r22
    101a:	90 e0       	ldi	r25, 0x00	; 0
    101c:	fc 01       	movw	r30, r24
    101e:	ee 0f       	add	r30, r30
    1020:	ff 1f       	adc	r31, r31
    1022:	ee 0f       	add	r30, r30
    1024:	ff 1f       	adc	r31, r31
    1026:	e8 0f       	add	r30, r24
    1028:	f9 1f       	adc	r31, r25
    102a:	ec 0f       	add	r30, r28
    102c:	fd 1f       	adc	r31, r29
    102e:	17 8e       	std	Z+31, r1	; 0x1f

	switch (key[idx].kstate) {
    1030:	86 8d       	ldd	r24, Z+30	; 0x1e
    1032:	81 30       	cpi	r24, 0x01	; 1
    1034:	a9 f0       	breq	.+42     	; 0x1060 <_ZN6Keypad12nextKeyStateEhb+0x5a>
    1036:	28 f0       	brcs	.+10     	; 0x1042 <_ZN6Keypad12nextKeyStateEhb+0x3c>
    1038:	82 30       	cpi	r24, 0x02	; 2
    103a:	b9 f1       	breq	.+110    	; 0x10aa <_ZN6Keypad12nextKeyStateEhb+0xa4>
    103c:	83 30       	cpi	r24, 0x03	; 3
    103e:	d9 f1       	breq	.+118    	; 0x10b6 <_ZN6Keypad12nextKeyStateEhb+0xb0>
    1040:	3d c0       	rjmp	.+122    	; 0x10bc <_ZN6Keypad12nextKeyStateEhb+0xb6>
		case IDLE:
			if (button==CLOSED) {
    1042:	44 23       	and	r20, r20
    1044:	09 f4       	brne	.+2      	; 0x1048 <_ZN6Keypad12nextKeyStateEhb+0x42>
    1046:	3a c0       	rjmp	.+116    	; 0x10bc <_ZN6Keypad12nextKeyStateEhb+0xb6>
				transitionTo (idx, PRESSED);
    1048:	41 e0       	ldi	r20, 0x01	; 1
    104a:	ce 01       	movw	r24, r28
    104c:	a5 df       	rcall	.-182    	; 0xf98 <_ZN6Keypad12transitionToEh8KeyState>
				holdTimer = millis(); }		// Get ready for next HOLD state.
    104e:	0e 94 c7 1f 	call	0x3f8e	; 0x3f8e <millis>
    1052:	c3 5b       	subi	r28, 0xB3	; 179
    1054:	df 4f       	sbci	r29, 0xFF	; 255
    1056:	68 83       	st	Y, r22
    1058:	79 83       	std	Y+1, r23	; 0x01
    105a:	8a 83       	std	Y+2, r24	; 0x02
    105c:	9b 83       	std	Y+3, r25	; 0x03
    105e:	2e c0       	rjmp	.+92     	; 0x10bc <_ZN6Keypad12nextKeyStateEhb+0xb6>
			break;
		case PRESSED:
			if ((millis()-holdTimer)>holdTime)	// Waiting for a key HOLD...
    1060:	0e 94 c7 1f 	call	0x3f8e	; 0x3f8e <millis>
    1064:	fe 01       	movw	r30, r28
    1066:	e3 5b       	subi	r30, 0xB3	; 179
    1068:	ff 4f       	sbci	r31, 0xFF	; 255
    106a:	00 81       	ld	r16, Z
    106c:	11 81       	ldd	r17, Z+1	; 0x01
    106e:	22 81       	ldd	r18, Z+2	; 0x02
    1070:	33 81       	ldd	r19, Z+3	; 0x03
    1072:	dc 01       	movw	r26, r24
    1074:	cb 01       	movw	r24, r22
    1076:	80 1b       	sub	r24, r16
    1078:	91 0b       	sbc	r25, r17
    107a:	a2 0b       	sbc	r26, r18
    107c:	b3 0b       	sbc	r27, r19
    107e:	72 96       	adiw	r30, 0x12	; 18
    1080:	00 81       	ld	r16, Z
    1082:	11 81       	ldd	r17, Z+1	; 0x01
    1084:	20 e0       	ldi	r18, 0x00	; 0
    1086:	30 e0       	ldi	r19, 0x00	; 0
    1088:	08 17       	cp	r16, r24
    108a:	19 07       	cpc	r17, r25
    108c:	2a 07       	cpc	r18, r26
    108e:	3b 07       	cpc	r19, r27
    1090:	28 f4       	brcc	.+10     	; 0x109c <_ZN6Keypad12nextKeyStateEhb+0x96>
				transitionTo (idx, HOLD);
    1092:	42 e0       	ldi	r20, 0x02	; 2
    1094:	6f 2d       	mov	r22, r15
    1096:	ce 01       	movw	r24, r28
    1098:	7f df       	rcall	.-258    	; 0xf98 <_ZN6Keypad12transitionToEh8KeyState>
    109a:	10 c0       	rjmp	.+32     	; 0x10bc <_ZN6Keypad12nextKeyStateEhb+0xb6>
			else if (button==OPEN)				// or for a key to be RELEASED.
    109c:	e1 10       	cpse	r14, r1
    109e:	0e c0       	rjmp	.+28     	; 0x10bc <_ZN6Keypad12nextKeyStateEhb+0xb6>
				transitionTo (idx, RELEASED);
    10a0:	43 e0       	ldi	r20, 0x03	; 3
    10a2:	6f 2d       	mov	r22, r15
    10a4:	ce 01       	movw	r24, r28
    10a6:	78 df       	rcall	.-272    	; 0xf98 <_ZN6Keypad12transitionToEh8KeyState>
    10a8:	09 c0       	rjmp	.+18     	; 0x10bc <_ZN6Keypad12nextKeyStateEhb+0xb6>
			break;
		case HOLD:
			if (button==OPEN)
    10aa:	41 11       	cpse	r20, r1
    10ac:	07 c0       	rjmp	.+14     	; 0x10bc <_ZN6Keypad12nextKeyStateEhb+0xb6>
				transitionTo (idx, RELEASED);
    10ae:	43 e0       	ldi	r20, 0x03	; 3
    10b0:	ce 01       	movw	r24, r28
    10b2:	72 df       	rcall	.-284    	; 0xf98 <_ZN6Keypad12transitionToEh8KeyState>
    10b4:	03 c0       	rjmp	.+6      	; 0x10bc <_ZN6Keypad12nextKeyStateEhb+0xb6>
			break;
		case RELEASED:
			transitionTo (idx, IDLE);
    10b6:	40 e0       	ldi	r20, 0x00	; 0
    10b8:	ce 01       	movw	r24, r28
    10ba:	6e df       	rcall	.-292    	; 0xf98 <_ZN6Keypad12transitionToEh8KeyState>
			break;
	}
}
    10bc:	df 91       	pop	r29
    10be:	cf 91       	pop	r28
    10c0:	1f 91       	pop	r17
    10c2:	0f 91       	pop	r16
    10c4:	ff 90       	pop	r15
    10c6:	ef 90       	pop	r14
    10c8:	08 95       	ret

000010ca <_ZN6Keypad10updateListEv>:
		pin_mode(columnPins[c],INPUT);
	}
}

// Manage the list without rearranging the keys. Returns true if any keys on the list changed state.
bool Keypad::updateList() {
    10ca:	2f 92       	push	r2
    10cc:	3f 92       	push	r3
    10ce:	4f 92       	push	r4
    10d0:	5f 92       	push	r5
    10d2:	6f 92       	push	r6
    10d4:	7f 92       	push	r7
    10d6:	8f 92       	push	r8
    10d8:	9f 92       	push	r9
    10da:	af 92       	push	r10
    10dc:	bf 92       	push	r11
    10de:	cf 92       	push	r12
    10e0:	df 92       	push	r13
    10e2:	ef 92       	push	r14
    10e4:	ff 92       	push	r15
    10e6:	0f 93       	push	r16
    10e8:	1f 93       	push	r17
    10ea:	cf 93       	push	r28
    10ec:	df 93       	push	r29
    10ee:	cd b7       	in	r28, 0x3d	; 61
    10f0:	de b7       	in	r29, 0x3e	; 62
    10f2:	27 97       	sbiw	r28, 0x07	; 7
    10f4:	0f b6       	in	r0, 0x3f	; 63
    10f6:	f8 94       	cli
    10f8:	de bf       	out	0x3e, r29	; 62
    10fa:	0f be       	out	0x3f, r0	; 63
    10fc:	cd bf       	out	0x3d, r28	; 61
    10fe:	8c 01       	movw	r16, r24
    1100:	fc 01       	movw	r30, r24
    1102:	7f 96       	adiw	r30, 0x1f	; 31
    1104:	2a e0       	ldi	r18, 0x0A	; 10

	// Delete any IDLE keys
	for (unsigned char i=0; i<LIST_MAX; i++) {
		if (key[i].kstate==IDLE) {
			key[i].kchar = NO_KEY;
			key[i].kcode = -1;
    1106:	8f ef       	ldi	r24, 0xFF	; 255
    1108:	9f ef       	ldi	r25, 0xFF	; 255
    110a:	df 01       	movw	r26, r30
    110c:	11 97       	sbiw	r26, 0x01	; 1

	bool anyActivity = false;

	// Delete any IDLE keys
	for (unsigned char i=0; i<LIST_MAX; i++) {
		if (key[i].kstate==IDLE) {
    110e:	3c 91       	ld	r19, X
    1110:	31 11       	cpse	r19, r1
    1112:	06 c0       	rjmp	.+12     	; 0x1120 <_ZN6Keypad10updateListEv+0x56>
    1114:	13 97       	sbiw	r26, 0x03	; 3
			key[i].kchar = NO_KEY;
    1116:	1c 92       	st	X, r1
    1118:	11 96       	adiw	r26, 0x01	; 1
			key[i].kcode = -1;
    111a:	8d 93       	st	X+, r24
    111c:	9c 93       	st	X, r25
			key[i].stateChanged = false;
    111e:	10 82       	st	Z, r1
    1120:	21 50       	subi	r18, 0x01	; 1
    1122:	35 96       	adiw	r30, 0x05	; 5
bool Keypad::updateList() {

	bool anyActivity = false;

	// Delete any IDLE keys
	for (unsigned char i=0; i<LIST_MAX; i++) {
    1124:	21 11       	cpse	r18, r1
    1126:	f1 cf       	rjmp	.-30     	; 0x110a <_ZN6Keypad10updateListEv+0x40>
			key[i].stateChanged = false;
		}
	}

	// Add new keys to empty slots in the key list.
	for (unsigned char r=0; r<sizeKpd.rows; r++) {
    1128:	f8 01       	movw	r30, r16
    112a:	e5 5a       	subi	r30, 0xA5	; 165
    112c:	ff 4f       	sbci	r31, 0xFF	; 255
    112e:	80 81       	ld	r24, Z
    1130:	88 23       	and	r24, r24
    1132:	09 f4       	brne	.+2      	; 0x1136 <_ZN6Keypad10updateListEv+0x6c>
    1134:	92 c0       	rjmp	.+292    	; 0x125a <_ZN6Keypad10updateListEv+0x190>
    1136:	21 2c       	mov	r2, r1
		for (unsigned char c=0; c<sizeKpd.columns; c++) {
    1138:	68 01       	movw	r12, r16
    113a:	2c e5       	ldi	r18, 0x5C	; 92
    113c:	c2 0e       	add	r12, r18
    113e:	d1 1c       	adc	r13, r1
			boolean button = bitRead(bitMap[r],c);
			char keyChar = keymap[r * sizeKpd.columns + c];
    1140:	48 01       	movw	r8, r16
    1142:	35 e5       	ldi	r19, 0x55	; 85
    1144:	83 0e       	add	r8, r19
    1146:	91 1c       	adc	r9, r1
				nextKeyState(idx, button);
			}
			// Key is NOT on the list so add it.
			if ((idx == -1) && button) {
				for (unsigned char i=0; i<LIST_MAX; i++) {
					if (key[i].kchar==NO_KEY) {		// Find an empty slot or don't add key to list.
    1148:	1d 82       	std	Y+5, r1	; 0x05
    114a:	c8 01       	movw	r24, r16
    114c:	80 96       	adiw	r24, 0x20	; 32
    114e:	9a 83       	std	Y+2, r25	; 0x02
    1150:	89 83       	std	Y+1, r24	; 0x01
			key[i].stateChanged = false;
		}
	}

	// Add new keys to empty slots in the key list.
	for (unsigned char r=0; r<sizeKpd.rows; r++) {
    1152:	fc 83       	std	Y+4, r31	; 0x04
    1154:	eb 83       	std	Y+3, r30	; 0x03
    1156:	65 c0       	rjmp	.+202    	; 0x1222 <_ZN6Keypad10updateListEv+0x158>
		for (unsigned char c=0; c<sizeKpd.columns; c++) {
			boolean button = bitRead(bitMap[r],c);
    1158:	f5 01       	movw	r30, r10
    115a:	80 81       	ld	r24, Z
    115c:	91 81       	ldd	r25, Z+1	; 0x01
    115e:	05 2c       	mov	r0, r5
    1160:	02 c0       	rjmp	.+4      	; 0x1166 <_ZN6Keypad10updateListEv+0x9c>
    1162:	96 95       	lsr	r25
    1164:	87 95       	ror	r24
    1166:	0a 94       	dec	r0
    1168:	e2 f7       	brpl	.-8      	; 0x1162 <_ZN6Keypad10updateListEv+0x98>
    116a:	f8 2f       	mov	r31, r24
    116c:	f1 70       	andi	r31, 0x01	; 1
    116e:	3f 2e       	mov	r3, r31
			char keyChar = keymap[r * sizeKpd.columns + c];
    1170:	2e 9d       	mul	r18, r14
    1172:	c0 01       	movw	r24, r0
    1174:	2f 9d       	mul	r18, r15
    1176:	90 0d       	add	r25, r0
    1178:	11 24       	eor	r1, r1
    117a:	9c 01       	movw	r18, r24
    117c:	25 0d       	add	r18, r5
    117e:	31 1d       	adc	r19, r1
    1180:	3f 83       	std	Y+7, r19	; 0x07
    1182:	2e 83       	std	Y+6, r18	; 0x06
    1184:	d4 01       	movw	r26, r8
    1186:	ed 91       	ld	r30, X+
    1188:	fc 91       	ld	r31, X
    118a:	e2 0f       	add	r30, r18
    118c:	f3 1f       	adc	r31, r19
    118e:	40 80       	ld	r4, Z
			int keyCode = r * sizeKpd.columns + c;
			int idx = findInList (keyCode);
    1190:	b9 01       	movw	r22, r18
    1192:	c8 01       	movw	r24, r16
    1194:	e4 de       	rcall	.-568    	; 0xf5e <_ZN6Keypad10findInListEi>
    1196:	3c 01       	movw	r6, r24
			// Key is already on the list so set its next state.
			if (idx > -1)	{
    1198:	99 23       	and	r25, r25
    119a:	24 f0       	brlt	.+8      	; 0x11a4 <_ZN6Keypad10updateListEv+0xda>
				nextKeyState(idx, button);
    119c:	43 2d       	mov	r20, r3
    119e:	68 2f       	mov	r22, r24
    11a0:	c8 01       	movw	r24, r16
    11a2:	31 df       	rcall	.-414    	; 0x1006 <_ZN6Keypad12nextKeyStateEhb>
			}
			// Key is NOT on the list so add it.
			if ((idx == -1) && button) {
    11a4:	67 20       	and	r6, r7
    11a6:	60 94       	com	r6
    11a8:	81 f5       	brne	.+96     	; 0x120a <_ZN6Keypad10updateListEv+0x140>
    11aa:	33 20       	and	r3, r3
    11ac:	71 f1       	breq	.+92     	; 0x120a <_ZN6Keypad10updateListEv+0x140>
				for (unsigned char i=0; i<LIST_MAX; i++) {
					if (key[i].kchar==NO_KEY) {		// Find an empty slot or don't add key to list.
    11ae:	f8 01       	movw	r30, r16
    11b0:	83 8d       	ldd	r24, Z+27	; 0x1b
    11b2:	88 23       	and	r24, r24
    11b4:	71 f0       	breq	.+28     	; 0x11d2 <_ZN6Keypad10updateListEv+0x108>
    11b6:	e9 81       	ldd	r30, Y+1	; 0x01
    11b8:	fa 81       	ldd	r31, Y+2	; 0x02
    11ba:	81 e0       	ldi	r24, 0x01	; 1
    11bc:	90 e0       	ldi	r25, 0x00	; 0
    11be:	ae 81       	ldd	r26, Y+6	; 0x06
    11c0:	bf 81       	ldd	r27, Y+7	; 0x07
    11c2:	68 2f       	mov	r22, r24
    11c4:	9c 01       	movw	r18, r24
    11c6:	40 81       	ld	r20, Z
    11c8:	41 11       	cpse	r20, r1
    11ca:	1a c0       	rjmp	.+52     	; 0x1200 <_ZN6Keypad10updateListEv+0x136>
    11cc:	bf 83       	std	Y+7, r27	; 0x07
    11ce:	ae 83       	std	Y+6, r26	; 0x06
    11d0:	03 c0       	rjmp	.+6      	; 0x11d8 <_ZN6Keypad10updateListEv+0x10e>
    11d2:	20 e0       	ldi	r18, 0x00	; 0
    11d4:	30 e0       	ldi	r19, 0x00	; 0
    11d6:	6d 81       	ldd	r22, Y+5	; 0x05
						key[i].kchar = keyChar;
    11d8:	f9 01       	movw	r30, r18
    11da:	ee 0f       	add	r30, r30
    11dc:	ff 1f       	adc	r31, r31
    11de:	ee 0f       	add	r30, r30
    11e0:	ff 1f       	adc	r31, r31
    11e2:	2e 0f       	add	r18, r30
    11e4:	3f 1f       	adc	r19, r31
    11e6:	f8 01       	movw	r30, r16
    11e8:	e2 0f       	add	r30, r18
    11ea:	f3 1f       	adc	r31, r19
    11ec:	43 8e       	std	Z+27, r4	; 0x1b
						key[i].kcode = keyCode;
    11ee:	2e 81       	ldd	r18, Y+6	; 0x06
    11f0:	3f 81       	ldd	r19, Y+7	; 0x07
    11f2:	35 8f       	std	Z+29, r19	; 0x1d
    11f4:	24 8f       	std	Z+28, r18	; 0x1c
						key[i].kstate = IDLE;		// Keys NOT on the list have an initial state of IDLE.
    11f6:	16 8e       	std	Z+30, r1	; 0x1e
						nextKeyState (i, button);
    11f8:	41 e0       	ldi	r20, 0x01	; 1
    11fa:	c8 01       	movw	r24, r16
    11fc:	04 df       	rcall	.-504    	; 0x1006 <_ZN6Keypad12nextKeyStateEhb>
						break;	// Don't fill all the empty slots with the same key.
    11fe:	05 c0       	rjmp	.+10     	; 0x120a <_ZN6Keypad10updateListEv+0x140>
    1200:	01 96       	adiw	r24, 0x01	; 1
    1202:	35 96       	adiw	r30, 0x05	; 5
			if (idx > -1)	{
				nextKeyState(idx, button);
			}
			// Key is NOT on the list so add it.
			if ((idx == -1) && button) {
				for (unsigned char i=0; i<LIST_MAX; i++) {
    1204:	8a 30       	cpi	r24, 0x0A	; 10
    1206:	91 05       	cpc	r25, r1
    1208:	e1 f6       	brne	.-72     	; 0x11c2 <_ZN6Keypad10updateListEv+0xf8>
		}
	}

	// Add new keys to empty slots in the key list.
	for (unsigned char r=0; r<sizeKpd.rows; r++) {
		for (unsigned char c=0; c<sizeKpd.columns; c++) {
    120a:	53 94       	inc	r5
    120c:	d6 01       	movw	r26, r12
    120e:	2c 91       	ld	r18, X
    1210:	52 16       	cp	r5, r18
    1212:	08 f4       	brcc	.+2      	; 0x1216 <_ZN6Keypad10updateListEv+0x14c>
    1214:	a1 cf       	rjmp	.-190    	; 0x1158 <_ZN6Keypad10updateListEv+0x8e>
			key[i].stateChanged = false;
		}
	}

	// Add new keys to empty slots in the key list.
	for (unsigned char r=0; r<sizeKpd.rows; r++) {
    1216:	23 94       	inc	r2
    1218:	eb 81       	ldd	r30, Y+3	; 0x03
    121a:	fc 81       	ldd	r31, Y+4	; 0x04
    121c:	80 81       	ld	r24, Z
    121e:	28 16       	cp	r2, r24
    1220:	e0 f4       	brcc	.+56     	; 0x125a <_ZN6Keypad10updateListEv+0x190>
		for (unsigned char c=0; c<sizeKpd.columns; c++) {
    1222:	d6 01       	movw	r26, r12
    1224:	2c 91       	ld	r18, X
    1226:	22 23       	and	r18, r18
    1228:	b1 f3       	breq	.-20     	; 0x1216 <_ZN6Keypad10updateListEv+0x14c>
    122a:	51 2c       	mov	r5, r1
			boolean button = bitRead(bitMap[r],c);
    122c:	e2 2c       	mov	r14, r2
    122e:	f1 2c       	mov	r15, r1
    1230:	57 01       	movw	r10, r14
    1232:	aa 0c       	add	r10, r10
    1234:	bb 1c       	adc	r11, r11
    1236:	a0 0e       	add	r10, r16
    1238:	b1 1e       	adc	r11, r17
    123a:	b7 e0       	ldi	r27, 0x07	; 7
    123c:	ab 0e       	add	r10, r27
    123e:	b1 1c       	adc	r11, r1
    1240:	8b cf       	rjmp	.-234    	; 0x1158 <_ZN6Keypad10updateListEv+0x8e>
    1242:	f8 01       	movw	r30, r16
    1244:	e2 0f       	add	r30, r18
    1246:	f3 1f       	adc	r31, r19
		}
	}

	// Report if the user changed the state of any key.
	for (unsigned char i=0; i<LIST_MAX; i++) {
		if (key[i].stateChanged) anyActivity = true;
    1248:	97 8d       	ldd	r25, Z+31	; 0x1f
    124a:	91 11       	cpse	r25, r1
    124c:	84 2f       	mov	r24, r20
    124e:	2b 5f       	subi	r18, 0xFB	; 251
    1250:	3f 4f       	sbci	r19, 0xFF	; 255
			}
		}
	}

	// Report if the user changed the state of any key.
	for (unsigned char i=0; i<LIST_MAX; i++) {
    1252:	22 33       	cpi	r18, 0x32	; 50
    1254:	31 05       	cpc	r19, r1
    1256:	a9 f7       	brne	.-22     	; 0x1242 <_ZN6Keypad10updateListEv+0x178>
    1258:	05 c0       	rjmp	.+10     	; 0x1264 <_ZN6Keypad10updateListEv+0x19a>
			key[i].stateChanged = false;
		}
	}

	// Add new keys to empty slots in the key list.
	for (unsigned char r=0; r<sizeKpd.rows; r++) {
    125a:	20 e0       	ldi	r18, 0x00	; 0
    125c:	30 e0       	ldi	r19, 0x00	; 0
    125e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}

	// Report if the user changed the state of any key.
	for (unsigned char i=0; i<LIST_MAX; i++) {
		if (key[i].stateChanged) anyActivity = true;
    1260:	41 e0       	ldi	r20, 0x01	; 1
    1262:	ef cf       	rjmp	.-34     	; 0x1242 <_ZN6Keypad10updateListEv+0x178>
	}

	return anyActivity;
}
    1264:	27 96       	adiw	r28, 0x07	; 7
    1266:	0f b6       	in	r0, 0x3f	; 63
    1268:	f8 94       	cli
    126a:	de bf       	out	0x3e, r29	; 62
    126c:	0f be       	out	0x3f, r0	; 63
    126e:	cd bf       	out	0x3d, r28	; 61
    1270:	df 91       	pop	r29
    1272:	cf 91       	pop	r28
    1274:	1f 91       	pop	r17
    1276:	0f 91       	pop	r16
    1278:	ff 90       	pop	r15
    127a:	ef 90       	pop	r14
    127c:	df 90       	pop	r13
    127e:	cf 90       	pop	r12
    1280:	bf 90       	pop	r11
    1282:	af 90       	pop	r10
    1284:	9f 90       	pop	r9
    1286:	8f 90       	pop	r8
    1288:	7f 90       	pop	r7
    128a:	6f 90       	pop	r6
    128c:	5f 90       	pop	r5
    128e:	4f 90       	pop	r4
    1290:	3f 90       	pop	r3
    1292:	2f 90       	pop	r2
    1294:	08 95       	ret

00001296 <_ZN6Keypad7getKeysEv>:

	return NO_KEY;
}

// Populate the key list.
bool Keypad::getKeys() {
    1296:	cf 92       	push	r12
    1298:	df 92       	push	r13
    129a:	ef 92       	push	r14
    129c:	ff 92       	push	r15
    129e:	0f 93       	push	r16
    12a0:	1f 93       	push	r17
    12a2:	cf 93       	push	r28
    12a4:	df 93       	push	r29
    12a6:	ec 01       	movw	r28, r24
	bool keyActivity = false;

	// Limit how often the keypad is scanned. This makes the loop() run 10 times as fast.
	if ( (millis()-startTime)>debounceTime ) {
    12a8:	0e 94 c7 1f 	call	0x3f8e	; 0x3f8e <millis>
    12ac:	fe 01       	movw	r30, r28
    12ae:	ef 5a       	subi	r30, 0xAF	; 175
    12b0:	ff 4f       	sbci	r31, 0xFF	; 255
    12b2:	00 81       	ld	r16, Z
    12b4:	11 81       	ldd	r17, Z+1	; 0x01
    12b6:	22 81       	ldd	r18, Z+2	; 0x02
    12b8:	33 81       	ldd	r19, Z+3	; 0x03
    12ba:	6b 01       	movw	r12, r22
    12bc:	7c 01       	movw	r14, r24
    12be:	c0 1a       	sub	r12, r16
    12c0:	d1 0a       	sbc	r13, r17
    12c2:	e2 0a       	sbc	r14, r18
    12c4:	f3 0a       	sbc	r15, r19
    12c6:	3c 96       	adiw	r30, 0x0c	; 12
    12c8:	60 81       	ld	r22, Z
    12ca:	71 81       	ldd	r23, Z+1	; 0x01
    12cc:	cb 01       	movw	r24, r22
    12ce:	a0 e0       	ldi	r26, 0x00	; 0
    12d0:	b0 e0       	ldi	r27, 0x00	; 0
    12d2:	8c 15       	cp	r24, r12
    12d4:	9d 05       	cpc	r25, r13
    12d6:	ae 05       	cpc	r26, r14
    12d8:	bf 05       	cpc	r27, r15
    12da:	70 f4       	brcc	.+28     	; 0x12f8 <_ZN6Keypad7getKeysEv+0x62>
		scanKeys();
    12dc:	ce 01       	movw	r24, r28
    12de:	5a dd       	rcall	.-1356   	; 0xd94 <_ZN6Keypad8scanKeysEv>
		keyActivity = updateList();
    12e0:	ce 01       	movw	r24, r28
    12e2:	f3 de       	rcall	.-538    	; 0x10ca <_ZN6Keypad10updateListEv>
    12e4:	18 2f       	mov	r17, r24
		startTime = millis();
    12e6:	0e 94 c7 1f 	call	0x3f8e	; 0x3f8e <millis>
    12ea:	cf 5a       	subi	r28, 0xAF	; 175
    12ec:	df 4f       	sbci	r29, 0xFF	; 255
    12ee:	68 83       	st	Y, r22
    12f0:	79 83       	std	Y+1, r23	; 0x01
    12f2:	8a 83       	std	Y+2, r24	; 0x02
    12f4:	9b 83       	std	Y+3, r25	; 0x03
    12f6:	01 c0       	rjmp	.+2      	; 0x12fa <_ZN6Keypad7getKeysEv+0x64>
	return NO_KEY;
}

// Populate the key list.
bool Keypad::getKeys() {
	bool keyActivity = false;
    12f8:	10 e0       	ldi	r17, 0x00	; 0
		keyActivity = updateList();
		startTime = millis();
	}

	return keyActivity;
}
    12fa:	81 2f       	mov	r24, r17
    12fc:	df 91       	pop	r29
    12fe:	cf 91       	pop	r28
    1300:	1f 91       	pop	r17
    1302:	0f 91       	pop	r16
    1304:	ff 90       	pop	r15
    1306:	ef 90       	pop	r14
    1308:	df 90       	pop	r13
    130a:	cf 90       	pop	r12
    130c:	08 95       	ret

0000130e <_ZN6Keypad6getKeyEv>:
void Keypad::begin(char *userKeymap) {
    keymap = userKeymap;
}

// Returns a single key only. Retained for backwards compatibility.
char Keypad::getKey() {
    130e:	cf 93       	push	r28
    1310:	df 93       	push	r29
    1312:	ec 01       	movw	r28, r24
	single_key = true;
    1314:	fc 01       	movw	r30, r24
    1316:	ef 59       	subi	r30, 0x9F	; 159
    1318:	ff 4f       	sbci	r31, 0xFF	; 255
    131a:	81 e0       	ldi	r24, 0x01	; 1
    131c:	80 83       	st	Z, r24

	if (getKeys() && key[0].stateChanged && (key[0].kstate==PRESSED))
    131e:	ce 01       	movw	r24, r28
    1320:	ba df       	rcall	.-140    	; 0x1296 <_ZN6Keypad7getKeysEv>
    1322:	88 23       	and	r24, r24
    1324:	41 f0       	breq	.+16     	; 0x1336 <_ZN6Keypad6getKeyEv+0x28>
    1326:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1328:	88 23       	and	r24, r24
    132a:	29 f0       	breq	.+10     	; 0x1336 <_ZN6Keypad6getKeyEv+0x28>
    132c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    132e:	81 30       	cpi	r24, 0x01	; 1
    1330:	11 f4       	brne	.+4      	; 0x1336 <_ZN6Keypad6getKeyEv+0x28>
		return key[0].kchar;
    1332:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1334:	04 c0       	rjmp	.+8      	; 0x133e <_ZN6Keypad6getKeyEv+0x30>
	
	single_key = false;
    1336:	cf 59       	subi	r28, 0x9F	; 159
    1338:	df 4f       	sbci	r29, 0xFF	; 255
    133a:	18 82       	st	Y, r1

	return NO_KEY;
    133c:	80 e0       	ldi	r24, 0x00	; 0
}
    133e:	df 91       	pop	r29
    1340:	cf 91       	pop	r28
    1342:	08 95       	ret

00001344 <_ZN3L3GC1Ev>:

  // combine high and low bytes
  g.x = (int16_t)(xhg << 8 | xlg);
  g.y = (int16_t)(yhg << 8 | ylg);
  g.z = (int16_t)(zhg << 8 | zlg);
}
    1344:	fc 01       	movw	r30, r24
    1346:	83 e0       	ldi	r24, 0x03	; 3
    1348:	87 83       	std	Z+7, r24	; 0x07
    134a:	12 86       	std	Z+10, r1	; 0x0a
    134c:	11 86       	std	Z+9, r1	; 0x09
    134e:	13 86       	std	Z+11, r1	; 0x0b
    1350:	08 95       	ret

00001352 <_ZN3L3G8writeRegEhh>:
    1352:	0f 93       	push	r16
    1354:	1f 93       	push	r17
    1356:	cf 93       	push	r28
    1358:	df 93       	push	r29
    135a:	ec 01       	movw	r28, r24
    135c:	06 2f       	mov	r16, r22
    135e:	14 2f       	mov	r17, r20
    1360:	68 85       	ldd	r22, Y+8	; 0x08
    1362:	84 e8       	ldi	r24, 0x84	; 132
    1364:	9e e0       	ldi	r25, 0x0E	; 14
    1366:	0e 94 7a 19 	call	0x32f4	; 0x32f4 <_ZN7TwoWire17beginTransmissionEh>
    136a:	60 2f       	mov	r22, r16
    136c:	84 e8       	ldi	r24, 0x84	; 132
    136e:	9e e0       	ldi	r25, 0x0E	; 14
    1370:	0e 94 21 19 	call	0x3242	; 0x3242 <_ZN7TwoWire5writeEh>
    1374:	61 2f       	mov	r22, r17
    1376:	84 e8       	ldi	r24, 0x84	; 132
    1378:	9e e0       	ldi	r25, 0x0E	; 14
    137a:	0e 94 21 19 	call	0x3242	; 0x3242 <_ZN7TwoWire5writeEh>
    137e:	84 e8       	ldi	r24, 0x84	; 132
    1380:	9e e0       	ldi	r25, 0x0E	; 14
    1382:	0e 94 96 19 	call	0x332c	; 0x332c <_ZN7TwoWire15endTransmissionEv>
    1386:	8e 83       	std	Y+6, r24	; 0x06
    1388:	df 91       	pop	r29
    138a:	cf 91       	pop	r28
    138c:	1f 91       	pop	r17
    138e:	0f 91       	pop	r16
    1390:	08 95       	ret

00001392 <_ZN3L3G13enableDefaultEv>:
    1392:	cf 93       	push	r28
    1394:	df 93       	push	r29
    1396:	ec 01       	movw	r28, r24
    1398:	8f 81       	ldd	r24, Y+7	; 0x07
    139a:	82 30       	cpi	r24, 0x02	; 2
    139c:	21 f4       	brne	.+8      	; 0x13a6 <_ZN3L3G13enableDefaultEv+0x14>
    139e:	40 e0       	ldi	r20, 0x00	; 0
    13a0:	69 e3       	ldi	r22, 0x39	; 57
    13a2:	ce 01       	movw	r24, r28
    13a4:	d6 df       	rcall	.-84     	; 0x1352 <_ZN3L3G8writeRegEhh>
    13a6:	40 e0       	ldi	r20, 0x00	; 0
    13a8:	63 e2       	ldi	r22, 0x23	; 35
    13aa:	ce 01       	movw	r24, r28
    13ac:	d2 df       	rcall	.-92     	; 0x1352 <_ZN3L3G8writeRegEhh>
    13ae:	4f e6       	ldi	r20, 0x6F	; 111
    13b0:	60 e2       	ldi	r22, 0x20	; 32
    13b2:	ce 01       	movw	r24, r28
    13b4:	ce df       	rcall	.-100    	; 0x1352 <_ZN3L3G8writeRegEhh>
    13b6:	df 91       	pop	r29
    13b8:	cf 91       	pop	r28
    13ba:	08 95       	ret

000013bc <_ZN3L3G7testRegEhNS_7regAddrE>:
}

// Private Methods //////////////////////////////////////////////////////////////

int L3G::testReg(byte address, regAddr reg)
{
    13bc:	cf 93       	push	r28
    13be:	df 93       	push	r29
    13c0:	c6 2f       	mov	r28, r22
    13c2:	d4 2f       	mov	r29, r20
  Wire.beginTransmission(address);
    13c4:	84 e8       	ldi	r24, 0x84	; 132
    13c6:	9e e0       	ldi	r25, 0x0E	; 14
    13c8:	0e 94 7a 19 	call	0x32f4	; 0x32f4 <_ZN7TwoWire17beginTransmissionEh>
  Wire.write((byte)reg);
    13cc:	6d 2f       	mov	r22, r29
    13ce:	84 e8       	ldi	r24, 0x84	; 132
    13d0:	9e e0       	ldi	r25, 0x0E	; 14
    13d2:	0e 94 21 19 	call	0x3242	; 0x3242 <_ZN7TwoWire5writeEh>
  if (Wire.endTransmission() != 0)
    13d6:	84 e8       	ldi	r24, 0x84	; 132
    13d8:	9e e0       	ldi	r25, 0x0E	; 14
    13da:	0e 94 96 19 	call	0x332c	; 0x332c <_ZN7TwoWire15endTransmissionEv>
    13de:	81 11       	cpse	r24, r1
    13e0:	11 c0       	rjmp	.+34     	; 0x1404 <_ZN3L3G7testRegEhNS_7regAddrE+0x48>
  {
    return TEST_REG_ERROR;
  }

  Wire.requestFrom(address, (byte)1);
    13e2:	41 e0       	ldi	r20, 0x01	; 1
    13e4:	6c 2f       	mov	r22, r28
    13e6:	84 e8       	ldi	r24, 0x84	; 132
    13e8:	9e e0       	ldi	r25, 0x0E	; 14
    13ea:	0e 94 77 19 	call	0x32ee	; 0x32ee <_ZN7TwoWire11requestFromEhh>
  if (Wire.available())
    13ee:	84 e8       	ldi	r24, 0x84	; 132
    13f0:	9e e0       	ldi	r25, 0x0E	; 14
    13f2:	0e 94 c7 18 	call	0x318e	; 0x318e <_ZN7TwoWire9availableEv>
    13f6:	89 2b       	or	r24, r25
    13f8:	41 f0       	breq	.+16     	; 0x140a <_ZN3L3G7testRegEhNS_7regAddrE+0x4e>
  {
    return Wire.read();
    13fa:	84 e8       	ldi	r24, 0x84	; 132
    13fc:	9e e0       	ldi	r25, 0x0E	; 14
    13fe:	0e 94 cf 18 	call	0x319e	; 0x319e <_ZN7TwoWire4readEv>
    1402:	05 c0       	rjmp	.+10     	; 0x140e <_ZN3L3G7testRegEhNS_7regAddrE+0x52>
{
  Wire.beginTransmission(address);
  Wire.write((byte)reg);
  if (Wire.endTransmission() != 0)
  {
    return TEST_REG_ERROR;
    1404:	8f ef       	ldi	r24, 0xFF	; 255
    1406:	9f ef       	ldi	r25, 0xFF	; 255
    1408:	02 c0       	rjmp	.+4      	; 0x140e <_ZN3L3G7testRegEhNS_7regAddrE+0x52>
  {
    return Wire.read();
  }
  else
  {
    return TEST_REG_ERROR;
    140a:	8f ef       	ldi	r24, 0xFF	; 255
    140c:	9f ef       	ldi	r25, 0xFF	; 255
  }
}
    140e:	df 91       	pop	r29
    1410:	cf 91       	pop	r28
    1412:	08 95       	ret

00001414 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE>:
{
  return io_timeout;
}

bool L3G::init(deviceType device, sa0State sa0)
{
    1414:	0f 93       	push	r16
    1416:	1f 93       	push	r17
    1418:	cf 93       	push	r28
    141a:	df 93       	push	r29
    141c:	ec 01       	movw	r28, r24
    141e:	16 2f       	mov	r17, r22
    1420:	04 2f       	mov	r16, r20
  int id;
  
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
    1422:	63 30       	cpi	r22, 0x03	; 3
    1424:	09 f4       	brne	.+2      	; 0x1428 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x14>
    1426:	56 c0       	rjmp	.+172    	; 0x14d4 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xc0>
    1428:	42 30       	cpi	r20, 0x02	; 2
    142a:	c9 f5       	brne	.+114    	; 0x149e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x8a>
    142c:	56 c0       	rjmp	.+172    	; 0x14da <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xc6>
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
        if (device == device_auto)
    142e:	13 30       	cpi	r17, 0x03	; 3
    1430:	09 f0       	breq	.+2      	; 0x1434 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x20>
    1432:	58 c0       	rjmp	.+176    	; 0x14e4 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xd0>
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
    1434:	87 3d       	cpi	r24, 0xD7	; 215
    1436:	91 05       	cpc	r25, r1
    1438:	09 f4       	brne	.+2      	; 0x143c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x28>
    143a:	58 c0       	rjmp	.+176    	; 0x14ec <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xd8>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
    143c:	01 e0       	ldi	r16, 0x01	; 1
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
    143e:	11 e0       	ldi	r17, 0x01	; 1
    1440:	2c c0       	rjmp	.+88     	; 0x149a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
        }
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
    1442:	01 30       	cpi	r16, 0x01	; 1
    1444:	91 f0       	breq	.+36     	; 0x146a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x56>
    1446:	4f e0       	ldi	r20, 0x0F	; 15
    1448:	6a e6       	ldi	r22, 0x6A	; 106
    144a:	ce 01       	movw	r24, r28
    144c:	b7 df       	rcall	.-146    	; 0x13bc <_ZN3L3G7testRegEhNS_7regAddrE>
    144e:	8f 3f       	cpi	r24, 0xFF	; 255
    1450:	2f ef       	ldi	r18, 0xFF	; 255
    1452:	92 07       	cpc	r25, r18
    1454:	51 f0       	breq	.+20     	; 0x146a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x56>
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
        if (device == device_auto)
    1456:	13 30       	cpi	r17, 0x03	; 3
    1458:	09 f0       	breq	.+2      	; 0x145c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x48>
    145a:	46 c0       	rjmp	.+140    	; 0x14e8 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xd4>
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
    145c:	87 3d       	cpi	r24, 0xD7	; 215
    145e:	91 05       	cpc	r25, r1
    1460:	09 f0       	breq	.+2      	; 0x1464 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x50>
    1462:	47 c0       	rjmp	.+142    	; 0x14f2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xde>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
    1464:	00 e0       	ldi	r16, 0x00	; 0
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
    1466:	12 e0       	ldi	r17, 0x02	; 2
    1468:	18 c0       	rjmp	.+48     	; 0x149a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
        }
      }
    }
    
    // check for L3G4200D if device is still unidentified or was specified to be this type
    if (device == device_auto || device == device_4200D)
    146a:	13 30       	cpi	r17, 0x03	; 3
    146c:	11 f0       	breq	.+4      	; 0x1472 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5e>
    146e:	11 11       	cpse	r17, r1
    1470:	14 c0       	rjmp	.+40     	; 0x149a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
    {
      if (sa0 != sa0_low && testReg(L3G4200D_SA0_HIGH_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
    1472:	00 23       	and	r16, r16
    1474:	49 f0       	breq	.+18     	; 0x1488 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x74>
    1476:	4f e0       	ldi	r20, 0x0F	; 15
    1478:	69 e6       	ldi	r22, 0x69	; 105
    147a:	ce 01       	movw	r24, r28
    147c:	9f df       	rcall	.-194    	; 0x13bc <_ZN3L3G7testRegEhNS_7regAddrE>
    147e:	83 3d       	cpi	r24, 0xD3	; 211
    1480:	91 05       	cpc	r25, r1
    1482:	d1 f1       	breq	.+116    	; 0x14f8 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xe4>
      {
        // device responds to address 1101001; it's a 4200D with SA0 high
        device = device_4200D;
        sa0 = sa0_high;
      }
      else if (sa0 != sa0_high && testReg(L3G4200D_SA0_LOW_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
    1484:	01 30       	cpi	r16, 0x01	; 1
    1486:	39 f0       	breq	.+14     	; 0x1496 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x82>
    1488:	4f e0       	ldi	r20, 0x0F	; 15
    148a:	68 e6       	ldi	r22, 0x68	; 104
    148c:	ce 01       	movw	r24, r28
    148e:	96 df       	rcall	.-212    	; 0x13bc <_ZN3L3G7testRegEhNS_7regAddrE>
    1490:	83 3d       	cpi	r24, 0xD3	; 211
    1492:	91 05       	cpc	r25, r1
    1494:	99 f1       	breq	.+102    	; 0x14fc <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xe8>
        sa0 = sa0_low;
      }
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
    1496:	13 30       	cpi	r17, 0x03	; 3
    1498:	b9 f0       	breq	.+46     	; 0x14c8 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xb4>
    149a:	02 30       	cpi	r16, 0x02	; 2
    149c:	b9 f0       	breq	.+46     	; 0x14cc <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xb8>
    {
      return false;
    }
  }
  
  _device = device;
    149e:	1f 83       	std	Y+7, r17	; 0x07

  // set device address
  switch (device)
    14a0:	11 23       	and	r17, r17
    14a2:	51 f0       	breq	.+20     	; 0x14b8 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xa4>
    14a4:	13 30       	cpi	r17, 0x03	; 3
    14a6:	a0 f4       	brcc	.+40     	; 0x14d0 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xbc>
  {
    case device_D20H:
    case device_D20:
      address = (sa0 == sa0_high) ? D20_SA0_HIGH_ADDRESS : D20_SA0_LOW_ADDRESS;
    14a8:	01 30       	cpi	r16, 0x01	; 1
    14aa:	11 f4       	brne	.+4      	; 0x14b0 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x9c>
    14ac:	8b e6       	ldi	r24, 0x6B	; 107
    14ae:	01 c0       	rjmp	.+2      	; 0x14b2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x9e>
    14b0:	8a e6       	ldi	r24, 0x6A	; 106
    14b2:	88 87       	std	Y+8, r24	; 0x08
    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
  }
  
  return true;
    14b4:	81 e0       	ldi	r24, 0x01	; 1
  switch (device)
  {
    case device_D20H:
    case device_D20:
      address = (sa0 == sa0_high) ? D20_SA0_HIGH_ADDRESS : D20_SA0_LOW_ADDRESS;
      break;
    14b6:	41 c0       	rjmp	.+130    	; 0x153a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>

    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
    14b8:	01 30       	cpi	r16, 0x01	; 1
    14ba:	11 f4       	brne	.+4      	; 0x14c0 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xac>
    14bc:	89 e6       	ldi	r24, 0x69	; 105
    14be:	01 c0       	rjmp	.+2      	; 0x14c2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xae>
    14c0:	88 e6       	ldi	r24, 0x68	; 104
    14c2:	88 87       	std	Y+8, r24	; 0x08
      break;
  }
  
  return true;
    14c4:	81 e0       	ldi	r24, 0x01	; 1
      address = (sa0 == sa0_high) ? D20_SA0_HIGH_ADDRESS : D20_SA0_LOW_ADDRESS;
      break;

    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
    14c6:	39 c0       	rjmp	.+114    	; 0x153a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
    {
      return false;
    14c8:	80 e0       	ldi	r24, 0x00	; 0
    14ca:	37 c0       	rjmp	.+110    	; 0x153a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
    14cc:	80 e0       	ldi	r24, 0x00	; 0
    14ce:	35 c0       	rjmp	.+106    	; 0x153a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
  }
  
  return true;
    14d0:	81 e0       	ldi	r24, 0x01	; 1
    14d2:	33 c0       	rjmp	.+102    	; 0x153a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
  {
    // check for L3GD20H, D20 if device is unidentified or was specified to be one of these types
    if (device == device_auto || device == device_D20H || device == device_D20)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
    14d4:	44 23       	and	r20, r20
    14d6:	41 f1       	breq	.+80     	; 0x1528 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x114>
    14d8:	1e c0       	rjmp	.+60     	; 0x1516 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x102>
  
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
  {
    // check for L3GD20H, D20 if device is unidentified or was specified to be one of these types
    if (device == device_auto || device == device_D20H || device == device_D20)
    14da:	8f ef       	ldi	r24, 0xFF	; 255
    14dc:	86 0f       	add	r24, r22
    14de:	83 30       	cpi	r24, 0x03	; 3
    14e0:	30 f6       	brcc	.-116    	; 0x146e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5a>
    14e2:	0f c0       	rjmp	.+30     	; 0x1502 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xee>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
    14e4:	01 e0       	ldi	r16, 0x01	; 1
    14e6:	c3 cf       	rjmp	.-122    	; 0x146e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5a>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
    14e8:	00 e0       	ldi	r16, 0x00	; 0
    14ea:	c1 cf       	rjmp	.-126    	; 0x146e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5a>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
    14ec:	01 e0       	ldi	r16, 0x01	; 1
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
    14ee:	12 e0       	ldi	r17, 0x02	; 2
    14f0:	d4 cf       	rjmp	.-88     	; 0x149a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
    14f2:	00 e0       	ldi	r16, 0x00	; 0
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
    14f4:	11 e0       	ldi	r17, 0x01	; 1
    14f6:	d1 cf       	rjmp	.-94     	; 0x149a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
    {
      if (sa0 != sa0_low && testReg(L3G4200D_SA0_HIGH_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
      {
        // device responds to address 1101001; it's a 4200D with SA0 high
        device = device_4200D;
        sa0 = sa0_high;
    14f8:	01 e0       	ldi	r16, 0x01	; 1
    14fa:	01 c0       	rjmp	.+2      	; 0x14fe <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xea>
      }
      else if (sa0 != sa0_high && testReg(L3G4200D_SA0_LOW_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
      {
        // device responds to address 1101000; it's a 4200D with SA0 low
        device = device_4200D;
        sa0 = sa0_low;
    14fc:	00 e0       	ldi	r16, 0x00	; 0
    {
      return false;
    }
  }
  
  _device = device;
    14fe:	1f 82       	std	Y+7, r1	; 0x07
    1500:	db cf       	rjmp	.-74     	; 0x14b8 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xa4>
  {
    // check for L3GD20H, D20 if device is unidentified or was specified to be one of these types
    if (device == device_auto || device == device_D20H || device == device_D20)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
    1502:	4f e0       	ldi	r20, 0x0F	; 15
    1504:	6b e6       	ldi	r22, 0x6B	; 107
    1506:	ce 01       	movw	r24, r28
    1508:	59 df       	rcall	.-334    	; 0x13bc <_ZN3L3G7testRegEhNS_7regAddrE>
    150a:	8f 3f       	cpi	r24, 0xFF	; 255
    150c:	2f ef       	ldi	r18, 0xFF	; 255
    150e:	92 07       	cpc	r25, r18
    1510:	09 f0       	breq	.+2      	; 0x1514 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x100>
    1512:	8d cf       	rjmp	.-230    	; 0x142e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x1a>
    1514:	98 cf       	rjmp	.-208    	; 0x1446 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x32>
    1516:	4f e0       	ldi	r20, 0x0F	; 15
    1518:	6b e6       	ldi	r22, 0x6B	; 107
    151a:	50 df       	rcall	.-352    	; 0x13bc <_ZN3L3G7testRegEhNS_7regAddrE>
    151c:	8f 3f       	cpi	r24, 0xFF	; 255
    151e:	2f ef       	ldi	r18, 0xFF	; 255
    1520:	92 07       	cpc	r25, r18
    1522:	09 f0       	breq	.+2      	; 0x1526 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x112>
    1524:	87 cf       	rjmp	.-242    	; 0x1434 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x20>
    1526:	8d cf       	rjmp	.-230    	; 0x1442 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x2e>
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
        }
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
    1528:	4f e0       	ldi	r20, 0x0F	; 15
    152a:	6a e6       	ldi	r22, 0x6A	; 106
    152c:	47 df       	rcall	.-370    	; 0x13bc <_ZN3L3G7testRegEhNS_7regAddrE>
    152e:	8f 3f       	cpi	r24, 0xFF	; 255
    1530:	2f ef       	ldi	r18, 0xFF	; 255
    1532:	92 07       	cpc	r25, r18
    1534:	09 f0       	breq	.+2      	; 0x1538 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x124>
    1536:	92 cf       	rjmp	.-220    	; 0x145c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x48>
    1538:	98 cf       	rjmp	.-208    	; 0x146a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x56>
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
  }
  
  return true;
}
    153a:	df 91       	pop	r29
    153c:	cf 91       	pop	r28
    153e:	1f 91       	pop	r17
    1540:	0f 91       	pop	r16
    1542:	08 95       	ret

00001544 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1544:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1546:	03 96       	adiw	r24, 0x03	; 3
    1548:	92 83       	std	Z+2, r25	; 0x02
    154a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    154c:	2f ef       	ldi	r18, 0xFF	; 255
    154e:	3f ef       	ldi	r19, 0xFF	; 255
    1550:	34 83       	std	Z+4, r19	; 0x04
    1552:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1554:	96 83       	std	Z+6, r25	; 0x06
    1556:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1558:	90 87       	std	Z+8, r25	; 0x08
    155a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    155c:	10 82       	st	Z, r1
    155e:	08 95       	ret

00001560 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1560:	fc 01       	movw	r30, r24
    1562:	11 86       	std	Z+9, r1	; 0x09
    1564:	10 86       	std	Z+8, r1	; 0x08
    1566:	08 95       	ret

00001568 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1568:	cf 93       	push	r28
    156a:	df 93       	push	r29
    156c:	9c 01       	movw	r18, r24
    156e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1570:	dc 01       	movw	r26, r24
    1572:	11 96       	adiw	r26, 0x01	; 1
    1574:	cd 91       	ld	r28, X+
    1576:	dc 91       	ld	r29, X
    1578:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    157a:	d3 83       	std	Z+3, r29	; 0x03
    157c:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    157e:	8c 81       	ldd	r24, Y+4	; 0x04
    1580:	9d 81       	ldd	r25, Y+5	; 0x05
    1582:	95 83       	std	Z+5, r25	; 0x05
    1584:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1586:	8c 81       	ldd	r24, Y+4	; 0x04
    1588:	9d 81       	ldd	r25, Y+5	; 0x05
    158a:	dc 01       	movw	r26, r24
    158c:	13 96       	adiw	r26, 0x03	; 3
    158e:	7c 93       	st	X, r23
    1590:	6e 93       	st	-X, r22
    1592:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    1594:	7d 83       	std	Y+5, r23	; 0x05
    1596:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1598:	31 87       	std	Z+9, r19	; 0x09
    159a:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    159c:	f9 01       	movw	r30, r18
    159e:	80 81       	ld	r24, Z
    15a0:	8f 5f       	subi	r24, 0xFF	; 255
    15a2:	80 83       	st	Z, r24
}
    15a4:	df 91       	pop	r29
    15a6:	cf 91       	pop	r28
    15a8:	08 95       	ret

000015aa <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    15aa:	cf 93       	push	r28
    15ac:	df 93       	push	r29
    15ae:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    15b0:	48 81       	ld	r20, Y
    15b2:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    15b4:	4f 3f       	cpi	r20, 0xFF	; 255
    15b6:	2f ef       	ldi	r18, 0xFF	; 255
    15b8:	52 07       	cpc	r21, r18
    15ba:	21 f4       	brne	.+8      	; 0x15c4 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    15bc:	fc 01       	movw	r30, r24
    15be:	a7 81       	ldd	r26, Z+7	; 0x07
    15c0:	b0 85       	ldd	r27, Z+8	; 0x08
    15c2:	0d c0       	rjmp	.+26     	; 0x15de <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    15c4:	dc 01       	movw	r26, r24
    15c6:	13 96       	adiw	r26, 0x03	; 3
    15c8:	12 96       	adiw	r26, 0x02	; 2
    15ca:	ed 91       	ld	r30, X+
    15cc:	fc 91       	ld	r31, X
    15ce:	13 97       	sbiw	r26, 0x03	; 3
    15d0:	20 81       	ld	r18, Z
    15d2:	31 81       	ldd	r19, Z+1	; 0x01
    15d4:	42 17       	cp	r20, r18
    15d6:	53 07       	cpc	r21, r19
    15d8:	10 f0       	brcs	.+4      	; 0x15de <vListInsert+0x34>
    15da:	df 01       	movw	r26, r30
    15dc:	f5 cf       	rjmp	.-22     	; 0x15c8 <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    15de:	12 96       	adiw	r26, 0x02	; 2
    15e0:	ed 91       	ld	r30, X+
    15e2:	fc 91       	ld	r31, X
    15e4:	13 97       	sbiw	r26, 0x03	; 3
    15e6:	fb 83       	std	Y+3, r31	; 0x03
    15e8:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    15ea:	d5 83       	std	Z+5, r29	; 0x05
    15ec:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    15ee:	bd 83       	std	Y+5, r27	; 0x05
    15f0:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    15f2:	13 96       	adiw	r26, 0x03	; 3
    15f4:	dc 93       	st	X, r29
    15f6:	ce 93       	st	-X, r28
    15f8:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    15fa:	99 87       	std	Y+9, r25	; 0x09
    15fc:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    15fe:	fc 01       	movw	r30, r24
    1600:	20 81       	ld	r18, Z
    1602:	2f 5f       	subi	r18, 0xFF	; 255
    1604:	20 83       	st	Z, r18
}
    1606:	df 91       	pop	r29
    1608:	cf 91       	pop	r28
    160a:	08 95       	ret

0000160c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    160c:	cf 93       	push	r28
    160e:	df 93       	push	r29
    1610:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1612:	a0 85       	ldd	r26, Z+8	; 0x08
    1614:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1616:	c2 81       	ldd	r28, Z+2	; 0x02
    1618:	d3 81       	ldd	r29, Z+3	; 0x03
    161a:	84 81       	ldd	r24, Z+4	; 0x04
    161c:	95 81       	ldd	r25, Z+5	; 0x05
    161e:	9d 83       	std	Y+5, r25	; 0x05
    1620:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1622:	c4 81       	ldd	r28, Z+4	; 0x04
    1624:	d5 81       	ldd	r29, Z+5	; 0x05
    1626:	82 81       	ldd	r24, Z+2	; 0x02
    1628:	93 81       	ldd	r25, Z+3	; 0x03
    162a:	9b 83       	std	Y+3, r25	; 0x03
    162c:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    162e:	11 96       	adiw	r26, 0x01	; 1
    1630:	cd 91       	ld	r28, X+
    1632:	dc 91       	ld	r29, X
    1634:	12 97       	sbiw	r26, 0x02	; 2
    1636:	ce 17       	cp	r28, r30
    1638:	df 07       	cpc	r29, r31
    163a:	31 f4       	brne	.+12     	; 0x1648 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    163c:	8c 81       	ldd	r24, Y+4	; 0x04
    163e:	9d 81       	ldd	r25, Y+5	; 0x05
    1640:	12 96       	adiw	r26, 0x02	; 2
    1642:	9c 93       	st	X, r25
    1644:	8e 93       	st	-X, r24
    1646:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1648:	11 86       	std	Z+9, r1	; 0x09
    164a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    164c:	8c 91       	ld	r24, X
    164e:	81 50       	subi	r24, 0x01	; 1
    1650:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    1652:	df 91       	pop	r29
    1654:	cf 91       	pop	r28
    1656:	08 95       	ret

00001658 <_ZN3LPSC1Ev>:

// converts pressure in inHg to altitude in feet; see notes above
float LPS::pressureToAltitudeFeet(float pressure_inHg, float altimeter_setting_inHg)
{
  return (1 - pow(pressure_inHg / altimeter_setting_inHg, 0.190263)) * 145442;
}
    1658:	22 e0       	ldi	r18, 0x02	; 2
    165a:	fc 01       	movw	r30, r24
    165c:	20 83       	st	Z, r18
    165e:	2d e5       	ldi	r18, 0x5D	; 93
    1660:	21 83       	std	Z+1, r18	; 0x01
    1662:	08 95       	ret

00001664 <_ZN3LPS8writeRegEih>:
  }
}

// writes register
void LPS::writeReg(int reg, byte value)
{
    1664:	1f 93       	push	r17
    1666:	cf 93       	push	r28
    1668:	df 93       	push	r29
    166a:	eb 01       	movw	r28, r22
    166c:	14 2f       	mov	r17, r20
  // if dummy register address, look up actual translated address (based on device type)
  if (reg < 0)
    166e:	dd 23       	and	r29, r29
    1670:	3c f4       	brge	.+14     	; 0x1680 <_ZN3LPS8writeRegEih+0x1c>
  {
    reg = translated_regs[-reg];
    1672:	fc 01       	movw	r30, r24
    1674:	e6 1b       	sub	r30, r22
    1676:	f7 0b       	sbc	r31, r23
    1678:	c2 81       	ldd	r28, Z+2	; 0x02
    167a:	dd 27       	eor	r29, r29
    167c:	c7 fd       	sbrc	r28, 7
    167e:	d0 95       	com	r29
  }

  Wire.beginTransmission(address);
    1680:	fc 01       	movw	r30, r24
    1682:	61 81       	ldd	r22, Z+1	; 0x01
    1684:	84 e8       	ldi	r24, 0x84	; 132
    1686:	9e e0       	ldi	r25, 0x0E	; 14
    1688:	0e 94 7a 19 	call	0x32f4	; 0x32f4 <_ZN7TwoWire17beginTransmissionEh>
    void onRequest( void (*)(void) );

    inline size_t write(unsigned long n) { return write((uint8_t)n); }
    inline size_t write(long n) { return write((uint8_t)n); }
    inline size_t write(unsigned int n) { return write((uint8_t)n); }
    inline size_t write(int n) { return write((uint8_t)n); }
    168c:	e0 91 84 0e 	lds	r30, 0x0E84
    1690:	f0 91 85 0e 	lds	r31, 0x0E85
    1694:	01 90       	ld	r0, Z+
    1696:	f0 81       	ld	r31, Z
    1698:	e0 2d       	mov	r30, r0
    169a:	6c 2f       	mov	r22, r28
    169c:	84 e8       	ldi	r24, 0x84	; 132
    169e:	9e e0       	ldi	r25, 0x0E	; 14
    16a0:	19 95       	eicall
  Wire.write(reg);
  Wire.write(value);
    16a2:	61 2f       	mov	r22, r17
    16a4:	84 e8       	ldi	r24, 0x84	; 132
    16a6:	9e e0       	ldi	r25, 0x0E	; 14
    16a8:	0e 94 21 19 	call	0x3242	; 0x3242 <_ZN7TwoWire5writeEh>
  Wire.endTransmission();
    16ac:	84 e8       	ldi	r24, 0x84	; 132
    16ae:	9e e0       	ldi	r25, 0x0E	; 14
    16b0:	0e 94 96 19 	call	0x332c	; 0x332c <_ZN7TwoWire15endTransmissionEv>
}
    16b4:	df 91       	pop	r29
    16b6:	cf 91       	pop	r28
    16b8:	1f 91       	pop	r17
    16ba:	08 95       	ret

000016bc <_ZN3LPS13enableDefaultEv>:
}

// turns on sensor and enables continuous output
void LPS::enableDefault(void)
{
  if (_device == device_25H)
    16bc:	fc 01       	movw	r30, r24
    16be:	20 81       	ld	r18, Z
    16c0:	21 30       	cpi	r18, 0x01	; 1
    16c2:	29 f4       	brne	.+10     	; 0x16ce <_ZN3LPS13enableDefaultEv+0x12>
  {
    // 0xB0 = 0b10110000
    // PD = 1 (active mode);  ODR = 011 (12.5 Hz pressure & temperature output data rate)
    writeReg(CTRL_REG1, 0xB0);
    16c4:	40 eb       	ldi	r20, 0xB0	; 176
    16c6:	60 e2       	ldi	r22, 0x20	; 32
    16c8:	70 e0       	ldi	r23, 0x00	; 0
    16ca:	cc cf       	rjmp	.-104    	; 0x1664 <_ZN3LPS8writeRegEih>
    16cc:	08 95       	ret
  }
  else if (_device == device_331AP)
    16ce:	21 11       	cpse	r18, r1
    16d0:	04 c0       	rjmp	.+8      	; 0x16da <_ZN3LPS13enableDefaultEv+0x1e>
  {
    // 0xE0 = 0b11100000
    // PD = 1 (active mode);  ODR = 110 (12.5 Hz pressure & temperature output data rate)
    writeReg(CTRL_REG1, 0xE0);
    16d2:	40 ee       	ldi	r20, 0xE0	; 224
    16d4:	60 e2       	ldi	r22, 0x20	; 32
    16d6:	70 e0       	ldi	r23, 0x00	; 0
    16d8:	c5 cf       	rjmp	.-118    	; 0x1664 <_ZN3LPS8writeRegEih>
    16da:	08 95       	ret

000016dc <_ZN6LSM303C1Ev>:
  }
  else
  {
    return readAccReg(reg);
  }
}
    16dc:	cf 93       	push	r28
    16de:	df 93       	push	r29
    16e0:	ec 01       	movw	r28, r24
    16e2:	86 e0       	ldi	r24, 0x06	; 6
    16e4:	e3 e2       	ldi	r30, 0x23	; 35
    16e6:	f2 e0       	ldi	r31, 0x02	; 2
    16e8:	de 01       	movw	r26, r28
    16ea:	52 96       	adiw	r26, 0x12	; 18
    16ec:	01 90       	ld	r0, Z+
    16ee:	0d 92       	st	X+, r0
    16f0:	8a 95       	dec	r24
    16f2:	e1 f7       	brne	.-8      	; 0x16ec <_ZN6LSM303C1Ev+0x10>
    16f4:	86 e0       	ldi	r24, 0x06	; 6
    16f6:	e9 e2       	ldi	r30, 0x29	; 41
    16f8:	f2 e0       	ldi	r31, 0x02	; 2
    16fa:	de 01       	movw	r26, r28
    16fc:	1c 96       	adiw	r26, 0x0c	; 12
    16fe:	01 90       	ld	r0, Z+
    1700:	0d 92       	st	X+, r0
    1702:	8a 95       	dec	r24
    1704:	e1 f7       	brne	.-8      	; 0x16fe <_ZN6LSM303C1Ev+0x22>
    1706:	84 e0       	ldi	r24, 0x04	; 4
    1708:	89 8f       	std	Y+25, r24	; 0x19
    170a:	1c a2       	std	Y+36, r1	; 0x24
    170c:	1b a2       	std	Y+35, r1	; 0x23
    170e:	1d a2       	std	Y+37, r1	; 0x25
    1710:	df 91       	pop	r29
    1712:	cf 91       	pop	r28
    1714:	08 95       	ret

00001716 <_ZN6LSM30316vector_normalizeEPNS_6vectorIfEE>:
    1716:	4f 92       	push	r4
    1718:	5f 92       	push	r5
    171a:	6f 92       	push	r6
    171c:	7f 92       	push	r7
    171e:	8f 92       	push	r8
    1720:	9f 92       	push	r9
    1722:	af 92       	push	r10
    1724:	bf 92       	push	r11
    1726:	cf 92       	push	r12
    1728:	df 92       	push	r13
    172a:	ef 92       	push	r14
    172c:	ff 92       	push	r15
    172e:	0f 93       	push	r16
    1730:	1f 93       	push	r17
    1732:	cf 93       	push	r28
    1734:	df 93       	push	r29
    1736:	00 d0       	rcall	.+0      	; 0x1738 <_ZN6LSM30316vector_normalizeEPNS_6vectorIfEE+0x22>
    1738:	1f 92       	push	r1
    173a:	cd b7       	in	r28, 0x3d	; 61
    173c:	de b7       	in	r29, 0x3e	; 62
    173e:	8c 01       	movw	r16, r24
    1740:	dc 01       	movw	r26, r24
    1742:	4d 90       	ld	r4, X+
    1744:	5d 90       	ld	r5, X+
    1746:	6d 90       	ld	r6, X+
    1748:	7c 90       	ld	r7, X
    174a:	13 97       	sbiw	r26, 0x03	; 3
    174c:	14 96       	adiw	r26, 0x04	; 4
    174e:	8d 90       	ld	r8, X+
    1750:	9d 90       	ld	r9, X+
    1752:	ad 90       	ld	r10, X+
    1754:	bc 90       	ld	r11, X
    1756:	17 97       	sbiw	r26, 0x07	; 7
    1758:	18 96       	adiw	r26, 0x08	; 8
    175a:	8d 91       	ld	r24, X+
    175c:	9d 91       	ld	r25, X+
    175e:	0d 90       	ld	r0, X+
    1760:	bc 91       	ld	r27, X
    1762:	a0 2d       	mov	r26, r0
    1764:	89 83       	std	Y+1, r24	; 0x01
    1766:	9a 83       	std	Y+2, r25	; 0x02
    1768:	ab 83       	std	Y+3, r26	; 0x03
    176a:	bc 83       	std	Y+4, r27	; 0x04
    176c:	a3 01       	movw	r20, r6
    176e:	92 01       	movw	r18, r4
    1770:	c3 01       	movw	r24, r6
    1772:	b2 01       	movw	r22, r4
    1774:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <__mulsf3>
    1778:	6b 01       	movw	r12, r22
    177a:	7c 01       	movw	r14, r24
    177c:	a5 01       	movw	r20, r10
    177e:	94 01       	movw	r18, r8
    1780:	c5 01       	movw	r24, r10
    1782:	b4 01       	movw	r22, r8
    1784:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <__mulsf3>
    1788:	9b 01       	movw	r18, r22
    178a:	ac 01       	movw	r20, r24
    178c:	c7 01       	movw	r24, r14
    178e:	b6 01       	movw	r22, r12
    1790:	0e 94 9e 19 	call	0x333c	; 0x333c <__addsf3>
    1794:	6b 01       	movw	r12, r22
    1796:	7c 01       	movw	r14, r24
    1798:	29 81       	ldd	r18, Y+1	; 0x01
    179a:	3a 81       	ldd	r19, Y+2	; 0x02
    179c:	4b 81       	ldd	r20, Y+3	; 0x03
    179e:	5c 81       	ldd	r21, Y+4	; 0x04
    17a0:	ca 01       	movw	r24, r20
    17a2:	b9 01       	movw	r22, r18
    17a4:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <__mulsf3>
    17a8:	9b 01       	movw	r18, r22
    17aa:	ac 01       	movw	r20, r24
    17ac:	c7 01       	movw	r24, r14
    17ae:	b6 01       	movw	r22, r12
    17b0:	0e 94 9e 19 	call	0x333c	; 0x333c <__addsf3>
    17b4:	0e 94 4a 1c 	call	0x3894	; 0x3894 <sqrt>
    17b8:	6b 01       	movw	r12, r22
    17ba:	7c 01       	movw	r14, r24
    17bc:	9b 01       	movw	r18, r22
    17be:	ac 01       	movw	r20, r24
    17c0:	c3 01       	movw	r24, r6
    17c2:	b2 01       	movw	r22, r4
    17c4:	0e 94 68 1a 	call	0x34d0	; 0x34d0 <__divsf3>
    17c8:	f8 01       	movw	r30, r16
    17ca:	60 83       	st	Z, r22
    17cc:	71 83       	std	Z+1, r23	; 0x01
    17ce:	82 83       	std	Z+2, r24	; 0x02
    17d0:	93 83       	std	Z+3, r25	; 0x03
    17d2:	a7 01       	movw	r20, r14
    17d4:	96 01       	movw	r18, r12
    17d6:	c5 01       	movw	r24, r10
    17d8:	b4 01       	movw	r22, r8
    17da:	0e 94 68 1a 	call	0x34d0	; 0x34d0 <__divsf3>
    17de:	d8 01       	movw	r26, r16
    17e0:	14 96       	adiw	r26, 0x04	; 4
    17e2:	6d 93       	st	X+, r22
    17e4:	7d 93       	st	X+, r23
    17e6:	8d 93       	st	X+, r24
    17e8:	9c 93       	st	X, r25
    17ea:	17 97       	sbiw	r26, 0x07	; 7
    17ec:	a7 01       	movw	r20, r14
    17ee:	96 01       	movw	r18, r12
    17f0:	69 81       	ldd	r22, Y+1	; 0x01
    17f2:	7a 81       	ldd	r23, Y+2	; 0x02
    17f4:	8b 81       	ldd	r24, Y+3	; 0x03
    17f6:	9c 81       	ldd	r25, Y+4	; 0x04
    17f8:	0e 94 68 1a 	call	0x34d0	; 0x34d0 <__divsf3>
    17fc:	f8 01       	movw	r30, r16
    17fe:	60 87       	std	Z+8, r22	; 0x08
    1800:	71 87       	std	Z+9, r23	; 0x09
    1802:	82 87       	std	Z+10, r24	; 0x0a
    1804:	93 87       	std	Z+11, r25	; 0x0b
    1806:	0f 90       	pop	r0
    1808:	0f 90       	pop	r0
    180a:	0f 90       	pop	r0
    180c:	0f 90       	pop	r0
    180e:	df 91       	pop	r29
    1810:	cf 91       	pop	r28
    1812:	1f 91       	pop	r17
    1814:	0f 91       	pop	r16
    1816:	ff 90       	pop	r15
    1818:	ef 90       	pop	r14
    181a:	df 90       	pop	r13
    181c:	cf 90       	pop	r12
    181e:	bf 90       	pop	r11
    1820:	af 90       	pop	r10
    1822:	9f 90       	pop	r9
    1824:	8f 90       	pop	r8
    1826:	7f 90       	pop	r7
    1828:	6f 90       	pop	r6
    182a:	5f 90       	pop	r5
    182c:	4f 90       	pop	r4
    182e:	08 95       	ret

00001830 <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE>:
    1830:	4f 92       	push	r4
    1832:	5f 92       	push	r5
    1834:	6f 92       	push	r6
    1836:	7f 92       	push	r7
    1838:	8f 92       	push	r8
    183a:	9f 92       	push	r9
    183c:	af 92       	push	r10
    183e:	bf 92       	push	r11
    1840:	cf 92       	push	r12
    1842:	df 92       	push	r13
    1844:	ef 92       	push	r14
    1846:	ff 92       	push	r15
    1848:	0f 93       	push	r16
    184a:	1f 93       	push	r17
    184c:	cf 93       	push	r28
    184e:	df 93       	push	r29
    1850:	cd b7       	in	r28, 0x3d	; 61
    1852:	de b7       	in	r29, 0x3e	; 62
    1854:	aa 97       	sbiw	r28, 0x2a	; 42
    1856:	0f b6       	in	r0, 0x3f	; 63
    1858:	f8 94       	cli
    185a:	de bf       	out	0x3e, r29	; 62
    185c:	0f be       	out	0x3f, r0	; 63
    185e:	cd bf       	out	0x3d, r28	; 61
    1860:	8c 01       	movw	r16, r24
    1862:	29 8f       	std	Y+25, r18	; 0x19
    1864:	3a 8f       	std	Y+26, r19	; 0x1a
    1866:	4b 8f       	std	Y+27, r20	; 0x1b
    1868:	5c 8f       	std	Y+28, r21	; 0x1c
    186a:	6d 8f       	std	Y+29, r22	; 0x1d
    186c:	7e 8f       	std	Y+30, r23	; 0x1e
    186e:	dc 01       	movw	r26, r24
    1870:	16 96       	adiw	r26, 0x06	; 6
    1872:	cd 90       	ld	r12, X+
    1874:	dc 90       	ld	r13, X
    1876:	17 97       	sbiw	r26, 0x07	; 7
    1878:	ee 24       	eor	r14, r14
    187a:	d7 fc       	sbrc	r13, 7
    187c:	e0 94       	com	r14
    187e:	fe 2c       	mov	r15, r14
    1880:	52 96       	adiw	r26, 0x12	; 18
    1882:	4d 91       	ld	r20, X+
    1884:	5c 91       	ld	r21, X
    1886:	53 97       	sbiw	r26, 0x13	; 19
    1888:	66 27       	eor	r22, r22
    188a:	57 fd       	sbrc	r21, 7
    188c:	60 95       	com	r22
    188e:	76 2f       	mov	r23, r22
    1890:	1c 96       	adiw	r26, 0x0c	; 12
    1892:	8d 91       	ld	r24, X+
    1894:	9c 91       	ld	r25, X
    1896:	1d 97       	sbiw	r26, 0x0d	; 13
    1898:	aa 27       	eor	r26, r26
    189a:	97 fd       	sbrc	r25, 7
    189c:	a0 95       	com	r26
    189e:	ba 2f       	mov	r27, r26
    18a0:	48 0f       	add	r20, r24
    18a2:	59 1f       	adc	r21, r25
    18a4:	6a 1f       	adc	r22, r26
    18a6:	7b 1f       	adc	r23, r27
    18a8:	db 01       	movw	r26, r22
    18aa:	ca 01       	movw	r24, r20
    18ac:	77 23       	and	r23, r23
    18ae:	1c f4       	brge	.+6      	; 0x18b6 <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE+0x86>
    18b0:	01 96       	adiw	r24, 0x01	; 1
    18b2:	a1 1d       	adc	r26, r1
    18b4:	b1 1d       	adc	r27, r1
    18b6:	b5 95       	asr	r27
    18b8:	a7 95       	ror	r26
    18ba:	97 95       	ror	r25
    18bc:	87 95       	ror	r24
    18be:	a7 01       	movw	r20, r14
    18c0:	96 01       	movw	r18, r12
    18c2:	28 1b       	sub	r18, r24
    18c4:	39 0b       	sbc	r19, r25
    18c6:	4a 0b       	sbc	r20, r26
    18c8:	5b 0b       	sbc	r21, r27
    18ca:	2f 8f       	std	Y+31, r18	; 0x1f
    18cc:	38 a3       	std	Y+32, r19	; 0x20
    18ce:	49 a3       	std	Y+33, r20	; 0x21
    18d0:	5a a3       	std	Y+34, r21	; 0x22
    18d2:	d8 01       	movw	r26, r16
    18d4:	18 96       	adiw	r26, 0x08	; 8
    18d6:	cd 90       	ld	r12, X+
    18d8:	dc 90       	ld	r13, X
    18da:	19 97       	sbiw	r26, 0x09	; 9
    18dc:	ee 24       	eor	r14, r14
    18de:	d7 fc       	sbrc	r13, 7
    18e0:	e0 94       	com	r14
    18e2:	fe 2c       	mov	r15, r14
    18e4:	54 96       	adiw	r26, 0x14	; 20
    18e6:	4d 91       	ld	r20, X+
    18e8:	5c 91       	ld	r21, X
    18ea:	55 97       	sbiw	r26, 0x15	; 21
    18ec:	66 27       	eor	r22, r22
    18ee:	57 fd       	sbrc	r21, 7
    18f0:	60 95       	com	r22
    18f2:	76 2f       	mov	r23, r22
    18f4:	1e 96       	adiw	r26, 0x0e	; 14
    18f6:	8d 91       	ld	r24, X+
    18f8:	9c 91       	ld	r25, X
    18fa:	1f 97       	sbiw	r26, 0x0f	; 15
    18fc:	aa 27       	eor	r26, r26
    18fe:	97 fd       	sbrc	r25, 7
    1900:	a0 95       	com	r26
    1902:	ba 2f       	mov	r27, r26
    1904:	48 0f       	add	r20, r24
    1906:	59 1f       	adc	r21, r25
    1908:	6a 1f       	adc	r22, r26
    190a:	7b 1f       	adc	r23, r27
    190c:	db 01       	movw	r26, r22
    190e:	ca 01       	movw	r24, r20
    1910:	77 23       	and	r23, r23
    1912:	1c f4       	brge	.+6      	; 0x191a <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE+0xea>
    1914:	01 96       	adiw	r24, 0x01	; 1
    1916:	a1 1d       	adc	r26, r1
    1918:	b1 1d       	adc	r27, r1
    191a:	b5 95       	asr	r27
    191c:	a7 95       	ror	r26
    191e:	97 95       	ror	r25
    1920:	87 95       	ror	r24
    1922:	a7 01       	movw	r20, r14
    1924:	96 01       	movw	r18, r12
    1926:	28 1b       	sub	r18, r24
    1928:	39 0b       	sbc	r19, r25
    192a:	4a 0b       	sbc	r20, r26
    192c:	5b 0b       	sbc	r21, r27
    192e:	2b a3       	std	Y+35, r18	; 0x23
    1930:	3c a3       	std	Y+36, r19	; 0x24
    1932:	4d a3       	std	Y+37, r20	; 0x25
    1934:	5e a3       	std	Y+38, r21	; 0x26
    1936:	d8 01       	movw	r26, r16
    1938:	1a 96       	adiw	r26, 0x0a	; 10
    193a:	4d 90       	ld	r4, X+
    193c:	5c 90       	ld	r5, X
    193e:	1b 97       	sbiw	r26, 0x0b	; 11
    1940:	66 24       	eor	r6, r6
    1942:	57 fc       	sbrc	r5, 7
    1944:	60 94       	com	r6
    1946:	76 2c       	mov	r7, r6
    1948:	56 96       	adiw	r26, 0x16	; 22
    194a:	4d 91       	ld	r20, X+
    194c:	5c 91       	ld	r21, X
    194e:	57 97       	sbiw	r26, 0x17	; 23
    1950:	66 27       	eor	r22, r22
    1952:	57 fd       	sbrc	r21, 7
    1954:	60 95       	com	r22
    1956:	76 2f       	mov	r23, r22
    1958:	50 96       	adiw	r26, 0x10	; 16
    195a:	8d 91       	ld	r24, X+
    195c:	9c 91       	ld	r25, X
    195e:	51 97       	sbiw	r26, 0x11	; 17
    1960:	aa 27       	eor	r26, r26
    1962:	97 fd       	sbrc	r25, 7
    1964:	a0 95       	com	r26
    1966:	ba 2f       	mov	r27, r26
    1968:	48 0f       	add	r20, r24
    196a:	59 1f       	adc	r21, r25
    196c:	6a 1f       	adc	r22, r26
    196e:	7b 1f       	adc	r23, r27
    1970:	db 01       	movw	r26, r22
    1972:	ca 01       	movw	r24, r20
    1974:	77 23       	and	r23, r23
    1976:	1c f4       	brge	.+6      	; 0x197e <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE+0x14e>
    1978:	01 96       	adiw	r24, 0x01	; 1
    197a:	a1 1d       	adc	r26, r1
    197c:	b1 1d       	adc	r27, r1
    197e:	b5 95       	asr	r27
    1980:	a7 95       	ror	r26
    1982:	97 95       	ror	r25
    1984:	87 95       	ror	r24
    1986:	48 1a       	sub	r4, r24
    1988:	59 0a       	sbc	r5, r25
    198a:	6a 0a       	sbc	r6, r26
    198c:	7b 0a       	sbc	r7, r27
    198e:	f8 01       	movw	r30, r16
    1990:	84 80       	ldd	r8, Z+4	; 0x04
    1992:	95 80       	ldd	r9, Z+5	; 0x05
    1994:	aa 24       	eor	r10, r10
    1996:	97 fc       	sbrc	r9, 7
    1998:	a0 94       	com	r10
    199a:	ba 2c       	mov	r11, r10
    199c:	82 81       	ldd	r24, Z+2	; 0x02
    199e:	93 81       	ldd	r25, Z+3	; 0x03
    19a0:	9c 01       	movw	r18, r24
    19a2:	44 27       	eor	r20, r20
    19a4:	37 fd       	sbrc	r19, 7
    19a6:	40 95       	com	r20
    19a8:	54 2f       	mov	r21, r20
    19aa:	2f a3       	std	Y+39, r18	; 0x27
    19ac:	38 a7       	std	Y+40, r19	; 0x28
    19ae:	49 a7       	std	Y+41, r20	; 0x29
    19b0:	5a a7       	std	Y+42, r21	; 0x2a
    19b2:	2b a1       	ldd	r18, Y+35	; 0x23
    19b4:	3c a1       	ldd	r19, Y+36	; 0x24
    19b6:	4d a1       	ldd	r20, Y+37	; 0x25
    19b8:	5e a1       	ldd	r21, Y+38	; 0x26
    19ba:	c5 01       	movw	r24, r10
    19bc:	b4 01       	movw	r22, r8
    19be:	0e 94 4d 22 	call	0x449a	; 0x449a <__mulsi3>
    19c2:	6b 01       	movw	r12, r22
    19c4:	7c 01       	movw	r14, r24
    19c6:	a3 01       	movw	r20, r6
    19c8:	92 01       	movw	r18, r4
    19ca:	6f a1       	ldd	r22, Y+39	; 0x27
    19cc:	78 a5       	ldd	r23, Y+40	; 0x28
    19ce:	89 a5       	ldd	r24, Y+41	; 0x29
    19d0:	9a a5       	ldd	r25, Y+42	; 0x2a
    19d2:	0e 94 4d 22 	call	0x449a	; 0x449a <__mulsi3>
    19d6:	a7 01       	movw	r20, r14
    19d8:	96 01       	movw	r18, r12
    19da:	26 1b       	sub	r18, r22
    19dc:	37 0b       	sbc	r19, r23
    19de:	48 0b       	sbc	r20, r24
    19e0:	59 0b       	sbc	r21, r25
    19e2:	ca 01       	movw	r24, r20
    19e4:	b9 01       	movw	r22, r18
    19e6:	0e 94 03 1b 	call	0x3606	; 0x3606 <__floatsisf>
    19ea:	6d 87       	std	Y+13, r22	; 0x0d
    19ec:	7e 87       	std	Y+14, r23	; 0x0e
    19ee:	8f 87       	std	Y+15, r24	; 0x0f
    19f0:	98 8b       	std	Y+16, r25	; 0x10
    19f2:	d8 01       	movw	r26, r16
    19f4:	cd 90       	ld	r12, X+
    19f6:	dc 90       	ld	r13, X
    19f8:	ee 24       	eor	r14, r14
    19fa:	d7 fc       	sbrc	r13, 7
    19fc:	e0 94       	com	r14
    19fe:	fe 2c       	mov	r15, r14
    1a00:	a3 01       	movw	r20, r6
    1a02:	92 01       	movw	r18, r4
    1a04:	c7 01       	movw	r24, r14
    1a06:	b6 01       	movw	r22, r12
    1a08:	0e 94 4d 22 	call	0x449a	; 0x449a <__mulsi3>
    1a0c:	2b 01       	movw	r4, r22
    1a0e:	3c 01       	movw	r6, r24
    1a10:	2f 8d       	ldd	r18, Y+31	; 0x1f
    1a12:	38 a1       	ldd	r19, Y+32	; 0x20
    1a14:	49 a1       	ldd	r20, Y+33	; 0x21
    1a16:	5a a1       	ldd	r21, Y+34	; 0x22
    1a18:	c5 01       	movw	r24, r10
    1a1a:	b4 01       	movw	r22, r8
    1a1c:	0e 94 4d 22 	call	0x449a	; 0x449a <__mulsi3>
    1a20:	a3 01       	movw	r20, r6
    1a22:	92 01       	movw	r18, r4
    1a24:	26 1b       	sub	r18, r22
    1a26:	37 0b       	sbc	r19, r23
    1a28:	48 0b       	sbc	r20, r24
    1a2a:	59 0b       	sbc	r21, r25
    1a2c:	ca 01       	movw	r24, r20
    1a2e:	b9 01       	movw	r22, r18
    1a30:	0e 94 03 1b 	call	0x3606	; 0x3606 <__floatsisf>
    1a34:	69 8b       	std	Y+17, r22	; 0x11
    1a36:	7a 8b       	std	Y+18, r23	; 0x12
    1a38:	8b 8b       	std	Y+19, r24	; 0x13
    1a3a:	9c 8b       	std	Y+20, r25	; 0x14
    1a3c:	2f 8d       	ldd	r18, Y+31	; 0x1f
    1a3e:	38 a1       	ldd	r19, Y+32	; 0x20
    1a40:	49 a1       	ldd	r20, Y+33	; 0x21
    1a42:	5a a1       	ldd	r21, Y+34	; 0x22
    1a44:	6f a1       	ldd	r22, Y+39	; 0x27
    1a46:	78 a5       	ldd	r23, Y+40	; 0x28
    1a48:	89 a5       	ldd	r24, Y+41	; 0x29
    1a4a:	9a a5       	ldd	r25, Y+42	; 0x2a
    1a4c:	0e 94 4d 22 	call	0x449a	; 0x449a <__mulsi3>
    1a50:	4b 01       	movw	r8, r22
    1a52:	5c 01       	movw	r10, r24
    1a54:	2b a1       	ldd	r18, Y+35	; 0x23
    1a56:	3c a1       	ldd	r19, Y+36	; 0x24
    1a58:	4d a1       	ldd	r20, Y+37	; 0x25
    1a5a:	5e a1       	ldd	r21, Y+38	; 0x26
    1a5c:	c7 01       	movw	r24, r14
    1a5e:	b6 01       	movw	r22, r12
    1a60:	0e 94 4d 22 	call	0x449a	; 0x449a <__mulsi3>
    1a64:	a5 01       	movw	r20, r10
    1a66:	94 01       	movw	r18, r8
    1a68:	26 1b       	sub	r18, r22
    1a6a:	37 0b       	sbc	r19, r23
    1a6c:	48 0b       	sbc	r20, r24
    1a6e:	59 0b       	sbc	r21, r25
    1a70:	ca 01       	movw	r24, r20
    1a72:	b9 01       	movw	r22, r18
    1a74:	0e 94 03 1b 	call	0x3606	; 0x3606 <__floatsisf>
    1a78:	6d 8b       	std	Y+21, r22	; 0x15
    1a7a:	7e 8b       	std	Y+22, r23	; 0x16
    1a7c:	8f 8b       	std	Y+23, r24	; 0x17
    1a7e:	98 8f       	std	Y+24, r25	; 0x18
    1a80:	ce 01       	movw	r24, r28
    1a82:	0d 96       	adiw	r24, 0x0d	; 13
    1a84:	48 de       	rcall	.-880    	; 0x1716 <_ZN6LSM30316vector_normalizeEPNS_6vectorIfEE>
    1a86:	d8 01       	movw	r26, r16
    1a88:	12 96       	adiw	r26, 0x02	; 2
    1a8a:	6d 91       	ld	r22, X+
    1a8c:	7c 91       	ld	r23, X
    1a8e:	13 97       	sbiw	r26, 0x03	; 3
    1a90:	88 27       	eor	r24, r24
    1a92:	77 fd       	sbrc	r23, 7
    1a94:	80 95       	com	r24
    1a96:	98 2f       	mov	r25, r24
    1a98:	0e 94 03 1b 	call	0x3606	; 0x3606 <__floatsisf>
    1a9c:	6b 01       	movw	r12, r22
    1a9e:	7c 01       	movw	r14, r24
    1aa0:	2d 89       	ldd	r18, Y+21	; 0x15
    1aa2:	3e 89       	ldd	r19, Y+22	; 0x16
    1aa4:	4f 89       	ldd	r20, Y+23	; 0x17
    1aa6:	58 8d       	ldd	r21, Y+24	; 0x18
    1aa8:	2f 8f       	std	Y+31, r18	; 0x1f
    1aaa:	38 a3       	std	Y+32, r19	; 0x20
    1aac:	49 a3       	std	Y+33, r20	; 0x21
    1aae:	5a a3       	std	Y+34, r21	; 0x22
    1ab0:	d8 01       	movw	r26, r16
    1ab2:	14 96       	adiw	r26, 0x04	; 4
    1ab4:	6d 91       	ld	r22, X+
    1ab6:	7c 91       	ld	r23, X
    1ab8:	15 97       	sbiw	r26, 0x05	; 5
    1aba:	88 27       	eor	r24, r24
    1abc:	77 fd       	sbrc	r23, 7
    1abe:	80 95       	com	r24
    1ac0:	98 2f       	mov	r25, r24
    1ac2:	0e 94 03 1b 	call	0x3606	; 0x3606 <__floatsisf>
    1ac6:	2b 01       	movw	r4, r22
    1ac8:	3c 01       	movw	r6, r24
    1aca:	29 89       	ldd	r18, Y+17	; 0x11
    1acc:	3a 89       	ldd	r19, Y+18	; 0x12
    1ace:	4b 89       	ldd	r20, Y+19	; 0x13
    1ad0:	5c 89       	ldd	r21, Y+20	; 0x14
    1ad2:	2b a3       	std	Y+35, r18	; 0x23
    1ad4:	3c a3       	std	Y+36, r19	; 0x24
    1ad6:	4d a3       	std	Y+37, r20	; 0x25
    1ad8:	5e a3       	std	Y+38, r21	; 0x26
    1ada:	2f 8d       	ldd	r18, Y+31	; 0x1f
    1adc:	38 a1       	ldd	r19, Y+32	; 0x20
    1ade:	49 a1       	ldd	r20, Y+33	; 0x21
    1ae0:	5a a1       	ldd	r21, Y+34	; 0x22
    1ae2:	c7 01       	movw	r24, r14
    1ae4:	b6 01       	movw	r22, r12
    1ae6:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <__mulsf3>
    1aea:	4b 01       	movw	r8, r22
    1aec:	5c 01       	movw	r10, r24
    1aee:	2b a1       	ldd	r18, Y+35	; 0x23
    1af0:	3c a1       	ldd	r19, Y+36	; 0x24
    1af2:	4d a1       	ldd	r20, Y+37	; 0x25
    1af4:	5e a1       	ldd	r21, Y+38	; 0x26
    1af6:	c3 01       	movw	r24, r6
    1af8:	b2 01       	movw	r22, r4
    1afa:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <__mulsf3>
    1afe:	9b 01       	movw	r18, r22
    1b00:	ac 01       	movw	r20, r24
    1b02:	c5 01       	movw	r24, r10
    1b04:	b4 01       	movw	r22, r8
    1b06:	0e 94 9d 19 	call	0x333a	; 0x333a <__subsf3>
    1b0a:	69 83       	std	Y+1, r22	; 0x01
    1b0c:	7a 83       	std	Y+2, r23	; 0x02
    1b0e:	8b 83       	std	Y+3, r24	; 0x03
    1b10:	9c 83       	std	Y+4, r25	; 0x04
    1b12:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b14:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b16:	af 85       	ldd	r26, Y+15	; 0x0f
    1b18:	b8 89       	ldd	r27, Y+16	; 0x10
    1b1a:	8f a3       	std	Y+39, r24	; 0x27
    1b1c:	98 a7       	std	Y+40, r25	; 0x28
    1b1e:	a9 a7       	std	Y+41, r26	; 0x29
    1b20:	ba a7       	std	Y+42, r27	; 0x2a
    1b22:	d8 01       	movw	r26, r16
    1b24:	6d 91       	ld	r22, X+
    1b26:	7c 91       	ld	r23, X
    1b28:	88 27       	eor	r24, r24
    1b2a:	77 fd       	sbrc	r23, 7
    1b2c:	80 95       	com	r24
    1b2e:	98 2f       	mov	r25, r24
    1b30:	0e 94 03 1b 	call	0x3606	; 0x3606 <__floatsisf>
    1b34:	4b 01       	movw	r8, r22
    1b36:	5c 01       	movw	r10, r24
    1b38:	2f a1       	ldd	r18, Y+39	; 0x27
    1b3a:	38 a5       	ldd	r19, Y+40	; 0x28
    1b3c:	49 a5       	ldd	r20, Y+41	; 0x29
    1b3e:	5a a5       	ldd	r21, Y+42	; 0x2a
    1b40:	c3 01       	movw	r24, r6
    1b42:	b2 01       	movw	r22, r4
    1b44:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <__mulsf3>
    1b48:	2b 01       	movw	r4, r22
    1b4a:	3c 01       	movw	r6, r24
    1b4c:	a5 01       	movw	r20, r10
    1b4e:	94 01       	movw	r18, r8
    1b50:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1b52:	78 a1       	ldd	r23, Y+32	; 0x20
    1b54:	89 a1       	ldd	r24, Y+33	; 0x21
    1b56:	9a a1       	ldd	r25, Y+34	; 0x22
    1b58:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <__mulsf3>
    1b5c:	9b 01       	movw	r18, r22
    1b5e:	ac 01       	movw	r20, r24
    1b60:	c3 01       	movw	r24, r6
    1b62:	b2 01       	movw	r22, r4
    1b64:	0e 94 9d 19 	call	0x333a	; 0x333a <__subsf3>
    1b68:	6d 83       	std	Y+5, r22	; 0x05
    1b6a:	7e 83       	std	Y+6, r23	; 0x06
    1b6c:	8f 83       	std	Y+7, r24	; 0x07
    1b6e:	98 87       	std	Y+8, r25	; 0x08
    1b70:	a5 01       	movw	r20, r10
    1b72:	94 01       	movw	r18, r8
    1b74:	6b a1       	ldd	r22, Y+35	; 0x23
    1b76:	7c a1       	ldd	r23, Y+36	; 0x24
    1b78:	8d a1       	ldd	r24, Y+37	; 0x25
    1b7a:	9e a1       	ldd	r25, Y+38	; 0x26
    1b7c:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <__mulsf3>
    1b80:	4b 01       	movw	r8, r22
    1b82:	5c 01       	movw	r10, r24
    1b84:	2f a1       	ldd	r18, Y+39	; 0x27
    1b86:	38 a5       	ldd	r19, Y+40	; 0x28
    1b88:	49 a5       	ldd	r20, Y+41	; 0x29
    1b8a:	5a a5       	ldd	r21, Y+42	; 0x2a
    1b8c:	c7 01       	movw	r24, r14
    1b8e:	b6 01       	movw	r22, r12
    1b90:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <__mulsf3>
    1b94:	9b 01       	movw	r18, r22
    1b96:	ac 01       	movw	r20, r24
    1b98:	c5 01       	movw	r24, r10
    1b9a:	b4 01       	movw	r22, r8
    1b9c:	0e 94 9d 19 	call	0x333a	; 0x333a <__subsf3>
    1ba0:	69 87       	std	Y+9, r22	; 0x09
    1ba2:	7a 87       	std	Y+10, r23	; 0x0a
    1ba4:	8b 87       	std	Y+11, r24	; 0x0b
    1ba6:	9c 87       	std	Y+12, r25	; 0x0c
    1ba8:	ce 01       	movw	r24, r28
    1baa:	01 96       	adiw	r24, 0x01	; 1
    1bac:	b4 dd       	rcall	.-1176   	; 0x1716 <_ZN6LSM30316vector_normalizeEPNS_6vectorIfEE>
    1bae:	69 8d       	ldd	r22, Y+25	; 0x19
    1bb0:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1bb2:	88 27       	eor	r24, r24
    1bb4:	77 fd       	sbrc	r23, 7
    1bb6:	80 95       	com	r24
    1bb8:	98 2f       	mov	r25, r24
    1bba:	0e 94 03 1b 	call	0x3606	; 0x3606 <__floatsisf>
    1bbe:	2b 01       	movw	r4, r22
    1bc0:	3c 01       	movw	r6, r24
    1bc2:	6b 8d       	ldd	r22, Y+27	; 0x1b
    1bc4:	7c 8d       	ldd	r23, Y+28	; 0x1c
    1bc6:	88 27       	eor	r24, r24
    1bc8:	77 fd       	sbrc	r23, 7
    1bca:	80 95       	com	r24
    1bcc:	98 2f       	mov	r25, r24
    1bce:	0e 94 03 1b 	call	0x3606	; 0x3606 <__floatsisf>
    1bd2:	4b 01       	movw	r8, r22
    1bd4:	5c 01       	movw	r10, r24
    1bd6:	6d 8d       	ldd	r22, Y+29	; 0x1d
    1bd8:	7e 8d       	ldd	r23, Y+30	; 0x1e
    1bda:	88 27       	eor	r24, r24
    1bdc:	77 fd       	sbrc	r23, 7
    1bde:	80 95       	com	r24
    1be0:	98 2f       	mov	r25, r24
    1be2:	0e 94 03 1b 	call	0x3606	; 0x3606 <__floatsisf>
    1be6:	6b 01       	movw	r12, r22
    1be8:	7c 01       	movw	r14, r24
    1bea:	29 81       	ldd	r18, Y+1	; 0x01
    1bec:	3a 81       	ldd	r19, Y+2	; 0x02
    1bee:	4b 81       	ldd	r20, Y+3	; 0x03
    1bf0:	5c 81       	ldd	r21, Y+4	; 0x04
    1bf2:	c3 01       	movw	r24, r6
    1bf4:	b2 01       	movw	r22, r4
    1bf6:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <__mulsf3>
    1bfa:	6f 8f       	std	Y+31, r22	; 0x1f
    1bfc:	78 a3       	std	Y+32, r23	; 0x20
    1bfe:	89 a3       	std	Y+33, r24	; 0x21
    1c00:	9a a3       	std	Y+34, r25	; 0x22
    1c02:	2d 81       	ldd	r18, Y+5	; 0x05
    1c04:	3e 81       	ldd	r19, Y+6	; 0x06
    1c06:	4f 81       	ldd	r20, Y+7	; 0x07
    1c08:	58 85       	ldd	r21, Y+8	; 0x08
    1c0a:	c5 01       	movw	r24, r10
    1c0c:	b4 01       	movw	r22, r8
    1c0e:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <__mulsf3>
    1c12:	9b 01       	movw	r18, r22
    1c14:	ac 01       	movw	r20, r24
    1c16:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1c18:	78 a1       	ldd	r23, Y+32	; 0x20
    1c1a:	89 a1       	ldd	r24, Y+33	; 0x21
    1c1c:	9a a1       	ldd	r25, Y+34	; 0x22
    1c1e:	0e 94 9e 19 	call	0x333c	; 0x333c <__addsf3>
    1c22:	6f 8f       	std	Y+31, r22	; 0x1f
    1c24:	78 a3       	std	Y+32, r23	; 0x20
    1c26:	89 a3       	std	Y+33, r24	; 0x21
    1c28:	9a a3       	std	Y+34, r25	; 0x22
    1c2a:	29 85       	ldd	r18, Y+9	; 0x09
    1c2c:	3a 85       	ldd	r19, Y+10	; 0x0a
    1c2e:	4b 85       	ldd	r20, Y+11	; 0x0b
    1c30:	5c 85       	ldd	r21, Y+12	; 0x0c
    1c32:	c7 01       	movw	r24, r14
    1c34:	b6 01       	movw	r22, r12
    1c36:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <__mulsf3>
    1c3a:	9b 01       	movw	r18, r22
    1c3c:	ac 01       	movw	r20, r24
    1c3e:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1c40:	78 a1       	ldd	r23, Y+32	; 0x20
    1c42:	89 a1       	ldd	r24, Y+33	; 0x21
    1c44:	9a a1       	ldd	r25, Y+34	; 0x22
    1c46:	0e 94 9e 19 	call	0x333c	; 0x333c <__addsf3>
    1c4a:	6f 8f       	std	Y+31, r22	; 0x1f
    1c4c:	78 a3       	std	Y+32, r23	; 0x20
    1c4e:	89 a3       	std	Y+33, r24	; 0x21
    1c50:	9a a3       	std	Y+34, r25	; 0x22
    1c52:	2d 85       	ldd	r18, Y+13	; 0x0d
    1c54:	3e 85       	ldd	r19, Y+14	; 0x0e
    1c56:	4f 85       	ldd	r20, Y+15	; 0x0f
    1c58:	58 89       	ldd	r21, Y+16	; 0x10
    1c5a:	c3 01       	movw	r24, r6
    1c5c:	b2 01       	movw	r22, r4
    1c5e:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <__mulsf3>
    1c62:	2b 01       	movw	r4, r22
    1c64:	3c 01       	movw	r6, r24
    1c66:	29 89       	ldd	r18, Y+17	; 0x11
    1c68:	3a 89       	ldd	r19, Y+18	; 0x12
    1c6a:	4b 89       	ldd	r20, Y+19	; 0x13
    1c6c:	5c 89       	ldd	r21, Y+20	; 0x14
    1c6e:	c5 01       	movw	r24, r10
    1c70:	b4 01       	movw	r22, r8
    1c72:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <__mulsf3>
    1c76:	9b 01       	movw	r18, r22
    1c78:	ac 01       	movw	r20, r24
    1c7a:	c3 01       	movw	r24, r6
    1c7c:	b2 01       	movw	r22, r4
    1c7e:	0e 94 9e 19 	call	0x333c	; 0x333c <__addsf3>
    1c82:	4b 01       	movw	r8, r22
    1c84:	5c 01       	movw	r10, r24
    1c86:	2d 89       	ldd	r18, Y+21	; 0x15
    1c88:	3e 89       	ldd	r19, Y+22	; 0x16
    1c8a:	4f 89       	ldd	r20, Y+23	; 0x17
    1c8c:	58 8d       	ldd	r21, Y+24	; 0x18
    1c8e:	c7 01       	movw	r24, r14
    1c90:	b6 01       	movw	r22, r12
    1c92:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <__mulsf3>
    1c96:	9b 01       	movw	r18, r22
    1c98:	ac 01       	movw	r20, r24
    1c9a:	c5 01       	movw	r24, r10
    1c9c:	b4 01       	movw	r22, r8
    1c9e:	0e 94 9e 19 	call	0x333c	; 0x333c <__addsf3>
    1ca2:	2f 8d       	ldd	r18, Y+31	; 0x1f
    1ca4:	38 a1       	ldd	r19, Y+32	; 0x20
    1ca6:	49 a1       	ldd	r20, Y+33	; 0x21
    1ca8:	5a a1       	ldd	r21, Y+34	; 0x22
    1caa:	0e 94 11 1a 	call	0x3422	; 0x3422 <atan2>
    1cae:	20 e0       	ldi	r18, 0x00	; 0
    1cb0:	30 e0       	ldi	r19, 0x00	; 0
    1cb2:	44 e3       	ldi	r20, 0x34	; 52
    1cb4:	53 e4       	ldi	r21, 0x43	; 67
    1cb6:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <__mulsf3>
    1cba:	2b ed       	ldi	r18, 0xDB	; 219
    1cbc:	3f e0       	ldi	r19, 0x0F	; 15
    1cbe:	49 e4       	ldi	r20, 0x49	; 73
    1cc0:	50 e4       	ldi	r21, 0x40	; 64
    1cc2:	0e 94 68 1a 	call	0x34d0	; 0x34d0 <__divsf3>
    1cc6:	6b 01       	movw	r12, r22
    1cc8:	7c 01       	movw	r14, r24
    1cca:	20 e0       	ldi	r18, 0x00	; 0
    1ccc:	30 e0       	ldi	r19, 0x00	; 0
    1cce:	a9 01       	movw	r20, r18
    1cd0:	0e 94 64 1a 	call	0x34c8	; 0x34c8 <__cmpsf2>
    1cd4:	88 23       	and	r24, r24
    1cd6:	54 f4       	brge	.+20     	; 0x1cec <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE+0x4bc>
    1cd8:	20 e0       	ldi	r18, 0x00	; 0
    1cda:	30 e0       	ldi	r19, 0x00	; 0
    1cdc:	44 eb       	ldi	r20, 0xB4	; 180
    1cde:	53 e4       	ldi	r21, 0x43	; 67
    1ce0:	c7 01       	movw	r24, r14
    1ce2:	b6 01       	movw	r22, r12
    1ce4:	0e 94 9e 19 	call	0x333c	; 0x333c <__addsf3>
    1ce8:	6b 01       	movw	r12, r22
    1cea:	7c 01       	movw	r14, r24
    1cec:	c7 01       	movw	r24, r14
    1cee:	b6 01       	movw	r22, r12
    1cf0:	aa 96       	adiw	r28, 0x2a	; 42
    1cf2:	0f b6       	in	r0, 0x3f	; 63
    1cf4:	f8 94       	cli
    1cf6:	de bf       	out	0x3e, r29	; 62
    1cf8:	0f be       	out	0x3f, r0	; 63
    1cfa:	cd bf       	out	0x3d, r28	; 61
    1cfc:	df 91       	pop	r29
    1cfe:	cf 91       	pop	r28
    1d00:	1f 91       	pop	r17
    1d02:	0f 91       	pop	r16
    1d04:	ff 90       	pop	r15
    1d06:	ef 90       	pop	r14
    1d08:	df 90       	pop	r13
    1d0a:	cf 90       	pop	r12
    1d0c:	bf 90       	pop	r11
    1d0e:	af 90       	pop	r10
    1d10:	9f 90       	pop	r9
    1d12:	8f 90       	pop	r8
    1d14:	7f 90       	pop	r7
    1d16:	6f 90       	pop	r6
    1d18:	5f 90       	pop	r5
    1d1a:	4f 90       	pop	r4
    1d1c:	08 95       	ret

00001d1e <_ZN6LSM3037headingEv>:
    1d1e:	cf 93       	push	r28
    1d20:	df 93       	push	r29
    1d22:	cd b7       	in	r28, 0x3d	; 61
    1d24:	de b7       	in	r29, 0x3e	; 62
    1d26:	2c 97       	sbiw	r28, 0x0c	; 12
    1d28:	0f b6       	in	r0, 0x3f	; 63
    1d2a:	f8 94       	cli
    1d2c:	de bf       	out	0x3e, r29	; 62
    1d2e:	0f be       	out	0x3f, r0	; 63
    1d30:	cd bf       	out	0x3d, r28	; 61
    1d32:	fc 01       	movw	r30, r24
    1d34:	21 8d       	ldd	r18, Z+25	; 0x19
    1d36:	23 30       	cpi	r18, 0x03	; 3
    1d38:	79 f4       	brne	.+30     	; 0x1d58 <_ZN6LSM3037headingEv+0x3a>
    1d3a:	31 e0       	ldi	r19, 0x01	; 1
    1d3c:	23 2f       	mov	r18, r19
    1d3e:	3f 83       	std	Y+7, r19	; 0x07
    1d40:	18 86       	std	Y+8, r1	; 0x08
    1d42:	1a 86       	std	Y+10, r1	; 0x0a
    1d44:	19 86       	std	Y+9, r1	; 0x09
    1d46:	1c 86       	std	Y+12, r1	; 0x0c
    1d48:	1b 86       	std	Y+11, r1	; 0x0b
    1d4a:	30 e0       	ldi	r19, 0x00	; 0
    1d4c:	40 e0       	ldi	r20, 0x00	; 0
    1d4e:	5a 85       	ldd	r21, Y+10	; 0x0a
    1d50:	60 e0       	ldi	r22, 0x00	; 0
    1d52:	7c 85       	ldd	r23, Y+12	; 0x0c
    1d54:	6d dd       	rcall	.-1318   	; 0x1830 <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE>
    1d56:	0e c0       	rjmp	.+28     	; 0x1d74 <_ZN6LSM3037headingEv+0x56>
    1d58:	1a 82       	std	Y+2, r1	; 0x02
    1d5a:	19 82       	std	Y+1, r1	; 0x01
    1d5c:	2f ef       	ldi	r18, 0xFF	; 255
    1d5e:	42 2f       	mov	r20, r18
    1d60:	2b 83       	std	Y+3, r18	; 0x03
    1d62:	2c 83       	std	Y+4, r18	; 0x04
    1d64:	1e 82       	std	Y+6, r1	; 0x06
    1d66:	1d 82       	std	Y+5, r1	; 0x05
    1d68:	20 e0       	ldi	r18, 0x00	; 0
    1d6a:	3a 81       	ldd	r19, Y+2	; 0x02
    1d6c:	5f ef       	ldi	r21, 0xFF	; 255
    1d6e:	60 e0       	ldi	r22, 0x00	; 0
    1d70:	7e 81       	ldd	r23, Y+6	; 0x06
    1d72:	5e dd       	rcall	.-1348   	; 0x1830 <_ZN6LSM3037headingIiEEfNS_6vectorIT_EE>
    1d74:	2c 96       	adiw	r28, 0x0c	; 12
    1d76:	0f b6       	in	r0, 0x3f	; 63
    1d78:	f8 94       	cli
    1d7a:	de bf       	out	0x3e, r29	; 62
    1d7c:	0f be       	out	0x3f, r0	; 63
    1d7e:	cd bf       	out	0x3d, r28	; 61
    1d80:	df 91       	pop	r29
    1d82:	cf 91       	pop	r28
    1d84:	08 95       	ret

00001d86 <_ZN6LSM30311writeAccRegEhh>:
    1d86:	0f 93       	push	r16
    1d88:	1f 93       	push	r17
    1d8a:	cf 93       	push	r28
    1d8c:	df 93       	push	r29
    1d8e:	ec 01       	movw	r28, r24
    1d90:	06 2f       	mov	r16, r22
    1d92:	14 2f       	mov	r17, r20
    1d94:	6a 8d       	ldd	r22, Y+26	; 0x1a
    1d96:	84 e8       	ldi	r24, 0x84	; 132
    1d98:	9e e0       	ldi	r25, 0x0E	; 14
    1d9a:	0e 94 7a 19 	call	0x32f4	; 0x32f4 <_ZN7TwoWire17beginTransmissionEh>
    1d9e:	60 2f       	mov	r22, r16
    1da0:	84 e8       	ldi	r24, 0x84	; 132
    1da2:	9e e0       	ldi	r25, 0x0E	; 14
    1da4:	0e 94 21 19 	call	0x3242	; 0x3242 <_ZN7TwoWire5writeEh>
    1da8:	61 2f       	mov	r22, r17
    1daa:	84 e8       	ldi	r24, 0x84	; 132
    1dac:	9e e0       	ldi	r25, 0x0E	; 14
    1dae:	0e 94 21 19 	call	0x3242	; 0x3242 <_ZN7TwoWire5writeEh>
    1db2:	84 e8       	ldi	r24, 0x84	; 132
    1db4:	9e e0       	ldi	r25, 0x0E	; 14
    1db6:	0e 94 96 19 	call	0x332c	; 0x332c <_ZN7TwoWire15endTransmissionEv>
    1dba:	88 8f       	std	Y+24, r24	; 0x18
    1dbc:	df 91       	pop	r29
    1dbe:	cf 91       	pop	r28
    1dc0:	1f 91       	pop	r17
    1dc2:	0f 91       	pop	r16
    1dc4:	08 95       	ret

00001dc6 <_ZN6LSM30311writeMagRegEhh>:
    1dc6:	0f 93       	push	r16
    1dc8:	1f 93       	push	r17
    1dca:	cf 93       	push	r28
    1dcc:	df 93       	push	r29
    1dce:	ec 01       	movw	r28, r24
    1dd0:	06 2f       	mov	r16, r22
    1dd2:	14 2f       	mov	r17, r20
    1dd4:	6b 8d       	ldd	r22, Y+27	; 0x1b
    1dd6:	84 e8       	ldi	r24, 0x84	; 132
    1dd8:	9e e0       	ldi	r25, 0x0E	; 14
    1dda:	0e 94 7a 19 	call	0x32f4	; 0x32f4 <_ZN7TwoWire17beginTransmissionEh>
    1dde:	60 2f       	mov	r22, r16
    1de0:	84 e8       	ldi	r24, 0x84	; 132
    1de2:	9e e0       	ldi	r25, 0x0E	; 14
    1de4:	0e 94 21 19 	call	0x3242	; 0x3242 <_ZN7TwoWire5writeEh>
    1de8:	61 2f       	mov	r22, r17
    1dea:	84 e8       	ldi	r24, 0x84	; 132
    1dec:	9e e0       	ldi	r25, 0x0E	; 14
    1dee:	0e 94 21 19 	call	0x3242	; 0x3242 <_ZN7TwoWire5writeEh>
    1df2:	84 e8       	ldi	r24, 0x84	; 132
    1df4:	9e e0       	ldi	r25, 0x0E	; 14
    1df6:	0e 94 96 19 	call	0x332c	; 0x332c <_ZN7TwoWire15endTransmissionEv>
    1dfa:	88 8f       	std	Y+24, r24	; 0x18
    1dfc:	df 91       	pop	r29
    1dfe:	cf 91       	pop	r28
    1e00:	1f 91       	pop	r17
    1e02:	0f 91       	pop	r16
    1e04:	08 95       	ret

00001e06 <_ZN6LSM3038writeRegEhh>:
    1e06:	fc 01       	movw	r30, r24
    1e08:	21 8d       	ldd	r18, Z+25	; 0x19
    1e0a:	23 30       	cpi	r18, 0x03	; 3
    1e0c:	11 f0       	breq	.+4      	; 0x1e12 <_ZN6LSM3038writeRegEhh+0xc>
    1e0e:	60 32       	cpi	r22, 0x20	; 32
    1e10:	10 f4       	brcc	.+4      	; 0x1e16 <_ZN6LSM3038writeRegEhh+0x10>
    1e12:	d9 cf       	rjmp	.-78     	; 0x1dc6 <_ZN6LSM30311writeMagRegEhh>
    1e14:	08 95       	ret
    1e16:	b7 cf       	rjmp	.-146    	; 0x1d86 <_ZN6LSM30311writeAccRegEhh>
    1e18:	08 95       	ret

00001e1a <_ZN6LSM30313enableDefaultEv>:
    1e1a:	cf 93       	push	r28
    1e1c:	df 93       	push	r29
    1e1e:	ec 01       	movw	r28, r24
    1e20:	89 8d       	ldd	r24, Y+25	; 0x19
    1e22:	83 30       	cpi	r24, 0x03	; 3
    1e24:	a9 f4       	brne	.+42     	; 0x1e50 <_ZN6LSM30313enableDefaultEv+0x36>
    1e26:	40 e0       	ldi	r20, 0x00	; 0
    1e28:	61 e2       	ldi	r22, 0x21	; 33
    1e2a:	ce 01       	movw	r24, r28
    1e2c:	ec df       	rcall	.-40     	; 0x1e06 <_ZN6LSM3038writeRegEhh>
    1e2e:	47 e5       	ldi	r20, 0x57	; 87
    1e30:	60 e2       	ldi	r22, 0x20	; 32
    1e32:	ce 01       	movw	r24, r28
    1e34:	e8 df       	rcall	.-48     	; 0x1e06 <_ZN6LSM3038writeRegEhh>
    1e36:	44 e6       	ldi	r20, 0x64	; 100
    1e38:	64 e2       	ldi	r22, 0x24	; 36
    1e3a:	ce 01       	movw	r24, r28
    1e3c:	e4 df       	rcall	.-56     	; 0x1e06 <_ZN6LSM3038writeRegEhh>
    1e3e:	40 e2       	ldi	r20, 0x20	; 32
    1e40:	65 e2       	ldi	r22, 0x25	; 37
    1e42:	ce 01       	movw	r24, r28
    1e44:	e0 df       	rcall	.-64     	; 0x1e06 <_ZN6LSM3038writeRegEhh>
    1e46:	40 e0       	ldi	r20, 0x00	; 0
    1e48:	66 e2       	ldi	r22, 0x26	; 38
    1e4a:	ce 01       	movw	r24, r28
    1e4c:	dc df       	rcall	.-72     	; 0x1e06 <_ZN6LSM3038writeRegEhh>
    1e4e:	1f c0       	rjmp	.+62     	; 0x1e8e <_ZN6LSM30313enableDefaultEv+0x74>
    1e50:	82 30       	cpi	r24, 0x02	; 2
    1e52:	49 f4       	brne	.+18     	; 0x1e66 <_ZN6LSM30313enableDefaultEv+0x4c>
    1e54:	48 e0       	ldi	r20, 0x08	; 8
    1e56:	63 e2       	ldi	r22, 0x23	; 35
    1e58:	ce 01       	movw	r24, r28
    1e5a:	95 df       	rcall	.-214    	; 0x1d86 <_ZN6LSM30311writeAccRegEhh>
    1e5c:	47 e4       	ldi	r20, 0x47	; 71
    1e5e:	60 e2       	ldi	r22, 0x20	; 32
    1e60:	ce 01       	movw	r24, r28
    1e62:	91 df       	rcall	.-222    	; 0x1d86 <_ZN6LSM30311writeAccRegEhh>
    1e64:	08 c0       	rjmp	.+16     	; 0x1e76 <_ZN6LSM30313enableDefaultEv+0x5c>
    1e66:	40 e0       	ldi	r20, 0x00	; 0
    1e68:	63 e2       	ldi	r22, 0x23	; 35
    1e6a:	ce 01       	movw	r24, r28
    1e6c:	8c df       	rcall	.-232    	; 0x1d86 <_ZN6LSM30311writeAccRegEhh>
    1e6e:	47 e2       	ldi	r20, 0x27	; 39
    1e70:	60 e2       	ldi	r22, 0x20	; 32
    1e72:	ce 01       	movw	r24, r28
    1e74:	88 df       	rcall	.-240    	; 0x1d86 <_ZN6LSM30311writeAccRegEhh>
    1e76:	4c e0       	ldi	r20, 0x0C	; 12
    1e78:	60 e0       	ldi	r22, 0x00	; 0
    1e7a:	ce 01       	movw	r24, r28
    1e7c:	a4 df       	rcall	.-184    	; 0x1dc6 <_ZN6LSM30311writeMagRegEhh>
    1e7e:	40 e2       	ldi	r20, 0x20	; 32
    1e80:	61 e0       	ldi	r22, 0x01	; 1
    1e82:	ce 01       	movw	r24, r28
    1e84:	a0 df       	rcall	.-192    	; 0x1dc6 <_ZN6LSM30311writeMagRegEhh>
    1e86:	40 e0       	ldi	r20, 0x00	; 0
    1e88:	62 e0       	ldi	r22, 0x02	; 2
    1e8a:	ce 01       	movw	r24, r28
    1e8c:	9c df       	rcall	.-200    	; 0x1dc6 <_ZN6LSM30311writeMagRegEhh>
    1e8e:	df 91       	pop	r29
    1e90:	cf 91       	pop	r28
    1e92:	08 95       	ret

00001e94 <_ZN6LSM3037readAccEv>:

// Reads the 3 accelerometer channels and stores them in vector a
void LSM303::readAcc(void)
{
    1e94:	9f 92       	push	r9
    1e96:	af 92       	push	r10
    1e98:	bf 92       	push	r11
    1e9a:	cf 92       	push	r12
    1e9c:	df 92       	push	r13
    1e9e:	ef 92       	push	r14
    1ea0:	ff 92       	push	r15
    1ea2:	0f 93       	push	r16
    1ea4:	1f 93       	push	r17
    1ea6:	cf 93       	push	r28
    1ea8:	df 93       	push	r29
    1eaa:	ec 01       	movw	r28, r24
  Wire.beginTransmission(acc_address);
    1eac:	6a 8d       	ldd	r22, Y+26	; 0x1a
    1eae:	84 e8       	ldi	r24, 0x84	; 132
    1eb0:	9e e0       	ldi	r25, 0x0E	; 14
    1eb2:	0e 94 7a 19 	call	0x32f4	; 0x32f4 <_ZN7TwoWire17beginTransmissionEh>
    1eb6:	e0 91 84 0e 	lds	r30, 0x0E84
    1eba:	f0 91 85 0e 	lds	r31, 0x0E85
    1ebe:	01 90       	ld	r0, Z+
    1ec0:	f0 81       	ld	r31, Z
    1ec2:	e0 2d       	mov	r30, r0
    1ec4:	68 ea       	ldi	r22, 0xA8	; 168
    1ec6:	84 e8       	ldi	r24, 0x84	; 132
    1ec8:	9e e0       	ldi	r25, 0x0E	; 14
    1eca:	19 95       	eicall
  // assert the MSB of the address to get the accelerometer
  // to do slave-transmit subaddress updating.
  Wire.write(OUT_X_L_A | (1 << 7));
  last_status = Wire.endTransmission();
    1ecc:	84 e8       	ldi	r24, 0x84	; 132
    1ece:	9e e0       	ldi	r25, 0x0E	; 14
    1ed0:	0e 94 96 19 	call	0x332c	; 0x332c <_ZN7TwoWire15endTransmissionEv>
    1ed4:	88 8f       	std	Y+24, r24	; 0x18
  Wire.requestFrom(acc_address, (byte)6);
    1ed6:	46 e0       	ldi	r20, 0x06	; 6
    1ed8:	6a 8d       	ldd	r22, Y+26	; 0x1a
    1eda:	84 e8       	ldi	r24, 0x84	; 132
    1edc:	9e e0       	ldi	r25, 0x0E	; 14
    1ede:	0e 94 77 19 	call	0x32ee	; 0x32ee <_ZN7TwoWire11requestFromEhh>

  unsigned int millis_start = millis();
    1ee2:	0e 94 c7 1f 	call	0x3f8e	; 0x3f8e <millis>
    1ee6:	8b 01       	movw	r16, r22
  while (Wire.available() < 6) {
    1ee8:	10 c0       	rjmp	.+32     	; 0x1f0a <_ZN6LSM3037readAccEv+0x76>
    if (io_timeout > 0 && ((unsigned int)millis() - millis_start) > io_timeout)
    1eea:	8b a1       	ldd	r24, Y+35	; 0x23
    1eec:	9c a1       	ldd	r25, Y+36	; 0x24
    1eee:	89 2b       	or	r24, r25
    1ef0:	61 f0       	breq	.+24     	; 0x1f0a <_ZN6LSM3037readAccEv+0x76>
    1ef2:	0e 94 c7 1f 	call	0x3f8e	; 0x3f8e <millis>
    1ef6:	60 1b       	sub	r22, r16
    1ef8:	71 0b       	sbc	r23, r17
    1efa:	8b a1       	ldd	r24, Y+35	; 0x23
    1efc:	9c a1       	ldd	r25, Y+36	; 0x24
    1efe:	86 17       	cp	r24, r22
    1f00:	97 07       	cpc	r25, r23
    1f02:	18 f4       	brcc	.+6      	; 0x1f0a <_ZN6LSM3037readAccEv+0x76>
    {
      did_timeout = true;
    1f04:	81 e0       	ldi	r24, 0x01	; 1
    1f06:	8d a3       	std	Y+37, r24	; 0x25
      return;
    1f08:	32 c0       	rjmp	.+100    	; 0x1f6e <_ZN6LSM3037readAccEv+0xda>
  Wire.write(OUT_X_L_A | (1 << 7));
  last_status = Wire.endTransmission();
  Wire.requestFrom(acc_address, (byte)6);

  unsigned int millis_start = millis();
  while (Wire.available() < 6) {
    1f0a:	84 e8       	ldi	r24, 0x84	; 132
    1f0c:	9e e0       	ldi	r25, 0x0E	; 14
    1f0e:	0e 94 c7 18 	call	0x318e	; 0x318e <_ZN7TwoWire9availableEv>
    1f12:	06 97       	sbiw	r24, 0x06	; 6
    1f14:	54 f3       	brlt	.-44     	; 0x1eea <_ZN6LSM3037readAccEv+0x56>
      did_timeout = true;
      return;
    }
  }

  byte xla = Wire.read();
    1f16:	84 e8       	ldi	r24, 0x84	; 132
    1f18:	9e e0       	ldi	r25, 0x0E	; 14
    1f1a:	0e 94 cf 18 	call	0x319e	; 0x319e <_ZN7TwoWire4readEv>
    1f1e:	a8 2e       	mov	r10, r24
  byte xha = Wire.read();
    1f20:	84 e8       	ldi	r24, 0x84	; 132
    1f22:	9e e0       	ldi	r25, 0x0E	; 14
    1f24:	0e 94 cf 18 	call	0x319e	; 0x319e <_ZN7TwoWire4readEv>
    1f28:	98 2e       	mov	r9, r24
  byte yla = Wire.read();
    1f2a:	84 e8       	ldi	r24, 0x84	; 132
    1f2c:	9e e0       	ldi	r25, 0x0E	; 14
    1f2e:	0e 94 cf 18 	call	0x319e	; 0x319e <_ZN7TwoWire4readEv>
    1f32:	08 2f       	mov	r16, r24
  byte yha = Wire.read();
    1f34:	84 e8       	ldi	r24, 0x84	; 132
    1f36:	9e e0       	ldi	r25, 0x0E	; 14
    1f38:	0e 94 cf 18 	call	0x319e	; 0x319e <_ZN7TwoWire4readEv>
    1f3c:	b8 2e       	mov	r11, r24
  byte zla = Wire.read();
    1f3e:	84 e8       	ldi	r24, 0x84	; 132
    1f40:	9e e0       	ldi	r25, 0x0E	; 14
    1f42:	0e 94 cf 18 	call	0x319e	; 0x319e <_ZN7TwoWire4readEv>
    1f46:	18 2f       	mov	r17, r24
  byte zha = Wire.read();
    1f48:	84 e8       	ldi	r24, 0x84	; 132
    1f4a:	9e e0       	ldi	r25, 0x0E	; 14
    1f4c:	0e 94 cf 18 	call	0x319e	; 0x319e <_ZN7TwoWire4readEv>

  // combine high and low bytes
  // This no longer drops the lowest 4 bits of the readings from the DLH/DLM/DLHC, which are always 0
  // (12-bit resolution, left-aligned). The D has 16-bit resolution
  a.x = (int16_t)(xha << 8 | xla);
    1f50:	d9 2c       	mov	r13, r9
    1f52:	c1 2c       	mov	r12, r1
    1f54:	ca 28       	or	r12, r10
    1f56:	d9 82       	std	Y+1, r13	; 0x01
    1f58:	c8 82       	st	Y, r12
  a.y = (int16_t)(yha << 8 | yla);
    1f5a:	fb 2c       	mov	r15, r11
    1f5c:	e1 2c       	mov	r14, r1
    1f5e:	e0 2a       	or	r14, r16
    1f60:	fb 82       	std	Y+3, r15	; 0x03
    1f62:	ea 82       	std	Y+2, r14	; 0x02
  a.z = (int16_t)(zha << 8 | zla);
    1f64:	98 2f       	mov	r25, r24
    1f66:	88 27       	eor	r24, r24
    1f68:	81 2b       	or	r24, r17
    1f6a:	9d 83       	std	Y+5, r25	; 0x05
    1f6c:	8c 83       	std	Y+4, r24	; 0x04
}
    1f6e:	df 91       	pop	r29
    1f70:	cf 91       	pop	r28
    1f72:	1f 91       	pop	r17
    1f74:	0f 91       	pop	r16
    1f76:	ff 90       	pop	r15
    1f78:	ef 90       	pop	r14
    1f7a:	df 90       	pop	r13
    1f7c:	cf 90       	pop	r12
    1f7e:	bf 90       	pop	r11
    1f80:	af 90       	pop	r10
    1f82:	9f 90       	pop	r9
    1f84:	08 95       	ret

00001f86 <_ZN6LSM3037readMagEv>:

// Reads the 3 magnetometer channels and stores them in vector m
void LSM303::readMag(void)
{
    1f86:	cf 92       	push	r12
    1f88:	df 92       	push	r13
    1f8a:	ef 92       	push	r14
    1f8c:	ff 92       	push	r15
    1f8e:	0f 93       	push	r16
    1f90:	1f 93       	push	r17
    1f92:	cf 93       	push	r28
    1f94:	df 93       	push	r29
    1f96:	ec 01       	movw	r28, r24
  Wire.beginTransmission(mag_address);
    1f98:	6b 8d       	ldd	r22, Y+27	; 0x1b
    1f9a:	84 e8       	ldi	r24, 0x84	; 132
    1f9c:	9e e0       	ldi	r25, 0x0E	; 14
    1f9e:	0e 94 7a 19 	call	0x32f4	; 0x32f4 <_ZN7TwoWire17beginTransmissionEh>
  // If LSM303D, assert MSB to enable subaddress updating
  // OUT_X_L_M comes first on D, OUT_X_H_M on others
  Wire.write((_device == device_D) ? translated_regs[-OUT_X_L_M] | (1 << 7) : translated_regs[-OUT_X_H_M]);
    1fa2:	89 8d       	ldd	r24, Y+25	; 0x19
    1fa4:	83 30       	cpi	r24, 0x03	; 3
    1fa6:	31 f4       	brne	.+12     	; 0x1fb4 <_ZN6LSM3037readMagEv+0x2e>
    1fa8:	6e 8d       	ldd	r22, Y+30	; 0x1e
    1faa:	77 27       	eor	r23, r23
    1fac:	67 fd       	sbrc	r22, 7
    1fae:	70 95       	com	r23
    1fb0:	60 68       	ori	r22, 0x80	; 128
    1fb2:	04 c0       	rjmp	.+8      	; 0x1fbc <_ZN6LSM3037readMagEv+0x36>
    1fb4:	6d 8d       	ldd	r22, Y+29	; 0x1d
    1fb6:	77 27       	eor	r23, r23
    1fb8:	67 fd       	sbrc	r22, 7
    1fba:	70 95       	com	r23
    1fbc:	e0 91 84 0e 	lds	r30, 0x0E84
    1fc0:	f0 91 85 0e 	lds	r31, 0x0E85
    1fc4:	01 90       	ld	r0, Z+
    1fc6:	f0 81       	ld	r31, Z
    1fc8:	e0 2d       	mov	r30, r0
    1fca:	84 e8       	ldi	r24, 0x84	; 132
    1fcc:	9e e0       	ldi	r25, 0x0E	; 14
    1fce:	19 95       	eicall
  last_status = Wire.endTransmission();
    1fd0:	84 e8       	ldi	r24, 0x84	; 132
    1fd2:	9e e0       	ldi	r25, 0x0E	; 14
    1fd4:	0e 94 96 19 	call	0x332c	; 0x332c <_ZN7TwoWire15endTransmissionEv>
    1fd8:	88 8f       	std	Y+24, r24	; 0x18
  Wire.requestFrom(mag_address, (byte)6);
    1fda:	46 e0       	ldi	r20, 0x06	; 6
    1fdc:	6b 8d       	ldd	r22, Y+27	; 0x1b
    1fde:	84 e8       	ldi	r24, 0x84	; 132
    1fe0:	9e e0       	ldi	r25, 0x0E	; 14
    1fe2:	0e 94 77 19 	call	0x32ee	; 0x32ee <_ZN7TwoWire11requestFromEhh>

  unsigned int millis_start = millis();
    1fe6:	0e 94 c7 1f 	call	0x3f8e	; 0x3f8e <millis>
    1fea:	8b 01       	movw	r16, r22
  while (Wire.available() < 6) {
    1fec:	10 c0       	rjmp	.+32     	; 0x200e <_ZN6LSM3037readMagEv+0x88>
    if (io_timeout > 0 && ((unsigned int)millis() - millis_start) > io_timeout)
    1fee:	8b a1       	ldd	r24, Y+35	; 0x23
    1ff0:	9c a1       	ldd	r25, Y+36	; 0x24
    1ff2:	89 2b       	or	r24, r25
    1ff4:	61 f0       	breq	.+24     	; 0x200e <_ZN6LSM3037readMagEv+0x88>
    1ff6:	0e 94 c7 1f 	call	0x3f8e	; 0x3f8e <millis>
    1ffa:	60 1b       	sub	r22, r16
    1ffc:	71 0b       	sbc	r23, r17
    1ffe:	8b a1       	ldd	r24, Y+35	; 0x23
    2000:	9c a1       	ldd	r25, Y+36	; 0x24
    2002:	86 17       	cp	r24, r22
    2004:	97 07       	cpc	r25, r23
    2006:	18 f4       	brcc	.+6      	; 0x200e <_ZN6LSM3037readMagEv+0x88>
    {
      did_timeout = true;
    2008:	81 e0       	ldi	r24, 0x01	; 1
    200a:	8d a3       	std	Y+37, r24	; 0x25
      return;
    200c:	6e c0       	rjmp	.+220    	; 0x20ea <_ZN6LSM3037readMagEv+0x164>
  Wire.write((_device == device_D) ? translated_regs[-OUT_X_L_M] | (1 << 7) : translated_regs[-OUT_X_H_M]);
  last_status = Wire.endTransmission();
  Wire.requestFrom(mag_address, (byte)6);

  unsigned int millis_start = millis();
  while (Wire.available() < 6) {
    200e:	84 e8       	ldi	r24, 0x84	; 132
    2010:	9e e0       	ldi	r25, 0x0E	; 14
    2012:	0e 94 c7 18 	call	0x318e	; 0x318e <_ZN7TwoWire9availableEv>
    2016:	06 97       	sbiw	r24, 0x06	; 6
    2018:	54 f3       	brlt	.-44     	; 0x1fee <_ZN6LSM3037readMagEv+0x68>
    }
  }

  byte xlm, xhm, ylm, yhm, zlm, zhm;

  if (_device == device_D)
    201a:	89 8d       	ldd	r24, Y+25	; 0x19
    201c:	83 30       	cpi	r24, 0x03	; 3
    201e:	f9 f4       	brne	.+62     	; 0x205e <_ZN6LSM3037readMagEv+0xd8>
  {
    // D: X_L, X_H, Y_L, Y_H, Z_L, Z_H
    xlm = Wire.read();
    2020:	84 e8       	ldi	r24, 0x84	; 132
    2022:	9e e0       	ldi	r25, 0x0E	; 14
    2024:	0e 94 cf 18 	call	0x319e	; 0x319e <_ZN7TwoWire4readEv>
    2028:	c8 2e       	mov	r12, r24
    xhm = Wire.read();
    202a:	84 e8       	ldi	r24, 0x84	; 132
    202c:	9e e0       	ldi	r25, 0x0E	; 14
    202e:	0e 94 cf 18 	call	0x319e	; 0x319e <_ZN7TwoWire4readEv>
    2032:	d8 2e       	mov	r13, r24
    ylm = Wire.read();
    2034:	84 e8       	ldi	r24, 0x84	; 132
    2036:	9e e0       	ldi	r25, 0x0E	; 14
    2038:	0e 94 cf 18 	call	0x319e	; 0x319e <_ZN7TwoWire4readEv>
    203c:	e8 2e       	mov	r14, r24
    yhm = Wire.read();
    203e:	84 e8       	ldi	r24, 0x84	; 132
    2040:	9e e0       	ldi	r25, 0x0E	; 14
    2042:	0e 94 cf 18 	call	0x319e	; 0x319e <_ZN7TwoWire4readEv>
    2046:	f8 2e       	mov	r15, r24
    zlm = Wire.read();
    2048:	84 e8       	ldi	r24, 0x84	; 132
    204a:	9e e0       	ldi	r25, 0x0E	; 14
    204c:	0e 94 cf 18 	call	0x319e	; 0x319e <_ZN7TwoWire4readEv>
    2050:	08 2f       	mov	r16, r24
    zhm = Wire.read();
    2052:	84 e8       	ldi	r24, 0x84	; 132
    2054:	9e e0       	ldi	r25, 0x0E	; 14
    2056:	0e 94 cf 18 	call	0x319e	; 0x319e <_ZN7TwoWire4readEv>
    205a:	18 2f       	mov	r17, r24
    205c:	36 c0       	rjmp	.+108    	; 0x20ca <_ZN6LSM3037readMagEv+0x144>
  }
  else
  {
    // DLHC, DLM, DLH: X_H, X_L...
    xhm = Wire.read();
    205e:	84 e8       	ldi	r24, 0x84	; 132
    2060:	9e e0       	ldi	r25, 0x0E	; 14
    2062:	0e 94 cf 18 	call	0x319e	; 0x319e <_ZN7TwoWire4readEv>
    2066:	d8 2e       	mov	r13, r24
    xlm = Wire.read();
    2068:	84 e8       	ldi	r24, 0x84	; 132
    206a:	9e e0       	ldi	r25, 0x0E	; 14
    206c:	0e 94 cf 18 	call	0x319e	; 0x319e <_ZN7TwoWire4readEv>
    2070:	c8 2e       	mov	r12, r24

    if (_device == device_DLH)
    2072:	89 8d       	ldd	r24, Y+25	; 0x19
    2074:	81 11       	cpse	r24, r1
    2076:	15 c0       	rjmp	.+42     	; 0x20a2 <_ZN6LSM3037readMagEv+0x11c>
    {
      // DLH: ...Y_H, Y_L, Z_H, Z_L
      yhm = Wire.read();
    2078:	84 e8       	ldi	r24, 0x84	; 132
    207a:	9e e0       	ldi	r25, 0x0E	; 14
    207c:	0e 94 cf 18 	call	0x319e	; 0x319e <_ZN7TwoWire4readEv>
    2080:	f8 2e       	mov	r15, r24
      ylm = Wire.read();
    2082:	84 e8       	ldi	r24, 0x84	; 132
    2084:	9e e0       	ldi	r25, 0x0E	; 14
    2086:	0e 94 cf 18 	call	0x319e	; 0x319e <_ZN7TwoWire4readEv>
    208a:	e8 2e       	mov	r14, r24
      zhm = Wire.read();
    208c:	84 e8       	ldi	r24, 0x84	; 132
    208e:	9e e0       	ldi	r25, 0x0E	; 14
    2090:	0e 94 cf 18 	call	0x319e	; 0x319e <_ZN7TwoWire4readEv>
    2094:	18 2f       	mov	r17, r24
      zlm = Wire.read();
    2096:	84 e8       	ldi	r24, 0x84	; 132
    2098:	9e e0       	ldi	r25, 0x0E	; 14
    209a:	0e 94 cf 18 	call	0x319e	; 0x319e <_ZN7TwoWire4readEv>
    209e:	08 2f       	mov	r16, r24
    20a0:	14 c0       	rjmp	.+40     	; 0x20ca <_ZN6LSM3037readMagEv+0x144>
    }
    else
    {
      // DLM, DLHC: ...Z_H, Z_L, Y_H, Y_L
      zhm = Wire.read();
    20a2:	84 e8       	ldi	r24, 0x84	; 132
    20a4:	9e e0       	ldi	r25, 0x0E	; 14
    20a6:	0e 94 cf 18 	call	0x319e	; 0x319e <_ZN7TwoWire4readEv>
    20aa:	18 2f       	mov	r17, r24
      zlm = Wire.read();
    20ac:	84 e8       	ldi	r24, 0x84	; 132
    20ae:	9e e0       	ldi	r25, 0x0E	; 14
    20b0:	0e 94 cf 18 	call	0x319e	; 0x319e <_ZN7TwoWire4readEv>
    20b4:	08 2f       	mov	r16, r24
      yhm = Wire.read();
    20b6:	84 e8       	ldi	r24, 0x84	; 132
    20b8:	9e e0       	ldi	r25, 0x0E	; 14
    20ba:	0e 94 cf 18 	call	0x319e	; 0x319e <_ZN7TwoWire4readEv>
    20be:	f8 2e       	mov	r15, r24
      ylm = Wire.read();
    20c0:	84 e8       	ldi	r24, 0x84	; 132
    20c2:	9e e0       	ldi	r25, 0x0E	; 14
    20c4:	0e 94 cf 18 	call	0x319e	; 0x319e <_ZN7TwoWire4readEv>
    20c8:	e8 2e       	mov	r14, r24
    }
  }

  // combine high and low bytes
  m.x = (int16_t)(xhm << 8 | xlm);
    20ca:	6c 2d       	mov	r22, r12
    20cc:	70 e0       	ldi	r23, 0x00	; 0
    20ce:	7d 29       	or	r23, r13
    20d0:	7f 83       	std	Y+7, r23	; 0x07
    20d2:	6e 83       	std	Y+6, r22	; 0x06
  m.y = (int16_t)(yhm << 8 | ylm);
    20d4:	4e 2d       	mov	r20, r14
    20d6:	50 e0       	ldi	r21, 0x00	; 0
    20d8:	5f 29       	or	r21, r15
    20da:	59 87       	std	Y+9, r21	; 0x09
    20dc:	48 87       	std	Y+8, r20	; 0x08
  m.z = (int16_t)(zhm << 8 | zlm);
    20de:	20 2f       	mov	r18, r16
    20e0:	30 e0       	ldi	r19, 0x00	; 0
    20e2:	c9 01       	movw	r24, r18
    20e4:	91 2b       	or	r25, r17
    20e6:	9b 87       	std	Y+11, r25	; 0x0b
    20e8:	8a 87       	std	Y+10, r24	; 0x0a
}
    20ea:	df 91       	pop	r29
    20ec:	cf 91       	pop	r28
    20ee:	1f 91       	pop	r17
    20f0:	0f 91       	pop	r16
    20f2:	ff 90       	pop	r15
    20f4:	ef 90       	pop	r14
    20f6:	df 90       	pop	r13
    20f8:	cf 90       	pop	r12
    20fa:	08 95       	ret

000020fc <_ZN6LSM3034readEv>:

// Reads all 6 channels of the LSM303 and stores them in the object variables
void LSM303::read(void)
{
    20fc:	cf 93       	push	r28
    20fe:	df 93       	push	r29
    2100:	ec 01       	movw	r28, r24
  readAcc();
    2102:	c8 de       	rcall	.-624    	; 0x1e94 <_ZN6LSM3037readAccEv>
  readMag();
    2104:	ce 01       	movw	r24, r28
    2106:	3f df       	rcall	.-386    	; 0x1f86 <_ZN6LSM3037readMagEv>
}
    2108:	df 91       	pop	r29
    210a:	cf 91       	pop	r28
    210c:	08 95       	ret

0000210e <_ZN6LSM3037testRegEhNS_7regAddrE>:
}

// Private Methods //////////////////////////////////////////////////////////////

int LSM303::testReg(byte address, regAddr reg)
{
    210e:	cf 93       	push	r28
    2110:	df 93       	push	r29
    2112:	c6 2f       	mov	r28, r22
    2114:	d4 2f       	mov	r29, r20
  Wire.beginTransmission(address);
    2116:	84 e8       	ldi	r24, 0x84	; 132
    2118:	9e e0       	ldi	r25, 0x0E	; 14
    211a:	0e 94 7a 19 	call	0x32f4	; 0x32f4 <_ZN7TwoWire17beginTransmissionEh>
  Wire.write((byte)reg);
    211e:	6d 2f       	mov	r22, r29
    2120:	84 e8       	ldi	r24, 0x84	; 132
    2122:	9e e0       	ldi	r25, 0x0E	; 14
    2124:	0e 94 21 19 	call	0x3242	; 0x3242 <_ZN7TwoWire5writeEh>
  if (Wire.endTransmission() != 0)
    2128:	84 e8       	ldi	r24, 0x84	; 132
    212a:	9e e0       	ldi	r25, 0x0E	; 14
    212c:	0e 94 96 19 	call	0x332c	; 0x332c <_ZN7TwoWire15endTransmissionEv>
    2130:	81 11       	cpse	r24, r1
    2132:	11 c0       	rjmp	.+34     	; 0x2156 <_ZN6LSM3037testRegEhNS_7regAddrE+0x48>
  {
    return TEST_REG_ERROR;
  }

  Wire.requestFrom(address, (byte)1);
    2134:	41 e0       	ldi	r20, 0x01	; 1
    2136:	6c 2f       	mov	r22, r28
    2138:	84 e8       	ldi	r24, 0x84	; 132
    213a:	9e e0       	ldi	r25, 0x0E	; 14
    213c:	0e 94 77 19 	call	0x32ee	; 0x32ee <_ZN7TwoWire11requestFromEhh>
  if (Wire.available())
    2140:	84 e8       	ldi	r24, 0x84	; 132
    2142:	9e e0       	ldi	r25, 0x0E	; 14
    2144:	0e 94 c7 18 	call	0x318e	; 0x318e <_ZN7TwoWire9availableEv>
    2148:	89 2b       	or	r24, r25
    214a:	41 f0       	breq	.+16     	; 0x215c <_ZN6LSM3037testRegEhNS_7regAddrE+0x4e>
  {
    return Wire.read();
    214c:	84 e8       	ldi	r24, 0x84	; 132
    214e:	9e e0       	ldi	r25, 0x0E	; 14
    2150:	0e 94 cf 18 	call	0x319e	; 0x319e <_ZN7TwoWire4readEv>
    2154:	05 c0       	rjmp	.+10     	; 0x2160 <_ZN6LSM3037testRegEhNS_7regAddrE+0x52>
{
  Wire.beginTransmission(address);
  Wire.write((byte)reg);
  if (Wire.endTransmission() != 0)
  {
    return TEST_REG_ERROR;
    2156:	8f ef       	ldi	r24, 0xFF	; 255
    2158:	9f ef       	ldi	r25, 0xFF	; 255
    215a:	02 c0       	rjmp	.+4      	; 0x2160 <_ZN6LSM3037testRegEhNS_7regAddrE+0x52>
  {
    return Wire.read();
  }
  else
  {
    return TEST_REG_ERROR;
    215c:	8f ef       	ldi	r24, 0xFF	; 255
    215e:	9f ef       	ldi	r25, 0xFF	; 255
  }
    2160:	df 91       	pop	r29
    2162:	cf 91       	pop	r28
    2164:	08 95       	ret

00002166 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE>:
{
  return io_timeout;
}

bool LSM303::init(deviceType device, sa0State sa0)
{
    2166:	0f 93       	push	r16
    2168:	1f 93       	push	r17
    216a:	cf 93       	push	r28
    216c:	df 93       	push	r29
    216e:	ec 01       	movw	r28, r24
    2170:	16 2f       	mov	r17, r22
    2172:	04 2f       	mov	r16, r20
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
    2174:	64 30       	cpi	r22, 0x04	; 4
    2176:	09 f4       	brne	.+2      	; 0x217a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x14>
    2178:	ad c0       	rjmp	.+346    	; 0x22d4 <__stack+0xd5>
    217a:	42 30       	cpi	r20, 0x02	; 2
    217c:	09 f0       	breq	.+2      	; 0x2180 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1a>
    217e:	47 c0       	rjmp	.+142    	; 0x220e <__stack+0xf>
    2180:	ad c0       	rjmp	.+346    	; 0x22dc <__stack+0xdd>
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
    2182:	4f e0       	ldi	r20, 0x0F	; 15
    2184:	6d e1       	ldi	r22, 0x1D	; 29
    2186:	ce 01       	movw	r24, r28
    2188:	c2 df       	rcall	.-124    	; 0x210e <_ZN6LSM3037testRegEhNS_7regAddrE>
    218a:	89 34       	cpi	r24, 0x49	; 73
    218c:	91 05       	cpc	r25, r1
    218e:	09 f4       	brne	.+2      	; 0x2192 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x2c>
    2190:	ab c0       	rjmp	.+342    	; 0x22e8 <__stack+0xe9>
        // device responds to address 0011101 with D ID; it's a D with SA0 high
        device = device_D;
        sa0 = sa0_high;
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(D_SA0_LOW_ADDRESS, WHO_AM_I) == D_WHO_ID)
    2192:	01 30       	cpi	r16, 0x01	; 1
    2194:	41 f0       	breq	.+16     	; 0x21a6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x40>
    2196:	4f e0       	ldi	r20, 0x0F	; 15
    2198:	6e e1       	ldi	r22, 0x1E	; 30
    219a:	ce 01       	movw	r24, r28
    219c:	b8 df       	rcall	.-144    	; 0x210e <_ZN6LSM3037testRegEhNS_7regAddrE>
    219e:	89 34       	cpi	r24, 0x49	; 73
    21a0:	91 05       	cpc	r25, r1
    21a2:	09 f4       	brne	.+2      	; 0x21a6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x40>
    21a4:	a3 c0       	rjmp	.+326    	; 0x22ec <__stack+0xed>
        sa0 = sa0_low;
      }
    }
    
    // check for LSM303DLHC, DLM, DLH if device is still unidentified or was specified to be one of these types
    if (device == device_auto || device == device_DLHC || device == device_DLM || device == device_DLH)
    21a6:	14 30       	cpi	r17, 0x04	; 4
    21a8:	11 f0       	breq	.+4      	; 0x21ae <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x48>
    21aa:	13 30       	cpi	r17, 0x03	; 3
    21ac:	68 f5       	brcc	.+90     	; 0x2208 <__stack+0x9>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
    21ae:	00 23       	and	r16, r16
    21b0:	a9 f0       	breq	.+42     	; 0x21dc <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x76>
    21b2:	40 e2       	ldi	r20, 0x20	; 32
    21b4:	69 e1       	ldi	r22, 0x19	; 25
    21b6:	ce 01       	movw	r24, r28
    21b8:	aa df       	rcall	.-172    	; 0x210e <_ZN6LSM3037testRegEhNS_7regAddrE>
    21ba:	01 96       	adiw	r24, 0x01	; 1
    21bc:	69 f0       	breq	.+26     	; 0x21d8 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x72>
      {
        // device responds to address 0011001; it's a DLHC, DLM with SA0 high, or DLH with SA0 high
        sa0 = sa0_high;
        if (device == device_auto)
    21be:	14 30       	cpi	r17, 0x04	; 4
    21c0:	09 f0       	breq	.+2      	; 0x21c4 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x5e>
    21c2:	99 c0       	rjmp	.+306    	; 0x22f6 <__stack+0xf7>
          // DLHC seems to respond to WHO_AM_I request the same way as DLM, even though this
          // register isn't documented in its datasheet. Since the DLHC accelerometer address is the
          // same as the DLM with SA0 high, but Pololu DLM boards pull SA0 low by default, we'll
          // guess that a device whose accelerometer responds to the SA0 high address and whose
          // magnetometer gives the DLM ID is actually a DLHC.
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLHC : device_DLH;
    21c4:	4f e0       	ldi	r20, 0x0F	; 15
    21c6:	6e e1       	ldi	r22, 0x1E	; 30
    21c8:	ce 01       	movw	r24, r28
    21ca:	a1 df       	rcall	.-190    	; 0x210e <_ZN6LSM3037testRegEhNS_7regAddrE>
    21cc:	cc 97       	sbiw	r24, 0x3c	; 60
    21ce:	09 f0       	breq	.+2      	; 0x21d2 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x6c>
    21d0:	94 c0       	rjmp	.+296    	; 0x22fa <__stack+0xfb>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011001; it's a DLHC, DLM with SA0 high, or DLH with SA0 high
        sa0 = sa0_high;
    21d2:	01 e0       	ldi	r16, 0x01	; 1
          // DLHC seems to respond to WHO_AM_I request the same way as DLM, even though this
          // register isn't documented in its datasheet. Since the DLHC accelerometer address is the
          // same as the DLM with SA0 high, but Pololu DLM boards pull SA0 low by default, we'll
          // guess that a device whose accelerometer responds to the SA0 high address and whose
          // magnetometer gives the DLM ID is actually a DLHC.
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLHC : device_DLH;
    21d4:	12 e0       	ldi	r17, 0x02	; 2
    21d6:	1b c0       	rjmp	.+54     	; 0x220e <__stack+0xf>
        }
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(DLM_DLH_ACC_SA0_LOW_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
    21d8:	01 30       	cpi	r16, 0x01	; 1
    21da:	99 f0       	breq	.+38     	; 0x2202 <__stack+0x3>
    21dc:	40 e2       	ldi	r20, 0x20	; 32
    21de:	68 e1       	ldi	r22, 0x18	; 24
    21e0:	ce 01       	movw	r24, r28
    21e2:	95 df       	rcall	.-214    	; 0x210e <_ZN6LSM3037testRegEhNS_7regAddrE>
    21e4:	01 96       	adiw	r24, 0x01	; 1
    21e6:	69 f0       	breq	.+26     	; 0x2202 <__stack+0x3>
      {
        // device responds to address 0011000; it's a DLM with SA0 low or DLH with SA0 low
        sa0 = sa0_low;
        if (device == device_auto)
    21e8:	14 30       	cpi	r17, 0x04	; 4
    21ea:	09 f0       	breq	.+2      	; 0x21ee <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x88>
    21ec:	89 c0       	rjmp	.+274    	; 0x2300 <__stack+0x101>
        {
          // use magnetometer WHO_AM_I register to determine device type
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLM : device_DLH;
    21ee:	4f e0       	ldi	r20, 0x0F	; 15
    21f0:	6e e1       	ldi	r22, 0x1E	; 30
    21f2:	ce 01       	movw	r24, r28
    21f4:	8c df       	rcall	.-232    	; 0x210e <_ZN6LSM3037testRegEhNS_7regAddrE>
    21f6:	11 e0       	ldi	r17, 0x01	; 1
    21f8:	cc 97       	sbiw	r24, 0x3c	; 60
    21fa:	09 f0       	breq	.+2      	; 0x21fe <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x98>
    21fc:	10 e0       	ldi	r17, 0x00	; 0
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(DLM_DLH_ACC_SA0_LOW_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011000; it's a DLM with SA0 low or DLH with SA0 low
        sa0 = sa0_low;
    21fe:	00 e0       	ldi	r16, 0x00	; 0
    2200:	06 c0       	rjmp	.+12     	; 0x220e <__stack+0xf>
        }
      }
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
    2202:	14 30       	cpi	r17, 0x04	; 4
    2204:	09 f4       	brne	.+2      	; 0x2208 <__stack+0x9>
    2206:	60 c0       	rjmp	.+192    	; 0x22c8 <__stack+0xc9>
    2208:	02 30       	cpi	r16, 0x02	; 2
    220a:	09 f4       	brne	.+2      	; 0x220e <__stack+0xf>
    220c:	5f c0       	rjmp	.+190    	; 0x22cc <__stack+0xcd>
    {
      return false;
    }
  }
  
  _device = device;
    220e:	19 8f       	std	Y+25, r17	; 0x19
  
  // set device addresses and translated register addresses
  switch (device)
    2210:	11 30       	cpi	r17, 0x01	; 1
    2212:	71 f1       	breq	.+92     	; 0x2270 <__stack+0x71>
    2214:	08 f4       	brcc	.+2      	; 0x2218 <__stack+0x19>
    2216:	42 c0       	rjmp	.+132    	; 0x229c <__stack+0x9d>
    2218:	12 30       	cpi	r17, 0x02	; 2
    221a:	c1 f0       	breq	.+48     	; 0x224c <__stack+0x4d>
    221c:	13 30       	cpi	r17, 0x03	; 3
    221e:	09 f0       	breq	.+2      	; 0x2222 <__stack+0x23>
    2220:	57 c0       	rjmp	.+174    	; 0x22d0 <__stack+0xd1>
  {
    case device_D:
      acc_address = mag_address = (sa0 == sa0_high) ? D_SA0_HIGH_ADDRESS : D_SA0_LOW_ADDRESS;
    2222:	01 30       	cpi	r16, 0x01	; 1
    2224:	11 f4       	brne	.+4      	; 0x222a <__stack+0x2b>
    2226:	8d e1       	ldi	r24, 0x1D	; 29
    2228:	01 c0       	rjmp	.+2      	; 0x222c <__stack+0x2d>
    222a:	8e e1       	ldi	r24, 0x1E	; 30
    222c:	8b 8f       	std	Y+27, r24	; 0x1b
    222e:	8a 8f       	std	Y+26, r24	; 0x1a
      translated_regs[-OUT_X_L_M] = D_OUT_X_L_M;
    2230:	88 e0       	ldi	r24, 0x08	; 8
    2232:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_X_H_M] = D_OUT_X_H_M;
    2234:	89 e0       	ldi	r24, 0x09	; 9
    2236:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_Y_L_M] = D_OUT_Y_L_M;
    2238:	8a e0       	ldi	r24, 0x0A	; 10
    223a:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Y_H_M] = D_OUT_Y_H_M;
    223c:	8b e0       	ldi	r24, 0x0B	; 11
    223e:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Z_L_M] = D_OUT_Z_L_M;
    2240:	8c e0       	ldi	r24, 0x0C	; 12
    2242:	8a a3       	std	Y+34, r24	; 0x22
      translated_regs[-OUT_Z_H_M] = D_OUT_Z_H_M;
    2244:	8d e0       	ldi	r24, 0x0D	; 13
    2246:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
    2248:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_H_M] = D_OUT_X_H_M;
      translated_regs[-OUT_Y_L_M] = D_OUT_Y_L_M;
      translated_regs[-OUT_Y_H_M] = D_OUT_Y_H_M;
      translated_regs[-OUT_Z_L_M] = D_OUT_Z_L_M;
      translated_regs[-OUT_Z_H_M] = D_OUT_Z_H_M;
      break;
    224a:	64 c0       	rjmp	.+200    	; 0x2314 <__stack+0x115>

    case device_DLHC:
      acc_address = DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS; // DLHC doesn't have configurable SA0 but uses same acc address as DLM/DLH with SA0 high
    224c:	89 e1       	ldi	r24, 0x19	; 25
    224e:	8a 8f       	std	Y+26, r24	; 0x1a
      mag_address = DLHC_DLM_DLH_MAG_ADDRESS;
    2250:	8e e1       	ldi	r24, 0x1E	; 30
    2252:	8b 8f       	std	Y+27, r24	; 0x1b
      translated_regs[-OUT_X_H_M] = DLHC_OUT_X_H_M;
    2254:	83 e0       	ldi	r24, 0x03	; 3
    2256:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_X_L_M] = DLHC_OUT_X_L_M;
    2258:	84 e0       	ldi	r24, 0x04	; 4
    225a:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_Y_H_M] = DLHC_OUT_Y_H_M;
    225c:	87 e0       	ldi	r24, 0x07	; 7
    225e:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Y_L_M] = DLHC_OUT_Y_L_M;
    2260:	88 e0       	ldi	r24, 0x08	; 8
    2262:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Z_H_M] = DLHC_OUT_Z_H_M;
    2264:	85 e0       	ldi	r24, 0x05	; 5
    2266:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_L_M] = DLHC_OUT_Z_L_M;
    2268:	86 e0       	ldi	r24, 0x06	; 6
    226a:	8a a3       	std	Y+34, r24	; 0x22
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
    226c:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_L_M] = DLHC_OUT_X_L_M;
      translated_regs[-OUT_Y_H_M] = DLHC_OUT_Y_H_M;
      translated_regs[-OUT_Y_L_M] = DLHC_OUT_Y_L_M;
      translated_regs[-OUT_Z_H_M] = DLHC_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLHC_OUT_Z_L_M;
      break;
    226e:	52 c0       	rjmp	.+164    	; 0x2314 <__stack+0x115>

    case device_DLM:
      acc_address = (sa0 == sa0_high) ? DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS : DLM_DLH_ACC_SA0_LOW_ADDRESS;
    2270:	01 30       	cpi	r16, 0x01	; 1
    2272:	11 f4       	brne	.+4      	; 0x2278 <__stack+0x79>
    2274:	89 e1       	ldi	r24, 0x19	; 25
    2276:	01 c0       	rjmp	.+2      	; 0x227a <__stack+0x7b>
    2278:	88 e1       	ldi	r24, 0x18	; 24
    227a:	8a 8f       	std	Y+26, r24	; 0x1a
      mag_address = DLHC_DLM_DLH_MAG_ADDRESS;
    227c:	8e e1       	ldi	r24, 0x1E	; 30
    227e:	8b 8f       	std	Y+27, r24	; 0x1b
      translated_regs[-OUT_X_H_M] = DLM_OUT_X_H_M;
    2280:	83 e0       	ldi	r24, 0x03	; 3
    2282:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_X_L_M] = DLM_OUT_X_L_M;
    2284:	84 e0       	ldi	r24, 0x04	; 4
    2286:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_Y_H_M] = DLM_OUT_Y_H_M;
    2288:	87 e0       	ldi	r24, 0x07	; 7
    228a:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Y_L_M] = DLM_OUT_Y_L_M;
    228c:	88 e0       	ldi	r24, 0x08	; 8
    228e:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Z_H_M] = DLM_OUT_Z_H_M;
    2290:	85 e0       	ldi	r24, 0x05	; 5
    2292:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_L_M] = DLM_OUT_Z_L_M;
    2294:	86 e0       	ldi	r24, 0x06	; 6
    2296:	8a a3       	std	Y+34, r24	; 0x22
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
    2298:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_L_M] = DLM_OUT_X_L_M;
      translated_regs[-OUT_Y_H_M] = DLM_OUT_Y_H_M;
      translated_regs[-OUT_Y_L_M] = DLM_OUT_Y_L_M;
      translated_regs[-OUT_Z_H_M] = DLM_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLM_OUT_Z_L_M;
      break;
    229a:	3c c0       	rjmp	.+120    	; 0x2314 <__stack+0x115>

    case device_DLH:
      acc_address = (sa0 == sa0_high) ? DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS : DLM_DLH_ACC_SA0_LOW_ADDRESS;
    229c:	01 30       	cpi	r16, 0x01	; 1
    229e:	11 f4       	brne	.+4      	; 0x22a4 <__stack+0xa5>
    22a0:	89 e1       	ldi	r24, 0x19	; 25
    22a2:	01 c0       	rjmp	.+2      	; 0x22a6 <__stack+0xa7>
    22a4:	88 e1       	ldi	r24, 0x18	; 24
    22a6:	8a 8f       	std	Y+26, r24	; 0x1a
      mag_address = DLHC_DLM_DLH_MAG_ADDRESS;
    22a8:	8e e1       	ldi	r24, 0x1E	; 30
    22aa:	8b 8f       	std	Y+27, r24	; 0x1b
      translated_regs[-OUT_X_H_M] = DLH_OUT_X_H_M;
    22ac:	83 e0       	ldi	r24, 0x03	; 3
    22ae:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_X_L_M] = DLH_OUT_X_L_M;
    22b0:	84 e0       	ldi	r24, 0x04	; 4
    22b2:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_Y_H_M] = DLH_OUT_Y_H_M;
    22b4:	85 e0       	ldi	r24, 0x05	; 5
    22b6:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Y_L_M] = DLH_OUT_Y_L_M;
    22b8:	86 e0       	ldi	r24, 0x06	; 6
    22ba:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
    22bc:	87 e0       	ldi	r24, 0x07	; 7
    22be:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
    22c0:	88 e0       	ldi	r24, 0x08	; 8
    22c2:	8a a3       	std	Y+34, r24	; 0x22
      break;
  }
  
  return true;
    22c4:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_L_M] = DLH_OUT_X_L_M;
      translated_regs[-OUT_Y_H_M] = DLH_OUT_Y_H_M;
      translated_regs[-OUT_Y_L_M] = DLH_OUT_Y_L_M;
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
    22c6:	26 c0       	rjmp	.+76     	; 0x2314 <__stack+0x115>
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
    {
      return false;
    22c8:	80 e0       	ldi	r24, 0x00	; 0
    22ca:	24 c0       	rjmp	.+72     	; 0x2314 <__stack+0x115>
    22cc:	80 e0       	ldi	r24, 0x00	; 0
    22ce:	22 c0       	rjmp	.+68     	; 0x2314 <__stack+0x115>
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
    22d0:	81 e0       	ldi	r24, 0x01	; 1
    22d2:	20 c0       	rjmp	.+64     	; 0x2314 <__stack+0x115>
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
    22d4:	44 23       	and	r20, r20
    22d6:	09 f4       	brne	.+2      	; 0x22da <__stack+0xdb>
    22d8:	5e cf       	rjmp	.-324    	; 0x2196 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x30>
    22da:	53 cf       	rjmp	.-346    	; 0x2182 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1c>
{
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    22dc:	8d ef       	ldi	r24, 0xFD	; 253
    22de:	86 0f       	add	r24, r22
    22e0:	82 30       	cpi	r24, 0x02	; 2
    22e2:	08 f0       	brcs	.+2      	; 0x22e6 <__stack+0xe7>
    22e4:	62 cf       	rjmp	.-316    	; 0x21aa <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x44>
    22e6:	0e c0       	rjmp	.+28     	; 0x2304 <__stack+0x105>
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
      {
        // device responds to address 0011101 with D ID; it's a D with SA0 high
        device = device_D;
        sa0 = sa0_high;
    22e8:	01 e0       	ldi	r16, 0x01	; 1
    22ea:	03 c0       	rjmp	.+6      	; 0x22f2 <__stack+0xf3>
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(D_SA0_LOW_ADDRESS, WHO_AM_I) == D_WHO_ID)
      {
        // device responds to address 0011110 with D ID; it's a D with SA0 low
        device = device_D;
        sa0 = sa0_low;
    22ec:	00 e0       	ldi	r16, 0x00	; 0
    22ee:	01 c0       	rjmp	.+2      	; 0x22f2 <__stack+0xf3>
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
      {
        // device responds to address 0011101 with D ID; it's a D with SA0 high
        device = device_D;
        sa0 = sa0_high;
    22f0:	01 e0       	ldi	r16, 0x01	; 1
    22f2:	13 e0       	ldi	r17, 0x03	; 3
    22f4:	89 cf       	rjmp	.-238    	; 0x2208 <__stack+0x9>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011001; it's a DLHC, DLM with SA0 high, or DLH with SA0 high
        sa0 = sa0_high;
    22f6:	01 e0       	ldi	r16, 0x01	; 1
    22f8:	8a cf       	rjmp	.-236    	; 0x220e <__stack+0xf>
    22fa:	01 e0       	ldi	r16, 0x01	; 1
          // DLHC seems to respond to WHO_AM_I request the same way as DLM, even though this
          // register isn't documented in its datasheet. Since the DLHC accelerometer address is the
          // same as the DLM with SA0 high, but Pololu DLM boards pull SA0 low by default, we'll
          // guess that a device whose accelerometer responds to the SA0 high address and whose
          // magnetometer gives the DLM ID is actually a DLHC.
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLHC : device_DLH;
    22fc:	10 e0       	ldi	r17, 0x00	; 0
    22fe:	87 cf       	rjmp	.-242    	; 0x220e <__stack+0xf>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(DLM_DLH_ACC_SA0_LOW_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011000; it's a DLM with SA0 low or DLH with SA0 low
        sa0 = sa0_low;
    2300:	00 e0       	ldi	r16, 0x00	; 0
    2302:	85 cf       	rjmp	.-246    	; 0x220e <__stack+0xf>
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
    2304:	4f e0       	ldi	r20, 0x0F	; 15
    2306:	6d e1       	ldi	r22, 0x1D	; 29
    2308:	ce 01       	movw	r24, r28
    230a:	01 df       	rcall	.-510    	; 0x210e <_ZN6LSM3037testRegEhNS_7regAddrE>
    230c:	89 34       	cpi	r24, 0x49	; 73
    230e:	91 05       	cpc	r25, r1
    2310:	79 f3       	breq	.-34     	; 0x22f0 <__stack+0xf1>
    2312:	41 cf       	rjmp	.-382    	; 0x2196 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x30>
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
}
    2314:	df 91       	pop	r29
    2316:	cf 91       	pop	r28
    2318:	1f 91       	pop	r17
    231a:	0f 91       	pop	r16
    231c:	08 95       	ret

0000231e <__vector_45>:
	}
}


//#if defined (__AVR_ATmega32U4__) // Use Timer4 for ATmega32U4 (Teensy/Leonardo).
ISR(TIMER4_OVF_vect) {
    231e:	1f 92       	push	r1
    2320:	0f 92       	push	r0
    2322:	0f b6       	in	r0, 0x3f	; 63
    2324:	0f 92       	push	r0
    2326:	11 24       	eor	r1, r1
    2328:	0b b6       	in	r0, 0x3b	; 59
    232a:	0f 92       	push	r0
    232c:	2f 93       	push	r18
    232e:	3f 93       	push	r19
    2330:	4f 93       	push	r20
    2332:	5f 93       	push	r21
    2334:	6f 93       	push	r22
    2336:	7f 93       	push	r23
    2338:	8f 93       	push	r24
    233a:	9f 93       	push	r25
    233c:	af 93       	push	r26
    233e:	bf 93       	push	r27
    2340:	ef 93       	push	r30
    2342:	ff 93       	push	r31
//#else
//ISR(TIMER2_COMPA_vect) {
//#endif
	if(intFunc) intFunc(); // If wrapped function is set, call it.
    2344:	e0 91 bb 0d 	lds	r30, 0x0DBB
    2348:	f0 91 bc 0d 	lds	r31, 0x0DBC
    234c:	30 97       	sbiw	r30, 0x00	; 0
    234e:	09 f0       	breq	.+2      	; 0x2352 <__vector_45+0x34>
    2350:	19 95       	eicall
}
    2352:	ff 91       	pop	r31
    2354:	ef 91       	pop	r30
    2356:	bf 91       	pop	r27
    2358:	af 91       	pop	r26
    235a:	9f 91       	pop	r25
    235c:	8f 91       	pop	r24
    235e:	7f 91       	pop	r23
    2360:	6f 91       	pop	r22
    2362:	5f 91       	pop	r21
    2364:	4f 91       	pop	r20
    2366:	3f 91       	pop	r19
    2368:	2f 91       	pop	r18
    236a:	0f 90       	pop	r0
    236c:	0b be       	out	0x3b, r0	; 59
    236e:	0f 90       	pop	r0
    2370:	0f be       	out	0x3f, r0	; 63
    2372:	0f 90       	pop	r0
    2374:	1f 90       	pop	r1
    2376:	18 95       	reti

00002378 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2378:	31 e1       	ldi	r19, 0x11	; 17
    237a:	fc 01       	movw	r30, r24
    237c:	30 83       	st	Z, r19
    237e:	31 97       	sbiw	r30, 0x01	; 1
    2380:	22 e2       	ldi	r18, 0x22	; 34
    2382:	20 83       	st	Z, r18
    2384:	31 97       	sbiw	r30, 0x01	; 1
    2386:	a3 e3       	ldi	r26, 0x33	; 51
    2388:	a0 83       	st	Z, r26
    238a:	31 97       	sbiw	r30, 0x01	; 1
    238c:	60 83       	st	Z, r22
    238e:	31 97       	sbiw	r30, 0x01	; 1
    2390:	70 83       	st	Z, r23
    2392:	31 97       	sbiw	r30, 0x01	; 1
    2394:	10 82       	st	Z, r1
    2396:	31 97       	sbiw	r30, 0x01	; 1
    2398:	10 82       	st	Z, r1
    239a:	31 97       	sbiw	r30, 0x01	; 1
    239c:	60 e8       	ldi	r22, 0x80	; 128
    239e:	60 83       	st	Z, r22
    23a0:	31 97       	sbiw	r30, 0x01	; 1
    23a2:	10 82       	st	Z, r1
    23a4:	31 97       	sbiw	r30, 0x01	; 1
    23a6:	10 82       	st	Z, r1
    23a8:	31 97       	sbiw	r30, 0x01	; 1
    23aa:	10 82       	st	Z, r1
    23ac:	31 97       	sbiw	r30, 0x01	; 1
    23ae:	62 e0       	ldi	r22, 0x02	; 2
    23b0:	60 83       	st	Z, r22
    23b2:	31 97       	sbiw	r30, 0x01	; 1
    23b4:	63 e0       	ldi	r22, 0x03	; 3
    23b6:	60 83       	st	Z, r22
    23b8:	31 97       	sbiw	r30, 0x01	; 1
    23ba:	64 e0       	ldi	r22, 0x04	; 4
    23bc:	60 83       	st	Z, r22
    23be:	31 97       	sbiw	r30, 0x01	; 1
    23c0:	65 e0       	ldi	r22, 0x05	; 5
    23c2:	60 83       	st	Z, r22
    23c4:	31 97       	sbiw	r30, 0x01	; 1
    23c6:	66 e0       	ldi	r22, 0x06	; 6
    23c8:	60 83       	st	Z, r22
    23ca:	31 97       	sbiw	r30, 0x01	; 1
    23cc:	67 e0       	ldi	r22, 0x07	; 7
    23ce:	60 83       	st	Z, r22
    23d0:	31 97       	sbiw	r30, 0x01	; 1
    23d2:	68 e0       	ldi	r22, 0x08	; 8
    23d4:	60 83       	st	Z, r22
    23d6:	31 97       	sbiw	r30, 0x01	; 1
    23d8:	69 e0       	ldi	r22, 0x09	; 9
    23da:	60 83       	st	Z, r22
    23dc:	31 97       	sbiw	r30, 0x01	; 1
    23de:	60 e1       	ldi	r22, 0x10	; 16
    23e0:	60 83       	st	Z, r22
    23e2:	31 97       	sbiw	r30, 0x01	; 1
    23e4:	30 83       	st	Z, r19
    23e6:	31 97       	sbiw	r30, 0x01	; 1
    23e8:	32 e1       	ldi	r19, 0x12	; 18
    23ea:	30 83       	st	Z, r19
    23ec:	31 97       	sbiw	r30, 0x01	; 1
    23ee:	33 e1       	ldi	r19, 0x13	; 19
    23f0:	30 83       	st	Z, r19
    23f2:	31 97       	sbiw	r30, 0x01	; 1
    23f4:	34 e1       	ldi	r19, 0x14	; 20
    23f6:	30 83       	st	Z, r19
    23f8:	31 97       	sbiw	r30, 0x01	; 1
    23fa:	35 e1       	ldi	r19, 0x15	; 21
    23fc:	30 83       	st	Z, r19
    23fe:	31 97       	sbiw	r30, 0x01	; 1
    2400:	36 e1       	ldi	r19, 0x16	; 22
    2402:	30 83       	st	Z, r19
    2404:	31 97       	sbiw	r30, 0x01	; 1
    2406:	37 e1       	ldi	r19, 0x17	; 23
    2408:	30 83       	st	Z, r19
    240a:	31 97       	sbiw	r30, 0x01	; 1
    240c:	38 e1       	ldi	r19, 0x18	; 24
    240e:	30 83       	st	Z, r19
    2410:	31 97       	sbiw	r30, 0x01	; 1
    2412:	39 e1       	ldi	r19, 0x19	; 25
    2414:	30 83       	st	Z, r19
    2416:	31 97       	sbiw	r30, 0x01	; 1
    2418:	30 e2       	ldi	r19, 0x20	; 32
    241a:	30 83       	st	Z, r19
    241c:	31 97       	sbiw	r30, 0x01	; 1
    241e:	31 e2       	ldi	r19, 0x21	; 33
    2420:	30 83       	st	Z, r19
    2422:	31 97       	sbiw	r30, 0x01	; 1
    2424:	20 83       	st	Z, r18
    2426:	31 97       	sbiw	r30, 0x01	; 1
    2428:	23 e2       	ldi	r18, 0x23	; 35
    242a:	20 83       	st	Z, r18
    242c:	31 97       	sbiw	r30, 0x01	; 1
    242e:	40 83       	st	Z, r20
    2430:	31 97       	sbiw	r30, 0x01	; 1
    2432:	50 83       	st	Z, r21
    2434:	31 97       	sbiw	r30, 0x01	; 1
    2436:	26 e2       	ldi	r18, 0x26	; 38
    2438:	20 83       	st	Z, r18
    243a:	31 97       	sbiw	r30, 0x01	; 1
    243c:	27 e2       	ldi	r18, 0x27	; 39
    243e:	20 83       	st	Z, r18
    2440:	31 97       	sbiw	r30, 0x01	; 1
    2442:	28 e2       	ldi	r18, 0x28	; 40
    2444:	20 83       	st	Z, r18
    2446:	31 97       	sbiw	r30, 0x01	; 1
    2448:	29 e2       	ldi	r18, 0x29	; 41
    244a:	20 83       	st	Z, r18
    244c:	31 97       	sbiw	r30, 0x01	; 1
    244e:	20 e3       	ldi	r18, 0x30	; 48
    2450:	20 83       	st	Z, r18
    2452:	31 97       	sbiw	r30, 0x01	; 1
    2454:	21 e3       	ldi	r18, 0x31	; 49
    2456:	20 83       	st	Z, r18
    2458:	89 97       	sbiw	r24, 0x29	; 41
    245a:	08 95       	ret

0000245c <xPortStartScheduler>:
    245c:	82 e0       	ldi	r24, 0x02	; 2
    245e:	80 93 b0 00 	sts	0x00B0, r24
    2462:	10 92 b2 00 	sts	0x00B2, r1
    2466:	80 e3       	ldi	r24, 0x30	; 48
    2468:	80 93 b3 00 	sts	0x00B3, r24
    246c:	e0 e7       	ldi	r30, 0x70	; 112
    246e:	f0 e0       	ldi	r31, 0x00	; 0
    2470:	80 81       	ld	r24, Z
    2472:	82 60       	ori	r24, 0x02	; 2
    2474:	80 83       	st	Z, r24
    2476:	83 e0       	ldi	r24, 0x03	; 3
    2478:	80 93 b1 00 	sts	0x00B1, r24
    247c:	a0 91 14 0e 	lds	r26, 0x0E14
    2480:	b0 91 15 0e 	lds	r27, 0x0E15
    2484:	cd 91       	ld	r28, X+
    2486:	cd bf       	out	0x3d, r28	; 61
    2488:	dd 91       	ld	r29, X+
    248a:	de bf       	out	0x3e, r29	; 62
    248c:	ff 91       	pop	r31
    248e:	ef 91       	pop	r30
    2490:	df 91       	pop	r29
    2492:	cf 91       	pop	r28
    2494:	bf 91       	pop	r27
    2496:	af 91       	pop	r26
    2498:	9f 91       	pop	r25
    249a:	8f 91       	pop	r24
    249c:	7f 91       	pop	r23
    249e:	6f 91       	pop	r22
    24a0:	5f 91       	pop	r21
    24a2:	4f 91       	pop	r20
    24a4:	3f 91       	pop	r19
    24a6:	2f 91       	pop	r18
    24a8:	1f 91       	pop	r17
    24aa:	0f 91       	pop	r16
    24ac:	ff 90       	pop	r15
    24ae:	ef 90       	pop	r14
    24b0:	df 90       	pop	r13
    24b2:	cf 90       	pop	r12
    24b4:	bf 90       	pop	r11
    24b6:	af 90       	pop	r10
    24b8:	9f 90       	pop	r9
    24ba:	8f 90       	pop	r8
    24bc:	7f 90       	pop	r7
    24be:	6f 90       	pop	r6
    24c0:	5f 90       	pop	r5
    24c2:	4f 90       	pop	r4
    24c4:	3f 90       	pop	r3
    24c6:	2f 90       	pop	r2
    24c8:	1f 90       	pop	r1
    24ca:	0f 90       	pop	r0
    24cc:	0c be       	out	0x3c, r0	; 60
    24ce:	0f 90       	pop	r0
    24d0:	0b be       	out	0x3b, r0	; 59
    24d2:	0f 90       	pop	r0
    24d4:	0f be       	out	0x3f, r0	; 63
    24d6:	0f 90       	pop	r0
    24d8:	08 95       	ret
    24da:	81 e0       	ldi	r24, 0x01	; 1
    24dc:	08 95       	ret

000024de <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    24de:	0f 92       	push	r0
    24e0:	0f b6       	in	r0, 0x3f	; 63
    24e2:	f8 94       	cli
    24e4:	0f 92       	push	r0
    24e6:	0b b6       	in	r0, 0x3b	; 59
    24e8:	0f 92       	push	r0
    24ea:	0c b6       	in	r0, 0x3c	; 60
    24ec:	0f 92       	push	r0
    24ee:	1f 92       	push	r1
    24f0:	11 24       	eor	r1, r1
    24f2:	2f 92       	push	r2
    24f4:	3f 92       	push	r3
    24f6:	4f 92       	push	r4
    24f8:	5f 92       	push	r5
    24fa:	6f 92       	push	r6
    24fc:	7f 92       	push	r7
    24fe:	8f 92       	push	r8
    2500:	9f 92       	push	r9
    2502:	af 92       	push	r10
    2504:	bf 92       	push	r11
    2506:	cf 92       	push	r12
    2508:	df 92       	push	r13
    250a:	ef 92       	push	r14
    250c:	ff 92       	push	r15
    250e:	0f 93       	push	r16
    2510:	1f 93       	push	r17
    2512:	2f 93       	push	r18
    2514:	3f 93       	push	r19
    2516:	4f 93       	push	r20
    2518:	5f 93       	push	r21
    251a:	6f 93       	push	r22
    251c:	7f 93       	push	r23
    251e:	8f 93       	push	r24
    2520:	9f 93       	push	r25
    2522:	af 93       	push	r26
    2524:	bf 93       	push	r27
    2526:	cf 93       	push	r28
    2528:	df 93       	push	r29
    252a:	ef 93       	push	r30
    252c:	ff 93       	push	r31
    252e:	a0 91 14 0e 	lds	r26, 0x0E14
    2532:	b0 91 15 0e 	lds	r27, 0x0E15
    2536:	0d b6       	in	r0, 0x3d	; 61
    2538:	0d 92       	st	X+, r0
    253a:	0e b6       	in	r0, 0x3e	; 62
    253c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    253e:	b4 d3       	rcall	.+1896   	; 0x2ca8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2540:	a0 91 14 0e 	lds	r26, 0x0E14
    2544:	b0 91 15 0e 	lds	r27, 0x0E15
    2548:	cd 91       	ld	r28, X+
    254a:	cd bf       	out	0x3d, r28	; 61
    254c:	dd 91       	ld	r29, X+
    254e:	de bf       	out	0x3e, r29	; 62
    2550:	ff 91       	pop	r31
    2552:	ef 91       	pop	r30
    2554:	df 91       	pop	r29
    2556:	cf 91       	pop	r28
    2558:	bf 91       	pop	r27
    255a:	af 91       	pop	r26
    255c:	9f 91       	pop	r25
    255e:	8f 91       	pop	r24
    2560:	7f 91       	pop	r23
    2562:	6f 91       	pop	r22
    2564:	5f 91       	pop	r21
    2566:	4f 91       	pop	r20
    2568:	3f 91       	pop	r19
    256a:	2f 91       	pop	r18
    256c:	1f 91       	pop	r17
    256e:	0f 91       	pop	r16
    2570:	ff 90       	pop	r15
    2572:	ef 90       	pop	r14
    2574:	df 90       	pop	r13
    2576:	cf 90       	pop	r12
    2578:	bf 90       	pop	r11
    257a:	af 90       	pop	r10
    257c:	9f 90       	pop	r9
    257e:	8f 90       	pop	r8
    2580:	7f 90       	pop	r7
    2582:	6f 90       	pop	r6
    2584:	5f 90       	pop	r5
    2586:	4f 90       	pop	r4
    2588:	3f 90       	pop	r3
    258a:	2f 90       	pop	r2
    258c:	1f 90       	pop	r1
    258e:	0f 90       	pop	r0
    2590:	0c be       	out	0x3c, r0	; 60
    2592:	0f 90       	pop	r0
    2594:	0b be       	out	0x3b, r0	; 59
    2596:	0f 90       	pop	r0
    2598:	0f be       	out	0x3f, r0	; 63
    259a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    259c:	08 95       	ret

0000259e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    259e:	0f 92       	push	r0
    25a0:	0f b6       	in	r0, 0x3f	; 63
    25a2:	f8 94       	cli
    25a4:	0f 92       	push	r0
    25a6:	0b b6       	in	r0, 0x3b	; 59
    25a8:	0f 92       	push	r0
    25aa:	0c b6       	in	r0, 0x3c	; 60
    25ac:	0f 92       	push	r0
    25ae:	1f 92       	push	r1
    25b0:	11 24       	eor	r1, r1
    25b2:	2f 92       	push	r2
    25b4:	3f 92       	push	r3
    25b6:	4f 92       	push	r4
    25b8:	5f 92       	push	r5
    25ba:	6f 92       	push	r6
    25bc:	7f 92       	push	r7
    25be:	8f 92       	push	r8
    25c0:	9f 92       	push	r9
    25c2:	af 92       	push	r10
    25c4:	bf 92       	push	r11
    25c6:	cf 92       	push	r12
    25c8:	df 92       	push	r13
    25ca:	ef 92       	push	r14
    25cc:	ff 92       	push	r15
    25ce:	0f 93       	push	r16
    25d0:	1f 93       	push	r17
    25d2:	2f 93       	push	r18
    25d4:	3f 93       	push	r19
    25d6:	4f 93       	push	r20
    25d8:	5f 93       	push	r21
    25da:	6f 93       	push	r22
    25dc:	7f 93       	push	r23
    25de:	8f 93       	push	r24
    25e0:	9f 93       	push	r25
    25e2:	af 93       	push	r26
    25e4:	bf 93       	push	r27
    25e6:	cf 93       	push	r28
    25e8:	df 93       	push	r29
    25ea:	ef 93       	push	r30
    25ec:	ff 93       	push	r31
    25ee:	a0 91 14 0e 	lds	r26, 0x0E14
    25f2:	b0 91 15 0e 	lds	r27, 0x0E15
    25f6:	0d b6       	in	r0, 0x3d	; 61
    25f8:	0d 92       	st	X+, r0
    25fa:	0e b6       	in	r0, 0x3e	; 62
    25fc:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    25fe:	c0 d1       	rcall	.+896    	; 0x2980 <xTaskIncrementTick>
    2600:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    2602:	52 d3       	rcall	.+1700   	; 0x2ca8 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    2604:	a0 91 14 0e 	lds	r26, 0x0E14
    2608:	b0 91 15 0e 	lds	r27, 0x0E15
    260c:	cd 91       	ld	r28, X+
    260e:	cd bf       	out	0x3d, r28	; 61
    2610:	dd 91       	ld	r29, X+
    2612:	de bf       	out	0x3e, r29	; 62
    2614:	ff 91       	pop	r31
    2616:	ef 91       	pop	r30
    2618:	df 91       	pop	r29
    261a:	cf 91       	pop	r28
    261c:	bf 91       	pop	r27
    261e:	af 91       	pop	r26
    2620:	9f 91       	pop	r25
    2622:	8f 91       	pop	r24
    2624:	7f 91       	pop	r23
    2626:	6f 91       	pop	r22
    2628:	5f 91       	pop	r21
    262a:	4f 91       	pop	r20
    262c:	3f 91       	pop	r19
    262e:	2f 91       	pop	r18
    2630:	1f 91       	pop	r17
    2632:	0f 91       	pop	r16
    2634:	ff 90       	pop	r15
    2636:	ef 90       	pop	r14
    2638:	df 90       	pop	r13
    263a:	cf 90       	pop	r12
    263c:	bf 90       	pop	r11
    263e:	af 90       	pop	r10
    2640:	9f 90       	pop	r9
    2642:	8f 90       	pop	r8
    2644:	7f 90       	pop	r7
    2646:	6f 90       	pop	r6
    2648:	5f 90       	pop	r5
    264a:	4f 90       	pop	r4
    264c:	3f 90       	pop	r3
    264e:	2f 90       	pop	r2
    2650:	1f 90       	pop	r1
    2652:	0f 90       	pop	r0
    2654:	0c be       	out	0x3c, r0	; 60
    2656:	0f 90       	pop	r0
    2658:	0b be       	out	0x3b, r0	; 59
    265a:	0f 90       	pop	r0
    265c:	0f be       	out	0x3f, r0	; 63
    265e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2660:	08 95       	ret

00002662 <__vector_13>:
	 */
	
	//ISR(TIMER0_COMPA_vect,ISR_NAKED) //comeback timer2
	ISR(TIMER2_COMPA_vect,ISR_NAKED)
	{
		vPortYieldFromTick();
    2662:	9d df       	rcall	.-198    	; 0x259e <vPortYieldFromTick>
		asm volatile ( "reti" );
    2664:	18 95       	reti

00002666 <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2666:	e0 91 dc 0d 	lds	r30, 0x0DDC
    266a:	f0 91 dd 0d 	lds	r31, 0x0DDD
    266e:	80 81       	ld	r24, Z
    2670:	81 11       	cpse	r24, r1
    2672:	07 c0       	rjmp	.+14     	; 0x2682 <prvResetNextTaskUnblockTime+0x1c>
    2674:	8f ef       	ldi	r24, 0xFF	; 255
    2676:	9f ef       	ldi	r25, 0xFF	; 255
    2678:	90 93 16 02 	sts	0x0216, r25
    267c:	80 93 15 02 	sts	0x0215, r24
    2680:	08 95       	ret
    2682:	e0 91 dc 0d 	lds	r30, 0x0DDC
    2686:	f0 91 dd 0d 	lds	r31, 0x0DDD
    268a:	05 80       	ldd	r0, Z+5	; 0x05
    268c:	f6 81       	ldd	r31, Z+6	; 0x06
    268e:	e0 2d       	mov	r30, r0
    2690:	06 80       	ldd	r0, Z+6	; 0x06
    2692:	f7 81       	ldd	r31, Z+7	; 0x07
    2694:	e0 2d       	mov	r30, r0
    2696:	82 81       	ldd	r24, Z+2	; 0x02
    2698:	93 81       	ldd	r25, Z+3	; 0x03
    269a:	90 93 16 02 	sts	0x0216, r25
    269e:	80 93 15 02 	sts	0x0215, r24
    26a2:	08 95       	ret

000026a4 <prvAddCurrentTaskToDelayedList>:
    26a4:	cf 93       	push	r28
    26a6:	df 93       	push	r29
    26a8:	ec 01       	movw	r28, r24
    26aa:	e0 91 14 0e 	lds	r30, 0x0E14
    26ae:	f0 91 15 0e 	lds	r31, 0x0E15
    26b2:	93 83       	std	Z+3, r25	; 0x03
    26b4:	82 83       	std	Z+2, r24	; 0x02
    26b6:	80 91 c4 0d 	lds	r24, 0x0DC4
    26ba:	90 91 c5 0d 	lds	r25, 0x0DC5
    26be:	c8 17       	cp	r28, r24
    26c0:	d9 07       	cpc	r29, r25
    26c2:	68 f4       	brcc	.+26     	; 0x26de <prvAddCurrentTaskToDelayedList+0x3a>
    26c4:	60 91 14 0e 	lds	r22, 0x0E14
    26c8:	70 91 15 0e 	lds	r23, 0x0E15
    26cc:	80 91 da 0d 	lds	r24, 0x0DDA
    26d0:	90 91 db 0d 	lds	r25, 0x0DDB
    26d4:	6e 5f       	subi	r22, 0xFE	; 254
    26d6:	7f 4f       	sbci	r23, 0xFF	; 255
    26d8:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <vListInsert>
    26dc:	17 c0       	rjmp	.+46     	; 0x270c <prvAddCurrentTaskToDelayedList+0x68>
    26de:	60 91 14 0e 	lds	r22, 0x0E14
    26e2:	70 91 15 0e 	lds	r23, 0x0E15
    26e6:	80 91 dc 0d 	lds	r24, 0x0DDC
    26ea:	90 91 dd 0d 	lds	r25, 0x0DDD
    26ee:	6e 5f       	subi	r22, 0xFE	; 254
    26f0:	7f 4f       	sbci	r23, 0xFF	; 255
    26f2:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <vListInsert>
    26f6:	80 91 15 02 	lds	r24, 0x0215
    26fa:	90 91 16 02 	lds	r25, 0x0216
    26fe:	c8 17       	cp	r28, r24
    2700:	d9 07       	cpc	r29, r25
    2702:	20 f4       	brcc	.+8      	; 0x270c <prvAddCurrentTaskToDelayedList+0x68>
    2704:	d0 93 16 02 	sts	0x0216, r29
    2708:	c0 93 15 02 	sts	0x0215, r28
    270c:	df 91       	pop	r29
    270e:	cf 91       	pop	r28
    2710:	08 95       	ret

00002712 <xTaskGenericCreate>:
    2712:	4f 92       	push	r4
    2714:	5f 92       	push	r5
    2716:	6f 92       	push	r6
    2718:	7f 92       	push	r7
    271a:	8f 92       	push	r8
    271c:	9f 92       	push	r9
    271e:	af 92       	push	r10
    2720:	bf 92       	push	r11
    2722:	cf 92       	push	r12
    2724:	df 92       	push	r13
    2726:	ef 92       	push	r14
    2728:	ff 92       	push	r15
    272a:	0f 93       	push	r16
    272c:	1f 93       	push	r17
    272e:	cf 93       	push	r28
    2730:	df 93       	push	r29
    2732:	4c 01       	movw	r8, r24
    2734:	5b 01       	movw	r10, r22
    2736:	2a 01       	movw	r4, r20
    2738:	39 01       	movw	r6, r18
    273a:	81 e2       	ldi	r24, 0x21	; 33
    273c:	90 e0       	ldi	r25, 0x00	; 0
    273e:	0e 94 26 06 	call	0xc4c	; 0xc4c <pvPortMalloc>
    2742:	ec 01       	movw	r28, r24
    2744:	00 97       	sbiw	r24, 0x00	; 0
    2746:	09 f4       	brne	.+2      	; 0x274a <xTaskGenericCreate+0x38>
    2748:	da c0       	rjmp	.+436    	; 0x28fe <xTaskGenericCreate+0x1ec>
    274a:	c1 14       	cp	r12, r1
    274c:	d1 04       	cpc	r13, r1
    274e:	09 f0       	breq	.+2      	; 0x2752 <xTaskGenericCreate+0x40>
    2750:	bf c0       	rjmp	.+382    	; 0x28d0 <xTaskGenericCreate+0x1be>
    2752:	c2 01       	movw	r24, r4
    2754:	0e 94 26 06 	call	0xc4c	; 0xc4c <pvPortMalloc>
    2758:	98 8f       	std	Y+24, r25	; 0x18
    275a:	8f 8b       	std	Y+23, r24	; 0x17
    275c:	89 2b       	or	r24, r25
    275e:	09 f0       	breq	.+2      	; 0x2762 <xTaskGenericCreate+0x50>
    2760:	b9 c0       	rjmp	.+370    	; 0x28d4 <xTaskGenericCreate+0x1c2>
    2762:	ce 01       	movw	r24, r28
    2764:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <vPortFree>
    2768:	ca c0       	rjmp	.+404    	; 0x28fe <xTaskGenericCreate+0x1ec>
    276a:	cf 01       	movw	r24, r30
    276c:	31 91       	ld	r19, Z+
    276e:	da 01       	movw	r26, r20
    2770:	3d 93       	st	X+, r19
    2772:	ad 01       	movw	r20, r26
    2774:	dc 01       	movw	r26, r24
    2776:	8c 91       	ld	r24, X
    2778:	88 23       	and	r24, r24
    277a:	11 f0       	breq	.+4      	; 0x2780 <xTaskGenericCreate+0x6e>
    277c:	21 50       	subi	r18, 0x01	; 1
    277e:	a9 f7       	brne	.-22     	; 0x276a <xTaskGenericCreate+0x58>
    2780:	18 a2       	std	Y+32, r1	; 0x20
    2782:	10 2f       	mov	r17, r16
    2784:	04 30       	cpi	r16, 0x04	; 4
    2786:	08 f0       	brcs	.+2      	; 0x278a <xTaskGenericCreate+0x78>
    2788:	13 e0       	ldi	r17, 0x03	; 3
    278a:	1e 8b       	std	Y+22, r17	; 0x16
    278c:	5e 01       	movw	r10, r28
    278e:	b2 e0       	ldi	r27, 0x02	; 2
    2790:	ab 0e       	add	r10, r27
    2792:	b1 1c       	adc	r11, r1
    2794:	c5 01       	movw	r24, r10
    2796:	0e 94 b0 0a 	call	0x1560	; 0x1560 <vListInitialiseItem>
    279a:	ce 01       	movw	r24, r28
    279c:	0c 96       	adiw	r24, 0x0c	; 12
    279e:	0e 94 b0 0a 	call	0x1560	; 0x1560 <vListInitialiseItem>
    27a2:	d9 87       	std	Y+9, r29	; 0x09
    27a4:	c8 87       	std	Y+8, r28	; 0x08
    27a6:	84 e0       	ldi	r24, 0x04	; 4
    27a8:	90 e0       	ldi	r25, 0x00	; 0
    27aa:	81 1b       	sub	r24, r17
    27ac:	91 09       	sbc	r25, r1
    27ae:	9d 87       	std	Y+13, r25	; 0x0d
    27b0:	8c 87       	std	Y+12, r24	; 0x0c
    27b2:	db 8b       	std	Y+19, r29	; 0x13
    27b4:	ca 8b       	std	Y+18, r28	; 0x12
    27b6:	a3 01       	movw	r20, r6
    27b8:	b4 01       	movw	r22, r8
    27ba:	c6 01       	movw	r24, r12
    27bc:	dd dd       	rcall	.-1094   	; 0x2378 <pxPortInitialiseStack>
    27be:	99 83       	std	Y+1, r25	; 0x01
    27c0:	88 83       	st	Y, r24
    27c2:	e1 14       	cp	r14, r1
    27c4:	f1 04       	cpc	r15, r1
    27c6:	19 f0       	breq	.+6      	; 0x27ce <xTaskGenericCreate+0xbc>
    27c8:	f7 01       	movw	r30, r14
    27ca:	d1 83       	std	Z+1, r29	; 0x01
    27cc:	c0 83       	st	Z, r28
    27ce:	0f b6       	in	r0, 0x3f	; 63
    27d0:	f8 94       	cli
    27d2:	0f 92       	push	r0
    27d4:	80 91 c6 0d 	lds	r24, 0x0DC6
    27d8:	8f 5f       	subi	r24, 0xFF	; 255
    27da:	80 93 c6 0d 	sts	0x0DC6, r24
    27de:	80 91 14 0e 	lds	r24, 0x0E14
    27e2:	90 91 15 0e 	lds	r25, 0x0E15
    27e6:	89 2b       	or	r24, r25
    27e8:	a9 f5       	brne	.+106    	; 0x2854 <xTaskGenericCreate+0x142>
    27ea:	d0 93 15 0e 	sts	0x0E15, r29
    27ee:	c0 93 14 0e 	sts	0x0E14, r28
    27f2:	80 91 c6 0d 	lds	r24, 0x0DC6
    27f6:	81 30       	cpi	r24, 0x01	; 1
    27f8:	e1 f5       	brne	.+120    	; 0x2872 <xTaskGenericCreate+0x160>
    27fa:	80 ef       	ldi	r24, 0xF0	; 240
    27fc:	9d e0       	ldi	r25, 0x0D	; 13
    27fe:	0e 94 a2 0a 	call	0x1544	; 0x1544 <vListInitialise>
    2802:	89 ef       	ldi	r24, 0xF9	; 249
    2804:	9d e0       	ldi	r25, 0x0D	; 13
    2806:	0e 94 a2 0a 	call	0x1544	; 0x1544 <vListInitialise>
    280a:	82 e0       	ldi	r24, 0x02	; 2
    280c:	9e e0       	ldi	r25, 0x0E	; 14
    280e:	0e 94 a2 0a 	call	0x1544	; 0x1544 <vListInitialise>
    2812:	8b e0       	ldi	r24, 0x0B	; 11
    2814:	9e e0       	ldi	r25, 0x0E	; 14
    2816:	0e 94 a2 0a 	call	0x1544	; 0x1544 <vListInitialise>
    281a:	87 ee       	ldi	r24, 0xE7	; 231
    281c:	9d e0       	ldi	r25, 0x0D	; 13
    281e:	0e 94 a2 0a 	call	0x1544	; 0x1544 <vListInitialise>
    2822:	8e ed       	ldi	r24, 0xDE	; 222
    2824:	9d e0       	ldi	r25, 0x0D	; 13
    2826:	0e 94 a2 0a 	call	0x1544	; 0x1544 <vListInitialise>
    282a:	81 ed       	ldi	r24, 0xD1	; 209
    282c:	9d e0       	ldi	r25, 0x0D	; 13
    282e:	0e 94 a2 0a 	call	0x1544	; 0x1544 <vListInitialise>
    2832:	88 ec       	ldi	r24, 0xC8	; 200
    2834:	9d e0       	ldi	r25, 0x0D	; 13
    2836:	0e 94 a2 0a 	call	0x1544	; 0x1544 <vListInitialise>
    283a:	87 ee       	ldi	r24, 0xE7	; 231
    283c:	9d e0       	ldi	r25, 0x0D	; 13
    283e:	90 93 dd 0d 	sts	0x0DDD, r25
    2842:	80 93 dc 0d 	sts	0x0DDC, r24
    2846:	8e ed       	ldi	r24, 0xDE	; 222
    2848:	9d e0       	ldi	r25, 0x0D	; 13
    284a:	90 93 db 0d 	sts	0x0DDB, r25
    284e:	80 93 da 0d 	sts	0x0DDA, r24
    2852:	0f c0       	rjmp	.+30     	; 0x2872 <xTaskGenericCreate+0x160>
    2854:	80 91 c2 0d 	lds	r24, 0x0DC2
    2858:	81 11       	cpse	r24, r1
    285a:	0b c0       	rjmp	.+22     	; 0x2872 <xTaskGenericCreate+0x160>
    285c:	e0 91 14 0e 	lds	r30, 0x0E14
    2860:	f0 91 15 0e 	lds	r31, 0x0E15
    2864:	86 89       	ldd	r24, Z+22	; 0x16
    2866:	08 17       	cp	r16, r24
    2868:	20 f0       	brcs	.+8      	; 0x2872 <xTaskGenericCreate+0x160>
    286a:	d0 93 15 0e 	sts	0x0E15, r29
    286e:	c0 93 14 0e 	sts	0x0E14, r28
    2872:	80 91 be 0d 	lds	r24, 0x0DBE
    2876:	8f 5f       	subi	r24, 0xFF	; 255
    2878:	80 93 be 0d 	sts	0x0DBE, r24
    287c:	8e 89       	ldd	r24, Y+22	; 0x16
    287e:	90 91 c3 0d 	lds	r25, 0x0DC3
    2882:	98 17       	cp	r25, r24
    2884:	10 f4       	brcc	.+4      	; 0x288a <xTaskGenericCreate+0x178>
    2886:	80 93 c3 0d 	sts	0x0DC3, r24
    288a:	90 e0       	ldi	r25, 0x00	; 0
    288c:	9c 01       	movw	r18, r24
    288e:	22 0f       	add	r18, r18
    2890:	33 1f       	adc	r19, r19
    2892:	22 0f       	add	r18, r18
    2894:	33 1f       	adc	r19, r19
    2896:	22 0f       	add	r18, r18
    2898:	33 1f       	adc	r19, r19
    289a:	82 0f       	add	r24, r18
    289c:	93 1f       	adc	r25, r19
    289e:	b5 01       	movw	r22, r10
    28a0:	80 51       	subi	r24, 0x10	; 16
    28a2:	92 4f       	sbci	r25, 0xF2	; 242
    28a4:	0e 94 b4 0a 	call	0x1568	; 0x1568 <vListInsertEnd>
    28a8:	0f 90       	pop	r0
    28aa:	0f be       	out	0x3f, r0	; 63
    28ac:	80 91 c2 0d 	lds	r24, 0x0DC2
    28b0:	88 23       	and	r24, r24
    28b2:	51 f0       	breq	.+20     	; 0x28c8 <xTaskGenericCreate+0x1b6>
    28b4:	e0 91 14 0e 	lds	r30, 0x0E14
    28b8:	f0 91 15 0e 	lds	r31, 0x0E15
    28bc:	86 89       	ldd	r24, Z+22	; 0x16
    28be:	80 17       	cp	r24, r16
    28c0:	28 f4       	brcc	.+10     	; 0x28cc <xTaskGenericCreate+0x1ba>
    28c2:	0d de       	rcall	.-998    	; 0x24de <vPortYield>
    28c4:	81 e0       	ldi	r24, 0x01	; 1
    28c6:	1c c0       	rjmp	.+56     	; 0x2900 <xTaskGenericCreate+0x1ee>
    28c8:	81 e0       	ldi	r24, 0x01	; 1
    28ca:	1a c0       	rjmp	.+52     	; 0x2900 <xTaskGenericCreate+0x1ee>
    28cc:	81 e0       	ldi	r24, 0x01	; 1
    28ce:	18 c0       	rjmp	.+48     	; 0x2900 <xTaskGenericCreate+0x1ee>
    28d0:	d8 8e       	std	Y+24, r13	; 0x18
    28d2:	cf 8a       	std	Y+23, r12	; 0x17
    28d4:	f1 e0       	ldi	r31, 0x01	; 1
    28d6:	4f 1a       	sub	r4, r31
    28d8:	51 08       	sbc	r5, r1
    28da:	cf 88       	ldd	r12, Y+23	; 0x17
    28dc:	d8 8c       	ldd	r13, Y+24	; 0x18
    28de:	c4 0c       	add	r12, r4
    28e0:	d5 1c       	adc	r13, r5
    28e2:	d5 01       	movw	r26, r10
    28e4:	8c 91       	ld	r24, X
    28e6:	89 8f       	std	Y+25, r24	; 0x19
    28e8:	8c 91       	ld	r24, X
    28ea:	88 23       	and	r24, r24
    28ec:	09 f4       	brne	.+2      	; 0x28f0 <xTaskGenericCreate+0x1de>
    28ee:	48 cf       	rjmp	.-368    	; 0x2780 <xTaskGenericCreate+0x6e>
    28f0:	ae 01       	movw	r20, r28
    28f2:	46 5e       	subi	r20, 0xE6	; 230
    28f4:	5f 4f       	sbci	r21, 0xFF	; 255
    28f6:	f5 01       	movw	r30, r10
    28f8:	31 96       	adiw	r30, 0x01	; 1
    28fa:	27 e0       	ldi	r18, 0x07	; 7
    28fc:	36 cf       	rjmp	.-404    	; 0x276a <xTaskGenericCreate+0x58>
    28fe:	8f ef       	ldi	r24, 0xFF	; 255
    2900:	df 91       	pop	r29
    2902:	cf 91       	pop	r28
    2904:	1f 91       	pop	r17
    2906:	0f 91       	pop	r16
    2908:	ff 90       	pop	r15
    290a:	ef 90       	pop	r14
    290c:	df 90       	pop	r13
    290e:	cf 90       	pop	r12
    2910:	bf 90       	pop	r11
    2912:	af 90       	pop	r10
    2914:	9f 90       	pop	r9
    2916:	8f 90       	pop	r8
    2918:	7f 90       	pop	r7
    291a:	6f 90       	pop	r6
    291c:	5f 90       	pop	r5
    291e:	4f 90       	pop	r4
    2920:	08 95       	ret

00002922 <vTaskStartScheduler>:
    2922:	af 92       	push	r10
    2924:	bf 92       	push	r11
    2926:	cf 92       	push	r12
    2928:	df 92       	push	r13
    292a:	ef 92       	push	r14
    292c:	ff 92       	push	r15
    292e:	0f 93       	push	r16
    2930:	a1 2c       	mov	r10, r1
    2932:	b1 2c       	mov	r11, r1
    2934:	c1 2c       	mov	r12, r1
    2936:	d1 2c       	mov	r13, r1
    2938:	e1 2c       	mov	r14, r1
    293a:	f1 2c       	mov	r15, r1
    293c:	00 e0       	ldi	r16, 0x00	; 0
    293e:	20 e0       	ldi	r18, 0x00	; 0
    2940:	30 e0       	ldi	r19, 0x00	; 0
    2942:	45 e5       	ldi	r20, 0x55	; 85
    2944:	50 e0       	ldi	r21, 0x00	; 0
    2946:	63 ef       	ldi	r22, 0xF3	; 243
    2948:	72 e0       	ldi	r23, 0x02	; 2
    294a:	8b e1       	ldi	r24, 0x1B	; 27
    294c:	96 e1       	ldi	r25, 0x16	; 22
    294e:	e1 de       	rcall	.-574    	; 0x2712 <xTaskGenericCreate>
    2950:	81 30       	cpi	r24, 0x01	; 1
    2952:	41 f4       	brne	.+16     	; 0x2964 <vTaskStartScheduler+0x42>
    2954:	f8 94       	cli
    2956:	80 93 c2 0d 	sts	0x0DC2, r24
    295a:	10 92 c5 0d 	sts	0x0DC5, r1
    295e:	10 92 c4 0d 	sts	0x0DC4, r1
    2962:	7c dd       	rcall	.-1288   	; 0x245c <xPortStartScheduler>
    2964:	0f 91       	pop	r16
    2966:	ff 90       	pop	r15
    2968:	ef 90       	pop	r14
    296a:	df 90       	pop	r13
    296c:	cf 90       	pop	r12
    296e:	bf 90       	pop	r11
    2970:	af 90       	pop	r10
    2972:	08 95       	ret

00002974 <vTaskSuspendAll>:
    2974:	80 91 bd 0d 	lds	r24, 0x0DBD
    2978:	8f 5f       	subi	r24, 0xFF	; 255
    297a:	80 93 bd 0d 	sts	0x0DBD, r24
    297e:	08 95       	ret

00002980 <xTaskIncrementTick>:
    2980:	cf 92       	push	r12
    2982:	df 92       	push	r13
    2984:	ef 92       	push	r14
    2986:	ff 92       	push	r15
    2988:	0f 93       	push	r16
    298a:	1f 93       	push	r17
    298c:	cf 93       	push	r28
    298e:	df 93       	push	r29
    2990:	80 91 bd 0d 	lds	r24, 0x0DBD
    2994:	81 11       	cpse	r24, r1
    2996:	99 c0       	rjmp	.+306    	; 0x2aca <xTaskIncrementTick+0x14a>
    2998:	80 91 c4 0d 	lds	r24, 0x0DC4
    299c:	90 91 c5 0d 	lds	r25, 0x0DC5
    29a0:	01 96       	adiw	r24, 0x01	; 1
    29a2:	90 93 c5 0d 	sts	0x0DC5, r25
    29a6:	80 93 c4 0d 	sts	0x0DC4, r24
    29aa:	e0 90 c4 0d 	lds	r14, 0x0DC4
    29ae:	f0 90 c5 0d 	lds	r15, 0x0DC5
    29b2:	e1 14       	cp	r14, r1
    29b4:	f1 04       	cpc	r15, r1
    29b6:	b1 f4       	brne	.+44     	; 0x29e4 <xTaskIncrementTick+0x64>
    29b8:	80 91 dc 0d 	lds	r24, 0x0DDC
    29bc:	90 91 dd 0d 	lds	r25, 0x0DDD
    29c0:	20 91 da 0d 	lds	r18, 0x0DDA
    29c4:	30 91 db 0d 	lds	r19, 0x0DDB
    29c8:	30 93 dd 0d 	sts	0x0DDD, r19
    29cc:	20 93 dc 0d 	sts	0x0DDC, r18
    29d0:	90 93 db 0d 	sts	0x0DDB, r25
    29d4:	80 93 da 0d 	sts	0x0DDA, r24
    29d8:	80 91 bf 0d 	lds	r24, 0x0DBF
    29dc:	8f 5f       	subi	r24, 0xFF	; 255
    29de:	80 93 bf 0d 	sts	0x0DBF, r24
    29e2:	41 de       	rcall	.-894    	; 0x2666 <prvResetNextTaskUnblockTime>
    29e4:	80 91 15 02 	lds	r24, 0x0215
    29e8:	90 91 16 02 	lds	r25, 0x0216
    29ec:	e8 16       	cp	r14, r24
    29ee:	f9 06       	cpc	r15, r25
    29f0:	08 f4       	brcc	.+2      	; 0x29f4 <xTaskIncrementTick+0x74>
    29f2:	54 c0       	rjmp	.+168    	; 0x2a9c <xTaskIncrementTick+0x11c>
    29f4:	d1 2c       	mov	r13, r1
    29f6:	cc 24       	eor	r12, r12
    29f8:	c3 94       	inc	r12
    29fa:	01 c0       	rjmp	.+2      	; 0x29fe <xTaskIncrementTick+0x7e>
    29fc:	dc 2c       	mov	r13, r12
    29fe:	e0 91 dc 0d 	lds	r30, 0x0DDC
    2a02:	f0 91 dd 0d 	lds	r31, 0x0DDD
    2a06:	80 81       	ld	r24, Z
    2a08:	81 11       	cpse	r24, r1
    2a0a:	07 c0       	rjmp	.+14     	; 0x2a1a <xTaskIncrementTick+0x9a>
    2a0c:	8f ef       	ldi	r24, 0xFF	; 255
    2a0e:	9f ef       	ldi	r25, 0xFF	; 255
    2a10:	90 93 16 02 	sts	0x0216, r25
    2a14:	80 93 15 02 	sts	0x0215, r24
    2a18:	42 c0       	rjmp	.+132    	; 0x2a9e <xTaskIncrementTick+0x11e>
    2a1a:	e0 91 dc 0d 	lds	r30, 0x0DDC
    2a1e:	f0 91 dd 0d 	lds	r31, 0x0DDD
    2a22:	05 80       	ldd	r0, Z+5	; 0x05
    2a24:	f6 81       	ldd	r31, Z+6	; 0x06
    2a26:	e0 2d       	mov	r30, r0
    2a28:	c6 81       	ldd	r28, Z+6	; 0x06
    2a2a:	d7 81       	ldd	r29, Z+7	; 0x07
    2a2c:	2a 81       	ldd	r18, Y+2	; 0x02
    2a2e:	3b 81       	ldd	r19, Y+3	; 0x03
    2a30:	e2 16       	cp	r14, r18
    2a32:	f3 06       	cpc	r15, r19
    2a34:	28 f4       	brcc	.+10     	; 0x2a40 <xTaskIncrementTick+0xc0>
    2a36:	30 93 16 02 	sts	0x0216, r19
    2a3a:	20 93 15 02 	sts	0x0215, r18
    2a3e:	2f c0       	rjmp	.+94     	; 0x2a9e <xTaskIncrementTick+0x11e>
    2a40:	8e 01       	movw	r16, r28
    2a42:	0e 5f       	subi	r16, 0xFE	; 254
    2a44:	1f 4f       	sbci	r17, 0xFF	; 255
    2a46:	c8 01       	movw	r24, r16
    2a48:	0e 94 06 0b 	call	0x160c	; 0x160c <uxListRemove>
    2a4c:	8c 89       	ldd	r24, Y+20	; 0x14
    2a4e:	9d 89       	ldd	r25, Y+21	; 0x15
    2a50:	89 2b       	or	r24, r25
    2a52:	21 f0       	breq	.+8      	; 0x2a5c <xTaskIncrementTick+0xdc>
    2a54:	ce 01       	movw	r24, r28
    2a56:	0c 96       	adiw	r24, 0x0c	; 12
    2a58:	0e 94 06 0b 	call	0x160c	; 0x160c <uxListRemove>
    2a5c:	2e 89       	ldd	r18, Y+22	; 0x16
    2a5e:	80 91 c3 0d 	lds	r24, 0x0DC3
    2a62:	82 17       	cp	r24, r18
    2a64:	10 f4       	brcc	.+4      	; 0x2a6a <xTaskIncrementTick+0xea>
    2a66:	20 93 c3 0d 	sts	0x0DC3, r18
    2a6a:	30 e0       	ldi	r19, 0x00	; 0
    2a6c:	c9 01       	movw	r24, r18
    2a6e:	88 0f       	add	r24, r24
    2a70:	99 1f       	adc	r25, r25
    2a72:	88 0f       	add	r24, r24
    2a74:	99 1f       	adc	r25, r25
    2a76:	88 0f       	add	r24, r24
    2a78:	99 1f       	adc	r25, r25
    2a7a:	82 0f       	add	r24, r18
    2a7c:	93 1f       	adc	r25, r19
    2a7e:	b8 01       	movw	r22, r16
    2a80:	80 51       	subi	r24, 0x10	; 16
    2a82:	92 4f       	sbci	r25, 0xF2	; 242
    2a84:	0e 94 b4 0a 	call	0x1568	; 0x1568 <vListInsertEnd>
    2a88:	e0 91 14 0e 	lds	r30, 0x0E14
    2a8c:	f0 91 15 0e 	lds	r31, 0x0E15
    2a90:	9e 89       	ldd	r25, Y+22	; 0x16
    2a92:	86 89       	ldd	r24, Z+22	; 0x16
    2a94:	98 17       	cp	r25, r24
    2a96:	08 f0       	brcs	.+2      	; 0x2a9a <xTaskIncrementTick+0x11a>
    2a98:	b1 cf       	rjmp	.-158    	; 0x29fc <xTaskIncrementTick+0x7c>
    2a9a:	b1 cf       	rjmp	.-158    	; 0x29fe <xTaskIncrementTick+0x7e>
    2a9c:	d1 2c       	mov	r13, r1
    2a9e:	e0 91 14 0e 	lds	r30, 0x0E14
    2aa2:	f0 91 15 0e 	lds	r31, 0x0E15
    2aa6:	86 89       	ldd	r24, Z+22	; 0x16
    2aa8:	90 e0       	ldi	r25, 0x00	; 0
    2aaa:	fc 01       	movw	r30, r24
    2aac:	ee 0f       	add	r30, r30
    2aae:	ff 1f       	adc	r31, r31
    2ab0:	ee 0f       	add	r30, r30
    2ab2:	ff 1f       	adc	r31, r31
    2ab4:	ee 0f       	add	r30, r30
    2ab6:	ff 1f       	adc	r31, r31
    2ab8:	8e 0f       	add	r24, r30
    2aba:	9f 1f       	adc	r25, r31
    2abc:	fc 01       	movw	r30, r24
    2abe:	e0 51       	subi	r30, 0x10	; 16
    2ac0:	f2 4f       	sbci	r31, 0xF2	; 242
    2ac2:	80 81       	ld	r24, Z
    2ac4:	82 30       	cpi	r24, 0x02	; 2
    2ac6:	40 f4       	brcc	.+16     	; 0x2ad8 <xTaskIncrementTick+0x158>
    2ac8:	09 c0       	rjmp	.+18     	; 0x2adc <xTaskIncrementTick+0x15c>
    2aca:	80 91 c1 0d 	lds	r24, 0x0DC1
    2ace:	8f 5f       	subi	r24, 0xFF	; 255
    2ad0:	80 93 c1 0d 	sts	0x0DC1, r24
    2ad4:	d1 2c       	mov	r13, r1
    2ad6:	02 c0       	rjmp	.+4      	; 0x2adc <xTaskIncrementTick+0x15c>
    2ad8:	dd 24       	eor	r13, r13
    2ada:	d3 94       	inc	r13
    2adc:	80 91 c0 0d 	lds	r24, 0x0DC0
    2ae0:	88 23       	and	r24, r24
    2ae2:	11 f0       	breq	.+4      	; 0x2ae8 <xTaskIncrementTick+0x168>
    2ae4:	dd 24       	eor	r13, r13
    2ae6:	d3 94       	inc	r13
    2ae8:	8d 2d       	mov	r24, r13
    2aea:	df 91       	pop	r29
    2aec:	cf 91       	pop	r28
    2aee:	1f 91       	pop	r17
    2af0:	0f 91       	pop	r16
    2af2:	ff 90       	pop	r15
    2af4:	ef 90       	pop	r14
    2af6:	df 90       	pop	r13
    2af8:	cf 90       	pop	r12
    2afa:	08 95       	ret

00002afc <xTaskResumeAll>:
    2afc:	df 92       	push	r13
    2afe:	ef 92       	push	r14
    2b00:	ff 92       	push	r15
    2b02:	0f 93       	push	r16
    2b04:	1f 93       	push	r17
    2b06:	cf 93       	push	r28
    2b08:	df 93       	push	r29
    2b0a:	0f b6       	in	r0, 0x3f	; 63
    2b0c:	f8 94       	cli
    2b0e:	0f 92       	push	r0
    2b10:	80 91 bd 0d 	lds	r24, 0x0DBD
    2b14:	81 50       	subi	r24, 0x01	; 1
    2b16:	80 93 bd 0d 	sts	0x0DBD, r24
    2b1a:	80 91 bd 0d 	lds	r24, 0x0DBD
    2b1e:	81 11       	cpse	r24, r1
    2b20:	5f c0       	rjmp	.+190    	; 0x2be0 <xTaskResumeAll+0xe4>
    2b22:	80 91 c6 0d 	lds	r24, 0x0DC6
    2b26:	88 23       	and	r24, r24
    2b28:	09 f4       	brne	.+2      	; 0x2b2c <xTaskResumeAll+0x30>
    2b2a:	5c c0       	rjmp	.+184    	; 0x2be4 <xTaskResumeAll+0xe8>
    2b2c:	0f 2e       	mov	r0, r31
    2b2e:	f1 ed       	ldi	r31, 0xD1	; 209
    2b30:	ef 2e       	mov	r14, r31
    2b32:	fd e0       	ldi	r31, 0x0D	; 13
    2b34:	ff 2e       	mov	r15, r31
    2b36:	f0 2d       	mov	r31, r0
    2b38:	dd 24       	eor	r13, r13
    2b3a:	d3 94       	inc	r13
    2b3c:	30 c0       	rjmp	.+96     	; 0x2b9e <xTaskResumeAll+0xa2>
    2b3e:	e0 91 d6 0d 	lds	r30, 0x0DD6
    2b42:	f0 91 d7 0d 	lds	r31, 0x0DD7
    2b46:	c6 81       	ldd	r28, Z+6	; 0x06
    2b48:	d7 81       	ldd	r29, Z+7	; 0x07
    2b4a:	ce 01       	movw	r24, r28
    2b4c:	0c 96       	adiw	r24, 0x0c	; 12
    2b4e:	0e 94 06 0b 	call	0x160c	; 0x160c <uxListRemove>
    2b52:	8e 01       	movw	r16, r28
    2b54:	0e 5f       	subi	r16, 0xFE	; 254
    2b56:	1f 4f       	sbci	r17, 0xFF	; 255
    2b58:	c8 01       	movw	r24, r16
    2b5a:	0e 94 06 0b 	call	0x160c	; 0x160c <uxListRemove>
    2b5e:	8e 89       	ldd	r24, Y+22	; 0x16
    2b60:	90 91 c3 0d 	lds	r25, 0x0DC3
    2b64:	98 17       	cp	r25, r24
    2b66:	10 f4       	brcc	.+4      	; 0x2b6c <xTaskResumeAll+0x70>
    2b68:	80 93 c3 0d 	sts	0x0DC3, r24
    2b6c:	90 e0       	ldi	r25, 0x00	; 0
    2b6e:	9c 01       	movw	r18, r24
    2b70:	22 0f       	add	r18, r18
    2b72:	33 1f       	adc	r19, r19
    2b74:	22 0f       	add	r18, r18
    2b76:	33 1f       	adc	r19, r19
    2b78:	22 0f       	add	r18, r18
    2b7a:	33 1f       	adc	r19, r19
    2b7c:	82 0f       	add	r24, r18
    2b7e:	93 1f       	adc	r25, r19
    2b80:	b8 01       	movw	r22, r16
    2b82:	80 51       	subi	r24, 0x10	; 16
    2b84:	92 4f       	sbci	r25, 0xF2	; 242
    2b86:	0e 94 b4 0a 	call	0x1568	; 0x1568 <vListInsertEnd>
    2b8a:	e0 91 14 0e 	lds	r30, 0x0E14
    2b8e:	f0 91 15 0e 	lds	r31, 0x0E15
    2b92:	9e 89       	ldd	r25, Y+22	; 0x16
    2b94:	86 89       	ldd	r24, Z+22	; 0x16
    2b96:	98 17       	cp	r25, r24
    2b98:	10 f0       	brcs	.+4      	; 0x2b9e <xTaskResumeAll+0xa2>
    2b9a:	d0 92 c0 0d 	sts	0x0DC0, r13
    2b9e:	f7 01       	movw	r30, r14
    2ba0:	80 81       	ld	r24, Z
    2ba2:	81 11       	cpse	r24, r1
    2ba4:	cc cf       	rjmp	.-104    	; 0x2b3e <xTaskResumeAll+0x42>
    2ba6:	80 91 c1 0d 	lds	r24, 0x0DC1
    2baa:	88 23       	and	r24, r24
    2bac:	91 f0       	breq	.+36     	; 0x2bd2 <xTaskResumeAll+0xd6>
    2bae:	80 91 c1 0d 	lds	r24, 0x0DC1
    2bb2:	88 23       	and	r24, r24
    2bb4:	71 f0       	breq	.+28     	; 0x2bd2 <xTaskResumeAll+0xd6>
    2bb6:	c1 e0       	ldi	r28, 0x01	; 1
    2bb8:	e3 de       	rcall	.-570    	; 0x2980 <xTaskIncrementTick>
    2bba:	81 11       	cpse	r24, r1
    2bbc:	c0 93 c0 0d 	sts	0x0DC0, r28
    2bc0:	80 91 c1 0d 	lds	r24, 0x0DC1
    2bc4:	81 50       	subi	r24, 0x01	; 1
    2bc6:	80 93 c1 0d 	sts	0x0DC1, r24
    2bca:	80 91 c1 0d 	lds	r24, 0x0DC1
    2bce:	81 11       	cpse	r24, r1
    2bd0:	f3 cf       	rjmp	.-26     	; 0x2bb8 <xTaskResumeAll+0xbc>
    2bd2:	80 91 c0 0d 	lds	r24, 0x0DC0
    2bd6:	81 30       	cpi	r24, 0x01	; 1
    2bd8:	39 f4       	brne	.+14     	; 0x2be8 <xTaskResumeAll+0xec>
    2bda:	81 dc       	rcall	.-1790   	; 0x24de <vPortYield>
    2bdc:	81 e0       	ldi	r24, 0x01	; 1
    2bde:	05 c0       	rjmp	.+10     	; 0x2bea <xTaskResumeAll+0xee>
    2be0:	80 e0       	ldi	r24, 0x00	; 0
    2be2:	03 c0       	rjmp	.+6      	; 0x2bea <xTaskResumeAll+0xee>
    2be4:	80 e0       	ldi	r24, 0x00	; 0
    2be6:	01 c0       	rjmp	.+2      	; 0x2bea <xTaskResumeAll+0xee>
    2be8:	80 e0       	ldi	r24, 0x00	; 0
    2bea:	0f 90       	pop	r0
    2bec:	0f be       	out	0x3f, r0	; 63
    2bee:	df 91       	pop	r29
    2bf0:	cf 91       	pop	r28
    2bf2:	1f 91       	pop	r17
    2bf4:	0f 91       	pop	r16
    2bf6:	ff 90       	pop	r15
    2bf8:	ef 90       	pop	r14
    2bfa:	df 90       	pop	r13
    2bfc:	08 95       	ret

00002bfe <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    2bfe:	cf 93       	push	r28
    2c00:	df 93       	push	r29
    2c02:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    2c04:	00 97       	sbiw	r24, 0x00	; 0
    2c06:	99 f0       	breq	.+38     	; 0x2c2e <vTaskDelay+0x30>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    2c08:	b5 de       	rcall	.-662    	; 0x2974 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2c0a:	80 91 c4 0d 	lds	r24, 0x0DC4
    2c0e:	90 91 c5 0d 	lds	r25, 0x0DC5
    2c12:	c8 0f       	add	r28, r24
    2c14:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2c16:	80 91 14 0e 	lds	r24, 0x0E14
    2c1a:	90 91 15 0e 	lds	r25, 0x0E15
    2c1e:	02 96       	adiw	r24, 0x02	; 2
    2c20:	0e 94 06 0b 	call	0x160c	; 0x160c <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2c24:	ce 01       	movw	r24, r28
    2c26:	3e dd       	rcall	.-1412   	; 0x26a4 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2c28:	69 df       	rcall	.-302    	; 0x2afc <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2c2a:	81 11       	cpse	r24, r1
    2c2c:	01 c0       	rjmp	.+2      	; 0x2c30 <vTaskDelay+0x32>
		{
			portYIELD_WITHIN_API();
    2c2e:	57 dc       	rcall	.-1874   	; 0x24de <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2c30:	df 91       	pop	r29
    2c32:	cf 91       	pop	r28
    2c34:	08 95       	ret

00002c36 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    2c36:	0f 2e       	mov	r0, r31
    2c38:	f0 ef       	ldi	r31, 0xF0	; 240
    2c3a:	ef 2e       	mov	r14, r31
    2c3c:	fd e0       	ldi	r31, 0x0D	; 13
    2c3e:	ff 2e       	mov	r15, r31
    2c40:	f0 2d       	mov	r31, r0
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2c42:	c8 ec       	ldi	r28, 0xC8	; 200
    2c44:	dd e0       	ldi	r29, 0x0D	; 13
    2c46:	26 c0       	rjmp	.+76     	; 0x2c94 <prvIdleTask+0x5e>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    2c48:	95 de       	rcall	.-726    	; 0x2974 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2c4a:	18 81       	ld	r17, Y
			}
			( void ) xTaskResumeAll();
    2c4c:	57 df       	rcall	.-338    	; 0x2afc <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    2c4e:	11 23       	and	r17, r17
    2c50:	09 f1       	breq	.+66     	; 0x2c94 <prvIdleTask+0x5e>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    2c52:	0f b6       	in	r0, 0x3f	; 63
    2c54:	f8 94       	cli
    2c56:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    2c58:	e0 91 cd 0d 	lds	r30, 0x0DCD
    2c5c:	f0 91 ce 0d 	lds	r31, 0x0DCE
    2c60:	06 81       	ldd	r16, Z+6	; 0x06
    2c62:	17 81       	ldd	r17, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    2c64:	c8 01       	movw	r24, r16
    2c66:	02 96       	adiw	r24, 0x02	; 2
    2c68:	0e 94 06 0b 	call	0x160c	; 0x160c <uxListRemove>
					--uxCurrentNumberOfTasks;
    2c6c:	80 91 c6 0d 	lds	r24, 0x0DC6
    2c70:	81 50       	subi	r24, 0x01	; 1
    2c72:	80 93 c6 0d 	sts	0x0DC6, r24
					--uxTasksDeleted;
    2c76:	80 91 c7 0d 	lds	r24, 0x0DC7
    2c7a:	81 50       	subi	r24, 0x01	; 1
    2c7c:	80 93 c7 0d 	sts	0x0DC7, r24
				}
				taskEXIT_CRITICAL();
    2c80:	0f 90       	pop	r0
    2c82:	0f be       	out	0x3f, r0	; 63
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
		vPortFreeAligned( pxTCB->pxStack );
    2c84:	f8 01       	movw	r30, r16
    2c86:	87 89       	ldd	r24, Z+23	; 0x17
    2c88:	90 8d       	ldd	r25, Z+24	; 0x18
    2c8a:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <vPortFree>
		vPortFree( pxTCB );
    2c8e:	c8 01       	movw	r24, r16
    2c90:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    2c94:	80 91 c7 0d 	lds	r24, 0x0DC7
    2c98:	81 11       	cpse	r24, r1
    2c9a:	d6 cf       	rjmp	.-84     	; 0x2c48 <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    2c9c:	f7 01       	movw	r30, r14
    2c9e:	80 81       	ld	r24, Z
    2ca0:	82 30       	cpi	r24, 0x02	; 2
    2ca2:	c0 f3       	brcs	.-16     	; 0x2c94 <prvIdleTask+0x5e>
			{
				taskYIELD();
    2ca4:	1c dc       	rcall	.-1992   	; 0x24de <vPortYield>
    2ca6:	f6 cf       	rjmp	.-20     	; 0x2c94 <prvIdleTask+0x5e>

00002ca8 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    2ca8:	80 91 bd 0d 	lds	r24, 0x0DBD
    2cac:	88 23       	and	r24, r24
    2cae:	21 f0       	breq	.+8      	; 0x2cb8 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    2cb0:	81 e0       	ldi	r24, 0x01	; 1
    2cb2:	80 93 c0 0d 	sts	0x0DC0, r24
    2cb6:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    2cb8:	10 92 c0 0d 	sts	0x0DC0, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    2cbc:	80 91 c3 0d 	lds	r24, 0x0DC3
    2cc0:	90 e0       	ldi	r25, 0x00	; 0
    2cc2:	fc 01       	movw	r30, r24
    2cc4:	ee 0f       	add	r30, r30
    2cc6:	ff 1f       	adc	r31, r31
    2cc8:	ee 0f       	add	r30, r30
    2cca:	ff 1f       	adc	r31, r31
    2ccc:	ee 0f       	add	r30, r30
    2cce:	ff 1f       	adc	r31, r31
    2cd0:	8e 0f       	add	r24, r30
    2cd2:	9f 1f       	adc	r25, r31
    2cd4:	fc 01       	movw	r30, r24
    2cd6:	e0 51       	subi	r30, 0x10	; 16
    2cd8:	f2 4f       	sbci	r31, 0xF2	; 242
    2cda:	80 81       	ld	r24, Z
    2cdc:	81 11       	cpse	r24, r1
    2cde:	17 c0       	rjmp	.+46     	; 0x2d0e <vTaskSwitchContext+0x66>
    2ce0:	80 91 c3 0d 	lds	r24, 0x0DC3
    2ce4:	81 50       	subi	r24, 0x01	; 1
    2ce6:	80 93 c3 0d 	sts	0x0DC3, r24
    2cea:	80 91 c3 0d 	lds	r24, 0x0DC3
    2cee:	90 e0       	ldi	r25, 0x00	; 0
    2cf0:	fc 01       	movw	r30, r24
    2cf2:	ee 0f       	add	r30, r30
    2cf4:	ff 1f       	adc	r31, r31
    2cf6:	ee 0f       	add	r30, r30
    2cf8:	ff 1f       	adc	r31, r31
    2cfa:	ee 0f       	add	r30, r30
    2cfc:	ff 1f       	adc	r31, r31
    2cfe:	8e 0f       	add	r24, r30
    2d00:	9f 1f       	adc	r25, r31
    2d02:	fc 01       	movw	r30, r24
    2d04:	e0 51       	subi	r30, 0x10	; 16
    2d06:	f2 4f       	sbci	r31, 0xF2	; 242
    2d08:	80 81       	ld	r24, Z
    2d0a:	88 23       	and	r24, r24
    2d0c:	49 f3       	breq	.-46     	; 0x2ce0 <vTaskSwitchContext+0x38>
    2d0e:	e0 91 c3 0d 	lds	r30, 0x0DC3
    2d12:	f0 e0       	ldi	r31, 0x00	; 0
    2d14:	cf 01       	movw	r24, r30
    2d16:	88 0f       	add	r24, r24
    2d18:	99 1f       	adc	r25, r25
    2d1a:	88 0f       	add	r24, r24
    2d1c:	99 1f       	adc	r25, r25
    2d1e:	88 0f       	add	r24, r24
    2d20:	99 1f       	adc	r25, r25
    2d22:	e8 0f       	add	r30, r24
    2d24:	f9 1f       	adc	r31, r25
    2d26:	e0 51       	subi	r30, 0x10	; 16
    2d28:	f2 4f       	sbci	r31, 0xF2	; 242
    2d2a:	a1 81       	ldd	r26, Z+1	; 0x01
    2d2c:	b2 81       	ldd	r27, Z+2	; 0x02
    2d2e:	12 96       	adiw	r26, 0x02	; 2
    2d30:	0d 90       	ld	r0, X+
    2d32:	bc 91       	ld	r27, X
    2d34:	a0 2d       	mov	r26, r0
    2d36:	b2 83       	std	Z+2, r27	; 0x02
    2d38:	a1 83       	std	Z+1, r26	; 0x01
    2d3a:	cf 01       	movw	r24, r30
    2d3c:	03 96       	adiw	r24, 0x03	; 3
    2d3e:	a8 17       	cp	r26, r24
    2d40:	b9 07       	cpc	r27, r25
    2d42:	31 f4       	brne	.+12     	; 0x2d50 <vTaskSwitchContext+0xa8>
    2d44:	12 96       	adiw	r26, 0x02	; 2
    2d46:	8d 91       	ld	r24, X+
    2d48:	9c 91       	ld	r25, X
    2d4a:	13 97       	sbiw	r26, 0x03	; 3
    2d4c:	92 83       	std	Z+2, r25	; 0x02
    2d4e:	81 83       	std	Z+1, r24	; 0x01
    2d50:	01 80       	ldd	r0, Z+1	; 0x01
    2d52:	f2 81       	ldd	r31, Z+2	; 0x02
    2d54:	e0 2d       	mov	r30, r0
    2d56:	86 81       	ldd	r24, Z+6	; 0x06
    2d58:	97 81       	ldd	r25, Z+7	; 0x07
    2d5a:	90 93 15 0e 	sts	0x0E15, r25
    2d5e:	80 93 14 0e 	sts	0x0E14, r24
    2d62:	08 95       	ret

00002d64 <twi_init>:
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    2d64:	10 92 83 0e 	sts	0x0E83, r1
    2d68:	81 e0       	ldi	r24, 0x01	; 1
    2d6a:	80 93 81 0e 	sts	0x0E81, r24
    2d6e:	10 92 80 0e 	sts	0x0E80, r1
    2d72:	61 e0       	ldi	r22, 0x01	; 1
    2d74:	84 e1       	ldi	r24, 0x14	; 20
    2d76:	0e 94 33 21 	call	0x4266	; 0x4266 <digitalWrite>
    2d7a:	61 e0       	ldi	r22, 0x01	; 1
    2d7c:	85 e1       	ldi	r24, 0x15	; 21
    2d7e:	0e 94 33 21 	call	0x4266	; 0x4266 <digitalWrite>
    2d82:	e9 eb       	ldi	r30, 0xB9	; 185
    2d84:	f0 e0       	ldi	r31, 0x00	; 0
    2d86:	80 81       	ld	r24, Z
    2d88:	8e 7f       	andi	r24, 0xFE	; 254
    2d8a:	80 83       	st	Z, r24
    2d8c:	80 81       	ld	r24, Z
    2d8e:	8d 7f       	andi	r24, 0xFD	; 253
    2d90:	80 83       	st	Z, r24
    2d92:	88 e4       	ldi	r24, 0x48	; 72
    2d94:	80 93 b8 00 	sts	0x00B8, r24
    2d98:	85 e4       	ldi	r24, 0x45	; 69
    2d9a:	80 93 bc 00 	sts	0x00BC, r24
    2d9e:	08 95       	ret

00002da0 <twi_readFrom>:
    2da0:	41 32       	cpi	r20, 0x21	; 33
    2da2:	08 f0       	brcs	.+2      	; 0x2da6 <twi_readFrom+0x6>
    2da4:	45 c0       	rjmp	.+138    	; 0x2e30 <twi_readFrom+0x90>
    2da6:	90 91 83 0e 	lds	r25, 0x0E83
    2daa:	91 11       	cpse	r25, r1
    2dac:	fc cf       	rjmp	.-8      	; 0x2da6 <twi_readFrom+0x6>
    2dae:	91 e0       	ldi	r25, 0x01	; 1
    2db0:	90 93 83 0e 	sts	0x0E83, r25
    2db4:	20 93 81 0e 	sts	0x0E81, r18
    2db8:	2f ef       	ldi	r18, 0xFF	; 255
    2dba:	20 93 16 0e 	sts	0x0E16, r18
    2dbe:	10 92 5b 0e 	sts	0x0E5B, r1
    2dc2:	24 0f       	add	r18, r20
    2dc4:	20 93 5a 0e 	sts	0x0E5A, r18
    2dc8:	90 93 82 0e 	sts	0x0E82, r25
    2dcc:	90 91 82 0e 	lds	r25, 0x0E82
    2dd0:	88 0f       	add	r24, r24
    2dd2:	89 2b       	or	r24, r25
    2dd4:	80 93 82 0e 	sts	0x0E82, r24
    2dd8:	80 91 80 0e 	lds	r24, 0x0E80
    2ddc:	81 30       	cpi	r24, 0x01	; 1
    2dde:	51 f4       	brne	.+20     	; 0x2df4 <twi_readFrom+0x54>
    2de0:	10 92 80 0e 	sts	0x0E80, r1
    2de4:	80 91 82 0e 	lds	r24, 0x0E82
    2de8:	80 93 bb 00 	sts	0x00BB, r24
    2dec:	85 ec       	ldi	r24, 0xC5	; 197
    2dee:	80 93 bc 00 	sts	0x00BC, r24
    2df2:	03 c0       	rjmp	.+6      	; 0x2dfa <twi_readFrom+0x5a>
    2df4:	85 ee       	ldi	r24, 0xE5	; 229
    2df6:	80 93 bc 00 	sts	0x00BC, r24
    2dfa:	80 91 83 0e 	lds	r24, 0x0E83
    2dfe:	81 30       	cpi	r24, 0x01	; 1
    2e00:	e1 f3       	breq	.-8      	; 0x2dfa <twi_readFrom+0x5a>
    2e02:	80 91 5b 0e 	lds	r24, 0x0E5B
    2e06:	84 17       	cp	r24, r20
    2e08:	10 f4       	brcc	.+4      	; 0x2e0e <twi_readFrom+0x6e>
    2e0a:	40 91 5b 0e 	lds	r20, 0x0E5B
    2e0e:	44 23       	and	r20, r20
    2e10:	89 f0       	breq	.+34     	; 0x2e34 <twi_readFrom+0x94>
    2e12:	ec e5       	ldi	r30, 0x5C	; 92
    2e14:	fe e0       	ldi	r31, 0x0E	; 14
    2e16:	a6 2f       	mov	r26, r22
    2e18:	b7 2f       	mov	r27, r23
    2e1a:	2f ef       	ldi	r18, 0xFF	; 255
    2e1c:	24 0f       	add	r18, r20
    2e1e:	30 e0       	ldi	r19, 0x00	; 0
    2e20:	23 5a       	subi	r18, 0xA3	; 163
    2e22:	31 4f       	sbci	r19, 0xF1	; 241
    2e24:	91 91       	ld	r25, Z+
    2e26:	9d 93       	st	X+, r25
    2e28:	e2 17       	cp	r30, r18
    2e2a:	f3 07       	cpc	r31, r19
    2e2c:	d9 f7       	brne	.-10     	; 0x2e24 <twi_readFrom+0x84>
    2e2e:	04 c0       	rjmp	.+8      	; 0x2e38 <twi_readFrom+0x98>
    2e30:	80 e0       	ldi	r24, 0x00	; 0
    2e32:	08 95       	ret
    2e34:	84 2f       	mov	r24, r20
    2e36:	08 95       	ret
    2e38:	84 2f       	mov	r24, r20
    2e3a:	08 95       	ret

00002e3c <twi_writeTo>:
    2e3c:	0f 93       	push	r16
    2e3e:	41 32       	cpi	r20, 0x21	; 33
    2e40:	08 f0       	brcs	.+2      	; 0x2e44 <twi_writeTo+0x8>
    2e42:	50 c0       	rjmp	.+160    	; 0x2ee4 <twi_writeTo+0xa8>
    2e44:	90 91 83 0e 	lds	r25, 0x0E83
    2e48:	91 11       	cpse	r25, r1
    2e4a:	fc cf       	rjmp	.-8      	; 0x2e44 <twi_writeTo+0x8>
    2e4c:	92 e0       	ldi	r25, 0x02	; 2
    2e4e:	90 93 83 0e 	sts	0x0E83, r25
    2e52:	00 93 81 0e 	sts	0x0E81, r16
    2e56:	9f ef       	ldi	r25, 0xFF	; 255
    2e58:	90 93 16 0e 	sts	0x0E16, r25
    2e5c:	10 92 5b 0e 	sts	0x0E5B, r1
    2e60:	40 93 5a 0e 	sts	0x0E5A, r20
    2e64:	44 23       	and	r20, r20
    2e66:	69 f0       	breq	.+26     	; 0x2e82 <twi_writeTo+0x46>
    2e68:	fb 01       	movw	r30, r22
    2e6a:	ac e5       	ldi	r26, 0x5C	; 92
    2e6c:	be e0       	ldi	r27, 0x0E	; 14
    2e6e:	6f 5f       	subi	r22, 0xFF	; 255
    2e70:	7f 4f       	sbci	r23, 0xFF	; 255
    2e72:	41 50       	subi	r20, 0x01	; 1
    2e74:	64 0f       	add	r22, r20
    2e76:	71 1d       	adc	r23, r1
    2e78:	91 91       	ld	r25, Z+
    2e7a:	9d 93       	st	X+, r25
    2e7c:	e6 17       	cp	r30, r22
    2e7e:	f7 07       	cpc	r31, r23
    2e80:	d9 f7       	brne	.-10     	; 0x2e78 <twi_writeTo+0x3c>
    2e82:	10 92 82 0e 	sts	0x0E82, r1
    2e86:	90 91 82 0e 	lds	r25, 0x0E82
    2e8a:	88 0f       	add	r24, r24
    2e8c:	89 2b       	or	r24, r25
    2e8e:	80 93 82 0e 	sts	0x0E82, r24
    2e92:	80 91 80 0e 	lds	r24, 0x0E80
    2e96:	81 30       	cpi	r24, 0x01	; 1
    2e98:	51 f4       	brne	.+20     	; 0x2eae <twi_writeTo+0x72>
    2e9a:	10 92 80 0e 	sts	0x0E80, r1
    2e9e:	80 91 82 0e 	lds	r24, 0x0E82
    2ea2:	80 93 bb 00 	sts	0x00BB, r24
    2ea6:	85 ec       	ldi	r24, 0xC5	; 197
    2ea8:	80 93 bc 00 	sts	0x00BC, r24
    2eac:	03 c0       	rjmp	.+6      	; 0x2eb4 <twi_writeTo+0x78>
    2eae:	85 ee       	ldi	r24, 0xE5	; 229
    2eb0:	80 93 bc 00 	sts	0x00BC, r24
    2eb4:	22 23       	and	r18, r18
    2eb6:	41 f0       	breq	.+16     	; 0x2ec8 <twi_writeTo+0x8c>
    2eb8:	80 91 83 0e 	lds	r24, 0x0E83
    2ebc:	82 30       	cpi	r24, 0x02	; 2
    2ebe:	21 f4       	brne	.+8      	; 0x2ec8 <twi_writeTo+0x8c>
    2ec0:	80 91 83 0e 	lds	r24, 0x0E83
    2ec4:	82 30       	cpi	r24, 0x02	; 2
    2ec6:	e1 f3       	breq	.-8      	; 0x2ec0 <twi_writeTo+0x84>
    2ec8:	80 91 16 0e 	lds	r24, 0x0E16
    2ecc:	8f 3f       	cpi	r24, 0xFF	; 255
    2ece:	61 f0       	breq	.+24     	; 0x2ee8 <twi_writeTo+0xac>
    2ed0:	80 91 16 0e 	lds	r24, 0x0E16
    2ed4:	80 32       	cpi	r24, 0x20	; 32
    2ed6:	51 f0       	breq	.+20     	; 0x2eec <twi_writeTo+0xb0>
    2ed8:	80 91 16 0e 	lds	r24, 0x0E16
    2edc:	80 33       	cpi	r24, 0x30	; 48
    2ede:	41 f4       	brne	.+16     	; 0x2ef0 <twi_writeTo+0xb4>
    2ee0:	83 e0       	ldi	r24, 0x03	; 3
    2ee2:	07 c0       	rjmp	.+14     	; 0x2ef2 <twi_writeTo+0xb6>
    2ee4:	81 e0       	ldi	r24, 0x01	; 1
    2ee6:	05 c0       	rjmp	.+10     	; 0x2ef2 <twi_writeTo+0xb6>
    2ee8:	80 e0       	ldi	r24, 0x00	; 0
    2eea:	03 c0       	rjmp	.+6      	; 0x2ef2 <twi_writeTo+0xb6>
    2eec:	82 e0       	ldi	r24, 0x02	; 2
    2eee:	01 c0       	rjmp	.+2      	; 0x2ef2 <twi_writeTo+0xb6>
    2ef0:	84 e0       	ldi	r24, 0x04	; 4
    2ef2:	0f 91       	pop	r16
    2ef4:	08 95       	ret

00002ef6 <twi_transmit>:
    2ef6:	61 32       	cpi	r22, 0x21	; 33
    2ef8:	a8 f4       	brcc	.+42     	; 0x2f24 <twi_transmit+0x2e>
    2efa:	20 91 83 0e 	lds	r18, 0x0E83
    2efe:	24 30       	cpi	r18, 0x04	; 4
    2f00:	99 f4       	brne	.+38     	; 0x2f28 <twi_transmit+0x32>
    2f02:	60 93 38 0e 	sts	0x0E38, r22
    2f06:	66 23       	and	r22, r22
    2f08:	89 f0       	breq	.+34     	; 0x2f2c <twi_transmit+0x36>
    2f0a:	fc 01       	movw	r30, r24
    2f0c:	aa e3       	ldi	r26, 0x3A	; 58
    2f0e:	be e0       	ldi	r27, 0x0E	; 14
    2f10:	01 96       	adiw	r24, 0x01	; 1
    2f12:	61 50       	subi	r22, 0x01	; 1
    2f14:	86 0f       	add	r24, r22
    2f16:	91 1d       	adc	r25, r1
    2f18:	21 91       	ld	r18, Z+
    2f1a:	2d 93       	st	X+, r18
    2f1c:	e8 17       	cp	r30, r24
    2f1e:	f9 07       	cpc	r31, r25
    2f20:	d9 f7       	brne	.-10     	; 0x2f18 <twi_transmit+0x22>
    2f22:	06 c0       	rjmp	.+12     	; 0x2f30 <twi_transmit+0x3a>
    2f24:	81 e0       	ldi	r24, 0x01	; 1
    2f26:	08 95       	ret
    2f28:	82 e0       	ldi	r24, 0x02	; 2
    2f2a:	08 95       	ret
    2f2c:	80 e0       	ldi	r24, 0x00	; 0
    2f2e:	08 95       	ret
    2f30:	80 e0       	ldi	r24, 0x00	; 0
    2f32:	08 95       	ret

00002f34 <twi_stop>:
 * Output   none
 */
void twi_stop(void)
{
  // send stop condition
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);
    2f34:	85 ed       	ldi	r24, 0xD5	; 213
    2f36:	80 93 bc 00 	sts	0x00BC, r24

  // wait for stop condition to be exectued on bus
  // TWINT is not set after a stop condition!
  while(TWCR & _BV(TWSTO)){
    2f3a:	ec eb       	ldi	r30, 0xBC	; 188
    2f3c:	f0 e0       	ldi	r31, 0x00	; 0
    2f3e:	80 81       	ld	r24, Z
    2f40:	84 fd       	sbrc	r24, 4
    2f42:	fd cf       	rjmp	.-6      	; 0x2f3e <twi_stop+0xa>
    continue;
  }

  // update twi state
  twi_state = TWI_READY;
    2f44:	10 92 83 0e 	sts	0x0E83, r1
    2f48:	08 95       	ret

00002f4a <twi_releaseBus>:
 * Output   none
 */
void twi_releaseBus(void)
{
  // release bus
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);
    2f4a:	85 ec       	ldi	r24, 0xC5	; 197
    2f4c:	80 93 bc 00 	sts	0x00BC, r24

  // update twi state
  twi_state = TWI_READY;
    2f50:	10 92 83 0e 	sts	0x0E83, r1
    2f54:	08 95       	ret

00002f56 <__vector_39>:
}

ISR(TWI_vect)
{
    2f56:	1f 92       	push	r1
    2f58:	0f 92       	push	r0
    2f5a:	0f b6       	in	r0, 0x3f	; 63
    2f5c:	0f 92       	push	r0
    2f5e:	11 24       	eor	r1, r1
    2f60:	0b b6       	in	r0, 0x3b	; 59
    2f62:	0f 92       	push	r0
    2f64:	2f 93       	push	r18
    2f66:	3f 93       	push	r19
    2f68:	4f 93       	push	r20
    2f6a:	5f 93       	push	r21
    2f6c:	6f 93       	push	r22
    2f6e:	7f 93       	push	r23
    2f70:	8f 93       	push	r24
    2f72:	9f 93       	push	r25
    2f74:	af 93       	push	r26
    2f76:	bf 93       	push	r27
    2f78:	ef 93       	push	r30
    2f7a:	ff 93       	push	r31
  switch(TW_STATUS){
    2f7c:	80 91 b9 00 	lds	r24, 0x00B9
    2f80:	88 7f       	andi	r24, 0xF8	; 248
    2f82:	90 e0       	ldi	r25, 0x00	; 0
    2f84:	89 3c       	cpi	r24, 0xC9	; 201
    2f86:	91 05       	cpc	r25, r1
    2f88:	08 f0       	brcs	.+2      	; 0x2f8c <__vector_39+0x36>
    2f8a:	ee c0       	rjmp	.+476    	; 0x3168 <__vector_39+0x212>
    2f8c:	fc 01       	movw	r30, r24
    2f8e:	ee 58       	subi	r30, 0x8E	; 142
    2f90:	ff 4f       	sbci	r31, 0xFF	; 255
    2f92:	0c 94 7e 22 	jmp	0x44fc	; 0x44fc <__tablejump2__>
    // All Master
    case TW_START:     // sent start condition
    case TW_REP_START: // sent repeated start condition
      // copy device address and r/w bit to output register and ack
      TWDR = twi_slarw;
    2f96:	80 91 82 0e 	lds	r24, 0x0E82
    2f9a:	80 93 bb 00 	sts	0x00BB, r24
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    2f9e:	85 ec       	ldi	r24, 0xC5	; 197
    2fa0:	80 93 bc 00 	sts	0x00BC, r24
    2fa4:	e1 c0       	rjmp	.+450    	; 0x3168 <__vector_39+0x212>

    // Master Transmitter
    case TW_MT_SLA_ACK:  // slave receiver acked address
    case TW_MT_DATA_ACK: // slave receiver acked data
      // if there is data to send, send it, otherwise stop 
      if(twi_masterBufferIndex < twi_masterBufferLength){
    2fa6:	90 91 5b 0e 	lds	r25, 0x0E5B
    2faa:	80 91 5a 0e 	lds	r24, 0x0E5A
    2fae:	98 17       	cp	r25, r24
    2fb0:	80 f4       	brcc	.+32     	; 0x2fd2 <__vector_39+0x7c>
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
    2fb2:	e0 91 5b 0e 	lds	r30, 0x0E5B
    2fb6:	81 e0       	ldi	r24, 0x01	; 1
    2fb8:	8e 0f       	add	r24, r30
    2fba:	80 93 5b 0e 	sts	0x0E5B, r24
    2fbe:	f0 e0       	ldi	r31, 0x00	; 0
    2fc0:	e4 5a       	subi	r30, 0xA4	; 164
    2fc2:	f1 4f       	sbci	r31, 0xF1	; 241
    2fc4:	80 81       	ld	r24, Z
    2fc6:	80 93 bb 00 	sts	0x00BB, r24
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    2fca:	85 ec       	ldi	r24, 0xC5	; 197
    2fcc:	80 93 bc 00 	sts	0x00BC, r24
    2fd0:	cb c0       	rjmp	.+406    	; 0x3168 <__vector_39+0x212>
      if(twi_masterBufferIndex < twi_masterBufferLength){
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
        twi_reply(1);
      }else{
	if (twi_sendStop)
    2fd2:	80 91 81 0e 	lds	r24, 0x0E81
    2fd6:	88 23       	and	r24, r24
    2fd8:	11 f0       	breq	.+4      	; 0x2fde <__vector_39+0x88>
          twi_stop();
    2fda:	ac df       	rcall	.-168    	; 0x2f34 <twi_stop>
    2fdc:	c5 c0       	rjmp	.+394    	; 0x3168 <__vector_39+0x212>
	else {
	  twi_inRepStart = true;	// we're gonna send the START
    2fde:	81 e0       	ldi	r24, 0x01	; 1
    2fe0:	80 93 80 0e 	sts	0x0E80, r24
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
    2fe4:	84 ea       	ldi	r24, 0xA4	; 164
    2fe6:	80 93 bc 00 	sts	0x00BC, r24
	  twi_state = TWI_READY;
    2fea:	10 92 83 0e 	sts	0x0E83, r1
    2fee:	bc c0       	rjmp	.+376    	; 0x3168 <__vector_39+0x212>
	}
      }
      break;
    case TW_MT_SLA_NACK:  // address sent, nack received
      twi_error = TW_MT_SLA_NACK;
    2ff0:	80 e2       	ldi	r24, 0x20	; 32
    2ff2:	80 93 16 0e 	sts	0x0E16, r24
      twi_stop();
    2ff6:	9e df       	rcall	.-196    	; 0x2f34 <twi_stop>
      break;
    2ff8:	b7 c0       	rjmp	.+366    	; 0x3168 <__vector_39+0x212>
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
    2ffa:	80 e3       	ldi	r24, 0x30	; 48
    2ffc:	80 93 16 0e 	sts	0x0E16, r24
      twi_stop();
    3000:	99 df       	rcall	.-206    	; 0x2f34 <twi_stop>
      break;
    3002:	b2 c0       	rjmp	.+356    	; 0x3168 <__vector_39+0x212>
    case TW_MT_ARB_LOST: // lost bus arbitration
      twi_error = TW_MT_ARB_LOST;
    3004:	88 e3       	ldi	r24, 0x38	; 56
    3006:	80 93 16 0e 	sts	0x0E16, r24
      twi_releaseBus();
    300a:	9f df       	rcall	.-194    	; 0x2f4a <twi_releaseBus>
      break;
    300c:	ad c0       	rjmp	.+346    	; 0x3168 <__vector_39+0x212>

    // Master Receiver
    case TW_MR_DATA_ACK: // data received, ack sent
      // put byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
    300e:	e0 91 5b 0e 	lds	r30, 0x0E5B
    3012:	81 e0       	ldi	r24, 0x01	; 1
    3014:	8e 0f       	add	r24, r30
    3016:	80 93 5b 0e 	sts	0x0E5B, r24
    301a:	80 91 bb 00 	lds	r24, 0x00BB
    301e:	f0 e0       	ldi	r31, 0x00	; 0
    3020:	e4 5a       	subi	r30, 0xA4	; 164
    3022:	f1 4f       	sbci	r31, 0xF1	; 241
    3024:	80 83       	st	Z, r24
    case TW_MR_SLA_ACK:  // address sent, ack received
      // ack if more bytes are expected, otherwise nack
      if(twi_masterBufferIndex < twi_masterBufferLength){
    3026:	90 91 5b 0e 	lds	r25, 0x0E5B
    302a:	80 91 5a 0e 	lds	r24, 0x0E5A
    302e:	98 17       	cp	r25, r24
    3030:	20 f4       	brcc	.+8      	; 0x303a <__vector_39+0xe4>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    3032:	85 ec       	ldi	r24, 0xC5	; 197
    3034:	80 93 bc 00 	sts	0x00BC, r24
    3038:	97 c0       	rjmp	.+302    	; 0x3168 <__vector_39+0x212>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    303a:	85 e8       	ldi	r24, 0x85	; 133
    303c:	80 93 bc 00 	sts	0x00BC, r24
    3040:	93 c0       	rjmp	.+294    	; 0x3168 <__vector_39+0x212>
        twi_reply(0);
      }
      break;
    case TW_MR_DATA_NACK: // data received, nack sent
      // put final byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
    3042:	e0 91 5b 0e 	lds	r30, 0x0E5B
    3046:	81 e0       	ldi	r24, 0x01	; 1
    3048:	8e 0f       	add	r24, r30
    304a:	80 93 5b 0e 	sts	0x0E5B, r24
    304e:	80 91 bb 00 	lds	r24, 0x00BB
    3052:	f0 e0       	ldi	r31, 0x00	; 0
    3054:	e4 5a       	subi	r30, 0xA4	; 164
    3056:	f1 4f       	sbci	r31, 0xF1	; 241
    3058:	80 83       	st	Z, r24
	if (twi_sendStop)
    305a:	80 91 81 0e 	lds	r24, 0x0E81
    305e:	88 23       	and	r24, r24
    3060:	11 f0       	breq	.+4      	; 0x3066 <__vector_39+0x110>
          twi_stop();
    3062:	68 df       	rcall	.-304    	; 0x2f34 <twi_stop>
    3064:	81 c0       	rjmp	.+258    	; 0x3168 <__vector_39+0x212>
	else {
	  twi_inRepStart = true;	// we're gonna send the START
    3066:	81 e0       	ldi	r24, 0x01	; 1
    3068:	80 93 80 0e 	sts	0x0E80, r24
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
    306c:	84 ea       	ldi	r24, 0xA4	; 164
    306e:	80 93 bc 00 	sts	0x00BC, r24
	  twi_state = TWI_READY;
    3072:	10 92 83 0e 	sts	0x0E83, r1
    3076:	78 c0       	rjmp	.+240    	; 0x3168 <__vector_39+0x212>
	}    
	break;
    case TW_MR_SLA_NACK: // address sent, nack received
      twi_stop();
    3078:	5d df       	rcall	.-326    	; 0x2f34 <twi_stop>
      break;
    307a:	76 c0       	rjmp	.+236    	; 0x3168 <__vector_39+0x212>
    case TW_SR_SLA_ACK:   // addressed, returned ack
    case TW_SR_GCALL_ACK: // addressed generally, returned ack
    case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack
    case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack
      // enter slave receiver mode
      twi_state = TWI_SRX;
    307c:	83 e0       	ldi	r24, 0x03	; 3
    307e:	80 93 83 0e 	sts	0x0E83, r24
      // indicate that rx buffer can be overwritten and ack
      twi_rxBufferIndex = 0;
    3082:	10 92 17 0e 	sts	0x0E17, r1
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    3086:	85 ec       	ldi	r24, 0xC5	; 197
    3088:	80 93 bc 00 	sts	0x00BC, r24
    308c:	6d c0       	rjmp	.+218    	; 0x3168 <__vector_39+0x212>
      twi_reply(1);
      break;
    case TW_SR_DATA_ACK:       // data received, returned ack
    case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack
      // if there is still room in the rx buffer
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
    308e:	80 91 17 0e 	lds	r24, 0x0E17
    3092:	80 32       	cpi	r24, 0x20	; 32
    3094:	80 f4       	brcc	.+32     	; 0x30b6 <__vector_39+0x160>
        // put byte in buffer and ack
        twi_rxBuffer[twi_rxBufferIndex++] = TWDR;
    3096:	e0 91 17 0e 	lds	r30, 0x0E17
    309a:	81 e0       	ldi	r24, 0x01	; 1
    309c:	8e 0f       	add	r24, r30
    309e:	80 93 17 0e 	sts	0x0E17, r24
    30a2:	80 91 bb 00 	lds	r24, 0x00BB
    30a6:	f0 e0       	ldi	r31, 0x00	; 0
    30a8:	e8 5e       	subi	r30, 0xE8	; 232
    30aa:	f1 4f       	sbci	r31, 0xF1	; 241
    30ac:	80 83       	st	Z, r24
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    30ae:	85 ec       	ldi	r24, 0xC5	; 197
    30b0:	80 93 bc 00 	sts	0x00BC, r24
    30b4:	59 c0       	rjmp	.+178    	; 0x3168 <__vector_39+0x212>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    30b6:	85 e8       	ldi	r24, 0x85	; 133
    30b8:	80 93 bc 00 	sts	0x00BC, r24
    30bc:	55 c0       	rjmp	.+170    	; 0x3168 <__vector_39+0x212>
        twi_reply(0);
      }
      break;
    case TW_SR_STOP: // stop or repeated start condition received
      // put a null char after data if there's room
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
    30be:	80 91 17 0e 	lds	r24, 0x0E17
    30c2:	80 32       	cpi	r24, 0x20	; 32
    30c4:	30 f4       	brcc	.+12     	; 0x30d2 <__vector_39+0x17c>
        twi_rxBuffer[twi_rxBufferIndex] = '\0';
    30c6:	e0 91 17 0e 	lds	r30, 0x0E17
    30ca:	f0 e0       	ldi	r31, 0x00	; 0
    30cc:	e8 5e       	subi	r30, 0xE8	; 232
    30ce:	f1 4f       	sbci	r31, 0xF1	; 241
    30d0:	10 82       	st	Z, r1
      }
      // sends ack and stops interface for clock stretching
      twi_stop();
    30d2:	30 df       	rcall	.-416    	; 0x2f34 <twi_stop>
      // callback to user defined callback
      twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);
    30d4:	60 91 17 0e 	lds	r22, 0x0E17
    30d8:	70 e0       	ldi	r23, 0x00	; 0
    30da:	e0 91 7c 0e 	lds	r30, 0x0E7C
    30de:	f0 91 7d 0e 	lds	r31, 0x0E7D
    30e2:	88 e1       	ldi	r24, 0x18	; 24
    30e4:	9e e0       	ldi	r25, 0x0E	; 14
    30e6:	19 95       	eicall
      // since we submit rx buffer to "wire" library, we can reset it
      twi_rxBufferIndex = 0;
    30e8:	10 92 17 0e 	sts	0x0E17, r1
      // ack future responses and leave slave receiver state
      twi_releaseBus();
    30ec:	2e df       	rcall	.-420    	; 0x2f4a <twi_releaseBus>
      break;
    30ee:	3c c0       	rjmp	.+120    	; 0x3168 <__vector_39+0x212>
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    30f0:	85 e8       	ldi	r24, 0x85	; 133
    30f2:	80 93 bc 00 	sts	0x00BC, r24
    30f6:	38 c0       	rjmp	.+112    	; 0x3168 <__vector_39+0x212>
    
    // Slave Transmitter
    case TW_ST_SLA_ACK:          // addressed, returned ack
    case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack
      // enter slave transmitter mode
      twi_state = TWI_STX;
    30f8:	84 e0       	ldi	r24, 0x04	; 4
    30fa:	80 93 83 0e 	sts	0x0E83, r24
      // ready the tx buffer index for iteration
      twi_txBufferIndex = 0;
    30fe:	10 92 39 0e 	sts	0x0E39, r1
      // set tx buffer length to be zero, to verify if user changes it
      twi_txBufferLength = 0;
    3102:	10 92 38 0e 	sts	0x0E38, r1
      // request for txBuffer to be filled and length to be set
      // note: user must call twi_transmit(bytes, length) to do this
      twi_onSlaveTransmit();
    3106:	e0 91 7e 0e 	lds	r30, 0x0E7E
    310a:	f0 91 7f 0e 	lds	r31, 0x0E7F
    310e:	19 95       	eicall
      // if they didn't change buffer & length, initialize it
      if(0 == twi_txBufferLength){
    3110:	80 91 38 0e 	lds	r24, 0x0E38
    3114:	81 11       	cpse	r24, r1
    3116:	05 c0       	rjmp	.+10     	; 0x3122 <__vector_39+0x1cc>
        twi_txBufferLength = 1;
    3118:	81 e0       	ldi	r24, 0x01	; 1
    311a:	80 93 38 0e 	sts	0x0E38, r24
        twi_txBuffer[0] = 0x00;
    311e:	10 92 3a 0e 	sts	0x0E3A, r1
      }
      // transmit first byte from buffer, fall
    case TW_ST_DATA_ACK: // byte sent, ack returned
      // copy data to output register
      TWDR = twi_txBuffer[twi_txBufferIndex++];
    3122:	e0 91 39 0e 	lds	r30, 0x0E39
    3126:	81 e0       	ldi	r24, 0x01	; 1
    3128:	8e 0f       	add	r24, r30
    312a:	80 93 39 0e 	sts	0x0E39, r24
    312e:	f0 e0       	ldi	r31, 0x00	; 0
    3130:	e6 5c       	subi	r30, 0xC6	; 198
    3132:	f1 4f       	sbci	r31, 0xF1	; 241
    3134:	80 81       	ld	r24, Z
    3136:	80 93 bb 00 	sts	0x00BB, r24
      // if there is more to send, ack, otherwise nack
      if(twi_txBufferIndex < twi_txBufferLength){
    313a:	90 91 39 0e 	lds	r25, 0x0E39
    313e:	80 91 38 0e 	lds	r24, 0x0E38
    3142:	98 17       	cp	r25, r24
    3144:	20 f4       	brcc	.+8      	; 0x314e <__vector_39+0x1f8>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    3146:	85 ec       	ldi	r24, 0xC5	; 197
    3148:	80 93 bc 00 	sts	0x00BC, r24
    314c:	0d c0       	rjmp	.+26     	; 0x3168 <__vector_39+0x212>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    314e:	85 e8       	ldi	r24, 0x85	; 133
    3150:	80 93 bc 00 	sts	0x00BC, r24
    3154:	09 c0       	rjmp	.+18     	; 0x3168 <__vector_39+0x212>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    3156:	85 ec       	ldi	r24, 0xC5	; 197
    3158:	80 93 bc 00 	sts	0x00BC, r24
    case TW_ST_DATA_NACK: // received nack, we are done 
    case TW_ST_LAST_DATA: // received ack, but we are done already!
      // ack future responses
      twi_reply(1);
      // leave slave receiver state
      twi_state = TWI_READY;
    315c:	10 92 83 0e 	sts	0x0E83, r1
      break;
    3160:	03 c0       	rjmp	.+6      	; 0x3168 <__vector_39+0x212>

    // All
    case TW_NO_INFO:   // no state information
      break;
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
    3162:	10 92 16 0e 	sts	0x0E16, r1
      twi_stop();
    3166:	e6 de       	rcall	.-564    	; 0x2f34 <twi_stop>
      break;
  }
}
    3168:	ff 91       	pop	r31
    316a:	ef 91       	pop	r30
    316c:	bf 91       	pop	r27
    316e:	af 91       	pop	r26
    3170:	9f 91       	pop	r25
    3172:	8f 91       	pop	r24
    3174:	7f 91       	pop	r23
    3176:	6f 91       	pop	r22
    3178:	5f 91       	pop	r21
    317a:	4f 91       	pop	r20
    317c:	3f 91       	pop	r19
    317e:	2f 91       	pop	r18
    3180:	0f 90       	pop	r0
    3182:	0b be       	out	0x3b, r0	; 59
    3184:	0f 90       	pop	r0
    3186:	0f be       	out	0x3f, r0	; 63
    3188:	0f 90       	pop	r0
    318a:	1f 90       	pop	r1
    318c:	18 95       	reti

0000318e <_ZN7TwoWire9availableEv>:
}

// sets function called on slave read
void TwoWire::onRequest( void (*function)(void) )
{
  user_onRequest = function;
    318e:	80 91 b4 0e 	lds	r24, 0x0EB4
    3192:	90 e0       	ldi	r25, 0x00	; 0
    3194:	20 91 b5 0e 	lds	r18, 0x0EB5
    3198:	82 1b       	sub	r24, r18
    319a:	91 09       	sbc	r25, r1
    319c:	08 95       	ret

0000319e <_ZN7TwoWire4readEv>:
    319e:	20 91 b5 0e 	lds	r18, 0x0EB5
    31a2:	80 91 b4 0e 	lds	r24, 0x0EB4
    31a6:	28 17       	cp	r18, r24
    31a8:	50 f4       	brcc	.+20     	; 0x31be <_ZN7TwoWire4readEv+0x20>
    31aa:	e2 2f       	mov	r30, r18
    31ac:	f0 e0       	ldi	r31, 0x00	; 0
    31ae:	ea 54       	subi	r30, 0x4A	; 74
    31b0:	f1 4f       	sbci	r31, 0xF1	; 241
    31b2:	80 81       	ld	r24, Z
    31b4:	90 e0       	ldi	r25, 0x00	; 0
    31b6:	2f 5f       	subi	r18, 0xFF	; 255
    31b8:	20 93 b5 0e 	sts	0x0EB5, r18
    31bc:	08 95       	ret
    31be:	8f ef       	ldi	r24, 0xFF	; 255
    31c0:	9f ef       	ldi	r25, 0xFF	; 255
    31c2:	08 95       	ret

000031c4 <_ZN7TwoWire4peekEv>:
    31c4:	e0 91 b5 0e 	lds	r30, 0x0EB5
    31c8:	80 91 b4 0e 	lds	r24, 0x0EB4
    31cc:	e8 17       	cp	r30, r24
    31ce:	30 f4       	brcc	.+12     	; 0x31dc <_ZN7TwoWire4peekEv+0x18>
    31d0:	f0 e0       	ldi	r31, 0x00	; 0
    31d2:	ea 54       	subi	r30, 0x4A	; 74
    31d4:	f1 4f       	sbci	r31, 0xF1	; 241
    31d6:	80 81       	ld	r24, Z
    31d8:	90 e0       	ldi	r25, 0x00	; 0
    31da:	08 95       	ret
    31dc:	8f ef       	ldi	r24, 0xFF	; 255
    31de:	9f ef       	ldi	r25, 0xFF	; 255
    31e0:	08 95       	ret

000031e2 <_ZN7TwoWire5flushEv>:
    31e2:	08 95       	ret

000031e4 <_ZN7TwoWire5writeEPKhj>:
    31e4:	cf 92       	push	r12
    31e6:	df 92       	push	r13
    31e8:	ef 92       	push	r14
    31ea:	ff 92       	push	r15
    31ec:	0f 93       	push	r16
    31ee:	1f 93       	push	r17
    31f0:	cf 93       	push	r28
    31f2:	df 93       	push	r29
    31f4:	8c 01       	movw	r16, r24
    31f6:	7b 01       	movw	r14, r22
    31f8:	6a 01       	movw	r12, r20
    31fa:	80 91 90 0e 	lds	r24, 0x0E90
    31fe:	88 23       	and	r24, r24
    3200:	99 f0       	breq	.+38     	; 0x3228 <_ZN7TwoWire5writeEPKhj+0x44>
    3202:	41 15       	cp	r20, r1
    3204:	51 05       	cpc	r21, r1
    3206:	99 f0       	breq	.+38     	; 0x322e <_ZN7TwoWire5writeEPKhj+0x4a>
    3208:	eb 01       	movw	r28, r22
    320a:	e4 0e       	add	r14, r20
    320c:	f5 1e       	adc	r15, r21
    320e:	69 91       	ld	r22, Y+
    3210:	d8 01       	movw	r26, r16
    3212:	ed 91       	ld	r30, X+
    3214:	fc 91       	ld	r31, X
    3216:	01 90       	ld	r0, Z+
    3218:	f0 81       	ld	r31, Z
    321a:	e0 2d       	mov	r30, r0
    321c:	c8 01       	movw	r24, r16
    321e:	19 95       	eicall
    3220:	ce 15       	cp	r28, r14
    3222:	df 05       	cpc	r29, r15
    3224:	a1 f7       	brne	.-24     	; 0x320e <_ZN7TwoWire5writeEPKhj+0x2a>
    3226:	03 c0       	rjmp	.+6      	; 0x322e <_ZN7TwoWire5writeEPKhj+0x4a>
    3228:	64 2f       	mov	r22, r20
    322a:	c7 01       	movw	r24, r14
    322c:	64 de       	rcall	.-824    	; 0x2ef6 <twi_transmit>
    322e:	c6 01       	movw	r24, r12
    3230:	df 91       	pop	r29
    3232:	cf 91       	pop	r28
    3234:	1f 91       	pop	r17
    3236:	0f 91       	pop	r16
    3238:	ff 90       	pop	r15
    323a:	ef 90       	pop	r14
    323c:	df 90       	pop	r13
    323e:	cf 90       	pop	r12
    3240:	08 95       	ret

00003242 <_ZN7TwoWire5writeEh>:
    3242:	cf 93       	push	r28
    3244:	df 93       	push	r29
    3246:	1f 92       	push	r1
    3248:	cd b7       	in	r28, 0x3d	; 61
    324a:	de b7       	in	r29, 0x3e	; 62
    324c:	69 83       	std	Y+1, r22	; 0x01
    324e:	20 91 90 0e 	lds	r18, 0x0E90
    3252:	22 23       	and	r18, r18
    3254:	e1 f0       	breq	.+56     	; 0x328e <_ZN7TwoWire5writeEh+0x4c>
    3256:	20 91 91 0e 	lds	r18, 0x0E91
    325a:	20 32       	cpi	r18, 0x20	; 32
    325c:	40 f0       	brcs	.+16     	; 0x326e <_ZN7TwoWire5writeEh+0x2c>
    325e:	21 e0       	ldi	r18, 0x01	; 1
    3260:	30 e0       	ldi	r19, 0x00	; 0
    3262:	fc 01       	movw	r30, r24
    3264:	33 83       	std	Z+3, r19	; 0x03
    3266:	22 83       	std	Z+2, r18	; 0x02
    3268:	80 e0       	ldi	r24, 0x00	; 0
    326a:	90 e0       	ldi	r25, 0x00	; 0
    326c:	16 c0       	rjmp	.+44     	; 0x329a <_ZN7TwoWire5writeEh+0x58>
    326e:	80 91 92 0e 	lds	r24, 0x0E92
    3272:	e8 2f       	mov	r30, r24
    3274:	f0 e0       	ldi	r31, 0x00	; 0
    3276:	ed 56       	subi	r30, 0x6D	; 109
    3278:	f1 4f       	sbci	r31, 0xF1	; 241
    327a:	99 81       	ldd	r25, Y+1	; 0x01
    327c:	90 83       	st	Z, r25
    327e:	8f 5f       	subi	r24, 0xFF	; 255
    3280:	80 93 92 0e 	sts	0x0E92, r24
    3284:	80 93 91 0e 	sts	0x0E91, r24
    3288:	81 e0       	ldi	r24, 0x01	; 1
    328a:	90 e0       	ldi	r25, 0x00	; 0
    328c:	06 c0       	rjmp	.+12     	; 0x329a <_ZN7TwoWire5writeEh+0x58>
    328e:	61 e0       	ldi	r22, 0x01	; 1
    3290:	ce 01       	movw	r24, r28
    3292:	01 96       	adiw	r24, 0x01	; 1
    3294:	30 de       	rcall	.-928    	; 0x2ef6 <twi_transmit>
    3296:	81 e0       	ldi	r24, 0x01	; 1
    3298:	90 e0       	ldi	r25, 0x00	; 0
    329a:	0f 90       	pop	r0
    329c:	df 91       	pop	r29
    329e:	cf 91       	pop	r28
    32a0:	08 95       	ret

000032a2 <_ZN7TwoWireC1Ev>:
    32a2:	fc 01       	movw	r30, r24
    32a4:	13 82       	std	Z+3, r1	; 0x03
    32a6:	12 82       	std	Z+2, r1	; 0x02
    32a8:	48 ee       	ldi	r20, 0xE8	; 232
    32aa:	53 e0       	ldi	r21, 0x03	; 3
    32ac:	60 e0       	ldi	r22, 0x00	; 0
    32ae:	70 e0       	ldi	r23, 0x00	; 0
    32b0:	44 83       	std	Z+4, r20	; 0x04
    32b2:	55 83       	std	Z+5, r21	; 0x05
    32b4:	66 83       	std	Z+6, r22	; 0x06
    32b6:	77 83       	std	Z+7, r23	; 0x07
    32b8:	8c ef       	ldi	r24, 0xFC	; 252
    32ba:	92 e0       	ldi	r25, 0x02	; 2
    32bc:	91 83       	std	Z+1, r25	; 0x01
    32be:	80 83       	st	Z, r24
    32c0:	08 95       	ret

000032c2 <_ZN7TwoWire5beginEv>:
    32c2:	10 92 b5 0e 	sts	0x0EB5, r1
    32c6:	10 92 b4 0e 	sts	0x0EB4, r1
    32ca:	10 92 92 0e 	sts	0x0E92, r1
    32ce:	10 92 91 0e 	sts	0x0E91, r1
    32d2:	48 cd       	rjmp	.-1392   	; 0x2d64 <twi_init>
    32d4:	08 95       	ret

000032d6 <_ZN7TwoWire11requestFromEhhh>:
    32d6:	86 2f       	mov	r24, r22
    32d8:	41 32       	cpi	r20, 0x21	; 33
    32da:	08 f0       	brcs	.+2      	; 0x32de <_ZN7TwoWire11requestFromEhhh+0x8>
    32dc:	40 e2       	ldi	r20, 0x20	; 32
    32de:	66 eb       	ldi	r22, 0xB6	; 182
    32e0:	7e e0       	ldi	r23, 0x0E	; 14
    32e2:	5e dd       	rcall	.-1348   	; 0x2da0 <twi_readFrom>
    32e4:	10 92 b5 0e 	sts	0x0EB5, r1
    32e8:	80 93 b4 0e 	sts	0x0EB4, r24
    32ec:	08 95       	ret

000032ee <_ZN7TwoWire11requestFromEhh>:
    32ee:	21 e0       	ldi	r18, 0x01	; 1
    32f0:	f2 cf       	rjmp	.-28     	; 0x32d6 <_ZN7TwoWire11requestFromEhhh>
    32f2:	08 95       	ret

000032f4 <_ZN7TwoWire17beginTransmissionEh>:
    32f4:	81 e0       	ldi	r24, 0x01	; 1
    32f6:	80 93 90 0e 	sts	0x0E90, r24
    32fa:	60 93 b3 0e 	sts	0x0EB3, r22
    32fe:	10 92 92 0e 	sts	0x0E92, r1
    3302:	10 92 91 0e 	sts	0x0E91, r1
    3306:	08 95       	ret

00003308 <_ZN7TwoWire15endTransmissionEh>:
    3308:	0f 93       	push	r16
    330a:	06 2f       	mov	r16, r22
    330c:	21 e0       	ldi	r18, 0x01	; 1
    330e:	40 91 91 0e 	lds	r20, 0x0E91
    3312:	63 e9       	ldi	r22, 0x93	; 147
    3314:	7e e0       	ldi	r23, 0x0E	; 14
    3316:	80 91 b3 0e 	lds	r24, 0x0EB3
    331a:	90 dd       	rcall	.-1248   	; 0x2e3c <twi_writeTo>
    331c:	10 92 92 0e 	sts	0x0E92, r1
    3320:	10 92 91 0e 	sts	0x0E91, r1
    3324:	10 92 90 0e 	sts	0x0E90, r1
    3328:	0f 91       	pop	r16
    332a:	08 95       	ret

0000332c <_ZN7TwoWire15endTransmissionEv>:
    332c:	61 e0       	ldi	r22, 0x01	; 1
    332e:	ec cf       	rjmp	.-40     	; 0x3308 <_ZN7TwoWire15endTransmissionEh>
    3330:	08 95       	ret

00003332 <_GLOBAL__sub_I__ZN7TwoWire8rxBufferE>:
}

// Preinstantiate Objects //////////////////////////////////////////////////////

TwoWire Wire = TwoWire();
    3332:	84 e8       	ldi	r24, 0x84	; 132
    3334:	9e e0       	ldi	r25, 0x0E	; 14
    3336:	b5 cf       	rjmp	.-150    	; 0x32a2 <_ZN7TwoWireC1Ev>
    3338:	08 95       	ret

0000333a <__subsf3>:
    333a:	50 58       	subi	r21, 0x80	; 128

0000333c <__addsf3>:
    333c:	bb 27       	eor	r27, r27
    333e:	aa 27       	eor	r26, r26
    3340:	0e d0       	rcall	.+28     	; 0x335e <__addsf3x>
    3342:	fc c1       	rjmp	.+1016   	; 0x373c <__fp_round>
    3344:	ed d1       	rcall	.+986    	; 0x3720 <__fp_pscA>
    3346:	30 f0       	brcs	.+12     	; 0x3354 <__addsf3+0x18>
    3348:	f2 d1       	rcall	.+996    	; 0x372e <__fp_pscB>
    334a:	20 f0       	brcs	.+8      	; 0x3354 <__addsf3+0x18>
    334c:	31 f4       	brne	.+12     	; 0x335a <__addsf3+0x1e>
    334e:	9f 3f       	cpi	r25, 0xFF	; 255
    3350:	11 f4       	brne	.+4      	; 0x3356 <__addsf3+0x1a>
    3352:	1e f4       	brtc	.+6      	; 0x335a <__addsf3+0x1e>
    3354:	bd c1       	rjmp	.+890    	; 0x36d0 <__fp_nan>
    3356:	0e f4       	brtc	.+2      	; 0x335a <__addsf3+0x1e>
    3358:	e0 95       	com	r30
    335a:	e7 fb       	bst	r30, 7
    335c:	b3 c1       	rjmp	.+870    	; 0x36c4 <__fp_inf>

0000335e <__addsf3x>:
    335e:	e9 2f       	mov	r30, r25
    3360:	fe d1       	rcall	.+1020   	; 0x375e <__fp_split3>
    3362:	80 f3       	brcs	.-32     	; 0x3344 <__addsf3+0x8>
    3364:	ba 17       	cp	r27, r26
    3366:	62 07       	cpc	r22, r18
    3368:	73 07       	cpc	r23, r19
    336a:	84 07       	cpc	r24, r20
    336c:	95 07       	cpc	r25, r21
    336e:	18 f0       	brcs	.+6      	; 0x3376 <__addsf3x+0x18>
    3370:	71 f4       	brne	.+28     	; 0x338e <__addsf3x+0x30>
    3372:	9e f5       	brtc	.+102    	; 0x33da <__addsf3x+0x7c>
    3374:	16 c2       	rjmp	.+1068   	; 0x37a2 <__fp_zero>
    3376:	0e f4       	brtc	.+2      	; 0x337a <__addsf3x+0x1c>
    3378:	e0 95       	com	r30
    337a:	0b 2e       	mov	r0, r27
    337c:	ba 2f       	mov	r27, r26
    337e:	a0 2d       	mov	r26, r0
    3380:	0b 01       	movw	r0, r22
    3382:	b9 01       	movw	r22, r18
    3384:	90 01       	movw	r18, r0
    3386:	0c 01       	movw	r0, r24
    3388:	ca 01       	movw	r24, r20
    338a:	a0 01       	movw	r20, r0
    338c:	11 24       	eor	r1, r1
    338e:	ff 27       	eor	r31, r31
    3390:	59 1b       	sub	r21, r25
    3392:	99 f0       	breq	.+38     	; 0x33ba <__addsf3x+0x5c>
    3394:	59 3f       	cpi	r21, 0xF9	; 249
    3396:	50 f4       	brcc	.+20     	; 0x33ac <__addsf3x+0x4e>
    3398:	50 3e       	cpi	r21, 0xE0	; 224
    339a:	68 f1       	brcs	.+90     	; 0x33f6 <__addsf3x+0x98>
    339c:	1a 16       	cp	r1, r26
    339e:	f0 40       	sbci	r31, 0x00	; 0
    33a0:	a2 2f       	mov	r26, r18
    33a2:	23 2f       	mov	r18, r19
    33a4:	34 2f       	mov	r19, r20
    33a6:	44 27       	eor	r20, r20
    33a8:	58 5f       	subi	r21, 0xF8	; 248
    33aa:	f3 cf       	rjmp	.-26     	; 0x3392 <__addsf3x+0x34>
    33ac:	46 95       	lsr	r20
    33ae:	37 95       	ror	r19
    33b0:	27 95       	ror	r18
    33b2:	a7 95       	ror	r26
    33b4:	f0 40       	sbci	r31, 0x00	; 0
    33b6:	53 95       	inc	r21
    33b8:	c9 f7       	brne	.-14     	; 0x33ac <__addsf3x+0x4e>
    33ba:	7e f4       	brtc	.+30     	; 0x33da <__addsf3x+0x7c>
    33bc:	1f 16       	cp	r1, r31
    33be:	ba 0b       	sbc	r27, r26
    33c0:	62 0b       	sbc	r22, r18
    33c2:	73 0b       	sbc	r23, r19
    33c4:	84 0b       	sbc	r24, r20
    33c6:	ba f0       	brmi	.+46     	; 0x33f6 <__addsf3x+0x98>
    33c8:	91 50       	subi	r25, 0x01	; 1
    33ca:	a1 f0       	breq	.+40     	; 0x33f4 <__addsf3x+0x96>
    33cc:	ff 0f       	add	r31, r31
    33ce:	bb 1f       	adc	r27, r27
    33d0:	66 1f       	adc	r22, r22
    33d2:	77 1f       	adc	r23, r23
    33d4:	88 1f       	adc	r24, r24
    33d6:	c2 f7       	brpl	.-16     	; 0x33c8 <__addsf3x+0x6a>
    33d8:	0e c0       	rjmp	.+28     	; 0x33f6 <__addsf3x+0x98>
    33da:	ba 0f       	add	r27, r26
    33dc:	62 1f       	adc	r22, r18
    33de:	73 1f       	adc	r23, r19
    33e0:	84 1f       	adc	r24, r20
    33e2:	48 f4       	brcc	.+18     	; 0x33f6 <__addsf3x+0x98>
    33e4:	87 95       	ror	r24
    33e6:	77 95       	ror	r23
    33e8:	67 95       	ror	r22
    33ea:	b7 95       	ror	r27
    33ec:	f7 95       	ror	r31
    33ee:	9e 3f       	cpi	r25, 0xFE	; 254
    33f0:	08 f0       	brcs	.+2      	; 0x33f4 <__addsf3x+0x96>
    33f2:	b3 cf       	rjmp	.-154    	; 0x335a <__addsf3+0x1e>
    33f4:	93 95       	inc	r25
    33f6:	88 0f       	add	r24, r24
    33f8:	08 f0       	brcs	.+2      	; 0x33fc <__addsf3x+0x9e>
    33fa:	99 27       	eor	r25, r25
    33fc:	ee 0f       	add	r30, r30
    33fe:	97 95       	ror	r25
    3400:	87 95       	ror	r24
    3402:	08 95       	ret
    3404:	8d d1       	rcall	.+794    	; 0x3720 <__fp_pscA>
    3406:	58 f0       	brcs	.+22     	; 0x341e <__addsf3x+0xc0>
    3408:	80 e8       	ldi	r24, 0x80	; 128
    340a:	91 e0       	ldi	r25, 0x01	; 1
    340c:	09 f4       	brne	.+2      	; 0x3410 <__addsf3x+0xb2>
    340e:	9e ef       	ldi	r25, 0xFE	; 254
    3410:	8e d1       	rcall	.+796    	; 0x372e <__fp_pscB>
    3412:	28 f0       	brcs	.+10     	; 0x341e <__addsf3x+0xc0>
    3414:	40 e8       	ldi	r20, 0x80	; 128
    3416:	51 e0       	ldi	r21, 0x01	; 1
    3418:	59 f4       	brne	.+22     	; 0x3430 <atan2+0xe>
    341a:	5e ef       	ldi	r21, 0xFE	; 254
    341c:	09 c0       	rjmp	.+18     	; 0x3430 <atan2+0xe>
    341e:	58 c1       	rjmp	.+688    	; 0x36d0 <__fp_nan>
    3420:	c0 c1       	rjmp	.+896    	; 0x37a2 <__fp_zero>

00003422 <atan2>:
    3422:	e9 2f       	mov	r30, r25
    3424:	e0 78       	andi	r30, 0x80	; 128
    3426:	9b d1       	rcall	.+822    	; 0x375e <__fp_split3>
    3428:	68 f3       	brcs	.-38     	; 0x3404 <__addsf3x+0xa6>
    342a:	09 2e       	mov	r0, r25
    342c:	05 2a       	or	r0, r21
    342e:	c1 f3       	breq	.-16     	; 0x3420 <__addsf3x+0xc2>
    3430:	26 17       	cp	r18, r22
    3432:	37 07       	cpc	r19, r23
    3434:	48 07       	cpc	r20, r24
    3436:	59 07       	cpc	r21, r25
    3438:	38 f0       	brcs	.+14     	; 0x3448 <atan2+0x26>
    343a:	0e 2e       	mov	r0, r30
    343c:	07 f8       	bld	r0, 7
    343e:	e0 25       	eor	r30, r0
    3440:	69 f0       	breq	.+26     	; 0x345c <atan2+0x3a>
    3442:	e0 25       	eor	r30, r0
    3444:	e0 64       	ori	r30, 0x40	; 64
    3446:	0a c0       	rjmp	.+20     	; 0x345c <atan2+0x3a>
    3448:	ef 63       	ori	r30, 0x3F	; 63
    344a:	07 f8       	bld	r0, 7
    344c:	00 94       	com	r0
    344e:	07 fa       	bst	r0, 7
    3450:	db 01       	movw	r26, r22
    3452:	b9 01       	movw	r22, r18
    3454:	9d 01       	movw	r18, r26
    3456:	dc 01       	movw	r26, r24
    3458:	ca 01       	movw	r24, r20
    345a:	ad 01       	movw	r20, r26
    345c:	ef 93       	push	r30
    345e:	47 d0       	rcall	.+142    	; 0x34ee <__divsf3_pse>
    3460:	6d d1       	rcall	.+730    	; 0x373c <__fp_round>
    3462:	0a d0       	rcall	.+20     	; 0x3478 <atan>
    3464:	5f 91       	pop	r21
    3466:	55 23       	and	r21, r21
    3468:	31 f0       	breq	.+12     	; 0x3476 <atan2+0x54>
    346a:	2b ed       	ldi	r18, 0xDB	; 219
    346c:	3f e0       	ldi	r19, 0x0F	; 15
    346e:	49 e4       	ldi	r20, 0x49	; 73
    3470:	50 fd       	sbrc	r21, 0
    3472:	49 ec       	ldi	r20, 0xC9	; 201
    3474:	63 cf       	rjmp	.-314    	; 0x333c <__addsf3>
    3476:	08 95       	ret

00003478 <atan>:
    3478:	df 93       	push	r29
    347a:	dd 27       	eor	r29, r29
    347c:	b9 2f       	mov	r27, r25
    347e:	bf 77       	andi	r27, 0x7F	; 127
    3480:	40 e8       	ldi	r20, 0x80	; 128
    3482:	5f e3       	ldi	r21, 0x3F	; 63
    3484:	16 16       	cp	r1, r22
    3486:	17 06       	cpc	r1, r23
    3488:	48 07       	cpc	r20, r24
    348a:	5b 07       	cpc	r21, r27
    348c:	10 f4       	brcc	.+4      	; 0x3492 <atan+0x1a>
    348e:	d9 2f       	mov	r29, r25
    3490:	93 d1       	rcall	.+806    	; 0x37b8 <inverse>
    3492:	9f 93       	push	r25
    3494:	8f 93       	push	r24
    3496:	7f 93       	push	r23
    3498:	6f 93       	push	r22
    349a:	3a d2       	rcall	.+1140   	; 0x3910 <square>
    349c:	e6 e7       	ldi	r30, 0x76	; 118
    349e:	f2 e0       	ldi	r31, 0x02	; 2
    34a0:	1a d1       	rcall	.+564    	; 0x36d6 <__fp_powser>
    34a2:	4c d1       	rcall	.+664    	; 0x373c <__fp_round>
    34a4:	2f 91       	pop	r18
    34a6:	3f 91       	pop	r19
    34a8:	4f 91       	pop	r20
    34aa:	5f 91       	pop	r21
    34ac:	98 d1       	rcall	.+816    	; 0x37de <__mulsf3x>
    34ae:	dd 23       	and	r29, r29
    34b0:	49 f0       	breq	.+18     	; 0x34c4 <atan+0x4c>
    34b2:	90 58       	subi	r25, 0x80	; 128
    34b4:	a2 ea       	ldi	r26, 0xA2	; 162
    34b6:	2a ed       	ldi	r18, 0xDA	; 218
    34b8:	3f e0       	ldi	r19, 0x0F	; 15
    34ba:	49 ec       	ldi	r20, 0xC9	; 201
    34bc:	5f e3       	ldi	r21, 0x3F	; 63
    34be:	d0 78       	andi	r29, 0x80	; 128
    34c0:	5d 27       	eor	r21, r29
    34c2:	4d df       	rcall	.-358    	; 0x335e <__addsf3x>
    34c4:	df 91       	pop	r29
    34c6:	3a c1       	rjmp	.+628    	; 0x373c <__fp_round>

000034c8 <__cmpsf2>:
    34c8:	d9 d0       	rcall	.+434    	; 0x367c <__fp_cmp>
    34ca:	08 f4       	brcc	.+2      	; 0x34ce <__cmpsf2+0x6>
    34cc:	81 e0       	ldi	r24, 0x01	; 1
    34ce:	08 95       	ret

000034d0 <__divsf3>:
    34d0:	0c d0       	rcall	.+24     	; 0x34ea <__divsf3x>
    34d2:	34 c1       	rjmp	.+616    	; 0x373c <__fp_round>
    34d4:	2c d1       	rcall	.+600    	; 0x372e <__fp_pscB>
    34d6:	40 f0       	brcs	.+16     	; 0x34e8 <__divsf3+0x18>
    34d8:	23 d1       	rcall	.+582    	; 0x3720 <__fp_pscA>
    34da:	30 f0       	brcs	.+12     	; 0x34e8 <__divsf3+0x18>
    34dc:	21 f4       	brne	.+8      	; 0x34e6 <__divsf3+0x16>
    34de:	5f 3f       	cpi	r21, 0xFF	; 255
    34e0:	19 f0       	breq	.+6      	; 0x34e8 <__divsf3+0x18>
    34e2:	f0 c0       	rjmp	.+480    	; 0x36c4 <__fp_inf>
    34e4:	51 11       	cpse	r21, r1
    34e6:	5e c1       	rjmp	.+700    	; 0x37a4 <__fp_szero>
    34e8:	f3 c0       	rjmp	.+486    	; 0x36d0 <__fp_nan>

000034ea <__divsf3x>:
    34ea:	39 d1       	rcall	.+626    	; 0x375e <__fp_split3>
    34ec:	98 f3       	brcs	.-26     	; 0x34d4 <__divsf3+0x4>

000034ee <__divsf3_pse>:
    34ee:	99 23       	and	r25, r25
    34f0:	c9 f3       	breq	.-14     	; 0x34e4 <__divsf3+0x14>
    34f2:	55 23       	and	r21, r21
    34f4:	b1 f3       	breq	.-20     	; 0x34e2 <__divsf3+0x12>
    34f6:	95 1b       	sub	r25, r21
    34f8:	55 0b       	sbc	r21, r21
    34fa:	bb 27       	eor	r27, r27
    34fc:	aa 27       	eor	r26, r26
    34fe:	62 17       	cp	r22, r18
    3500:	73 07       	cpc	r23, r19
    3502:	84 07       	cpc	r24, r20
    3504:	38 f0       	brcs	.+14     	; 0x3514 <__divsf3_pse+0x26>
    3506:	9f 5f       	subi	r25, 0xFF	; 255
    3508:	5f 4f       	sbci	r21, 0xFF	; 255
    350a:	22 0f       	add	r18, r18
    350c:	33 1f       	adc	r19, r19
    350e:	44 1f       	adc	r20, r20
    3510:	aa 1f       	adc	r26, r26
    3512:	a9 f3       	breq	.-22     	; 0x34fe <__divsf3_pse+0x10>
    3514:	33 d0       	rcall	.+102    	; 0x357c <__divsf3_pse+0x8e>
    3516:	0e 2e       	mov	r0, r30
    3518:	3a f0       	brmi	.+14     	; 0x3528 <__divsf3_pse+0x3a>
    351a:	e0 e8       	ldi	r30, 0x80	; 128
    351c:	30 d0       	rcall	.+96     	; 0x357e <__divsf3_pse+0x90>
    351e:	91 50       	subi	r25, 0x01	; 1
    3520:	50 40       	sbci	r21, 0x00	; 0
    3522:	e6 95       	lsr	r30
    3524:	00 1c       	adc	r0, r0
    3526:	ca f7       	brpl	.-14     	; 0x351a <__divsf3_pse+0x2c>
    3528:	29 d0       	rcall	.+82     	; 0x357c <__divsf3_pse+0x8e>
    352a:	fe 2f       	mov	r31, r30
    352c:	27 d0       	rcall	.+78     	; 0x357c <__divsf3_pse+0x8e>
    352e:	66 0f       	add	r22, r22
    3530:	77 1f       	adc	r23, r23
    3532:	88 1f       	adc	r24, r24
    3534:	bb 1f       	adc	r27, r27
    3536:	26 17       	cp	r18, r22
    3538:	37 07       	cpc	r19, r23
    353a:	48 07       	cpc	r20, r24
    353c:	ab 07       	cpc	r26, r27
    353e:	b0 e8       	ldi	r27, 0x80	; 128
    3540:	09 f0       	breq	.+2      	; 0x3544 <__divsf3_pse+0x56>
    3542:	bb 0b       	sbc	r27, r27
    3544:	80 2d       	mov	r24, r0
    3546:	bf 01       	movw	r22, r30
    3548:	ff 27       	eor	r31, r31
    354a:	93 58       	subi	r25, 0x83	; 131
    354c:	5f 4f       	sbci	r21, 0xFF	; 255
    354e:	2a f0       	brmi	.+10     	; 0x355a <__divsf3_pse+0x6c>
    3550:	9e 3f       	cpi	r25, 0xFE	; 254
    3552:	51 05       	cpc	r21, r1
    3554:	68 f0       	brcs	.+26     	; 0x3570 <__divsf3_pse+0x82>
    3556:	b6 c0       	rjmp	.+364    	; 0x36c4 <__fp_inf>
    3558:	25 c1       	rjmp	.+586    	; 0x37a4 <__fp_szero>
    355a:	5f 3f       	cpi	r21, 0xFF	; 255
    355c:	ec f3       	brlt	.-6      	; 0x3558 <__divsf3_pse+0x6a>
    355e:	98 3e       	cpi	r25, 0xE8	; 232
    3560:	dc f3       	brlt	.-10     	; 0x3558 <__divsf3_pse+0x6a>
    3562:	86 95       	lsr	r24
    3564:	77 95       	ror	r23
    3566:	67 95       	ror	r22
    3568:	b7 95       	ror	r27
    356a:	f7 95       	ror	r31
    356c:	9f 5f       	subi	r25, 0xFF	; 255
    356e:	c9 f7       	brne	.-14     	; 0x3562 <__divsf3_pse+0x74>
    3570:	88 0f       	add	r24, r24
    3572:	91 1d       	adc	r25, r1
    3574:	96 95       	lsr	r25
    3576:	87 95       	ror	r24
    3578:	97 f9       	bld	r25, 7
    357a:	08 95       	ret
    357c:	e1 e0       	ldi	r30, 0x01	; 1
    357e:	66 0f       	add	r22, r22
    3580:	77 1f       	adc	r23, r23
    3582:	88 1f       	adc	r24, r24
    3584:	bb 1f       	adc	r27, r27
    3586:	62 17       	cp	r22, r18
    3588:	73 07       	cpc	r23, r19
    358a:	84 07       	cpc	r24, r20
    358c:	ba 07       	cpc	r27, r26
    358e:	20 f0       	brcs	.+8      	; 0x3598 <__divsf3_pse+0xaa>
    3590:	62 1b       	sub	r22, r18
    3592:	73 0b       	sbc	r23, r19
    3594:	84 0b       	sbc	r24, r20
    3596:	ba 0b       	sbc	r27, r26
    3598:	ee 1f       	adc	r30, r30
    359a:	88 f7       	brcc	.-30     	; 0x357e <__divsf3_pse+0x90>
    359c:	e0 95       	com	r30
    359e:	08 95       	ret

000035a0 <__fixsfsi>:
    35a0:	04 d0       	rcall	.+8      	; 0x35aa <__fixunssfsi>
    35a2:	68 94       	set
    35a4:	b1 11       	cpse	r27, r1
    35a6:	fe c0       	rjmp	.+508    	; 0x37a4 <__fp_szero>
    35a8:	08 95       	ret

000035aa <__fixunssfsi>:
    35aa:	e1 d0       	rcall	.+450    	; 0x376e <__fp_splitA>
    35ac:	88 f0       	brcs	.+34     	; 0x35d0 <__fixunssfsi+0x26>
    35ae:	9f 57       	subi	r25, 0x7F	; 127
    35b0:	90 f0       	brcs	.+36     	; 0x35d6 <__fixunssfsi+0x2c>
    35b2:	b9 2f       	mov	r27, r25
    35b4:	99 27       	eor	r25, r25
    35b6:	b7 51       	subi	r27, 0x17	; 23
    35b8:	a0 f0       	brcs	.+40     	; 0x35e2 <__fixunssfsi+0x38>
    35ba:	d1 f0       	breq	.+52     	; 0x35f0 <__fixunssfsi+0x46>
    35bc:	66 0f       	add	r22, r22
    35be:	77 1f       	adc	r23, r23
    35c0:	88 1f       	adc	r24, r24
    35c2:	99 1f       	adc	r25, r25
    35c4:	1a f0       	brmi	.+6      	; 0x35cc <__fixunssfsi+0x22>
    35c6:	ba 95       	dec	r27
    35c8:	c9 f7       	brne	.-14     	; 0x35bc <__fixunssfsi+0x12>
    35ca:	12 c0       	rjmp	.+36     	; 0x35f0 <__fixunssfsi+0x46>
    35cc:	b1 30       	cpi	r27, 0x01	; 1
    35ce:	81 f0       	breq	.+32     	; 0x35f0 <__fixunssfsi+0x46>
    35d0:	e8 d0       	rcall	.+464    	; 0x37a2 <__fp_zero>
    35d2:	b1 e0       	ldi	r27, 0x01	; 1
    35d4:	08 95       	ret
    35d6:	e5 c0       	rjmp	.+458    	; 0x37a2 <__fp_zero>
    35d8:	67 2f       	mov	r22, r23
    35da:	78 2f       	mov	r23, r24
    35dc:	88 27       	eor	r24, r24
    35de:	b8 5f       	subi	r27, 0xF8	; 248
    35e0:	39 f0       	breq	.+14     	; 0x35f0 <__fixunssfsi+0x46>
    35e2:	b9 3f       	cpi	r27, 0xF9	; 249
    35e4:	cc f3       	brlt	.-14     	; 0x35d8 <__fixunssfsi+0x2e>
    35e6:	86 95       	lsr	r24
    35e8:	77 95       	ror	r23
    35ea:	67 95       	ror	r22
    35ec:	b3 95       	inc	r27
    35ee:	d9 f7       	brne	.-10     	; 0x35e6 <__fixunssfsi+0x3c>
    35f0:	3e f4       	brtc	.+14     	; 0x3600 <__fixunssfsi+0x56>
    35f2:	90 95       	com	r25
    35f4:	80 95       	com	r24
    35f6:	70 95       	com	r23
    35f8:	61 95       	neg	r22
    35fa:	7f 4f       	sbci	r23, 0xFF	; 255
    35fc:	8f 4f       	sbci	r24, 0xFF	; 255
    35fe:	9f 4f       	sbci	r25, 0xFF	; 255
    3600:	08 95       	ret

00003602 <__floatunsisf>:
    3602:	e8 94       	clt
    3604:	09 c0       	rjmp	.+18     	; 0x3618 <__floatsisf+0x12>

00003606 <__floatsisf>:
    3606:	97 fb       	bst	r25, 7
    3608:	3e f4       	brtc	.+14     	; 0x3618 <__floatsisf+0x12>
    360a:	90 95       	com	r25
    360c:	80 95       	com	r24
    360e:	70 95       	com	r23
    3610:	61 95       	neg	r22
    3612:	7f 4f       	sbci	r23, 0xFF	; 255
    3614:	8f 4f       	sbci	r24, 0xFF	; 255
    3616:	9f 4f       	sbci	r25, 0xFF	; 255
    3618:	99 23       	and	r25, r25
    361a:	a9 f0       	breq	.+42     	; 0x3646 <__floatsisf+0x40>
    361c:	f9 2f       	mov	r31, r25
    361e:	96 e9       	ldi	r25, 0x96	; 150
    3620:	bb 27       	eor	r27, r27
    3622:	93 95       	inc	r25
    3624:	f6 95       	lsr	r31
    3626:	87 95       	ror	r24
    3628:	77 95       	ror	r23
    362a:	67 95       	ror	r22
    362c:	b7 95       	ror	r27
    362e:	f1 11       	cpse	r31, r1
    3630:	f8 cf       	rjmp	.-16     	; 0x3622 <__floatsisf+0x1c>
    3632:	fa f4       	brpl	.+62     	; 0x3672 <__floatsisf+0x6c>
    3634:	bb 0f       	add	r27, r27
    3636:	11 f4       	brne	.+4      	; 0x363c <__floatsisf+0x36>
    3638:	60 ff       	sbrs	r22, 0
    363a:	1b c0       	rjmp	.+54     	; 0x3672 <__floatsisf+0x6c>
    363c:	6f 5f       	subi	r22, 0xFF	; 255
    363e:	7f 4f       	sbci	r23, 0xFF	; 255
    3640:	8f 4f       	sbci	r24, 0xFF	; 255
    3642:	9f 4f       	sbci	r25, 0xFF	; 255
    3644:	16 c0       	rjmp	.+44     	; 0x3672 <__floatsisf+0x6c>
    3646:	88 23       	and	r24, r24
    3648:	11 f0       	breq	.+4      	; 0x364e <__floatsisf+0x48>
    364a:	96 e9       	ldi	r25, 0x96	; 150
    364c:	11 c0       	rjmp	.+34     	; 0x3670 <__floatsisf+0x6a>
    364e:	77 23       	and	r23, r23
    3650:	21 f0       	breq	.+8      	; 0x365a <__floatsisf+0x54>
    3652:	9e e8       	ldi	r25, 0x8E	; 142
    3654:	87 2f       	mov	r24, r23
    3656:	76 2f       	mov	r23, r22
    3658:	05 c0       	rjmp	.+10     	; 0x3664 <__floatsisf+0x5e>
    365a:	66 23       	and	r22, r22
    365c:	71 f0       	breq	.+28     	; 0x367a <__floatsisf+0x74>
    365e:	96 e8       	ldi	r25, 0x86	; 134
    3660:	86 2f       	mov	r24, r22
    3662:	70 e0       	ldi	r23, 0x00	; 0
    3664:	60 e0       	ldi	r22, 0x00	; 0
    3666:	2a f0       	brmi	.+10     	; 0x3672 <__floatsisf+0x6c>
    3668:	9a 95       	dec	r25
    366a:	66 0f       	add	r22, r22
    366c:	77 1f       	adc	r23, r23
    366e:	88 1f       	adc	r24, r24
    3670:	da f7       	brpl	.-10     	; 0x3668 <__floatsisf+0x62>
    3672:	88 0f       	add	r24, r24
    3674:	96 95       	lsr	r25
    3676:	87 95       	ror	r24
    3678:	97 f9       	bld	r25, 7
    367a:	08 95       	ret

0000367c <__fp_cmp>:
    367c:	99 0f       	add	r25, r25
    367e:	00 08       	sbc	r0, r0
    3680:	55 0f       	add	r21, r21
    3682:	aa 0b       	sbc	r26, r26
    3684:	e0 e8       	ldi	r30, 0x80	; 128
    3686:	fe ef       	ldi	r31, 0xFE	; 254
    3688:	16 16       	cp	r1, r22
    368a:	17 06       	cpc	r1, r23
    368c:	e8 07       	cpc	r30, r24
    368e:	f9 07       	cpc	r31, r25
    3690:	c0 f0       	brcs	.+48     	; 0x36c2 <__fp_cmp+0x46>
    3692:	12 16       	cp	r1, r18
    3694:	13 06       	cpc	r1, r19
    3696:	e4 07       	cpc	r30, r20
    3698:	f5 07       	cpc	r31, r21
    369a:	98 f0       	brcs	.+38     	; 0x36c2 <__fp_cmp+0x46>
    369c:	62 1b       	sub	r22, r18
    369e:	73 0b       	sbc	r23, r19
    36a0:	84 0b       	sbc	r24, r20
    36a2:	95 0b       	sbc	r25, r21
    36a4:	39 f4       	brne	.+14     	; 0x36b4 <__fp_cmp+0x38>
    36a6:	0a 26       	eor	r0, r26
    36a8:	61 f0       	breq	.+24     	; 0x36c2 <__fp_cmp+0x46>
    36aa:	23 2b       	or	r18, r19
    36ac:	24 2b       	or	r18, r20
    36ae:	25 2b       	or	r18, r21
    36b0:	21 f4       	brne	.+8      	; 0x36ba <__fp_cmp+0x3e>
    36b2:	08 95       	ret
    36b4:	0a 26       	eor	r0, r26
    36b6:	09 f4       	brne	.+2      	; 0x36ba <__fp_cmp+0x3e>
    36b8:	a1 40       	sbci	r26, 0x01	; 1
    36ba:	a6 95       	lsr	r26
    36bc:	8f ef       	ldi	r24, 0xFF	; 255
    36be:	81 1d       	adc	r24, r1
    36c0:	81 1d       	adc	r24, r1
    36c2:	08 95       	ret

000036c4 <__fp_inf>:
    36c4:	97 f9       	bld	r25, 7
    36c6:	9f 67       	ori	r25, 0x7F	; 127
    36c8:	80 e8       	ldi	r24, 0x80	; 128
    36ca:	70 e0       	ldi	r23, 0x00	; 0
    36cc:	60 e0       	ldi	r22, 0x00	; 0
    36ce:	08 95       	ret

000036d0 <__fp_nan>:
    36d0:	9f ef       	ldi	r25, 0xFF	; 255
    36d2:	80 ec       	ldi	r24, 0xC0	; 192
    36d4:	08 95       	ret

000036d6 <__fp_powser>:
    36d6:	df 93       	push	r29
    36d8:	cf 93       	push	r28
    36da:	1f 93       	push	r17
    36dc:	0f 93       	push	r16
    36de:	ff 92       	push	r15
    36e0:	ef 92       	push	r14
    36e2:	df 92       	push	r13
    36e4:	7b 01       	movw	r14, r22
    36e6:	8c 01       	movw	r16, r24
    36e8:	68 94       	set
    36ea:	05 c0       	rjmp	.+10     	; 0x36f6 <__fp_powser+0x20>
    36ec:	da 2e       	mov	r13, r26
    36ee:	ef 01       	movw	r28, r30
    36f0:	76 d0       	rcall	.+236    	; 0x37de <__mulsf3x>
    36f2:	fe 01       	movw	r30, r28
    36f4:	e8 94       	clt
    36f6:	a5 91       	lpm	r26, Z+
    36f8:	25 91       	lpm	r18, Z+
    36fa:	35 91       	lpm	r19, Z+
    36fc:	45 91       	lpm	r20, Z+
    36fe:	55 91       	lpm	r21, Z+
    3700:	ae f3       	brts	.-22     	; 0x36ec <__fp_powser+0x16>
    3702:	ef 01       	movw	r28, r30
    3704:	2c de       	rcall	.-936    	; 0x335e <__addsf3x>
    3706:	fe 01       	movw	r30, r28
    3708:	97 01       	movw	r18, r14
    370a:	a8 01       	movw	r20, r16
    370c:	da 94       	dec	r13
    370e:	79 f7       	brne	.-34     	; 0x36ee <__fp_powser+0x18>
    3710:	df 90       	pop	r13
    3712:	ef 90       	pop	r14
    3714:	ff 90       	pop	r15
    3716:	0f 91       	pop	r16
    3718:	1f 91       	pop	r17
    371a:	cf 91       	pop	r28
    371c:	df 91       	pop	r29
    371e:	08 95       	ret

00003720 <__fp_pscA>:
    3720:	00 24       	eor	r0, r0
    3722:	0a 94       	dec	r0
    3724:	16 16       	cp	r1, r22
    3726:	17 06       	cpc	r1, r23
    3728:	18 06       	cpc	r1, r24
    372a:	09 06       	cpc	r0, r25
    372c:	08 95       	ret

0000372e <__fp_pscB>:
    372e:	00 24       	eor	r0, r0
    3730:	0a 94       	dec	r0
    3732:	12 16       	cp	r1, r18
    3734:	13 06       	cpc	r1, r19
    3736:	14 06       	cpc	r1, r20
    3738:	05 06       	cpc	r0, r21
    373a:	08 95       	ret

0000373c <__fp_round>:
    373c:	09 2e       	mov	r0, r25
    373e:	03 94       	inc	r0
    3740:	00 0c       	add	r0, r0
    3742:	11 f4       	brne	.+4      	; 0x3748 <__fp_round+0xc>
    3744:	88 23       	and	r24, r24
    3746:	52 f0       	brmi	.+20     	; 0x375c <__fp_round+0x20>
    3748:	bb 0f       	add	r27, r27
    374a:	40 f4       	brcc	.+16     	; 0x375c <__fp_round+0x20>
    374c:	bf 2b       	or	r27, r31
    374e:	11 f4       	brne	.+4      	; 0x3754 <__fp_round+0x18>
    3750:	60 ff       	sbrs	r22, 0
    3752:	04 c0       	rjmp	.+8      	; 0x375c <__fp_round+0x20>
    3754:	6f 5f       	subi	r22, 0xFF	; 255
    3756:	7f 4f       	sbci	r23, 0xFF	; 255
    3758:	8f 4f       	sbci	r24, 0xFF	; 255
    375a:	9f 4f       	sbci	r25, 0xFF	; 255
    375c:	08 95       	ret

0000375e <__fp_split3>:
    375e:	57 fd       	sbrc	r21, 7
    3760:	90 58       	subi	r25, 0x80	; 128
    3762:	44 0f       	add	r20, r20
    3764:	55 1f       	adc	r21, r21
    3766:	59 f0       	breq	.+22     	; 0x377e <__fp_splitA+0x10>
    3768:	5f 3f       	cpi	r21, 0xFF	; 255
    376a:	71 f0       	breq	.+28     	; 0x3788 <__fp_splitA+0x1a>
    376c:	47 95       	ror	r20

0000376e <__fp_splitA>:
    376e:	88 0f       	add	r24, r24
    3770:	97 fb       	bst	r25, 7
    3772:	99 1f       	adc	r25, r25
    3774:	61 f0       	breq	.+24     	; 0x378e <__fp_splitA+0x20>
    3776:	9f 3f       	cpi	r25, 0xFF	; 255
    3778:	79 f0       	breq	.+30     	; 0x3798 <__fp_splitA+0x2a>
    377a:	87 95       	ror	r24
    377c:	08 95       	ret
    377e:	12 16       	cp	r1, r18
    3780:	13 06       	cpc	r1, r19
    3782:	14 06       	cpc	r1, r20
    3784:	55 1f       	adc	r21, r21
    3786:	f2 cf       	rjmp	.-28     	; 0x376c <__fp_split3+0xe>
    3788:	46 95       	lsr	r20
    378a:	f1 df       	rcall	.-30     	; 0x376e <__fp_splitA>
    378c:	08 c0       	rjmp	.+16     	; 0x379e <__fp_splitA+0x30>
    378e:	16 16       	cp	r1, r22
    3790:	17 06       	cpc	r1, r23
    3792:	18 06       	cpc	r1, r24
    3794:	99 1f       	adc	r25, r25
    3796:	f1 cf       	rjmp	.-30     	; 0x377a <__fp_splitA+0xc>
    3798:	86 95       	lsr	r24
    379a:	71 05       	cpc	r23, r1
    379c:	61 05       	cpc	r22, r1
    379e:	08 94       	sec
    37a0:	08 95       	ret

000037a2 <__fp_zero>:
    37a2:	e8 94       	clt

000037a4 <__fp_szero>:
    37a4:	bb 27       	eor	r27, r27
    37a6:	66 27       	eor	r22, r22
    37a8:	77 27       	eor	r23, r23
    37aa:	cb 01       	movw	r24, r22
    37ac:	97 f9       	bld	r25, 7
    37ae:	08 95       	ret

000037b0 <__gesf2>:
    37b0:	65 df       	rcall	.-310    	; 0x367c <__fp_cmp>
    37b2:	08 f4       	brcc	.+2      	; 0x37b6 <__gesf2+0x6>
    37b4:	8f ef       	ldi	r24, 0xFF	; 255
    37b6:	08 95       	ret

000037b8 <inverse>:
    37b8:	9b 01       	movw	r18, r22
    37ba:	ac 01       	movw	r20, r24
    37bc:	60 e0       	ldi	r22, 0x00	; 0
    37be:	70 e0       	ldi	r23, 0x00	; 0
    37c0:	80 e8       	ldi	r24, 0x80	; 128
    37c2:	9f e3       	ldi	r25, 0x3F	; 63
    37c4:	85 ce       	rjmp	.-758    	; 0x34d0 <__divsf3>

000037c6 <__mulsf3>:
    37c6:	0b d0       	rcall	.+22     	; 0x37de <__mulsf3x>
    37c8:	b9 cf       	rjmp	.-142    	; 0x373c <__fp_round>
    37ca:	aa df       	rcall	.-172    	; 0x3720 <__fp_pscA>
    37cc:	28 f0       	brcs	.+10     	; 0x37d8 <__mulsf3+0x12>
    37ce:	af df       	rcall	.-162    	; 0x372e <__fp_pscB>
    37d0:	18 f0       	brcs	.+6      	; 0x37d8 <__mulsf3+0x12>
    37d2:	95 23       	and	r25, r21
    37d4:	09 f0       	breq	.+2      	; 0x37d8 <__mulsf3+0x12>
    37d6:	76 cf       	rjmp	.-276    	; 0x36c4 <__fp_inf>
    37d8:	7b cf       	rjmp	.-266    	; 0x36d0 <__fp_nan>
    37da:	11 24       	eor	r1, r1
    37dc:	e3 cf       	rjmp	.-58     	; 0x37a4 <__fp_szero>

000037de <__mulsf3x>:
    37de:	bf df       	rcall	.-130    	; 0x375e <__fp_split3>
    37e0:	a0 f3       	brcs	.-24     	; 0x37ca <__mulsf3+0x4>

000037e2 <__mulsf3_pse>:
    37e2:	95 9f       	mul	r25, r21
    37e4:	d1 f3       	breq	.-12     	; 0x37da <__mulsf3+0x14>
    37e6:	95 0f       	add	r25, r21
    37e8:	50 e0       	ldi	r21, 0x00	; 0
    37ea:	55 1f       	adc	r21, r21
    37ec:	62 9f       	mul	r22, r18
    37ee:	f0 01       	movw	r30, r0
    37f0:	72 9f       	mul	r23, r18
    37f2:	bb 27       	eor	r27, r27
    37f4:	f0 0d       	add	r31, r0
    37f6:	b1 1d       	adc	r27, r1
    37f8:	63 9f       	mul	r22, r19
    37fa:	aa 27       	eor	r26, r26
    37fc:	f0 0d       	add	r31, r0
    37fe:	b1 1d       	adc	r27, r1
    3800:	aa 1f       	adc	r26, r26
    3802:	64 9f       	mul	r22, r20
    3804:	66 27       	eor	r22, r22
    3806:	b0 0d       	add	r27, r0
    3808:	a1 1d       	adc	r26, r1
    380a:	66 1f       	adc	r22, r22
    380c:	82 9f       	mul	r24, r18
    380e:	22 27       	eor	r18, r18
    3810:	b0 0d       	add	r27, r0
    3812:	a1 1d       	adc	r26, r1
    3814:	62 1f       	adc	r22, r18
    3816:	73 9f       	mul	r23, r19
    3818:	b0 0d       	add	r27, r0
    381a:	a1 1d       	adc	r26, r1
    381c:	62 1f       	adc	r22, r18
    381e:	83 9f       	mul	r24, r19
    3820:	a0 0d       	add	r26, r0
    3822:	61 1d       	adc	r22, r1
    3824:	22 1f       	adc	r18, r18
    3826:	74 9f       	mul	r23, r20
    3828:	33 27       	eor	r19, r19
    382a:	a0 0d       	add	r26, r0
    382c:	61 1d       	adc	r22, r1
    382e:	23 1f       	adc	r18, r19
    3830:	84 9f       	mul	r24, r20
    3832:	60 0d       	add	r22, r0
    3834:	21 1d       	adc	r18, r1
    3836:	82 2f       	mov	r24, r18
    3838:	76 2f       	mov	r23, r22
    383a:	6a 2f       	mov	r22, r26
    383c:	11 24       	eor	r1, r1
    383e:	9f 57       	subi	r25, 0x7F	; 127
    3840:	50 40       	sbci	r21, 0x00	; 0
    3842:	8a f0       	brmi	.+34     	; 0x3866 <__mulsf3_pse+0x84>
    3844:	e1 f0       	breq	.+56     	; 0x387e <__mulsf3_pse+0x9c>
    3846:	88 23       	and	r24, r24
    3848:	4a f0       	brmi	.+18     	; 0x385c <__mulsf3_pse+0x7a>
    384a:	ee 0f       	add	r30, r30
    384c:	ff 1f       	adc	r31, r31
    384e:	bb 1f       	adc	r27, r27
    3850:	66 1f       	adc	r22, r22
    3852:	77 1f       	adc	r23, r23
    3854:	88 1f       	adc	r24, r24
    3856:	91 50       	subi	r25, 0x01	; 1
    3858:	50 40       	sbci	r21, 0x00	; 0
    385a:	a9 f7       	brne	.-22     	; 0x3846 <__mulsf3_pse+0x64>
    385c:	9e 3f       	cpi	r25, 0xFE	; 254
    385e:	51 05       	cpc	r21, r1
    3860:	70 f0       	brcs	.+28     	; 0x387e <__mulsf3_pse+0x9c>
    3862:	30 cf       	rjmp	.-416    	; 0x36c4 <__fp_inf>
    3864:	9f cf       	rjmp	.-194    	; 0x37a4 <__fp_szero>
    3866:	5f 3f       	cpi	r21, 0xFF	; 255
    3868:	ec f3       	brlt	.-6      	; 0x3864 <__mulsf3_pse+0x82>
    386a:	98 3e       	cpi	r25, 0xE8	; 232
    386c:	dc f3       	brlt	.-10     	; 0x3864 <__mulsf3_pse+0x82>
    386e:	86 95       	lsr	r24
    3870:	77 95       	ror	r23
    3872:	67 95       	ror	r22
    3874:	b7 95       	ror	r27
    3876:	f7 95       	ror	r31
    3878:	e7 95       	ror	r30
    387a:	9f 5f       	subi	r25, 0xFF	; 255
    387c:	c1 f7       	brne	.-16     	; 0x386e <__mulsf3_pse+0x8c>
    387e:	fe 2b       	or	r31, r30
    3880:	88 0f       	add	r24, r24
    3882:	91 1d       	adc	r25, r1
    3884:	96 95       	lsr	r25
    3886:	87 95       	ror	r24
    3888:	97 f9       	bld	r25, 7
    388a:	08 95       	ret
    388c:	11 f4       	brne	.+4      	; 0x3892 <__mulsf3_pse+0xb0>
    388e:	0e f4       	brtc	.+2      	; 0x3892 <__mulsf3_pse+0xb0>
    3890:	1f cf       	rjmp	.-450    	; 0x36d0 <__fp_nan>
    3892:	41 c0       	rjmp	.+130    	; 0x3916 <__fp_mpack>

00003894 <sqrt>:
    3894:	6c df       	rcall	.-296    	; 0x376e <__fp_splitA>
    3896:	d0 f3       	brcs	.-12     	; 0x388c <__mulsf3_pse+0xaa>
    3898:	99 23       	and	r25, r25
    389a:	d9 f3       	breq	.-10     	; 0x3892 <__mulsf3_pse+0xb0>
    389c:	ce f3       	brts	.-14     	; 0x3890 <__mulsf3_pse+0xae>
    389e:	9f 57       	subi	r25, 0x7F	; 127
    38a0:	55 0b       	sbc	r21, r21
    38a2:	87 ff       	sbrs	r24, 7
    38a4:	46 d0       	rcall	.+140    	; 0x3932 <__fp_norm2>
    38a6:	00 24       	eor	r0, r0
    38a8:	a0 e6       	ldi	r26, 0x60	; 96
    38aa:	40 ea       	ldi	r20, 0xA0	; 160
    38ac:	90 01       	movw	r18, r0
    38ae:	80 58       	subi	r24, 0x80	; 128
    38b0:	56 95       	lsr	r21
    38b2:	97 95       	ror	r25
    38b4:	28 f4       	brcc	.+10     	; 0x38c0 <sqrt+0x2c>
    38b6:	80 5c       	subi	r24, 0xC0	; 192
    38b8:	66 0f       	add	r22, r22
    38ba:	77 1f       	adc	r23, r23
    38bc:	88 1f       	adc	r24, r24
    38be:	20 f0       	brcs	.+8      	; 0x38c8 <sqrt+0x34>
    38c0:	26 17       	cp	r18, r22
    38c2:	37 07       	cpc	r19, r23
    38c4:	48 07       	cpc	r20, r24
    38c6:	30 f4       	brcc	.+12     	; 0x38d4 <sqrt+0x40>
    38c8:	62 1b       	sub	r22, r18
    38ca:	73 0b       	sbc	r23, r19
    38cc:	84 0b       	sbc	r24, r20
    38ce:	20 29       	or	r18, r0
    38d0:	31 29       	or	r19, r1
    38d2:	4a 2b       	or	r20, r26
    38d4:	a6 95       	lsr	r26
    38d6:	17 94       	ror	r1
    38d8:	07 94       	ror	r0
    38da:	20 25       	eor	r18, r0
    38dc:	31 25       	eor	r19, r1
    38de:	4a 27       	eor	r20, r26
    38e0:	58 f7       	brcc	.-42     	; 0x38b8 <sqrt+0x24>
    38e2:	66 0f       	add	r22, r22
    38e4:	77 1f       	adc	r23, r23
    38e6:	88 1f       	adc	r24, r24
    38e8:	20 f0       	brcs	.+8      	; 0x38f2 <sqrt+0x5e>
    38ea:	26 17       	cp	r18, r22
    38ec:	37 07       	cpc	r19, r23
    38ee:	48 07       	cpc	r20, r24
    38f0:	30 f4       	brcc	.+12     	; 0x38fe <sqrt+0x6a>
    38f2:	62 0b       	sbc	r22, r18
    38f4:	73 0b       	sbc	r23, r19
    38f6:	84 0b       	sbc	r24, r20
    38f8:	20 0d       	add	r18, r0
    38fa:	31 1d       	adc	r19, r1
    38fc:	41 1d       	adc	r20, r1
    38fe:	a0 95       	com	r26
    3900:	81 f7       	brne	.-32     	; 0x38e2 <sqrt+0x4e>
    3902:	b9 01       	movw	r22, r18
    3904:	84 2f       	mov	r24, r20
    3906:	91 58       	subi	r25, 0x81	; 129
    3908:	88 0f       	add	r24, r24
    390a:	96 95       	lsr	r25
    390c:	87 95       	ror	r24
    390e:	08 95       	ret

00003910 <square>:
    3910:	9b 01       	movw	r18, r22
    3912:	ac 01       	movw	r20, r24
    3914:	58 cf       	rjmp	.-336    	; 0x37c6 <__mulsf3>

00003916 <__fp_mpack>:
    3916:	9f 3f       	cpi	r25, 0xFF	; 255
    3918:	31 f0       	breq	.+12     	; 0x3926 <__fp_mpack_finite+0xc>

0000391a <__fp_mpack_finite>:
    391a:	91 50       	subi	r25, 0x01	; 1
    391c:	20 f4       	brcc	.+8      	; 0x3926 <__fp_mpack_finite+0xc>
    391e:	87 95       	ror	r24
    3920:	77 95       	ror	r23
    3922:	67 95       	ror	r22
    3924:	b7 95       	ror	r27
    3926:	88 0f       	add	r24, r24
    3928:	91 1d       	adc	r25, r1
    392a:	96 95       	lsr	r25
    392c:	87 95       	ror	r24
    392e:	97 f9       	bld	r25, 7
    3930:	08 95       	ret

00003932 <__fp_norm2>:
    3932:	91 50       	subi	r25, 0x01	; 1
    3934:	50 40       	sbci	r21, 0x00	; 0
    3936:	66 0f       	add	r22, r22
    3938:	77 1f       	adc	r23, r23
    393a:	88 1f       	adc	r24, r24
    393c:	d2 f7       	brpl	.-12     	; 0x3932 <__fp_norm2>
    393e:	08 95       	ret

00003940 <_ZN14HardwareSerial9availableEv>:
#endif
/*#if defined(HAVE_HWSERIAL2)
  if (Serial2_available && serialEvent2 && Serial2_available()) serialEvent2();
#endif
#if defined(HAVE_HWSERIAL3)
  if (Serial3_available && serialEvent3 && Serial3_available()) serialEvent3();*/
    3940:	fc 01       	movw	r30, r24
    3942:	81 8d       	ldd	r24, Z+25	; 0x19
    3944:	22 8d       	ldd	r18, Z+26	; 0x1a
    3946:	90 e0       	ldi	r25, 0x00	; 0
    3948:	80 5c       	subi	r24, 0xC0	; 192
    394a:	9f 4f       	sbci	r25, 0xFF	; 255
    394c:	82 1b       	sub	r24, r18
    394e:	91 09       	sbc	r25, r1
    3950:	8f 73       	andi	r24, 0x3F	; 63
    3952:	99 27       	eor	r25, r25
    3954:	08 95       	ret

00003956 <_ZN14HardwareSerial4peekEv>:
    3956:	fc 01       	movw	r30, r24
    3958:	91 8d       	ldd	r25, Z+25	; 0x19
    395a:	82 8d       	ldd	r24, Z+26	; 0x1a
    395c:	98 17       	cp	r25, r24
    395e:	31 f0       	breq	.+12     	; 0x396c <_ZN14HardwareSerial4peekEv+0x16>
    3960:	82 8d       	ldd	r24, Z+26	; 0x1a
    3962:	e8 0f       	add	r30, r24
    3964:	f1 1d       	adc	r31, r1
    3966:	85 8d       	ldd	r24, Z+29	; 0x1d
    3968:	90 e0       	ldi	r25, 0x00	; 0
    396a:	08 95       	ret
    396c:	8f ef       	ldi	r24, 0xFF	; 255
    396e:	9f ef       	ldi	r25, 0xFF	; 255
    3970:	08 95       	ret

00003972 <_ZN14HardwareSerial4readEv>:
    3972:	fc 01       	movw	r30, r24
    3974:	91 8d       	ldd	r25, Z+25	; 0x19
    3976:	82 8d       	ldd	r24, Z+26	; 0x1a
    3978:	98 17       	cp	r25, r24
    397a:	61 f0       	breq	.+24     	; 0x3994 <_ZN14HardwareSerial4readEv+0x22>
    397c:	82 8d       	ldd	r24, Z+26	; 0x1a
    397e:	df 01       	movw	r26, r30
    3980:	a8 0f       	add	r26, r24
    3982:	b1 1d       	adc	r27, r1
    3984:	5d 96       	adiw	r26, 0x1d	; 29
    3986:	8c 91       	ld	r24, X
    3988:	92 8d       	ldd	r25, Z+26	; 0x1a
    398a:	9f 5f       	subi	r25, 0xFF	; 255
    398c:	9f 73       	andi	r25, 0x3F	; 63
    398e:	92 8f       	std	Z+26, r25	; 0x1a
    3990:	90 e0       	ldi	r25, 0x00	; 0
    3992:	08 95       	ret
    3994:	8f ef       	ldi	r24, 0xFF	; 255
    3996:	9f ef       	ldi	r25, 0xFF	; 255
    3998:	08 95       	ret

0000399a <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
}

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
    399a:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
    399c:	84 8d       	ldd	r24, Z+28	; 0x1c
    399e:	df 01       	movw	r26, r30
    39a0:	a8 0f       	add	r26, r24
    39a2:	b1 1d       	adc	r27, r1
    39a4:	a3 5a       	subi	r26, 0xA3	; 163
    39a6:	bf 4f       	sbci	r27, 0xFF	; 255
    39a8:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
    39aa:	84 8d       	ldd	r24, Z+28	; 0x1c
    39ac:	90 e0       	ldi	r25, 0x00	; 0
    39ae:	01 96       	adiw	r24, 0x01	; 1
    39b0:	8f 73       	andi	r24, 0x3F	; 63
    39b2:	90 78       	andi	r25, 0x80	; 128
    39b4:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
    39b6:	a6 89       	ldd	r26, Z+22	; 0x16
    39b8:	b7 89       	ldd	r27, Z+23	; 0x17
    39ba:	2c 93       	st	X, r18

  // clear the TXC bit -- "can be cleared by writing a one to its bit
  // location". This makes sure flush() won't return until the bytes
  // actually got written
  sbi(*_ucsra, TXC0);
    39bc:	a0 89       	ldd	r26, Z+16	; 0x10
    39be:	b1 89       	ldd	r27, Z+17	; 0x11
    39c0:	8c 91       	ld	r24, X
    39c2:	80 64       	ori	r24, 0x40	; 64
    39c4:	8c 93       	st	X, r24

  if (_tx_buffer_head == _tx_buffer_tail) {
    39c6:	93 8d       	ldd	r25, Z+27	; 0x1b
    39c8:	84 8d       	ldd	r24, Z+28	; 0x1c
    39ca:	98 13       	cpse	r25, r24
    39cc:	06 c0       	rjmp	.+12     	; 0x39da <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x40>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
    39ce:	02 88       	ldd	r0, Z+18	; 0x12
    39d0:	f3 89       	ldd	r31, Z+19	; 0x13
    39d2:	e0 2d       	mov	r30, r0
    39d4:	80 81       	ld	r24, Z
    39d6:	8f 7d       	andi	r24, 0xDF	; 223
    39d8:	80 83       	st	Z, r24
    39da:	08 95       	ret

000039dc <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
    39dc:	cf 93       	push	r28
    39de:	df 93       	push	r29
    39e0:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    39e2:	88 8d       	ldd	r24, Y+24	; 0x18
    39e4:	81 11       	cpse	r24, r1
    39e6:	0a c0       	rjmp	.+20     	; 0x39fc <_ZN14HardwareSerial5flushEv+0x20>
    39e8:	1a c0       	rjmp	.+52     	; 0x3a1e <_ZN14HardwareSerial5flushEv+0x42>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
    39ea:	0f b6       	in	r0, 0x3f	; 63
    39ec:	07 fc       	sbrc	r0, 7
    39ee:	08 c0       	rjmp	.+16     	; 0x3a00 <_ZN14HardwareSerial5flushEv+0x24>
    39f0:	80 81       	ld	r24, Z
    39f2:	85 ff       	sbrs	r24, 5
    39f4:	05 c0       	rjmp	.+10     	; 0x3a00 <_ZN14HardwareSerial5flushEv+0x24>
    39f6:	0d c0       	rjmp	.+26     	; 0x3a12 <_ZN14HardwareSerial5flushEv+0x36>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
	  _tx_udr_empty_irq();
    39f8:	ce 01       	movw	r24, r28
    39fa:	cf df       	rcall	.-98     	; 0x399a <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    39fc:	ea 89       	ldd	r30, Y+18	; 0x12
    39fe:	fb 89       	ldd	r31, Y+19	; 0x13
    3a00:	80 81       	ld	r24, Z
    3a02:	85 fd       	sbrc	r24, 5
    3a04:	f2 cf       	rjmp	.-28     	; 0x39ea <_ZN14HardwareSerial5flushEv+0xe>
    3a06:	a8 89       	ldd	r26, Y+16	; 0x10
    3a08:	b9 89       	ldd	r27, Y+17	; 0x11
    3a0a:	8c 91       	ld	r24, X
    3a0c:	86 ff       	sbrs	r24, 6
    3a0e:	ed cf       	rjmp	.-38     	; 0x39ea <_ZN14HardwareSerial5flushEv+0xe>
    3a10:	06 c0       	rjmp	.+12     	; 0x3a1e <_ZN14HardwareSerial5flushEv+0x42>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
    3a12:	a8 89       	ldd	r26, Y+16	; 0x10
    3a14:	b9 89       	ldd	r27, Y+17	; 0x11
    3a16:	8c 91       	ld	r24, X
    3a18:	85 ff       	sbrs	r24, 5
    3a1a:	f2 cf       	rjmp	.-28     	; 0x3a00 <_ZN14HardwareSerial5flushEv+0x24>
    3a1c:	ed cf       	rjmp	.-38     	; 0x39f8 <_ZN14HardwareSerial5flushEv+0x1c>
	  _tx_udr_empty_irq();
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
    3a1e:	df 91       	pop	r29
    3a20:	cf 91       	pop	r28
    3a22:	08 95       	ret

00003a24 <_ZN14HardwareSerial5writeEh>:

size_t HardwareSerial::write(uint8_t c)
{
    3a24:	0f 93       	push	r16
    3a26:	1f 93       	push	r17
    3a28:	cf 93       	push	r28
    3a2a:	df 93       	push	r29
    3a2c:	ec 01       	movw	r28, r24
    3a2e:	16 2f       	mov	r17, r22
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    3a30:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3a32:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3a34:	98 13       	cpse	r25, r24
    3a36:	23 c0       	rjmp	.+70     	; 0x3a7e <_ZN14HardwareSerial5writeEh+0x5a>
    3a38:	e8 89       	ldd	r30, Y+16	; 0x10
    3a3a:	f9 89       	ldd	r31, Y+17	; 0x11
    3a3c:	80 81       	ld	r24, Z
    3a3e:	85 fd       	sbrc	r24, 5
    3a40:	25 c0       	rjmp	.+74     	; 0x3a8c <_ZN14HardwareSerial5writeEh+0x68>
    3a42:	1d c0       	rjmp	.+58     	; 0x3a7e <_ZN14HardwareSerial5writeEh+0x5a>
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    if (bit_is_clear(SREG, SREG_I)) {
    3a44:	0f b6       	in	r0, 0x3f	; 63
    3a46:	07 fc       	sbrc	r0, 7
    3a48:	07 c0       	rjmp	.+14     	; 0x3a58 <_ZN14HardwareSerial5writeEh+0x34>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
    3a4a:	e8 89       	ldd	r30, Y+16	; 0x10
    3a4c:	f9 89       	ldd	r31, Y+17	; 0x11
    3a4e:	80 81       	ld	r24, Z
    3a50:	85 ff       	sbrs	r24, 5
    3a52:	02 c0       	rjmp	.+4      	; 0x3a58 <_ZN14HardwareSerial5writeEh+0x34>
	_tx_udr_empty_irq();
    3a54:	ce 01       	movw	r24, r28
    3a56:	a1 df       	rcall	.-190    	; 0x399a <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    3a58:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3a5a:	09 17       	cp	r16, r25
    3a5c:	99 f3       	breq	.-26     	; 0x3a44 <_ZN14HardwareSerial5writeEh+0x20>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
    3a5e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3a60:	fe 01       	movw	r30, r28
    3a62:	e8 0f       	add	r30, r24
    3a64:	f1 1d       	adc	r31, r1
    3a66:	e3 5a       	subi	r30, 0xA3	; 163
    3a68:	ff 4f       	sbci	r31, 0xFF	; 255
    3a6a:	10 83       	st	Z, r17
  _tx_buffer_head = i;
    3a6c:	0b 8f       	std	Y+27, r16	; 0x1b
	
  sbi(*_ucsrb, UDRIE0);
    3a6e:	ea 89       	ldd	r30, Y+18	; 0x12
    3a70:	fb 89       	ldd	r31, Y+19	; 0x13
    3a72:	80 81       	ld	r24, Z
    3a74:	80 62       	ori	r24, 0x20	; 32
    3a76:	80 83       	st	Z, r24
  _written = true;
    3a78:	81 e0       	ldi	r24, 0x01	; 1
    3a7a:	88 8f       	std	Y+24, r24	; 0x18
  
  return 1;
    3a7c:	0f c0       	rjmp	.+30     	; 0x3a9c <_ZN14HardwareSerial5writeEh+0x78>
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    *_udr = c;
    sbi(*_ucsra, TXC0);
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
    3a7e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3a80:	90 e0       	ldi	r25, 0x00	; 0
    3a82:	01 96       	adiw	r24, 0x01	; 1
    3a84:	8f 73       	andi	r24, 0x3F	; 63
    3a86:	90 78       	andi	r25, 0x80	; 128
    3a88:	08 2f       	mov	r16, r24
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    3a8a:	e6 cf       	rjmp	.-52     	; 0x3a58 <_ZN14HardwareSerial5writeEh+0x34>
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    *_udr = c;
    3a8c:	ee 89       	ldd	r30, Y+22	; 0x16
    3a8e:	ff 89       	ldd	r31, Y+23	; 0x17
    3a90:	60 83       	st	Z, r22
    sbi(*_ucsra, TXC0);
    3a92:	e8 89       	ldd	r30, Y+16	; 0x10
    3a94:	f9 89       	ldd	r31, Y+17	; 0x11
    3a96:	80 81       	ld	r24, Z
    3a98:	80 64       	ori	r24, 0x40	; 64
    3a9a:	80 83       	st	Z, r24
	
  sbi(*_ucsrb, UDRIE0);
  _written = true;
  
  return 1;
}
    3a9c:	81 e0       	ldi	r24, 0x01	; 1
    3a9e:	90 e0       	ldi	r25, 0x00	; 0
    3aa0:	df 91       	pop	r29
    3aa2:	cf 91       	pop	r28
    3aa4:	1f 91       	pop	r17
    3aa6:	0f 91       	pop	r16
    3aa8:	08 95       	ret

00003aaa <_ZN14HardwareSerial5beginEmh>:
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
    3aaa:	cf 92       	push	r12
    3aac:	df 92       	push	r13
    3aae:	ef 92       	push	r14
    3ab0:	ff 92       	push	r15
    3ab2:	1f 93       	push	r17
    3ab4:	cf 93       	push	r28
    3ab6:	df 93       	push	r29
    3ab8:	ec 01       	movw	r28, r24
    3aba:	6a 01       	movw	r12, r20
    3abc:	7b 01       	movw	r14, r22
    3abe:	12 2f       	mov	r17, r18
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
    3ac0:	e8 89       	ldd	r30, Y+16	; 0x10
    3ac2:	f9 89       	ldd	r31, Y+17	; 0x11
    3ac4:	82 e0       	ldi	r24, 0x02	; 2
    3ac6:	80 83       	st	Z, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    3ac8:	41 15       	cp	r20, r1
    3aca:	81 ee       	ldi	r24, 0xE1	; 225
    3acc:	58 07       	cpc	r21, r24
    3ace:	61 05       	cpc	r22, r1
    3ad0:	71 05       	cpc	r23, r1
    3ad2:	a9 f0       	breq	.+42     	; 0x3afe <_ZN14HardwareSerial5beginEmh+0x54>
// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
    3ad4:	60 e0       	ldi	r22, 0x00	; 0
    3ad6:	79 e0       	ldi	r23, 0x09	; 9
    3ad8:	8d e3       	ldi	r24, 0x3D	; 61
    3ada:	90 e0       	ldi	r25, 0x00	; 0
    3adc:	a7 01       	movw	r20, r14
    3ade:	96 01       	movw	r18, r12
    3ae0:	eb d4       	rcall	.+2518   	; 0x44b8 <__udivmodsi4>
    3ae2:	ba 01       	movw	r22, r20
    3ae4:	a9 01       	movw	r20, r18
    3ae6:	41 50       	subi	r20, 0x01	; 1
    3ae8:	51 09       	sbc	r21, r1
    3aea:	61 09       	sbc	r22, r1
    3aec:	71 09       	sbc	r23, r1
    3aee:	76 95       	lsr	r23
    3af0:	67 95       	ror	r22
    3af2:	57 95       	ror	r21
    3af4:	47 95       	ror	r20
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    3af6:	41 15       	cp	r20, r1
    3af8:	80 e1       	ldi	r24, 0x10	; 16
    3afa:	58 07       	cpc	r21, r24
    3afc:	a0 f0       	brcs	.+40     	; 0x3b26 <_ZN14HardwareSerial5beginEmh+0x7c>
  {
    *_ucsra = 0;
    3afe:	e8 89       	ldd	r30, Y+16	; 0x10
    3b00:	f9 89       	ldd	r31, Y+17	; 0x11
    3b02:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
    3b04:	60 e8       	ldi	r22, 0x80	; 128
    3b06:	74 e8       	ldi	r23, 0x84	; 132
    3b08:	8e e1       	ldi	r24, 0x1E	; 30
    3b0a:	90 e0       	ldi	r25, 0x00	; 0
    3b0c:	a7 01       	movw	r20, r14
    3b0e:	96 01       	movw	r18, r12
    3b10:	d3 d4       	rcall	.+2470   	; 0x44b8 <__udivmodsi4>
    3b12:	ba 01       	movw	r22, r20
    3b14:	a9 01       	movw	r20, r18
    3b16:	41 50       	subi	r20, 0x01	; 1
    3b18:	51 09       	sbc	r21, r1
    3b1a:	61 09       	sbc	r22, r1
    3b1c:	71 09       	sbc	r23, r1
    3b1e:	76 95       	lsr	r23
    3b20:	67 95       	ror	r22
    3b22:	57 95       	ror	r21
    3b24:	47 95       	ror	r20
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
    3b26:	ec 85       	ldd	r30, Y+12	; 0x0c
    3b28:	fd 85       	ldd	r31, Y+13	; 0x0d
    3b2a:	50 83       	st	Z, r21
  *_ubrrl = baud_setting;
    3b2c:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b2e:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b30:	40 83       	st	Z, r20

  _written = false;
    3b32:	18 8e       	std	Y+24, r1	; 0x18

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
    3b34:	ec 89       	ldd	r30, Y+20	; 0x14
    3b36:	fd 89       	ldd	r31, Y+21	; 0x15
    3b38:	10 83       	st	Z, r17
  
  sbi(*_ucsrb, RXEN0);
    3b3a:	ea 89       	ldd	r30, Y+18	; 0x12
    3b3c:	fb 89       	ldd	r31, Y+19	; 0x13
    3b3e:	80 81       	ld	r24, Z
    3b40:	80 61       	ori	r24, 0x10	; 16
    3b42:	80 83       	st	Z, r24
  sbi(*_ucsrb, TXEN0);
    3b44:	ea 89       	ldd	r30, Y+18	; 0x12
    3b46:	fb 89       	ldd	r31, Y+19	; 0x13
    3b48:	80 81       	ld	r24, Z
    3b4a:	88 60       	ori	r24, 0x08	; 8
    3b4c:	80 83       	st	Z, r24
  sbi(*_ucsrb, RXCIE0);
    3b4e:	ea 89       	ldd	r30, Y+18	; 0x12
    3b50:	fb 89       	ldd	r31, Y+19	; 0x13
    3b52:	80 81       	ld	r24, Z
    3b54:	80 68       	ori	r24, 0x80	; 128
    3b56:	80 83       	st	Z, r24
  cbi(*_ucsrb, UDRIE0);
    3b58:	ea 89       	ldd	r30, Y+18	; 0x12
    3b5a:	fb 89       	ldd	r31, Y+19	; 0x13
    3b5c:	80 81       	ld	r24, Z
    3b5e:	8f 7d       	andi	r24, 0xDF	; 223
    3b60:	80 83       	st	Z, r24
}
    3b62:	df 91       	pop	r29
    3b64:	cf 91       	pop	r28
    3b66:	1f 91       	pop	r17
    3b68:	ff 90       	pop	r15
    3b6a:	ef 90       	pop	r14
    3b6c:	df 90       	pop	r13
    3b6e:	cf 90       	pop	r12
    3b70:	08 95       	ret

00003b72 <__vector_25>:

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
}
    3b72:	1f 92       	push	r1
    3b74:	0f 92       	push	r0
    3b76:	0f b6       	in	r0, 0x3f	; 63
    3b78:	0f 92       	push	r0
    3b7a:	11 24       	eor	r1, r1
    3b7c:	0b b6       	in	r0, 0x3b	; 59
    3b7e:	0f 92       	push	r0
    3b80:	2f 93       	push	r18
    3b82:	8f 93       	push	r24
    3b84:	9f 93       	push	r25
    3b86:	af 93       	push	r26
    3b88:	bf 93       	push	r27
    3b8a:	ef 93       	push	r30
    3b8c:	ff 93       	push	r31
    3b8e:	e0 91 e6 0e 	lds	r30, 0x0EE6
    3b92:	f0 91 e7 0e 	lds	r31, 0x0EE7
    3b96:	80 81       	ld	r24, Z
    3b98:	82 fd       	sbrc	r24, 2
    3b9a:	17 c0       	rjmp	.+46     	; 0x3bca <__vector_25+0x58>
    3b9c:	e0 91 ec 0e 	lds	r30, 0x0EEC
    3ba0:	f0 91 ed 0e 	lds	r31, 0x0EED
    3ba4:	20 81       	ld	r18, Z
    3ba6:	80 91 ef 0e 	lds	r24, 0x0EEF
    3baa:	8f 5f       	subi	r24, 0xFF	; 255
    3bac:	8f 73       	andi	r24, 0x3F	; 63
    3bae:	90 91 f0 0e 	lds	r25, 0x0EF0
    3bb2:	89 17       	cp	r24, r25
    3bb4:	79 f0       	breq	.+30     	; 0x3bd4 <__vector_25+0x62>
    3bb6:	ef ee       	ldi	r30, 0xEF	; 239
    3bb8:	fe e0       	ldi	r31, 0x0E	; 14
    3bba:	a0 81       	ld	r26, Z
    3bbc:	b0 e0       	ldi	r27, 0x00	; 0
    3bbe:	aa 52       	subi	r26, 0x2A	; 42
    3bc0:	b1 4f       	sbci	r27, 0xF1	; 241
    3bc2:	5d 96       	adiw	r26, 0x1d	; 29
    3bc4:	2c 93       	st	X, r18
    3bc6:	80 83       	st	Z, r24
    3bc8:	05 c0       	rjmp	.+10     	; 0x3bd4 <__vector_25+0x62>
    3bca:	e0 91 ec 0e 	lds	r30, 0x0EEC
    3bce:	f0 91 ed 0e 	lds	r31, 0x0EED
    3bd2:	80 81       	ld	r24, Z
    3bd4:	ff 91       	pop	r31
    3bd6:	ef 91       	pop	r30
    3bd8:	bf 91       	pop	r27
    3bda:	af 91       	pop	r26
    3bdc:	9f 91       	pop	r25
    3bde:	8f 91       	pop	r24
    3be0:	2f 91       	pop	r18
    3be2:	0f 90       	pop	r0
    3be4:	0b be       	out	0x3b, r0	; 59
    3be6:	0f 90       	pop	r0
    3be8:	0f be       	out	0x3f, r0	; 63
    3bea:	0f 90       	pop	r0
    3bec:	1f 90       	pop	r1
    3bee:	18 95       	reti

00003bf0 <__vector_26>:
    3bf0:	1f 92       	push	r1
    3bf2:	0f 92       	push	r0
    3bf4:	0f b6       	in	r0, 0x3f	; 63
    3bf6:	0f 92       	push	r0
    3bf8:	11 24       	eor	r1, r1
    3bfa:	0b b6       	in	r0, 0x3b	; 59
    3bfc:	0f 92       	push	r0
    3bfe:	2f 93       	push	r18
    3c00:	3f 93       	push	r19
    3c02:	4f 93       	push	r20
    3c04:	5f 93       	push	r21
    3c06:	6f 93       	push	r22
    3c08:	7f 93       	push	r23
    3c0a:	8f 93       	push	r24
    3c0c:	9f 93       	push	r25
    3c0e:	af 93       	push	r26
    3c10:	bf 93       	push	r27
    3c12:	ef 93       	push	r30
    3c14:	ff 93       	push	r31
    3c16:	86 ed       	ldi	r24, 0xD6	; 214
    3c18:	9e e0       	ldi	r25, 0x0E	; 14
    3c1a:	bf de       	rcall	.-642    	; 0x399a <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    3c1c:	ff 91       	pop	r31
    3c1e:	ef 91       	pop	r30
    3c20:	bf 91       	pop	r27
    3c22:	af 91       	pop	r26
    3c24:	9f 91       	pop	r25
    3c26:	8f 91       	pop	r24
    3c28:	7f 91       	pop	r23
    3c2a:	6f 91       	pop	r22
    3c2c:	5f 91       	pop	r21
    3c2e:	4f 91       	pop	r20
    3c30:	3f 91       	pop	r19
    3c32:	2f 91       	pop	r18
    3c34:	0f 90       	pop	r0
    3c36:	0b be       	out	0x3b, r0	; 59
    3c38:	0f 90       	pop	r0
    3c3a:	0f be       	out	0x3f, r0	; 63
    3c3c:	0f 90       	pop	r0
    3c3e:	1f 90       	pop	r1
    3c40:	18 95       	reti

00003c42 <_GLOBAL__sub_I___vector_25>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
    3c42:	10 92 d9 0e 	sts	0x0ED9, r1
    3c46:	10 92 d8 0e 	sts	0x0ED8, r1
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
    3c4a:	88 ee       	ldi	r24, 0xE8	; 232
    3c4c:	93 e0       	ldi	r25, 0x03	; 3
    3c4e:	a0 e0       	ldi	r26, 0x00	; 0
    3c50:	b0 e0       	ldi	r27, 0x00	; 0
    3c52:	80 93 da 0e 	sts	0x0EDA, r24
    3c56:	90 93 db 0e 	sts	0x0EDB, r25
    3c5a:	a0 93 dc 0e 	sts	0x0EDC, r26
    3c5e:	b0 93 dd 0e 	sts	0x0EDD, r27
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
    3c62:	8c e0       	ldi	r24, 0x0C	; 12
    3c64:	93 e0       	ldi	r25, 0x03	; 3
    3c66:	90 93 d7 0e 	sts	0x0ED7, r25
    3c6a:	80 93 d6 0e 	sts	0x0ED6, r24
    3c6e:	85 ec       	ldi	r24, 0xC5	; 197
    3c70:	90 e0       	ldi	r25, 0x00	; 0
    3c72:	90 93 e3 0e 	sts	0x0EE3, r25
    3c76:	80 93 e2 0e 	sts	0x0EE2, r24
    3c7a:	84 ec       	ldi	r24, 0xC4	; 196
    3c7c:	90 e0       	ldi	r25, 0x00	; 0
    3c7e:	90 93 e5 0e 	sts	0x0EE5, r25
    3c82:	80 93 e4 0e 	sts	0x0EE4, r24
    3c86:	80 ec       	ldi	r24, 0xC0	; 192
    3c88:	90 e0       	ldi	r25, 0x00	; 0
    3c8a:	90 93 e7 0e 	sts	0x0EE7, r25
    3c8e:	80 93 e6 0e 	sts	0x0EE6, r24
    3c92:	81 ec       	ldi	r24, 0xC1	; 193
    3c94:	90 e0       	ldi	r25, 0x00	; 0
    3c96:	90 93 e9 0e 	sts	0x0EE9, r25
    3c9a:	80 93 e8 0e 	sts	0x0EE8, r24
    3c9e:	82 ec       	ldi	r24, 0xC2	; 194
    3ca0:	90 e0       	ldi	r25, 0x00	; 0
    3ca2:	90 93 eb 0e 	sts	0x0EEB, r25
    3ca6:	80 93 ea 0e 	sts	0x0EEA, r24
    3caa:	86 ec       	ldi	r24, 0xC6	; 198
    3cac:	90 e0       	ldi	r25, 0x00	; 0
    3cae:	90 93 ed 0e 	sts	0x0EED, r25
    3cb2:	80 93 ec 0e 	sts	0x0EEC, r24
    3cb6:	10 92 ef 0e 	sts	0x0EEF, r1
    3cba:	10 92 f0 0e 	sts	0x0EF0, r1
    3cbe:	10 92 f1 0e 	sts	0x0EF1, r1
    3cc2:	10 92 f2 0e 	sts	0x0EF2, r1
    3cc6:	08 95       	ret

00003cc8 <__vector_36>:

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial1_available() {
  return Serial1.available();
}
    3cc8:	1f 92       	push	r1
    3cca:	0f 92       	push	r0
    3ccc:	0f b6       	in	r0, 0x3f	; 63
    3cce:	0f 92       	push	r0
    3cd0:	11 24       	eor	r1, r1
    3cd2:	0b b6       	in	r0, 0x3b	; 59
    3cd4:	0f 92       	push	r0
    3cd6:	2f 93       	push	r18
    3cd8:	8f 93       	push	r24
    3cda:	9f 93       	push	r25
    3cdc:	af 93       	push	r26
    3cde:	bf 93       	push	r27
    3ce0:	ef 93       	push	r30
    3ce2:	ff 93       	push	r31
    3ce4:	e0 91 83 0f 	lds	r30, 0x0F83
    3ce8:	f0 91 84 0f 	lds	r31, 0x0F84
    3cec:	80 81       	ld	r24, Z
    3cee:	82 fd       	sbrc	r24, 2
    3cf0:	17 c0       	rjmp	.+46     	; 0x3d20 <__vector_36+0x58>
    3cf2:	e0 91 89 0f 	lds	r30, 0x0F89
    3cf6:	f0 91 8a 0f 	lds	r31, 0x0F8A
    3cfa:	20 81       	ld	r18, Z
    3cfc:	80 91 8c 0f 	lds	r24, 0x0F8C
    3d00:	8f 5f       	subi	r24, 0xFF	; 255
    3d02:	8f 73       	andi	r24, 0x3F	; 63
    3d04:	90 91 8d 0f 	lds	r25, 0x0F8D
    3d08:	89 17       	cp	r24, r25
    3d0a:	79 f0       	breq	.+30     	; 0x3d2a <__vector_36+0x62>
    3d0c:	ec e8       	ldi	r30, 0x8C	; 140
    3d0e:	ff e0       	ldi	r31, 0x0F	; 15
    3d10:	a0 81       	ld	r26, Z
    3d12:	b0 e0       	ldi	r27, 0x00	; 0
    3d14:	ad 58       	subi	r26, 0x8D	; 141
    3d16:	b0 4f       	sbci	r27, 0xF0	; 240
    3d18:	5d 96       	adiw	r26, 0x1d	; 29
    3d1a:	2c 93       	st	X, r18
    3d1c:	80 83       	st	Z, r24
    3d1e:	05 c0       	rjmp	.+10     	; 0x3d2a <__vector_36+0x62>
    3d20:	e0 91 89 0f 	lds	r30, 0x0F89
    3d24:	f0 91 8a 0f 	lds	r31, 0x0F8A
    3d28:	80 81       	ld	r24, Z
    3d2a:	ff 91       	pop	r31
    3d2c:	ef 91       	pop	r30
    3d2e:	bf 91       	pop	r27
    3d30:	af 91       	pop	r26
    3d32:	9f 91       	pop	r25
    3d34:	8f 91       	pop	r24
    3d36:	2f 91       	pop	r18
    3d38:	0f 90       	pop	r0
    3d3a:	0b be       	out	0x3b, r0	; 59
    3d3c:	0f 90       	pop	r0
    3d3e:	0f be       	out	0x3f, r0	; 63
    3d40:	0f 90       	pop	r0
    3d42:	1f 90       	pop	r1
    3d44:	18 95       	reti

00003d46 <__vector_37>:
    3d46:	1f 92       	push	r1
    3d48:	0f 92       	push	r0
    3d4a:	0f b6       	in	r0, 0x3f	; 63
    3d4c:	0f 92       	push	r0
    3d4e:	11 24       	eor	r1, r1
    3d50:	0b b6       	in	r0, 0x3b	; 59
    3d52:	0f 92       	push	r0
    3d54:	2f 93       	push	r18
    3d56:	3f 93       	push	r19
    3d58:	4f 93       	push	r20
    3d5a:	5f 93       	push	r21
    3d5c:	6f 93       	push	r22
    3d5e:	7f 93       	push	r23
    3d60:	8f 93       	push	r24
    3d62:	9f 93       	push	r25
    3d64:	af 93       	push	r26
    3d66:	bf 93       	push	r27
    3d68:	ef 93       	push	r30
    3d6a:	ff 93       	push	r31
    3d6c:	83 e7       	ldi	r24, 0x73	; 115
    3d6e:	9f e0       	ldi	r25, 0x0F	; 15
    3d70:	14 de       	rcall	.-984    	; 0x399a <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    3d72:	ff 91       	pop	r31
    3d74:	ef 91       	pop	r30
    3d76:	bf 91       	pop	r27
    3d78:	af 91       	pop	r26
    3d7a:	9f 91       	pop	r25
    3d7c:	8f 91       	pop	r24
    3d7e:	7f 91       	pop	r23
    3d80:	6f 91       	pop	r22
    3d82:	5f 91       	pop	r21
    3d84:	4f 91       	pop	r20
    3d86:	3f 91       	pop	r19
    3d88:	2f 91       	pop	r18
    3d8a:	0f 90       	pop	r0
    3d8c:	0b be       	out	0x3b, r0	; 59
    3d8e:	0f 90       	pop	r0
    3d90:	0f be       	out	0x3f, r0	; 63
    3d92:	0f 90       	pop	r0
    3d94:	1f 90       	pop	r1
    3d96:	18 95       	reti

00003d98 <_GLOBAL__sub_I___vector_36>:
    3d98:	10 92 76 0f 	sts	0x0F76, r1
    3d9c:	10 92 75 0f 	sts	0x0F75, r1
    3da0:	88 ee       	ldi	r24, 0xE8	; 232
    3da2:	93 e0       	ldi	r25, 0x03	; 3
    3da4:	a0 e0       	ldi	r26, 0x00	; 0
    3da6:	b0 e0       	ldi	r27, 0x00	; 0
    3da8:	80 93 77 0f 	sts	0x0F77, r24
    3dac:	90 93 78 0f 	sts	0x0F78, r25
    3db0:	a0 93 79 0f 	sts	0x0F79, r26
    3db4:	b0 93 7a 0f 	sts	0x0F7A, r27
    3db8:	8c e0       	ldi	r24, 0x0C	; 12
    3dba:	93 e0       	ldi	r25, 0x03	; 3
    3dbc:	90 93 74 0f 	sts	0x0F74, r25
    3dc0:	80 93 73 0f 	sts	0x0F73, r24
    3dc4:	8d ec       	ldi	r24, 0xCD	; 205
    3dc6:	90 e0       	ldi	r25, 0x00	; 0
    3dc8:	90 93 80 0f 	sts	0x0F80, r25
    3dcc:	80 93 7f 0f 	sts	0x0F7F, r24
    3dd0:	8c ec       	ldi	r24, 0xCC	; 204
    3dd2:	90 e0       	ldi	r25, 0x00	; 0
    3dd4:	90 93 82 0f 	sts	0x0F82, r25
    3dd8:	80 93 81 0f 	sts	0x0F81, r24
    3ddc:	88 ec       	ldi	r24, 0xC8	; 200
    3dde:	90 e0       	ldi	r25, 0x00	; 0
    3de0:	90 93 84 0f 	sts	0x0F84, r25
    3de4:	80 93 83 0f 	sts	0x0F83, r24
    3de8:	89 ec       	ldi	r24, 0xC9	; 201
    3dea:	90 e0       	ldi	r25, 0x00	; 0
    3dec:	90 93 86 0f 	sts	0x0F86, r25
    3df0:	80 93 85 0f 	sts	0x0F85, r24
    3df4:	8a ec       	ldi	r24, 0xCA	; 202
    3df6:	90 e0       	ldi	r25, 0x00	; 0
    3df8:	90 93 88 0f 	sts	0x0F88, r25
    3dfc:	80 93 87 0f 	sts	0x0F87, r24
    3e00:	8e ec       	ldi	r24, 0xCE	; 206
    3e02:	90 e0       	ldi	r25, 0x00	; 0
    3e04:	90 93 8a 0f 	sts	0x0F8A, r25
    3e08:	80 93 89 0f 	sts	0x0F89, r24
    3e0c:	10 92 8c 0f 	sts	0x0F8C, r1
    3e10:	10 92 8d 0f 	sts	0x0F8D, r1
    3e14:	10 92 8e 0f 	sts	0x0F8E, r1
    3e18:	10 92 8f 0f 	sts	0x0F8F, r1
    3e1c:	08 95       	ret

00003e1e <_ZN5Print5writeEPKhj>:
size_t Print::println(const String &s)
{
  size_t n = print(s);
  n += println();
  return n;
}
    3e1e:	cf 92       	push	r12
    3e20:	df 92       	push	r13
    3e22:	ef 92       	push	r14
    3e24:	ff 92       	push	r15
    3e26:	0f 93       	push	r16
    3e28:	1f 93       	push	r17
    3e2a:	cf 93       	push	r28
    3e2c:	df 93       	push	r29
    3e2e:	6c 01       	movw	r12, r24
    3e30:	41 15       	cp	r20, r1
    3e32:	51 05       	cpc	r21, r1
    3e34:	b1 f0       	breq	.+44     	; 0x3e62 <_ZN5Print5writeEPKhj+0x44>
    3e36:	06 2f       	mov	r16, r22
    3e38:	17 2f       	mov	r17, r23
    3e3a:	ea 01       	movw	r28, r20
    3e3c:	e1 2c       	mov	r14, r1
    3e3e:	f1 2c       	mov	r15, r1
    3e40:	d8 01       	movw	r26, r16
    3e42:	6d 91       	ld	r22, X+
    3e44:	8d 01       	movw	r16, r26
    3e46:	d6 01       	movw	r26, r12
    3e48:	ed 91       	ld	r30, X+
    3e4a:	fc 91       	ld	r31, X
    3e4c:	01 90       	ld	r0, Z+
    3e4e:	f0 81       	ld	r31, Z
    3e50:	e0 2d       	mov	r30, r0
    3e52:	c6 01       	movw	r24, r12
    3e54:	19 95       	eicall
    3e56:	e8 0e       	add	r14, r24
    3e58:	f9 1e       	adc	r15, r25
    3e5a:	21 97       	sbiw	r28, 0x01	; 1
    3e5c:	20 97       	sbiw	r28, 0x00	; 0
    3e5e:	81 f7       	brne	.-32     	; 0x3e40 <_ZN5Print5writeEPKhj+0x22>
    3e60:	02 c0       	rjmp	.+4      	; 0x3e66 <_ZN5Print5writeEPKhj+0x48>
    3e62:	e1 2c       	mov	r14, r1
    3e64:	f1 2c       	mov	r15, r1
    3e66:	c7 01       	movw	r24, r14
    3e68:	df 91       	pop	r29
    3e6a:	cf 91       	pop	r28
    3e6c:	1f 91       	pop	r17
    3e6e:	0f 91       	pop	r16
    3e70:	ff 90       	pop	r15
    3e72:	ef 90       	pop	r14
    3e74:	df 90       	pop	r13
    3e76:	cf 90       	pop	r12
    3e78:	08 95       	ret

00003e7a <_ZN5Print5printEPKc>:
    3e7a:	61 15       	cp	r22, r1
    3e7c:	71 05       	cpc	r23, r1
    3e7e:	81 f0       	breq	.+32     	; 0x3ea0 <_ZN5Print5printEPKc+0x26>
    3e80:	fb 01       	movw	r30, r22
    3e82:	01 90       	ld	r0, Z+
    3e84:	00 20       	and	r0, r0
    3e86:	e9 f7       	brne	.-6      	; 0x3e82 <_ZN5Print5printEPKc+0x8>
    3e88:	31 97       	sbiw	r30, 0x01	; 1
    3e8a:	af 01       	movw	r20, r30
    3e8c:	46 1b       	sub	r20, r22
    3e8e:	57 0b       	sbc	r21, r23
    3e90:	dc 01       	movw	r26, r24
    3e92:	ed 91       	ld	r30, X+
    3e94:	fc 91       	ld	r31, X
    3e96:	02 80       	ldd	r0, Z+2	; 0x02
    3e98:	f3 81       	ldd	r31, Z+3	; 0x03
    3e9a:	e0 2d       	mov	r30, r0
    3e9c:	19 95       	eicall
    3e9e:	08 95       	ret
    3ea0:	80 e0       	ldi	r24, 0x00	; 0
    3ea2:	90 e0       	ldi	r25, 0x00	; 0
    3ea4:	08 95       	ret

00003ea6 <_ZN5Print5printEc>:
    3ea6:	dc 01       	movw	r26, r24
    3ea8:	ed 91       	ld	r30, X+
    3eaa:	fc 91       	ld	r31, X
    3eac:	01 90       	ld	r0, Z+
    3eae:	f0 81       	ld	r31, Z
    3eb0:	e0 2d       	mov	r30, r0
    3eb2:	19 95       	eicall
    3eb4:	08 95       	ret

00003eb6 <_ZN5Print7printlnEv>:
    3eb6:	0f 93       	push	r16
    3eb8:	1f 93       	push	r17
    3eba:	cf 93       	push	r28
    3ebc:	df 93       	push	r29
    3ebe:	ec 01       	movw	r28, r24
    3ec0:	6d e0       	ldi	r22, 0x0D	; 13
    3ec2:	f1 df       	rcall	.-30     	; 0x3ea6 <_ZN5Print5printEc>
    3ec4:	8c 01       	movw	r16, r24
    3ec6:	6a e0       	ldi	r22, 0x0A	; 10
    3ec8:	ce 01       	movw	r24, r28
    3eca:	ed df       	rcall	.-38     	; 0x3ea6 <_ZN5Print5printEc>
    3ecc:	80 0f       	add	r24, r16
    3ece:	91 1f       	adc	r25, r17
    3ed0:	df 91       	pop	r29
    3ed2:	cf 91       	pop	r28
    3ed4:	1f 91       	pop	r17
    3ed6:	0f 91       	pop	r16
    3ed8:	08 95       	ret

00003eda <_ZN5Print7printlnEPKc>:

size_t Print::println(const char c[])
{
    3eda:	0f 93       	push	r16
    3edc:	1f 93       	push	r17
    3ede:	cf 93       	push	r28
    3ee0:	df 93       	push	r29
    3ee2:	ec 01       	movw	r28, r24
  size_t n = print(c);
    3ee4:	ca df       	rcall	.-108    	; 0x3e7a <_ZN5Print5printEPKc>
    3ee6:	8c 01       	movw	r16, r24
  n += println();
    3ee8:	ce 01       	movw	r24, r28
    3eea:	e5 df       	rcall	.-54     	; 0x3eb6 <_ZN5Print7printlnEv>
  return n;
}
    3eec:	80 0f       	add	r24, r16
    3eee:	91 1f       	adc	r25, r17
    3ef0:	df 91       	pop	r29
    3ef2:	cf 91       	pop	r28
    3ef4:	1f 91       	pop	r17
    3ef6:	0f 91       	pop	r16
    3ef8:	08 95       	ret

00003efa <__vector_23>:
#if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
    3efa:	1f 92       	push	r1
    3efc:	0f 92       	push	r0
    3efe:	0f b6       	in	r0, 0x3f	; 63
    3f00:	0f 92       	push	r0
    3f02:	11 24       	eor	r1, r1
    3f04:	2f 93       	push	r18
    3f06:	3f 93       	push	r19
    3f08:	8f 93       	push	r24
    3f0a:	9f 93       	push	r25
    3f0c:	af 93       	push	r26
    3f0e:	bf 93       	push	r27
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
    3f10:	80 91 11 10 	lds	r24, 0x1011
    3f14:	90 91 12 10 	lds	r25, 0x1012
    3f18:	a0 91 13 10 	lds	r26, 0x1013
    3f1c:	b0 91 14 10 	lds	r27, 0x1014
	unsigned char f = timer0_fract;
    3f20:	30 91 10 10 	lds	r19, 0x1010

	m += MILLIS_INC;
	f += FRACT_INC;
    3f24:	23 e0       	ldi	r18, 0x03	; 3
    3f26:	23 0f       	add	r18, r19
	if (f >= FRACT_MAX) {
    3f28:	2d 37       	cpi	r18, 0x7D	; 125
    3f2a:	20 f4       	brcc	.+8      	; 0x3f34 <__vector_23+0x3a>
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
    3f2c:	01 96       	adiw	r24, 0x01	; 1
    3f2e:	a1 1d       	adc	r26, r1
    3f30:	b1 1d       	adc	r27, r1
    3f32:	05 c0       	rjmp	.+10     	; 0x3f3e <__vector_23+0x44>
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
    3f34:	26 e8       	ldi	r18, 0x86	; 134
    3f36:	23 0f       	add	r18, r19
		m += 1;
    3f38:	02 96       	adiw	r24, 0x02	; 2
    3f3a:	a1 1d       	adc	r26, r1
    3f3c:	b1 1d       	adc	r27, r1
	}

	timer0_fract = f;
    3f3e:	20 93 10 10 	sts	0x1010, r18
	timer0_millis = m;
    3f42:	80 93 11 10 	sts	0x1011, r24
    3f46:	90 93 12 10 	sts	0x1012, r25
    3f4a:	a0 93 13 10 	sts	0x1013, r26
    3f4e:	b0 93 14 10 	sts	0x1014, r27
	timer0_overflow_count++;
    3f52:	80 91 15 10 	lds	r24, 0x1015
    3f56:	90 91 16 10 	lds	r25, 0x1016
    3f5a:	a0 91 17 10 	lds	r26, 0x1017
    3f5e:	b0 91 18 10 	lds	r27, 0x1018
    3f62:	01 96       	adiw	r24, 0x01	; 1
    3f64:	a1 1d       	adc	r26, r1
    3f66:	b1 1d       	adc	r27, r1
    3f68:	80 93 15 10 	sts	0x1015, r24
    3f6c:	90 93 16 10 	sts	0x1016, r25
    3f70:	a0 93 17 10 	sts	0x1017, r26
    3f74:	b0 93 18 10 	sts	0x1018, r27
}
    3f78:	bf 91       	pop	r27
    3f7a:	af 91       	pop	r26
    3f7c:	9f 91       	pop	r25
    3f7e:	8f 91       	pop	r24
    3f80:	3f 91       	pop	r19
    3f82:	2f 91       	pop	r18
    3f84:	0f 90       	pop	r0
    3f86:	0f be       	out	0x3f, r0	; 63
    3f88:	0f 90       	pop	r0
    3f8a:	1f 90       	pop	r1
    3f8c:	18 95       	reti

00003f8e <millis>:

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
    3f8e:	2f b7       	in	r18, 0x3f	; 63

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
    3f90:	f8 94       	cli
	m = timer0_millis;
    3f92:	60 91 11 10 	lds	r22, 0x1011
    3f96:	70 91 12 10 	lds	r23, 0x1012
    3f9a:	80 91 13 10 	lds	r24, 0x1013
    3f9e:	90 91 14 10 	lds	r25, 0x1014
	SREG = oldSREG;
    3fa2:	2f bf       	out	0x3f, r18	; 63

	return m;
}
    3fa4:	08 95       	ret

00003fa6 <micros>:

unsigned long micros() {
	unsigned long m;
	uint8_t oldSREG = SREG, t;
    3fa6:	3f b7       	in	r19, 0x3f	; 63
	
	cli();
    3fa8:	f8 94       	cli
	m = timer0_overflow_count;
    3faa:	80 91 15 10 	lds	r24, 0x1015
    3fae:	90 91 16 10 	lds	r25, 0x1016
    3fb2:	a0 91 17 10 	lds	r26, 0x1017
    3fb6:	b0 91 18 10 	lds	r27, 0x1018
#if defined(TCNT0)
	t = TCNT0;
    3fba:	26 b5       	in	r18, 0x26	; 38
	#error TIMER 0 not defined
#endif

  
#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
    3fbc:	a8 9b       	sbis	0x15, 0	; 21
    3fbe:	05 c0       	rjmp	.+10     	; 0x3fca <micros+0x24>
    3fc0:	2f 3f       	cpi	r18, 0xFF	; 255
    3fc2:	19 f0       	breq	.+6      	; 0x3fca <micros+0x24>
		m++;
    3fc4:	01 96       	adiw	r24, 0x01	; 1
    3fc6:	a1 1d       	adc	r26, r1
    3fc8:	b1 1d       	adc	r27, r1
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
    3fca:	3f bf       	out	0x3f, r19	; 63
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
    3fcc:	ba 2f       	mov	r27, r26
    3fce:	a9 2f       	mov	r26, r25
    3fd0:	98 2f       	mov	r25, r24
    3fd2:	88 27       	eor	r24, r24
    3fd4:	82 0f       	add	r24, r18
    3fd6:	91 1d       	adc	r25, r1
    3fd8:	a1 1d       	adc	r26, r1
    3fda:	b1 1d       	adc	r27, r1
    3fdc:	bc 01       	movw	r22, r24
    3fde:	cd 01       	movw	r24, r26
    3fe0:	66 0f       	add	r22, r22
    3fe2:	77 1f       	adc	r23, r23
    3fe4:	88 1f       	adc	r24, r24
    3fe6:	99 1f       	adc	r25, r25
    3fe8:	66 0f       	add	r22, r22
    3fea:	77 1f       	adc	r23, r23
    3fec:	88 1f       	adc	r24, r24
    3fee:	99 1f       	adc	r25, r25
}
    3ff0:	08 95       	ret

00003ff2 <delay>:

void delay(unsigned long ms)
{
    3ff2:	cf 92       	push	r12
    3ff4:	df 92       	push	r13
    3ff6:	ef 92       	push	r14
    3ff8:	ff 92       	push	r15
    3ffa:	cf 93       	push	r28
    3ffc:	df 93       	push	r29
    3ffe:	6b 01       	movw	r12, r22
    4000:	7c 01       	movw	r14, r24
	uint16_t start = (uint16_t)micros();
    4002:	d1 df       	rcall	.-94     	; 0x3fa6 <micros>
    4004:	eb 01       	movw	r28, r22

	while (ms > 0) {
    4006:	c1 14       	cp	r12, r1
    4008:	d1 04       	cpc	r13, r1
    400a:	e1 04       	cpc	r14, r1
    400c:	f1 04       	cpc	r15, r1
    400e:	99 f0       	breq	.+38     	; 0x4036 <delay+0x44>
		yield();
    4010:	43 d2       	rcall	.+1158   	; 0x4498 <yield>
		if (((uint16_t)micros() - start) >= 1000) {
    4012:	c9 df       	rcall	.-110    	; 0x3fa6 <micros>
    4014:	6c 1b       	sub	r22, r28
    4016:	7d 0b       	sbc	r23, r29
    4018:	68 3e       	cpi	r22, 0xE8	; 232
    401a:	73 40       	sbci	r23, 0x03	; 3
    401c:	38 f0       	brcs	.+14     	; 0x402c <delay+0x3a>
			ms--;
    401e:	81 e0       	ldi	r24, 0x01	; 1
    4020:	c8 1a       	sub	r12, r24
    4022:	d1 08       	sbc	r13, r1
    4024:	e1 08       	sbc	r14, r1
    4026:	f1 08       	sbc	r15, r1
			start += 1000;
    4028:	c8 51       	subi	r28, 0x18	; 24
    402a:	dc 4f       	sbci	r29, 0xFC	; 252

void delay(unsigned long ms)
{
	uint16_t start = (uint16_t)micros();

	while (ms > 0) {
    402c:	c1 14       	cp	r12, r1
    402e:	d1 04       	cpc	r13, r1
    4030:	e1 04       	cpc	r14, r1
    4032:	f1 04       	cpc	r15, r1
    4034:	69 f7       	brne	.-38     	; 0x4010 <delay+0x1e>
		if (((uint16_t)micros() - start) >= 1000) {
			ms--;
			start += 1000;
		}
	}
}
    4036:	df 91       	pop	r29
    4038:	cf 91       	pop	r28
    403a:	ff 90       	pop	r15
    403c:	ef 90       	pop	r14
    403e:	df 90       	pop	r13
    4040:	cf 90       	pop	r12
    4042:	08 95       	ret

00004044 <delayMicroseconds>:
#elif F_CPU >= 16000000L
	// for the 16 MHz clock on most Arduino boards

	// for a one-microsecond delay, simply return.  the overhead
	// of the function call yields a delay of approximately 1 1/8 us.
	if (--us == 0)
    4044:	01 97       	sbiw	r24, 0x01	; 1
    4046:	00 97       	sbiw	r24, 0x00	; 0
    4048:	39 f0       	breq	.+14     	; 0x4058 <delayMicroseconds+0x14>
		return;

	// the following loop takes a quarter of a microsecond (4 cycles)
	// per iteration, so execute it four times for each microsecond of
	// delay requested.
	us <<= 2;
    404a:	88 0f       	add	r24, r24
    404c:	99 1f       	adc	r25, r25
    404e:	88 0f       	add	r24, r24
    4050:	99 1f       	adc	r25, r25

	// account for the time taken in the preceeding commands.
	us -= 2;
    4052:	02 97       	sbiw	r24, 0x02	; 2
	// we can't subtract any more than this or we'd overflow w/ small delays.
	us--;
#endif

	// busy wait
	__asm__ __volatile__ (
    4054:	01 97       	sbiw	r24, 0x01	; 1
    4056:	f1 f7       	brne	.-4      	; 0x4054 <delayMicroseconds+0x10>
    4058:	08 95       	ret

0000405a <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
    405a:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
    405c:	84 b5       	in	r24, 0x24	; 36
    405e:	82 60       	ori	r24, 0x02	; 2
    4060:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
    4062:	84 b5       	in	r24, 0x24	; 36
    4064:	81 60       	ori	r24, 0x01	; 1
    4066:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
    4068:	85 b5       	in	r24, 0x25	; 37
    406a:	82 60       	ori	r24, 0x02	; 2
    406c:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
    406e:	85 b5       	in	r24, 0x25	; 37
    4070:	81 60       	ori	r24, 0x01	; 1
    4072:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
    4074:	ee e6       	ldi	r30, 0x6E	; 110
    4076:	f0 e0       	ldi	r31, 0x00	; 0
    4078:	80 81       	ld	r24, Z
    407a:	81 60       	ori	r24, 0x01	; 1
    407c:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
    407e:	e1 e8       	ldi	r30, 0x81	; 129
    4080:	f0 e0       	ldi	r31, 0x00	; 0
    4082:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
    4084:	80 81       	ld	r24, Z
    4086:	82 60       	ori	r24, 0x02	; 2
    4088:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
    408a:	80 81       	ld	r24, Z
    408c:	81 60       	ori	r24, 0x01	; 1
    408e:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
    4090:	e0 e8       	ldi	r30, 0x80	; 128
    4092:	f0 e0       	ldi	r31, 0x00	; 0
    4094:	80 81       	ld	r24, Z
    4096:	81 60       	ori	r24, 0x01	; 1
    4098:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
    409a:	e1 eb       	ldi	r30, 0xB1	; 177
    409c:	f0 e0       	ldi	r31, 0x00	; 0
    409e:	80 81       	ld	r24, Z
    40a0:	84 60       	ori	r24, 0x04	; 4
    40a2:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
    40a4:	e0 eb       	ldi	r30, 0xB0	; 176
    40a6:	f0 e0       	ldi	r31, 0x00	; 0
    40a8:	80 81       	ld	r24, Z
    40aa:	81 60       	ori	r24, 0x01	; 1
    40ac:	80 83       	st	Z, r24
#else
	#warning Timer 2 not finished (may not be present on this CPU)
#endif

#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
    40ae:	e1 e9       	ldi	r30, 0x91	; 145
    40b0:	f0 e0       	ldi	r31, 0x00	; 0
    40b2:	80 81       	ld	r24, Z
    40b4:	82 60       	ori	r24, 0x02	; 2
    40b6:	80 83       	st	Z, r24
	sbi(TCCR3B, CS30);
    40b8:	80 81       	ld	r24, Z
    40ba:	81 60       	ori	r24, 0x01	; 1
    40bc:	80 83       	st	Z, r24
	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
    40be:	e0 e9       	ldi	r30, 0x90	; 144
    40c0:	f0 e0       	ldi	r31, 0x00	; 0
    40c2:	80 81       	ld	r24, Z
    40c4:	81 60       	ori	r24, 0x01	; 1
    40c6:	80 83       	st	Z, r24
	sbi(TCCR4D, WGM40);		// put timer 4 in phase- and frequency-correct PWM mode	
	sbi(TCCR4A, PWM4A);		// enable PWM mode for comparator OCR4A
	sbi(TCCR4C, PWM4D);		// enable PWM mode for comparator OCR4D
#else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */
#if defined(TCCR4B) && defined(CS41) && defined(WGM40)
	sbi(TCCR4B, CS41);		// set timer 4 prescale factor to 64
    40c8:	e1 ea       	ldi	r30, 0xA1	; 161
    40ca:	f0 e0       	ldi	r31, 0x00	; 0
    40cc:	80 81       	ld	r24, Z
    40ce:	82 60       	ori	r24, 0x02	; 2
    40d0:	80 83       	st	Z, r24
	sbi(TCCR4B, CS40);
    40d2:	80 81       	ld	r24, Z
    40d4:	81 60       	ori	r24, 0x01	; 1
    40d6:	80 83       	st	Z, r24
	sbi(TCCR4A, WGM40);		// put timer 4 in 8-bit phase correct pwm mode
    40d8:	e0 ea       	ldi	r30, 0xA0	; 160
    40da:	f0 e0       	ldi	r31, 0x00	; 0
    40dc:	80 81       	ld	r24, Z
    40de:	81 60       	ori	r24, 0x01	; 1
    40e0:	80 83       	st	Z, r24
#endif
#endif /* end timer4 block for ATMEGA1280/2560 and similar */	

#if defined(TCCR5B) && defined(CS51) && defined(WGM50)
	sbi(TCCR5B, CS51);		// set timer 5 prescale factor to 64
    40e2:	e1 e2       	ldi	r30, 0x21	; 33
    40e4:	f1 e0       	ldi	r31, 0x01	; 1
    40e6:	80 81       	ld	r24, Z
    40e8:	82 60       	ori	r24, 0x02	; 2
    40ea:	80 83       	st	Z, r24
	sbi(TCCR5B, CS50);
    40ec:	80 81       	ld	r24, Z
    40ee:	81 60       	ori	r24, 0x01	; 1
    40f0:	80 83       	st	Z, r24
	sbi(TCCR5A, WGM50);		// put timer 5 in 8-bit phase correct pwm mode
    40f2:	e0 e2       	ldi	r30, 0x20	; 32
    40f4:	f1 e0       	ldi	r31, 0x01	; 1
    40f6:	80 81       	ld	r24, Z
    40f8:	81 60       	ori	r24, 0x01	; 1
    40fa:	80 83       	st	Z, r24
#if defined(ADCSRA)
	// set a2d prescale factor to 128
	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
	// XXX: this will not work properly for other clock speeds, and
	// this code should use F_CPU to determine the prescale factor.
	sbi(ADCSRA, ADPS2);
    40fc:	ea e7       	ldi	r30, 0x7A	; 122
    40fe:	f0 e0       	ldi	r31, 0x00	; 0
    4100:	80 81       	ld	r24, Z
    4102:	84 60       	ori	r24, 0x04	; 4
    4104:	80 83       	st	Z, r24
	sbi(ADCSRA, ADPS1);
    4106:	80 81       	ld	r24, Z
    4108:	82 60       	ori	r24, 0x02	; 2
    410a:	80 83       	st	Z, r24
	sbi(ADCSRA, ADPS0);
    410c:	80 81       	ld	r24, Z
    410e:	81 60       	ori	r24, 0x01	; 1
    4110:	80 83       	st	Z, r24

	// enable a2d conversions
	sbi(ADCSRA, ADEN);
    4112:	80 81       	ld	r24, Z
    4114:	80 68       	ori	r24, 0x80	; 128
    4116:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
    4118:	10 92 c1 00 	sts	0x00C1, r1
    411c:	08 95       	ret

0000411e <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
    411e:	90 e0       	ldi	r25, 0x00	; 0
    4120:	fc 01       	movw	r30, r24
    4122:	31 97       	sbiw	r30, 0x01	; 1
    4124:	e2 31       	cpi	r30, 0x12	; 18
    4126:	f1 05       	cpc	r31, r1
    4128:	08 f0       	brcs	.+2      	; 0x412c <turnOffPWM+0xe>
    412a:	5e c0       	rjmp	.+188    	; 0x41e8 <turnOffPWM+0xca>
    412c:	ee 5a       	subi	r30, 0xAE	; 174
    412e:	fe 4f       	sbci	r31, 0xFE	; 254
    4130:	e5 c1       	rjmp	.+970    	; 0x44fc <__tablejump2__>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
    4132:	e0 e8       	ldi	r30, 0x80	; 128
    4134:	f0 e0       	ldi	r31, 0x00	; 0
    4136:	80 81       	ld	r24, Z
    4138:	8f 77       	andi	r24, 0x7F	; 127
    413a:	80 83       	st	Z, r24
    413c:	08 95       	ret
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    413e:	e0 e8       	ldi	r30, 0x80	; 128
    4140:	f0 e0       	ldi	r31, 0x00	; 0
    4142:	80 81       	ld	r24, Z
    4144:	8f 7d       	andi	r24, 0xDF	; 223
    4146:	80 83       	st	Z, r24
    4148:	08 95       	ret
		#endif
		#if defined(TCCR1A) && defined(COM1C1)
		case TIMER1C:   cbi(TCCR1A, COM1C1);    break;
    414a:	e0 e8       	ldi	r30, 0x80	; 128
    414c:	f0 e0       	ldi	r31, 0x00	; 0
    414e:	80 81       	ld	r24, Z
    4150:	87 7f       	andi	r24, 0xF7	; 247
    4152:	80 83       	st	Z, r24
    4154:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
    4156:	84 b5       	in	r24, 0x24	; 36
    4158:	8f 77       	andi	r24, 0x7F	; 127
    415a:	84 bd       	out	0x24, r24	; 36
    415c:	08 95       	ret
		#endif
		
		#if defined(TIMER0B) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
    415e:	84 b5       	in	r24, 0x24	; 36
    4160:	8f 7d       	andi	r24, 0xDF	; 223
    4162:	84 bd       	out	0x24, r24	; 36
    4164:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
    4166:	e0 eb       	ldi	r30, 0xB0	; 176
    4168:	f0 e0       	ldi	r31, 0x00	; 0
    416a:	80 81       	ld	r24, Z
    416c:	8f 77       	andi	r24, 0x7F	; 127
    416e:	80 83       	st	Z, r24
    4170:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
    4172:	e0 eb       	ldi	r30, 0xB0	; 176
    4174:	f0 e0       	ldi	r31, 0x00	; 0
    4176:	80 81       	ld	r24, Z
    4178:	8f 7d       	andi	r24, 0xDF	; 223
    417a:	80 83       	st	Z, r24
    417c:	08 95       	ret
		#endif
		
		#if defined(TCCR3A) && defined(COM3A1)
		case  TIMER3A:  cbi(TCCR3A, COM3A1);    break;
    417e:	e0 e9       	ldi	r30, 0x90	; 144
    4180:	f0 e0       	ldi	r31, 0x00	; 0
    4182:	80 81       	ld	r24, Z
    4184:	8f 77       	andi	r24, 0x7F	; 127
    4186:	80 83       	st	Z, r24
    4188:	08 95       	ret
		#endif
		#if defined(TCCR3A) && defined(COM3B1)
		case  TIMER3B:  cbi(TCCR3A, COM3B1);    break;
    418a:	e0 e9       	ldi	r30, 0x90	; 144
    418c:	f0 e0       	ldi	r31, 0x00	; 0
    418e:	80 81       	ld	r24, Z
    4190:	8f 7d       	andi	r24, 0xDF	; 223
    4192:	80 83       	st	Z, r24
    4194:	08 95       	ret
		#endif
		#if defined(TCCR3A) && defined(COM3C1)
		case  TIMER3C:  cbi(TCCR3A, COM3C1);    break;
    4196:	e0 e9       	ldi	r30, 0x90	; 144
    4198:	f0 e0       	ldi	r31, 0x00	; 0
    419a:	80 81       	ld	r24, Z
    419c:	87 7f       	andi	r24, 0xF7	; 247
    419e:	80 83       	st	Z, r24
    41a0:	08 95       	ret
		#endif

		#if defined(TCCR4A) && defined(COM4A1)
		case  TIMER4A:  cbi(TCCR4A, COM4A1);    break;
    41a2:	e0 ea       	ldi	r30, 0xA0	; 160
    41a4:	f0 e0       	ldi	r31, 0x00	; 0
    41a6:	80 81       	ld	r24, Z
    41a8:	8f 77       	andi	r24, 0x7F	; 127
    41aa:	80 83       	st	Z, r24
    41ac:	08 95       	ret
		#endif					
		#if defined(TCCR4A) && defined(COM4B1)
		case  TIMER4B:  cbi(TCCR4A, COM4B1);    break;
    41ae:	e0 ea       	ldi	r30, 0xA0	; 160
    41b0:	f0 e0       	ldi	r31, 0x00	; 0
    41b2:	80 81       	ld	r24, Z
    41b4:	8f 7d       	andi	r24, 0xDF	; 223
    41b6:	80 83       	st	Z, r24
    41b8:	08 95       	ret
		#endif
		#if defined(TCCR4A) && defined(COM4C1)
		case  TIMER4C:  cbi(TCCR4A, COM4C1);    break;
    41ba:	e0 ea       	ldi	r30, 0xA0	; 160
    41bc:	f0 e0       	ldi	r31, 0x00	; 0
    41be:	80 81       	ld	r24, Z
    41c0:	87 7f       	andi	r24, 0xF7	; 247
    41c2:	80 83       	st	Z, r24
    41c4:	08 95       	ret
		#if defined(TCCR4C) && defined(COM4D1)
		case TIMER4D:	cbi(TCCR4C, COM4D1);	break;
		#endif			
			
		#if defined(TCCR5A)
		case  TIMER5A:  cbi(TCCR5A, COM5A1);    break;
    41c6:	e0 e2       	ldi	r30, 0x20	; 32
    41c8:	f1 e0       	ldi	r31, 0x01	; 1
    41ca:	80 81       	ld	r24, Z
    41cc:	8f 77       	andi	r24, 0x7F	; 127
    41ce:	80 83       	st	Z, r24
    41d0:	08 95       	ret
		case  TIMER5B:  cbi(TCCR5A, COM5B1);    break;
    41d2:	e0 e2       	ldi	r30, 0x20	; 32
    41d4:	f1 e0       	ldi	r31, 0x01	; 1
    41d6:	80 81       	ld	r24, Z
    41d8:	8f 7d       	andi	r24, 0xDF	; 223
    41da:	80 83       	st	Z, r24
    41dc:	08 95       	ret
		case  TIMER5C:  cbi(TCCR5A, COM5C1);    break;
    41de:	e0 e2       	ldi	r30, 0x20	; 32
    41e0:	f1 e0       	ldi	r31, 0x01	; 1
    41e2:	80 81       	ld	r24, Z
    41e4:	87 7f       	andi	r24, 0xF7	; 247
    41e6:	80 83       	st	Z, r24
    41e8:	08 95       	ret

000041ea <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
    41ea:	cf 93       	push	r28
    41ec:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
    41ee:	90 e0       	ldi	r25, 0x00	; 0
    41f0:	fc 01       	movw	r30, r24
    41f2:	e2 5f       	subi	r30, 0xF2	; 242
    41f4:	fc 4f       	sbci	r31, 0xFC	; 252
    41f6:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
    41f8:	fc 01       	movw	r30, r24
    41fa:	ec 5a       	subi	r30, 0xAC	; 172
    41fc:	fc 4f       	sbci	r31, 0xFC	; 252
    41fe:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
    4200:	88 23       	and	r24, r24
    4202:	71 f1       	breq	.+92     	; 0x4260 <pinMode+0x76>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
    4204:	90 e0       	ldi	r25, 0x00	; 0
    4206:	88 0f       	add	r24, r24
    4208:	99 1f       	adc	r25, r25
    420a:	fc 01       	movw	r30, r24
    420c:	e2 53       	subi	r30, 0x32	; 50
    420e:	fc 4f       	sbci	r31, 0xFC	; 252
    4210:	a5 91       	lpm	r26, Z+
    4212:	b4 91       	lpm	r27, Z
	out = portOutputRegister(port);
    4214:	8c 54       	subi	r24, 0x4C	; 76
    4216:	9c 4f       	sbci	r25, 0xFC	; 252
    4218:	fc 01       	movw	r30, r24
    421a:	c5 91       	lpm	r28, Z+
    421c:	d4 91       	lpm	r29, Z

	if (mode == INPUT) { 
    421e:	61 11       	cpse	r22, r1
    4220:	0b c0       	rjmp	.+22     	; 0x4238 <pinMode+0x4e>
		uint8_t oldSREG = SREG;
    4222:	8f b7       	in	r24, 0x3f	; 63
                cli();
    4224:	f8 94       	cli
		*reg &= ~bit;
    4226:	9c 91       	ld	r25, X
    4228:	20 95       	com	r18
    422a:	92 23       	and	r25, r18
    422c:	9c 93       	st	X, r25
		*out &= ~bit;
    422e:	e8 81       	ld	r30, Y
    4230:	2e 23       	and	r18, r30
    4232:	28 83       	st	Y, r18
		SREG = oldSREG;
    4234:	8f bf       	out	0x3f, r24	; 63
    4236:	14 c0       	rjmp	.+40     	; 0x4260 <pinMode+0x76>
	} else if (mode == INPUT_PULLUP) {
    4238:	62 30       	cpi	r22, 0x02	; 2
    423a:	61 f4       	brne	.+24     	; 0x4254 <pinMode+0x6a>
		uint8_t oldSREG = SREG;
    423c:	8f b7       	in	r24, 0x3f	; 63
                cli();
    423e:	f8 94       	cli
		*reg &= ~bit;
    4240:	3c 91       	ld	r19, X
    4242:	92 2f       	mov	r25, r18
    4244:	90 95       	com	r25
    4246:	93 23       	and	r25, r19
    4248:	9c 93       	st	X, r25
		*out |= bit;
    424a:	e8 81       	ld	r30, Y
    424c:	2e 2b       	or	r18, r30
    424e:	28 83       	st	Y, r18
		SREG = oldSREG;
    4250:	8f bf       	out	0x3f, r24	; 63
    4252:	06 c0       	rjmp	.+12     	; 0x4260 <pinMode+0x76>
	} else {
		uint8_t oldSREG = SREG;
    4254:	8f b7       	in	r24, 0x3f	; 63
                cli();
    4256:	f8 94       	cli
		*reg |= bit;
    4258:	ec 91       	ld	r30, X
    425a:	2e 2b       	or	r18, r30
    425c:	2c 93       	st	X, r18
		SREG = oldSREG;
    425e:	8f bf       	out	0x3f, r24	; 63
	}
}
    4260:	df 91       	pop	r29
    4262:	cf 91       	pop	r28
    4264:	08 95       	ret

00004266 <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
    4266:	1f 93       	push	r17
    4268:	cf 93       	push	r28
    426a:	df 93       	push	r29
    426c:	c6 2f       	mov	r28, r22
	uint8_t timer = digitalPinToTimer(pin);
    426e:	28 2f       	mov	r18, r24
    4270:	30 e0       	ldi	r19, 0x00	; 0
    4272:	f9 01       	movw	r30, r18
    4274:	e8 53       	subi	r30, 0x38	; 56
    4276:	fd 4f       	sbci	r31, 0xFD	; 253
    4278:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
    427a:	f9 01       	movw	r30, r18
    427c:	e2 5f       	subi	r30, 0xF2	; 242
    427e:	fc 4f       	sbci	r31, 0xFC	; 252
    4280:	14 91       	lpm	r17, Z
	uint8_t port = digitalPinToPort(pin);
    4282:	f9 01       	movw	r30, r18
    4284:	ec 5a       	subi	r30, 0xAC	; 172
    4286:	fc 4f       	sbci	r31, 0xFC	; 252
    4288:	d4 91       	lpm	r29, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
    428a:	dd 23       	and	r29, r29
    428c:	c1 f0       	breq	.+48     	; 0x42be <digitalWrite+0x58>

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    428e:	81 11       	cpse	r24, r1
    4290:	46 df       	rcall	.-372    	; 0x411e <turnOffPWM>

	out = portOutputRegister(port);
    4292:	2d 2f       	mov	r18, r29
    4294:	30 e0       	ldi	r19, 0x00	; 0
    4296:	f9 01       	movw	r30, r18
    4298:	ee 0f       	add	r30, r30
    429a:	ff 1f       	adc	r31, r31
    429c:	ec 54       	subi	r30, 0x4C	; 76
    429e:	fc 4f       	sbci	r31, 0xFC	; 252
    42a0:	a5 91       	lpm	r26, Z+
    42a2:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
    42a4:	8f b7       	in	r24, 0x3f	; 63
	cli();
    42a6:	f8 94       	cli

	if (val == LOW) {
    42a8:	c1 11       	cpse	r28, r1
    42aa:	05 c0       	rjmp	.+10     	; 0x42b6 <digitalWrite+0x50>
		*out &= ~bit;
    42ac:	ec 91       	ld	r30, X
    42ae:	10 95       	com	r17
    42b0:	1e 23       	and	r17, r30
    42b2:	1c 93       	st	X, r17
    42b4:	03 c0       	rjmp	.+6      	; 0x42bc <digitalWrite+0x56>
	} else {
		*out |= bit;
    42b6:	ec 91       	ld	r30, X
    42b8:	1e 2b       	or	r17, r30
    42ba:	1c 93       	st	X, r17
	}

	SREG = oldSREG;
    42bc:	8f bf       	out	0x3f, r24	; 63
}
    42be:	df 91       	pop	r29
    42c0:	cf 91       	pop	r28
    42c2:	1f 91       	pop	r17
    42c4:	08 95       	ret

000042c6 <digitalRead>:

int digitalRead(uint8_t pin)
{
    42c6:	cf 93       	push	r28
    42c8:	df 93       	push	r29
	uint8_t timer = digitalPinToTimer(pin);
    42ca:	28 2f       	mov	r18, r24
    42cc:	30 e0       	ldi	r19, 0x00	; 0
    42ce:	f9 01       	movw	r30, r18
    42d0:	e8 53       	subi	r30, 0x38	; 56
    42d2:	fd 4f       	sbci	r31, 0xFD	; 253
    42d4:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
    42d6:	f9 01       	movw	r30, r18
    42d8:	e2 5f       	subi	r30, 0xF2	; 242
    42da:	fc 4f       	sbci	r31, 0xFC	; 252
    42dc:	d4 91       	lpm	r29, Z
	uint8_t port = digitalPinToPort(pin);
    42de:	f9 01       	movw	r30, r18
    42e0:	ec 5a       	subi	r30, 0xAC	; 172
    42e2:	fc 4f       	sbci	r31, 0xFC	; 252
    42e4:	c4 91       	lpm	r28, Z

	if (port == NOT_A_PIN) return LOW;
    42e6:	cc 23       	and	r28, r28
    42e8:	91 f0       	breq	.+36     	; 0x430e <digitalRead+0x48>

	// If the pin that support PWM output, we need to turn it off
	// before getting a digital reading.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    42ea:	81 11       	cpse	r24, r1
    42ec:	18 df       	rcall	.-464    	; 0x411e <turnOffPWM>

	if (*portInputRegister(port) & bit) return HIGH;
    42ee:	2c 2f       	mov	r18, r28
    42f0:	30 e0       	ldi	r19, 0x00	; 0
    42f2:	f9 01       	movw	r30, r18
    42f4:	ee 0f       	add	r30, r30
    42f6:	ff 1f       	adc	r31, r31
    42f8:	e6 56       	subi	r30, 0x66	; 102
    42fa:	fc 4f       	sbci	r31, 0xFC	; 252
    42fc:	a5 91       	lpm	r26, Z+
    42fe:	b4 91       	lpm	r27, Z
    4300:	ec 91       	ld	r30, X
    4302:	de 23       	and	r29, r30
    4304:	81 e0       	ldi	r24, 0x01	; 1
    4306:	90 e0       	ldi	r25, 0x00	; 0
    4308:	21 f4       	brne	.+8      	; 0x4312 <digitalRead+0x4c>
    430a:	80 e0       	ldi	r24, 0x00	; 0
    430c:	02 c0       	rjmp	.+4      	; 0x4312 <digitalRead+0x4c>
{
	uint8_t timer = digitalPinToTimer(pin);
	uint8_t bit = digitalPinToBitMask(pin);
	uint8_t port = digitalPinToPort(pin);

	if (port == NOT_A_PIN) return LOW;
    430e:	80 e0       	ldi	r24, 0x00	; 0
    4310:	90 e0       	ldi	r25, 0x00	; 0
	// before getting a digital reading.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	if (*portInputRegister(port) & bit) return HIGH;
	return LOW;
}
    4312:	df 91       	pop	r29
    4314:	cf 91       	pop	r28
    4316:	08 95       	ret

00004318 <pulseIn>:
/* Measures the length (in microseconds) of a pulse on the pin; state is HIGH
 * or LOW, the type of pulse to measure.  Works on pulses from 2-3 microseconds
 * to 3 minutes in length, but must be called at least a few dozen microseconds
 * before the start of the pulse. */
unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout)
{
    4318:	af 92       	push	r10
    431a:	bf 92       	push	r11
    431c:	cf 92       	push	r12
    431e:	df 92       	push	r13
    4320:	ef 92       	push	r14
    4322:	ff 92       	push	r15
    4324:	0f 93       	push	r16
    4326:	1f 93       	push	r17
    4328:	cf 93       	push	r28
    432a:	df 93       	push	r29
	// cache the port and bit of the pin in order to speed up the
	// pulse width measuring loop and achieve finer resolution.  calling
	// digitalRead() instead yields much coarser resolution.
	uint8_t bit = digitalPinToBitMask(pin);
    432c:	90 e0       	ldi	r25, 0x00	; 0
    432e:	fc 01       	movw	r30, r24
    4330:	e2 5f       	subi	r30, 0xF2	; 242
    4332:	fc 4f       	sbci	r31, 0xFC	; 252
    4334:	b4 90       	lpm	r11, Z
	uint8_t port = digitalPinToPort(pin);
    4336:	fc 01       	movw	r30, r24
    4338:	ec 5a       	subi	r30, 0xAC	; 172
    433a:	fc 4f       	sbci	r31, 0xFC	; 252
    433c:	c4 91       	lpm	r28, Z
	uint8_t stateMask = (state ? bit : 0);
    433e:	61 11       	cpse	r22, r1
    4340:	02 c0       	rjmp	.+4      	; 0x4346 <pulseIn+0x2e>
    4342:	a1 2c       	mov	r10, r1
    4344:	01 c0       	rjmp	.+2      	; 0x4348 <pulseIn+0x30>
    4346:	ab 2c       	mov	r10, r11
	unsigned long width = 0; // keep initialization out of time critical area
	
	// convert the timeout from microseconds to a number of times through
	// the initial loop; it takes 16 clock cycles per iteration.
	unsigned long numloops = 0;
	unsigned long maxloops = microsecondsToClockCycles(timeout) / 16;
    4348:	89 01       	movw	r16, r18
    434a:	9a 01       	movw	r18, r20
    434c:	3f 70       	andi	r19, 0x0F	; 15
	
	// wait for any previous pulse to end
	while ((*portInputRegister(port) & bit) == stateMask)
    434e:	d0 e0       	ldi	r29, 0x00	; 0
    4350:	cc 0f       	add	r28, r28
    4352:	dd 1f       	adc	r29, r29
    4354:	c6 56       	subi	r28, 0x66	; 102
    4356:	dc 4f       	sbci	r29, 0xFC	; 252
	uint8_t stateMask = (state ? bit : 0);
	unsigned long width = 0; // keep initialization out of time critical area
	
	// convert the timeout from microseconds to a number of times through
	// the initial loop; it takes 16 clock cycles per iteration.
	unsigned long numloops = 0;
    4358:	80 e0       	ldi	r24, 0x00	; 0
    435a:	90 e0       	ldi	r25, 0x00	; 0
    435c:	dc 01       	movw	r26, r24
	unsigned long maxloops = microsecondsToClockCycles(timeout) / 16;
	
	// wait for any previous pulse to end
	while ((*portInputRegister(port) & bit) == stateMask)
    435e:	0e c0       	rjmp	.+28     	; 0x437c <pulseIn+0x64>
		if (numloops++ == maxloops)
    4360:	ac 01       	movw	r20, r24
    4362:	bd 01       	movw	r22, r26
    4364:	4f 5f       	subi	r20, 0xFF	; 255
    4366:	5f 4f       	sbci	r21, 0xFF	; 255
    4368:	6f 4f       	sbci	r22, 0xFF	; 255
    436a:	7f 4f       	sbci	r23, 0xFF	; 255
    436c:	80 17       	cp	r24, r16
    436e:	91 07       	cpc	r25, r17
    4370:	a2 07       	cpc	r26, r18
    4372:	b3 07       	cpc	r27, r19
    4374:	09 f4       	brne	.+2      	; 0x4378 <pulseIn+0x60>
    4376:	76 c0       	rjmp	.+236    	; 0x4464 <pulseIn+0x14c>
    4378:	db 01       	movw	r26, r22
    437a:	ca 01       	movw	r24, r20
	// the initial loop; it takes 16 clock cycles per iteration.
	unsigned long numloops = 0;
	unsigned long maxloops = microsecondsToClockCycles(timeout) / 16;
	
	// wait for any previous pulse to end
	while ((*portInputRegister(port) & bit) == stateMask)
    437c:	fe 01       	movw	r30, r28
    437e:	45 91       	lpm	r20, Z+
    4380:	54 91       	lpm	r21, Z
    4382:	fa 01       	movw	r30, r20
    4384:	40 81       	ld	r20, Z
    4386:	4b 21       	and	r20, r11
    4388:	a4 16       	cp	r10, r20
    438a:	51 f3       	breq	.-44     	; 0x4360 <pulseIn+0x48>
    438c:	0e c0       	rjmp	.+28     	; 0x43aa <pulseIn+0x92>
		if (numloops++ == maxloops)
			return 0;
	
	// wait for the pulse to start
	while ((*portInputRegister(port) & bit) != stateMask)
		if (numloops++ == maxloops)
    438e:	ac 01       	movw	r20, r24
    4390:	bd 01       	movw	r22, r26
    4392:	4f 5f       	subi	r20, 0xFF	; 255
    4394:	5f 4f       	sbci	r21, 0xFF	; 255
    4396:	6f 4f       	sbci	r22, 0xFF	; 255
    4398:	7f 4f       	sbci	r23, 0xFF	; 255
    439a:	80 17       	cp	r24, r16
    439c:	91 07       	cpc	r25, r17
    439e:	a2 07       	cpc	r26, r18
    43a0:	b3 07       	cpc	r27, r19
    43a2:	09 f4       	brne	.+2      	; 0x43a6 <pulseIn+0x8e>
    43a4:	63 c0       	rjmp	.+198    	; 0x446c <pulseIn+0x154>
    43a6:	db 01       	movw	r26, r22
    43a8:	ca 01       	movw	r24, r20
	while ((*portInputRegister(port) & bit) == stateMask)
		if (numloops++ == maxloops)
			return 0;
	
	// wait for the pulse to start
	while ((*portInputRegister(port) & bit) != stateMask)
    43aa:	fe 01       	movw	r30, r28
    43ac:	45 91       	lpm	r20, Z+
    43ae:	54 91       	lpm	r21, Z
    43b0:	fa 01       	movw	r30, r20
    43b2:	40 81       	ld	r20, Z
    43b4:	4b 21       	and	r20, r11
    43b6:	a4 12       	cpse	r10, r20
    43b8:	ea cf       	rjmp	.-44     	; 0x438e <pulseIn+0x76>
		if (numloops++ == maxloops)
			return 0;
	
	// wait for the pulse to stop
	while ((*portInputRegister(port) & bit) == stateMask) {
    43ba:	fe 01       	movw	r30, r28
    43bc:	45 91       	lpm	r20, Z+
    43be:	54 91       	lpm	r21, Z
    43c0:	fa 01       	movw	r30, r20
    43c2:	40 81       	ld	r20, Z
    43c4:	4b 21       	and	r20, r11
    43c6:	a4 12       	cpse	r10, r20
    43c8:	24 c0       	rjmp	.+72     	; 0x4412 <pulseIn+0xfa>
		if (numloops++ == maxloops)
    43ca:	80 17       	cp	r24, r16
    43cc:	91 07       	cpc	r25, r17
    43ce:	a2 07       	cpc	r26, r18
    43d0:	b3 07       	cpc	r27, r19
    43d2:	09 f4       	brne	.+2      	; 0x43d6 <pulseIn+0xbe>
    43d4:	4f c0       	rjmp	.+158    	; 0x4474 <pulseIn+0x15c>
    43d6:	c1 2c       	mov	r12, r1
    43d8:	d1 2c       	mov	r13, r1
    43da:	76 01       	movw	r14, r12
    43dc:	0c c0       	rjmp	.+24     	; 0x43f6 <pulseIn+0xde>
    43de:	ac 01       	movw	r20, r24
    43e0:	bd 01       	movw	r22, r26
    43e2:	4c 0d       	add	r20, r12
    43e4:	5d 1d       	adc	r21, r13
    43e6:	6e 1d       	adc	r22, r14
    43e8:	7f 1d       	adc	r23, r15
    43ea:	04 17       	cp	r16, r20
    43ec:	15 07       	cpc	r17, r21
    43ee:	26 07       	cpc	r18, r22
    43f0:	37 07       	cpc	r19, r23
    43f2:	09 f4       	brne	.+2      	; 0x43f6 <pulseIn+0xde>
    43f4:	43 c0       	rjmp	.+134    	; 0x447c <pulseIn+0x164>
			return 0;
		width++;
    43f6:	ff ef       	ldi	r31, 0xFF	; 255
    43f8:	cf 1a       	sub	r12, r31
    43fa:	df 0a       	sbc	r13, r31
    43fc:	ef 0a       	sbc	r14, r31
    43fe:	ff 0a       	sbc	r15, r31
	while ((*portInputRegister(port) & bit) != stateMask)
		if (numloops++ == maxloops)
			return 0;
	
	// wait for the pulse to stop
	while ((*portInputRegister(port) & bit) == stateMask) {
    4400:	fe 01       	movw	r30, r28
    4402:	45 91       	lpm	r20, Z+
    4404:	54 91       	lpm	r21, Z
    4406:	fa 01       	movw	r30, r20
    4408:	40 81       	ld	r20, Z
    440a:	4b 21       	and	r20, r11
    440c:	a4 16       	cp	r10, r20
    440e:	39 f3       	breq	.-50     	; 0x43de <pulseIn+0xc6>
    4410:	03 c0       	rjmp	.+6      	; 0x4418 <pulseIn+0x100>
    4412:	c1 2c       	mov	r12, r1
    4414:	d1 2c       	mov	r13, r1
    4416:	76 01       	movw	r14, r12
#if __GNUC__==4 && __GNUC_MINOR__==3 && __GNUC_PATCHLEVEL__==2
	// avr-gcc 4.3.2
	return clockCyclesToMicroseconds(width * 21 + 16);
#elif __GNUC__==4 && __GNUC_MINOR__==8 && __GNUC_PATCHLEVEL__==1
	// avr-gcc 4.8.1
	return clockCyclesToMicroseconds(width * 24 + 16);
    4418:	d7 01       	movw	r26, r14
    441a:	c6 01       	movw	r24, r12
    441c:	88 0f       	add	r24, r24
    441e:	99 1f       	adc	r25, r25
    4420:	aa 1f       	adc	r26, r26
    4422:	bb 1f       	adc	r27, r27
    4424:	c8 0e       	add	r12, r24
    4426:	d9 1e       	adc	r13, r25
    4428:	ea 1e       	adc	r14, r26
    442a:	fb 1e       	adc	r15, r27
    442c:	d7 01       	movw	r26, r14
    442e:	c6 01       	movw	r24, r12
    4430:	88 0f       	add	r24, r24
    4432:	99 1f       	adc	r25, r25
    4434:	aa 1f       	adc	r26, r26
    4436:	bb 1f       	adc	r27, r27
    4438:	88 0f       	add	r24, r24
    443a:	99 1f       	adc	r25, r25
    443c:	aa 1f       	adc	r26, r26
    443e:	bb 1f       	adc	r27, r27
    4440:	88 0f       	add	r24, r24
    4442:	99 1f       	adc	r25, r25
    4444:	aa 1f       	adc	r26, r26
    4446:	bb 1f       	adc	r27, r27
    4448:	40 96       	adiw	r24, 0x10	; 16
    444a:	a1 1d       	adc	r26, r1
    444c:	b1 1d       	adc	r27, r1
    444e:	bc 01       	movw	r22, r24
    4450:	cd 01       	movw	r24, r26
    4452:	68 94       	set
    4454:	13 f8       	bld	r1, 3
    4456:	96 95       	lsr	r25
    4458:	87 95       	ror	r24
    445a:	77 95       	ror	r23
    445c:	67 95       	ror	r22
    445e:	16 94       	lsr	r1
    4460:	d1 f7       	brne	.-12     	; 0x4456 <pulseIn+0x13e>
    4462:	0f c0       	rjmp	.+30     	; 0x4482 <pulseIn+0x16a>
	unsigned long maxloops = microsecondsToClockCycles(timeout) / 16;
	
	// wait for any previous pulse to end
	while ((*portInputRegister(port) & bit) == stateMask)
		if (numloops++ == maxloops)
			return 0;
    4464:	60 e0       	ldi	r22, 0x00	; 0
    4466:	70 e0       	ldi	r23, 0x00	; 0
    4468:	cb 01       	movw	r24, r22
    446a:	0b c0       	rjmp	.+22     	; 0x4482 <pulseIn+0x16a>
	
	// wait for the pulse to start
	while ((*portInputRegister(port) & bit) != stateMask)
		if (numloops++ == maxloops)
			return 0;
    446c:	60 e0       	ldi	r22, 0x00	; 0
    446e:	70 e0       	ldi	r23, 0x00	; 0
    4470:	cb 01       	movw	r24, r22
    4472:	07 c0       	rjmp	.+14     	; 0x4482 <pulseIn+0x16a>
	
	// wait for the pulse to stop
	while ((*portInputRegister(port) & bit) == stateMask) {
		if (numloops++ == maxloops)
			return 0;
    4474:	60 e0       	ldi	r22, 0x00	; 0
    4476:	70 e0       	ldi	r23, 0x00	; 0
    4478:	cb 01       	movw	r24, r22
    447a:	03 c0       	rjmp	.+6      	; 0x4482 <pulseIn+0x16a>
    447c:	60 e0       	ldi	r22, 0x00	; 0
    447e:	70 e0       	ldi	r23, 0x00	; 0
    4480:	cb 01       	movw	r24, r22
	// avr-gcc >4.3.x
	#warning "pulseIn() results may not be accurate"
	return clockCyclesToMicroseconds(width * 24 + 16);
#endif

}
    4482:	df 91       	pop	r29
    4484:	cf 91       	pop	r28
    4486:	1f 91       	pop	r17
    4488:	0f 91       	pop	r16
    448a:	ff 90       	pop	r15
    448c:	ef 90       	pop	r14
    448e:	df 90       	pop	r13
    4490:	cf 90       	pop	r12
    4492:	bf 90       	pop	r11
    4494:	af 90       	pop	r10
    4496:	08 95       	ret

00004498 <yield>:
 * libraries or sketches that supports cooperative threads.
 *
 * Its defined as a weak symbol and it can be redefined to implement a
 * real cooperative scheduler.
 */
static void __empty() {
    4498:	08 95       	ret

0000449a <__mulsi3>:
    449a:	db 01       	movw	r26, r22
    449c:	8f 93       	push	r24
    449e:	9f 93       	push	r25
    44a0:	42 d0       	rcall	.+132    	; 0x4526 <__muluhisi3>
    44a2:	bf 91       	pop	r27
    44a4:	af 91       	pop	r26
    44a6:	a2 9f       	mul	r26, r18
    44a8:	80 0d       	add	r24, r0
    44aa:	91 1d       	adc	r25, r1
    44ac:	a3 9f       	mul	r26, r19
    44ae:	90 0d       	add	r25, r0
    44b0:	b2 9f       	mul	r27, r18
    44b2:	90 0d       	add	r25, r0
    44b4:	11 24       	eor	r1, r1
    44b6:	08 95       	ret

000044b8 <__udivmodsi4>:
    44b8:	a1 e2       	ldi	r26, 0x21	; 33
    44ba:	1a 2e       	mov	r1, r26
    44bc:	aa 1b       	sub	r26, r26
    44be:	bb 1b       	sub	r27, r27
    44c0:	fd 01       	movw	r30, r26
    44c2:	0d c0       	rjmp	.+26     	; 0x44de <__udivmodsi4_ep>

000044c4 <__udivmodsi4_loop>:
    44c4:	aa 1f       	adc	r26, r26
    44c6:	bb 1f       	adc	r27, r27
    44c8:	ee 1f       	adc	r30, r30
    44ca:	ff 1f       	adc	r31, r31
    44cc:	a2 17       	cp	r26, r18
    44ce:	b3 07       	cpc	r27, r19
    44d0:	e4 07       	cpc	r30, r20
    44d2:	f5 07       	cpc	r31, r21
    44d4:	20 f0       	brcs	.+8      	; 0x44de <__udivmodsi4_ep>
    44d6:	a2 1b       	sub	r26, r18
    44d8:	b3 0b       	sbc	r27, r19
    44da:	e4 0b       	sbc	r30, r20
    44dc:	f5 0b       	sbc	r31, r21

000044de <__udivmodsi4_ep>:
    44de:	66 1f       	adc	r22, r22
    44e0:	77 1f       	adc	r23, r23
    44e2:	88 1f       	adc	r24, r24
    44e4:	99 1f       	adc	r25, r25
    44e6:	1a 94       	dec	r1
    44e8:	69 f7       	brne	.-38     	; 0x44c4 <__udivmodsi4_loop>
    44ea:	60 95       	com	r22
    44ec:	70 95       	com	r23
    44ee:	80 95       	com	r24
    44f0:	90 95       	com	r25
    44f2:	9b 01       	movw	r18, r22
    44f4:	ac 01       	movw	r20, r24
    44f6:	bd 01       	movw	r22, r26
    44f8:	cf 01       	movw	r24, r30
    44fa:	08 95       	ret

000044fc <__tablejump2__>:
    44fc:	ee 0f       	add	r30, r30
    44fe:	ff 1f       	adc	r31, r31

00004500 <__tablejump__>:
    4500:	05 90       	lpm	r0, Z+
    4502:	f4 91       	lpm	r31, Z
    4504:	e0 2d       	mov	r30, r0
    4506:	19 94       	eijmp

00004508 <__umulhisi3>:
    4508:	a2 9f       	mul	r26, r18
    450a:	b0 01       	movw	r22, r0
    450c:	b3 9f       	mul	r27, r19
    450e:	c0 01       	movw	r24, r0
    4510:	a3 9f       	mul	r26, r19
    4512:	70 0d       	add	r23, r0
    4514:	81 1d       	adc	r24, r1
    4516:	11 24       	eor	r1, r1
    4518:	91 1d       	adc	r25, r1
    451a:	b2 9f       	mul	r27, r18
    451c:	70 0d       	add	r23, r0
    451e:	81 1d       	adc	r24, r1
    4520:	11 24       	eor	r1, r1
    4522:	91 1d       	adc	r25, r1
    4524:	08 95       	ret

00004526 <__muluhisi3>:
    4526:	f0 df       	rcall	.-32     	; 0x4508 <__umulhisi3>
    4528:	a5 9f       	mul	r26, r21
    452a:	90 0d       	add	r25, r0
    452c:	b4 9f       	mul	r27, r20
    452e:	90 0d       	add	r25, r0
    4530:	a4 9f       	mul	r26, r20
    4532:	80 0d       	add	r24, r0
    4534:	91 1d       	adc	r25, r1
    4536:	11 24       	eor	r1, r1
    4538:	08 95       	ret

0000453a <__tablejump_elpm__>:
    453a:	07 90       	elpm	r0, Z+
    453c:	f6 91       	elpm	r31, Z
    453e:	e0 2d       	mov	r30, r0
    4540:	19 94       	eijmp

00004542 <vsprintf>:
    4542:	0f 93       	push	r16
    4544:	1f 93       	push	r17
    4546:	cf 93       	push	r28
    4548:	df 93       	push	r29
    454a:	cd b7       	in	r28, 0x3d	; 61
    454c:	de b7       	in	r29, 0x3e	; 62
    454e:	2e 97       	sbiw	r28, 0x0e	; 14
    4550:	0f b6       	in	r0, 0x3f	; 63
    4552:	f8 94       	cli
    4554:	de bf       	out	0x3e, r29	; 62
    4556:	0f be       	out	0x3f, r0	; 63
    4558:	cd bf       	out	0x3d, r28	; 61
    455a:	8c 01       	movw	r16, r24
    455c:	86 e0       	ldi	r24, 0x06	; 6
    455e:	8c 83       	std	Y+4, r24	; 0x04
    4560:	1a 83       	std	Y+2, r17	; 0x02
    4562:	09 83       	std	Y+1, r16	; 0x01
    4564:	8f ef       	ldi	r24, 0xFF	; 255
    4566:	9f e7       	ldi	r25, 0x7F	; 127
    4568:	9e 83       	std	Y+6, r25	; 0x06
    456a:	8d 83       	std	Y+5, r24	; 0x05
    456c:	ce 01       	movw	r24, r28
    456e:	01 96       	adiw	r24, 0x01	; 1
    4570:	10 d0       	rcall	.+32     	; 0x4592 <vfprintf>
    4572:	ef 81       	ldd	r30, Y+7	; 0x07
    4574:	f8 85       	ldd	r31, Y+8	; 0x08
    4576:	e0 0f       	add	r30, r16
    4578:	f1 1f       	adc	r31, r17
    457a:	10 82       	st	Z, r1
    457c:	2e 96       	adiw	r28, 0x0e	; 14
    457e:	0f b6       	in	r0, 0x3f	; 63
    4580:	f8 94       	cli
    4582:	de bf       	out	0x3e, r29	; 62
    4584:	0f be       	out	0x3f, r0	; 63
    4586:	cd bf       	out	0x3d, r28	; 61
    4588:	df 91       	pop	r29
    458a:	cf 91       	pop	r28
    458c:	1f 91       	pop	r17
    458e:	0f 91       	pop	r16
    4590:	08 95       	ret

00004592 <vfprintf>:
    4592:	2f 92       	push	r2
    4594:	3f 92       	push	r3
    4596:	4f 92       	push	r4
    4598:	5f 92       	push	r5
    459a:	6f 92       	push	r6
    459c:	7f 92       	push	r7
    459e:	8f 92       	push	r8
    45a0:	9f 92       	push	r9
    45a2:	af 92       	push	r10
    45a4:	bf 92       	push	r11
    45a6:	cf 92       	push	r12
    45a8:	df 92       	push	r13
    45aa:	ef 92       	push	r14
    45ac:	ff 92       	push	r15
    45ae:	0f 93       	push	r16
    45b0:	1f 93       	push	r17
    45b2:	cf 93       	push	r28
    45b4:	df 93       	push	r29
    45b6:	cd b7       	in	r28, 0x3d	; 61
    45b8:	de b7       	in	r29, 0x3e	; 62
    45ba:	2c 97       	sbiw	r28, 0x0c	; 12
    45bc:	0f b6       	in	r0, 0x3f	; 63
    45be:	f8 94       	cli
    45c0:	de bf       	out	0x3e, r29	; 62
    45c2:	0f be       	out	0x3f, r0	; 63
    45c4:	cd bf       	out	0x3d, r28	; 61
    45c6:	7c 01       	movw	r14, r24
    45c8:	6b 01       	movw	r12, r22
    45ca:	8a 01       	movw	r16, r20
    45cc:	fc 01       	movw	r30, r24
    45ce:	17 82       	std	Z+7, r1	; 0x07
    45d0:	16 82       	std	Z+6, r1	; 0x06
    45d2:	83 81       	ldd	r24, Z+3	; 0x03
    45d4:	81 ff       	sbrs	r24, 1
    45d6:	b0 c1       	rjmp	.+864    	; 0x4938 <vfprintf+0x3a6>
    45d8:	ce 01       	movw	r24, r28
    45da:	01 96       	adiw	r24, 0x01	; 1
    45dc:	4c 01       	movw	r8, r24
    45de:	f7 01       	movw	r30, r14
    45e0:	93 81       	ldd	r25, Z+3	; 0x03
    45e2:	f6 01       	movw	r30, r12
    45e4:	93 fd       	sbrc	r25, 3
    45e6:	85 91       	lpm	r24, Z+
    45e8:	93 ff       	sbrs	r25, 3
    45ea:	81 91       	ld	r24, Z+
    45ec:	6f 01       	movw	r12, r30
    45ee:	88 23       	and	r24, r24
    45f0:	09 f4       	brne	.+2      	; 0x45f4 <vfprintf+0x62>
    45f2:	9e c1       	rjmp	.+828    	; 0x4930 <vfprintf+0x39e>
    45f4:	85 32       	cpi	r24, 0x25	; 37
    45f6:	39 f4       	brne	.+14     	; 0x4606 <vfprintf+0x74>
    45f8:	93 fd       	sbrc	r25, 3
    45fa:	85 91       	lpm	r24, Z+
    45fc:	93 ff       	sbrs	r25, 3
    45fe:	81 91       	ld	r24, Z+
    4600:	6f 01       	movw	r12, r30
    4602:	85 32       	cpi	r24, 0x25	; 37
    4604:	21 f4       	brne	.+8      	; 0x460e <vfprintf+0x7c>
    4606:	b7 01       	movw	r22, r14
    4608:	90 e0       	ldi	r25, 0x00	; 0
    460a:	c7 d1       	rcall	.+910    	; 0x499a <fputc>
    460c:	e8 cf       	rjmp	.-48     	; 0x45de <vfprintf+0x4c>
    460e:	51 2c       	mov	r5, r1
    4610:	31 2c       	mov	r3, r1
    4612:	20 e0       	ldi	r18, 0x00	; 0
    4614:	20 32       	cpi	r18, 0x20	; 32
    4616:	a0 f4       	brcc	.+40     	; 0x4640 <vfprintf+0xae>
    4618:	8b 32       	cpi	r24, 0x2B	; 43
    461a:	69 f0       	breq	.+26     	; 0x4636 <vfprintf+0xa4>
    461c:	30 f4       	brcc	.+12     	; 0x462a <vfprintf+0x98>
    461e:	80 32       	cpi	r24, 0x20	; 32
    4620:	59 f0       	breq	.+22     	; 0x4638 <vfprintf+0xa6>
    4622:	83 32       	cpi	r24, 0x23	; 35
    4624:	69 f4       	brne	.+26     	; 0x4640 <vfprintf+0xae>
    4626:	20 61       	ori	r18, 0x10	; 16
    4628:	2c c0       	rjmp	.+88     	; 0x4682 <vfprintf+0xf0>
    462a:	8d 32       	cpi	r24, 0x2D	; 45
    462c:	39 f0       	breq	.+14     	; 0x463c <vfprintf+0xaa>
    462e:	80 33       	cpi	r24, 0x30	; 48
    4630:	39 f4       	brne	.+14     	; 0x4640 <vfprintf+0xae>
    4632:	21 60       	ori	r18, 0x01	; 1
    4634:	26 c0       	rjmp	.+76     	; 0x4682 <vfprintf+0xf0>
    4636:	22 60       	ori	r18, 0x02	; 2
    4638:	24 60       	ori	r18, 0x04	; 4
    463a:	23 c0       	rjmp	.+70     	; 0x4682 <vfprintf+0xf0>
    463c:	28 60       	ori	r18, 0x08	; 8
    463e:	21 c0       	rjmp	.+66     	; 0x4682 <vfprintf+0xf0>
    4640:	27 fd       	sbrc	r18, 7
    4642:	27 c0       	rjmp	.+78     	; 0x4692 <vfprintf+0x100>
    4644:	30 ed       	ldi	r19, 0xD0	; 208
    4646:	38 0f       	add	r19, r24
    4648:	3a 30       	cpi	r19, 0x0A	; 10
    464a:	78 f4       	brcc	.+30     	; 0x466a <vfprintf+0xd8>
    464c:	26 ff       	sbrs	r18, 6
    464e:	06 c0       	rjmp	.+12     	; 0x465c <vfprintf+0xca>
    4650:	fa e0       	ldi	r31, 0x0A	; 10
    4652:	5f 9e       	mul	r5, r31
    4654:	30 0d       	add	r19, r0
    4656:	11 24       	eor	r1, r1
    4658:	53 2e       	mov	r5, r19
    465a:	13 c0       	rjmp	.+38     	; 0x4682 <vfprintf+0xf0>
    465c:	8a e0       	ldi	r24, 0x0A	; 10
    465e:	38 9e       	mul	r3, r24
    4660:	30 0d       	add	r19, r0
    4662:	11 24       	eor	r1, r1
    4664:	33 2e       	mov	r3, r19
    4666:	20 62       	ori	r18, 0x20	; 32
    4668:	0c c0       	rjmp	.+24     	; 0x4682 <vfprintf+0xf0>
    466a:	8e 32       	cpi	r24, 0x2E	; 46
    466c:	21 f4       	brne	.+8      	; 0x4676 <vfprintf+0xe4>
    466e:	26 fd       	sbrc	r18, 6
    4670:	5f c1       	rjmp	.+702    	; 0x4930 <vfprintf+0x39e>
    4672:	20 64       	ori	r18, 0x40	; 64
    4674:	06 c0       	rjmp	.+12     	; 0x4682 <vfprintf+0xf0>
    4676:	8c 36       	cpi	r24, 0x6C	; 108
    4678:	11 f4       	brne	.+4      	; 0x467e <vfprintf+0xec>
    467a:	20 68       	ori	r18, 0x80	; 128
    467c:	02 c0       	rjmp	.+4      	; 0x4682 <vfprintf+0xf0>
    467e:	88 36       	cpi	r24, 0x68	; 104
    4680:	41 f4       	brne	.+16     	; 0x4692 <vfprintf+0x100>
    4682:	f6 01       	movw	r30, r12
    4684:	93 fd       	sbrc	r25, 3
    4686:	85 91       	lpm	r24, Z+
    4688:	93 ff       	sbrs	r25, 3
    468a:	81 91       	ld	r24, Z+
    468c:	6f 01       	movw	r12, r30
    468e:	81 11       	cpse	r24, r1
    4690:	c1 cf       	rjmp	.-126    	; 0x4614 <vfprintf+0x82>
    4692:	98 2f       	mov	r25, r24
    4694:	9f 7d       	andi	r25, 0xDF	; 223
    4696:	95 54       	subi	r25, 0x45	; 69
    4698:	93 30       	cpi	r25, 0x03	; 3
    469a:	28 f4       	brcc	.+10     	; 0x46a6 <vfprintf+0x114>
    469c:	0c 5f       	subi	r16, 0xFC	; 252
    469e:	1f 4f       	sbci	r17, 0xFF	; 255
    46a0:	ff e3       	ldi	r31, 0x3F	; 63
    46a2:	f9 83       	std	Y+1, r31	; 0x01
    46a4:	0d c0       	rjmp	.+26     	; 0x46c0 <vfprintf+0x12e>
    46a6:	83 36       	cpi	r24, 0x63	; 99
    46a8:	31 f0       	breq	.+12     	; 0x46b6 <vfprintf+0x124>
    46aa:	83 37       	cpi	r24, 0x73	; 115
    46ac:	71 f0       	breq	.+28     	; 0x46ca <vfprintf+0x138>
    46ae:	83 35       	cpi	r24, 0x53	; 83
    46b0:	09 f0       	breq	.+2      	; 0x46b4 <vfprintf+0x122>
    46b2:	57 c0       	rjmp	.+174    	; 0x4762 <vfprintf+0x1d0>
    46b4:	21 c0       	rjmp	.+66     	; 0x46f8 <vfprintf+0x166>
    46b6:	f8 01       	movw	r30, r16
    46b8:	80 81       	ld	r24, Z
    46ba:	89 83       	std	Y+1, r24	; 0x01
    46bc:	0e 5f       	subi	r16, 0xFE	; 254
    46be:	1f 4f       	sbci	r17, 0xFF	; 255
    46c0:	44 24       	eor	r4, r4
    46c2:	43 94       	inc	r4
    46c4:	51 2c       	mov	r5, r1
    46c6:	54 01       	movw	r10, r8
    46c8:	14 c0       	rjmp	.+40     	; 0x46f2 <vfprintf+0x160>
    46ca:	38 01       	movw	r6, r16
    46cc:	f2 e0       	ldi	r31, 0x02	; 2
    46ce:	6f 0e       	add	r6, r31
    46d0:	71 1c       	adc	r7, r1
    46d2:	f8 01       	movw	r30, r16
    46d4:	a0 80       	ld	r10, Z
    46d6:	b1 80       	ldd	r11, Z+1	; 0x01
    46d8:	26 ff       	sbrs	r18, 6
    46da:	03 c0       	rjmp	.+6      	; 0x46e2 <vfprintf+0x150>
    46dc:	65 2d       	mov	r22, r5
    46de:	70 e0       	ldi	r23, 0x00	; 0
    46e0:	02 c0       	rjmp	.+4      	; 0x46e6 <vfprintf+0x154>
    46e2:	6f ef       	ldi	r22, 0xFF	; 255
    46e4:	7f ef       	ldi	r23, 0xFF	; 255
    46e6:	c5 01       	movw	r24, r10
    46e8:	2c 87       	std	Y+12, r18	; 0x0c
    46ea:	4c d1       	rcall	.+664    	; 0x4984 <strnlen>
    46ec:	2c 01       	movw	r4, r24
    46ee:	83 01       	movw	r16, r6
    46f0:	2c 85       	ldd	r18, Y+12	; 0x0c
    46f2:	2f 77       	andi	r18, 0x7F	; 127
    46f4:	22 2e       	mov	r2, r18
    46f6:	16 c0       	rjmp	.+44     	; 0x4724 <vfprintf+0x192>
    46f8:	38 01       	movw	r6, r16
    46fa:	f2 e0       	ldi	r31, 0x02	; 2
    46fc:	6f 0e       	add	r6, r31
    46fe:	71 1c       	adc	r7, r1
    4700:	f8 01       	movw	r30, r16
    4702:	a0 80       	ld	r10, Z
    4704:	b1 80       	ldd	r11, Z+1	; 0x01
    4706:	26 ff       	sbrs	r18, 6
    4708:	03 c0       	rjmp	.+6      	; 0x4710 <vfprintf+0x17e>
    470a:	65 2d       	mov	r22, r5
    470c:	70 e0       	ldi	r23, 0x00	; 0
    470e:	02 c0       	rjmp	.+4      	; 0x4714 <vfprintf+0x182>
    4710:	6f ef       	ldi	r22, 0xFF	; 255
    4712:	7f ef       	ldi	r23, 0xFF	; 255
    4714:	c5 01       	movw	r24, r10
    4716:	2c 87       	std	Y+12, r18	; 0x0c
    4718:	2a d1       	rcall	.+596    	; 0x496e <strnlen_P>
    471a:	2c 01       	movw	r4, r24
    471c:	2c 85       	ldd	r18, Y+12	; 0x0c
    471e:	20 68       	ori	r18, 0x80	; 128
    4720:	22 2e       	mov	r2, r18
    4722:	83 01       	movw	r16, r6
    4724:	23 fc       	sbrc	r2, 3
    4726:	19 c0       	rjmp	.+50     	; 0x475a <vfprintf+0x1c8>
    4728:	83 2d       	mov	r24, r3
    472a:	90 e0       	ldi	r25, 0x00	; 0
    472c:	48 16       	cp	r4, r24
    472e:	59 06       	cpc	r5, r25
    4730:	a0 f4       	brcc	.+40     	; 0x475a <vfprintf+0x1c8>
    4732:	b7 01       	movw	r22, r14
    4734:	80 e2       	ldi	r24, 0x20	; 32
    4736:	90 e0       	ldi	r25, 0x00	; 0
    4738:	30 d1       	rcall	.+608    	; 0x499a <fputc>
    473a:	3a 94       	dec	r3
    473c:	f5 cf       	rjmp	.-22     	; 0x4728 <vfprintf+0x196>
    473e:	f5 01       	movw	r30, r10
    4740:	27 fc       	sbrc	r2, 7
    4742:	85 91       	lpm	r24, Z+
    4744:	27 fe       	sbrs	r2, 7
    4746:	81 91       	ld	r24, Z+
    4748:	5f 01       	movw	r10, r30
    474a:	b7 01       	movw	r22, r14
    474c:	90 e0       	ldi	r25, 0x00	; 0
    474e:	25 d1       	rcall	.+586    	; 0x499a <fputc>
    4750:	31 10       	cpse	r3, r1
    4752:	3a 94       	dec	r3
    4754:	f1 e0       	ldi	r31, 0x01	; 1
    4756:	4f 1a       	sub	r4, r31
    4758:	51 08       	sbc	r5, r1
    475a:	41 14       	cp	r4, r1
    475c:	51 04       	cpc	r5, r1
    475e:	79 f7       	brne	.-34     	; 0x473e <vfprintf+0x1ac>
    4760:	de c0       	rjmp	.+444    	; 0x491e <vfprintf+0x38c>
    4762:	84 36       	cpi	r24, 0x64	; 100
    4764:	11 f0       	breq	.+4      	; 0x476a <vfprintf+0x1d8>
    4766:	89 36       	cpi	r24, 0x69	; 105
    4768:	31 f5       	brne	.+76     	; 0x47b6 <vfprintf+0x224>
    476a:	f8 01       	movw	r30, r16
    476c:	27 ff       	sbrs	r18, 7
    476e:	07 c0       	rjmp	.+14     	; 0x477e <vfprintf+0x1ec>
    4770:	60 81       	ld	r22, Z
    4772:	71 81       	ldd	r23, Z+1	; 0x01
    4774:	82 81       	ldd	r24, Z+2	; 0x02
    4776:	93 81       	ldd	r25, Z+3	; 0x03
    4778:	0c 5f       	subi	r16, 0xFC	; 252
    477a:	1f 4f       	sbci	r17, 0xFF	; 255
    477c:	08 c0       	rjmp	.+16     	; 0x478e <vfprintf+0x1fc>
    477e:	60 81       	ld	r22, Z
    4780:	71 81       	ldd	r23, Z+1	; 0x01
    4782:	88 27       	eor	r24, r24
    4784:	77 fd       	sbrc	r23, 7
    4786:	80 95       	com	r24
    4788:	98 2f       	mov	r25, r24
    478a:	0e 5f       	subi	r16, 0xFE	; 254
    478c:	1f 4f       	sbci	r17, 0xFF	; 255
    478e:	2f 76       	andi	r18, 0x6F	; 111
    4790:	b2 2e       	mov	r11, r18
    4792:	97 ff       	sbrs	r25, 7
    4794:	09 c0       	rjmp	.+18     	; 0x47a8 <vfprintf+0x216>
    4796:	90 95       	com	r25
    4798:	80 95       	com	r24
    479a:	70 95       	com	r23
    479c:	61 95       	neg	r22
    479e:	7f 4f       	sbci	r23, 0xFF	; 255
    47a0:	8f 4f       	sbci	r24, 0xFF	; 255
    47a2:	9f 4f       	sbci	r25, 0xFF	; 255
    47a4:	20 68       	ori	r18, 0x80	; 128
    47a6:	b2 2e       	mov	r11, r18
    47a8:	2a e0       	ldi	r18, 0x0A	; 10
    47aa:	30 e0       	ldi	r19, 0x00	; 0
    47ac:	a4 01       	movw	r20, r8
    47ae:	27 d1       	rcall	.+590    	; 0x49fe <__ultoa_invert>
    47b0:	a8 2e       	mov	r10, r24
    47b2:	a8 18       	sub	r10, r8
    47b4:	43 c0       	rjmp	.+134    	; 0x483c <vfprintf+0x2aa>
    47b6:	85 37       	cpi	r24, 0x75	; 117
    47b8:	29 f4       	brne	.+10     	; 0x47c4 <vfprintf+0x232>
    47ba:	2f 7e       	andi	r18, 0xEF	; 239
    47bc:	b2 2e       	mov	r11, r18
    47be:	2a e0       	ldi	r18, 0x0A	; 10
    47c0:	30 e0       	ldi	r19, 0x00	; 0
    47c2:	25 c0       	rjmp	.+74     	; 0x480e <vfprintf+0x27c>
    47c4:	f2 2f       	mov	r31, r18
    47c6:	f9 7f       	andi	r31, 0xF9	; 249
    47c8:	bf 2e       	mov	r11, r31
    47ca:	8f 36       	cpi	r24, 0x6F	; 111
    47cc:	c1 f0       	breq	.+48     	; 0x47fe <vfprintf+0x26c>
    47ce:	18 f4       	brcc	.+6      	; 0x47d6 <vfprintf+0x244>
    47d0:	88 35       	cpi	r24, 0x58	; 88
    47d2:	79 f0       	breq	.+30     	; 0x47f2 <vfprintf+0x260>
    47d4:	ad c0       	rjmp	.+346    	; 0x4930 <vfprintf+0x39e>
    47d6:	80 37       	cpi	r24, 0x70	; 112
    47d8:	19 f0       	breq	.+6      	; 0x47e0 <vfprintf+0x24e>
    47da:	88 37       	cpi	r24, 0x78	; 120
    47dc:	21 f0       	breq	.+8      	; 0x47e6 <vfprintf+0x254>
    47de:	a8 c0       	rjmp	.+336    	; 0x4930 <vfprintf+0x39e>
    47e0:	2f 2f       	mov	r18, r31
    47e2:	20 61       	ori	r18, 0x10	; 16
    47e4:	b2 2e       	mov	r11, r18
    47e6:	b4 fe       	sbrs	r11, 4
    47e8:	0d c0       	rjmp	.+26     	; 0x4804 <vfprintf+0x272>
    47ea:	8b 2d       	mov	r24, r11
    47ec:	84 60       	ori	r24, 0x04	; 4
    47ee:	b8 2e       	mov	r11, r24
    47f0:	09 c0       	rjmp	.+18     	; 0x4804 <vfprintf+0x272>
    47f2:	24 ff       	sbrs	r18, 4
    47f4:	0a c0       	rjmp	.+20     	; 0x480a <vfprintf+0x278>
    47f6:	9f 2f       	mov	r25, r31
    47f8:	96 60       	ori	r25, 0x06	; 6
    47fa:	b9 2e       	mov	r11, r25
    47fc:	06 c0       	rjmp	.+12     	; 0x480a <vfprintf+0x278>
    47fe:	28 e0       	ldi	r18, 0x08	; 8
    4800:	30 e0       	ldi	r19, 0x00	; 0
    4802:	05 c0       	rjmp	.+10     	; 0x480e <vfprintf+0x27c>
    4804:	20 e1       	ldi	r18, 0x10	; 16
    4806:	30 e0       	ldi	r19, 0x00	; 0
    4808:	02 c0       	rjmp	.+4      	; 0x480e <vfprintf+0x27c>
    480a:	20 e1       	ldi	r18, 0x10	; 16
    480c:	32 e0       	ldi	r19, 0x02	; 2
    480e:	f8 01       	movw	r30, r16
    4810:	b7 fe       	sbrs	r11, 7
    4812:	07 c0       	rjmp	.+14     	; 0x4822 <vfprintf+0x290>
    4814:	60 81       	ld	r22, Z
    4816:	71 81       	ldd	r23, Z+1	; 0x01
    4818:	82 81       	ldd	r24, Z+2	; 0x02
    481a:	93 81       	ldd	r25, Z+3	; 0x03
    481c:	0c 5f       	subi	r16, 0xFC	; 252
    481e:	1f 4f       	sbci	r17, 0xFF	; 255
    4820:	06 c0       	rjmp	.+12     	; 0x482e <vfprintf+0x29c>
    4822:	60 81       	ld	r22, Z
    4824:	71 81       	ldd	r23, Z+1	; 0x01
    4826:	80 e0       	ldi	r24, 0x00	; 0
    4828:	90 e0       	ldi	r25, 0x00	; 0
    482a:	0e 5f       	subi	r16, 0xFE	; 254
    482c:	1f 4f       	sbci	r17, 0xFF	; 255
    482e:	a4 01       	movw	r20, r8
    4830:	e6 d0       	rcall	.+460    	; 0x49fe <__ultoa_invert>
    4832:	a8 2e       	mov	r10, r24
    4834:	a8 18       	sub	r10, r8
    4836:	fb 2d       	mov	r31, r11
    4838:	ff 77       	andi	r31, 0x7F	; 127
    483a:	bf 2e       	mov	r11, r31
    483c:	b6 fe       	sbrs	r11, 6
    483e:	0b c0       	rjmp	.+22     	; 0x4856 <vfprintf+0x2c4>
    4840:	2b 2d       	mov	r18, r11
    4842:	2e 7f       	andi	r18, 0xFE	; 254
    4844:	a5 14       	cp	r10, r5
    4846:	50 f4       	brcc	.+20     	; 0x485c <vfprintf+0x2ca>
    4848:	b4 fe       	sbrs	r11, 4
    484a:	0a c0       	rjmp	.+20     	; 0x4860 <vfprintf+0x2ce>
    484c:	b2 fc       	sbrc	r11, 2
    484e:	08 c0       	rjmp	.+16     	; 0x4860 <vfprintf+0x2ce>
    4850:	2b 2d       	mov	r18, r11
    4852:	2e 7e       	andi	r18, 0xEE	; 238
    4854:	05 c0       	rjmp	.+10     	; 0x4860 <vfprintf+0x2ce>
    4856:	7a 2c       	mov	r7, r10
    4858:	2b 2d       	mov	r18, r11
    485a:	03 c0       	rjmp	.+6      	; 0x4862 <vfprintf+0x2d0>
    485c:	7a 2c       	mov	r7, r10
    485e:	01 c0       	rjmp	.+2      	; 0x4862 <vfprintf+0x2d0>
    4860:	75 2c       	mov	r7, r5
    4862:	24 ff       	sbrs	r18, 4
    4864:	0d c0       	rjmp	.+26     	; 0x4880 <vfprintf+0x2ee>
    4866:	fe 01       	movw	r30, r28
    4868:	ea 0d       	add	r30, r10
    486a:	f1 1d       	adc	r31, r1
    486c:	80 81       	ld	r24, Z
    486e:	80 33       	cpi	r24, 0x30	; 48
    4870:	11 f4       	brne	.+4      	; 0x4876 <vfprintf+0x2e4>
    4872:	29 7e       	andi	r18, 0xE9	; 233
    4874:	09 c0       	rjmp	.+18     	; 0x4888 <vfprintf+0x2f6>
    4876:	22 ff       	sbrs	r18, 2
    4878:	06 c0       	rjmp	.+12     	; 0x4886 <vfprintf+0x2f4>
    487a:	73 94       	inc	r7
    487c:	73 94       	inc	r7
    487e:	04 c0       	rjmp	.+8      	; 0x4888 <vfprintf+0x2f6>
    4880:	82 2f       	mov	r24, r18
    4882:	86 78       	andi	r24, 0x86	; 134
    4884:	09 f0       	breq	.+2      	; 0x4888 <vfprintf+0x2f6>
    4886:	73 94       	inc	r7
    4888:	23 fd       	sbrc	r18, 3
    488a:	12 c0       	rjmp	.+36     	; 0x48b0 <vfprintf+0x31e>
    488c:	20 ff       	sbrs	r18, 0
    488e:	06 c0       	rjmp	.+12     	; 0x489c <vfprintf+0x30a>
    4890:	5a 2c       	mov	r5, r10
    4892:	73 14       	cp	r7, r3
    4894:	18 f4       	brcc	.+6      	; 0x489c <vfprintf+0x30a>
    4896:	53 0c       	add	r5, r3
    4898:	57 18       	sub	r5, r7
    489a:	73 2c       	mov	r7, r3
    489c:	73 14       	cp	r7, r3
    489e:	60 f4       	brcc	.+24     	; 0x48b8 <vfprintf+0x326>
    48a0:	b7 01       	movw	r22, r14
    48a2:	80 e2       	ldi	r24, 0x20	; 32
    48a4:	90 e0       	ldi	r25, 0x00	; 0
    48a6:	2c 87       	std	Y+12, r18	; 0x0c
    48a8:	78 d0       	rcall	.+240    	; 0x499a <fputc>
    48aa:	73 94       	inc	r7
    48ac:	2c 85       	ldd	r18, Y+12	; 0x0c
    48ae:	f6 cf       	rjmp	.-20     	; 0x489c <vfprintf+0x30a>
    48b0:	73 14       	cp	r7, r3
    48b2:	10 f4       	brcc	.+4      	; 0x48b8 <vfprintf+0x326>
    48b4:	37 18       	sub	r3, r7
    48b6:	01 c0       	rjmp	.+2      	; 0x48ba <vfprintf+0x328>
    48b8:	31 2c       	mov	r3, r1
    48ba:	24 ff       	sbrs	r18, 4
    48bc:	11 c0       	rjmp	.+34     	; 0x48e0 <vfprintf+0x34e>
    48be:	b7 01       	movw	r22, r14
    48c0:	80 e3       	ldi	r24, 0x30	; 48
    48c2:	90 e0       	ldi	r25, 0x00	; 0
    48c4:	2c 87       	std	Y+12, r18	; 0x0c
    48c6:	69 d0       	rcall	.+210    	; 0x499a <fputc>
    48c8:	2c 85       	ldd	r18, Y+12	; 0x0c
    48ca:	22 ff       	sbrs	r18, 2
    48cc:	16 c0       	rjmp	.+44     	; 0x48fa <vfprintf+0x368>
    48ce:	21 ff       	sbrs	r18, 1
    48d0:	03 c0       	rjmp	.+6      	; 0x48d8 <vfprintf+0x346>
    48d2:	88 e5       	ldi	r24, 0x58	; 88
    48d4:	90 e0       	ldi	r25, 0x00	; 0
    48d6:	02 c0       	rjmp	.+4      	; 0x48dc <vfprintf+0x34a>
    48d8:	88 e7       	ldi	r24, 0x78	; 120
    48da:	90 e0       	ldi	r25, 0x00	; 0
    48dc:	b7 01       	movw	r22, r14
    48de:	0c c0       	rjmp	.+24     	; 0x48f8 <vfprintf+0x366>
    48e0:	82 2f       	mov	r24, r18
    48e2:	86 78       	andi	r24, 0x86	; 134
    48e4:	51 f0       	breq	.+20     	; 0x48fa <vfprintf+0x368>
    48e6:	21 fd       	sbrc	r18, 1
    48e8:	02 c0       	rjmp	.+4      	; 0x48ee <vfprintf+0x35c>
    48ea:	80 e2       	ldi	r24, 0x20	; 32
    48ec:	01 c0       	rjmp	.+2      	; 0x48f0 <vfprintf+0x35e>
    48ee:	8b e2       	ldi	r24, 0x2B	; 43
    48f0:	27 fd       	sbrc	r18, 7
    48f2:	8d e2       	ldi	r24, 0x2D	; 45
    48f4:	b7 01       	movw	r22, r14
    48f6:	90 e0       	ldi	r25, 0x00	; 0
    48f8:	50 d0       	rcall	.+160    	; 0x499a <fputc>
    48fa:	a5 14       	cp	r10, r5
    48fc:	30 f4       	brcc	.+12     	; 0x490a <vfprintf+0x378>
    48fe:	b7 01       	movw	r22, r14
    4900:	80 e3       	ldi	r24, 0x30	; 48
    4902:	90 e0       	ldi	r25, 0x00	; 0
    4904:	4a d0       	rcall	.+148    	; 0x499a <fputc>
    4906:	5a 94       	dec	r5
    4908:	f8 cf       	rjmp	.-16     	; 0x48fa <vfprintf+0x368>
    490a:	aa 94       	dec	r10
    490c:	f4 01       	movw	r30, r8
    490e:	ea 0d       	add	r30, r10
    4910:	f1 1d       	adc	r31, r1
    4912:	80 81       	ld	r24, Z
    4914:	b7 01       	movw	r22, r14
    4916:	90 e0       	ldi	r25, 0x00	; 0
    4918:	40 d0       	rcall	.+128    	; 0x499a <fputc>
    491a:	a1 10       	cpse	r10, r1
    491c:	f6 cf       	rjmp	.-20     	; 0x490a <vfprintf+0x378>
    491e:	33 20       	and	r3, r3
    4920:	09 f4       	brne	.+2      	; 0x4924 <vfprintf+0x392>
    4922:	5d ce       	rjmp	.-838    	; 0x45de <vfprintf+0x4c>
    4924:	b7 01       	movw	r22, r14
    4926:	80 e2       	ldi	r24, 0x20	; 32
    4928:	90 e0       	ldi	r25, 0x00	; 0
    492a:	37 d0       	rcall	.+110    	; 0x499a <fputc>
    492c:	3a 94       	dec	r3
    492e:	f7 cf       	rjmp	.-18     	; 0x491e <vfprintf+0x38c>
    4930:	f7 01       	movw	r30, r14
    4932:	86 81       	ldd	r24, Z+6	; 0x06
    4934:	97 81       	ldd	r25, Z+7	; 0x07
    4936:	02 c0       	rjmp	.+4      	; 0x493c <vfprintf+0x3aa>
    4938:	8f ef       	ldi	r24, 0xFF	; 255
    493a:	9f ef       	ldi	r25, 0xFF	; 255
    493c:	2c 96       	adiw	r28, 0x0c	; 12
    493e:	0f b6       	in	r0, 0x3f	; 63
    4940:	f8 94       	cli
    4942:	de bf       	out	0x3e, r29	; 62
    4944:	0f be       	out	0x3f, r0	; 63
    4946:	cd bf       	out	0x3d, r28	; 61
    4948:	df 91       	pop	r29
    494a:	cf 91       	pop	r28
    494c:	1f 91       	pop	r17
    494e:	0f 91       	pop	r16
    4950:	ff 90       	pop	r15
    4952:	ef 90       	pop	r14
    4954:	df 90       	pop	r13
    4956:	cf 90       	pop	r12
    4958:	bf 90       	pop	r11
    495a:	af 90       	pop	r10
    495c:	9f 90       	pop	r9
    495e:	8f 90       	pop	r8
    4960:	7f 90       	pop	r7
    4962:	6f 90       	pop	r6
    4964:	5f 90       	pop	r5
    4966:	4f 90       	pop	r4
    4968:	3f 90       	pop	r3
    496a:	2f 90       	pop	r2
    496c:	08 95       	ret

0000496e <strnlen_P>:
    496e:	fc 01       	movw	r30, r24
    4970:	05 90       	lpm	r0, Z+
    4972:	61 50       	subi	r22, 0x01	; 1
    4974:	70 40       	sbci	r23, 0x00	; 0
    4976:	01 10       	cpse	r0, r1
    4978:	d8 f7       	brcc	.-10     	; 0x4970 <strnlen_P+0x2>
    497a:	80 95       	com	r24
    497c:	90 95       	com	r25
    497e:	8e 0f       	add	r24, r30
    4980:	9f 1f       	adc	r25, r31
    4982:	08 95       	ret

00004984 <strnlen>:
    4984:	fc 01       	movw	r30, r24
    4986:	61 50       	subi	r22, 0x01	; 1
    4988:	70 40       	sbci	r23, 0x00	; 0
    498a:	01 90       	ld	r0, Z+
    498c:	01 10       	cpse	r0, r1
    498e:	d8 f7       	brcc	.-10     	; 0x4986 <strnlen+0x2>
    4990:	80 95       	com	r24
    4992:	90 95       	com	r25
    4994:	8e 0f       	add	r24, r30
    4996:	9f 1f       	adc	r25, r31
    4998:	08 95       	ret

0000499a <fputc>:
    499a:	0f 93       	push	r16
    499c:	1f 93       	push	r17
    499e:	cf 93       	push	r28
    49a0:	df 93       	push	r29
    49a2:	18 2f       	mov	r17, r24
    49a4:	09 2f       	mov	r16, r25
    49a6:	eb 01       	movw	r28, r22
    49a8:	8b 81       	ldd	r24, Y+3	; 0x03
    49aa:	81 fd       	sbrc	r24, 1
    49ac:	03 c0       	rjmp	.+6      	; 0x49b4 <fputc+0x1a>
    49ae:	8f ef       	ldi	r24, 0xFF	; 255
    49b0:	9f ef       	ldi	r25, 0xFF	; 255
    49b2:	20 c0       	rjmp	.+64     	; 0x49f4 <fputc+0x5a>
    49b4:	82 ff       	sbrs	r24, 2
    49b6:	10 c0       	rjmp	.+32     	; 0x49d8 <fputc+0x3e>
    49b8:	4e 81       	ldd	r20, Y+6	; 0x06
    49ba:	5f 81       	ldd	r21, Y+7	; 0x07
    49bc:	2c 81       	ldd	r18, Y+4	; 0x04
    49be:	3d 81       	ldd	r19, Y+5	; 0x05
    49c0:	42 17       	cp	r20, r18
    49c2:	53 07       	cpc	r21, r19
    49c4:	7c f4       	brge	.+30     	; 0x49e4 <fputc+0x4a>
    49c6:	e8 81       	ld	r30, Y
    49c8:	f9 81       	ldd	r31, Y+1	; 0x01
    49ca:	9f 01       	movw	r18, r30
    49cc:	2f 5f       	subi	r18, 0xFF	; 255
    49ce:	3f 4f       	sbci	r19, 0xFF	; 255
    49d0:	39 83       	std	Y+1, r19	; 0x01
    49d2:	28 83       	st	Y, r18
    49d4:	10 83       	st	Z, r17
    49d6:	06 c0       	rjmp	.+12     	; 0x49e4 <fputc+0x4a>
    49d8:	e8 85       	ldd	r30, Y+8	; 0x08
    49da:	f9 85       	ldd	r31, Y+9	; 0x09
    49dc:	81 2f       	mov	r24, r17
    49de:	19 95       	eicall
    49e0:	89 2b       	or	r24, r25
    49e2:	29 f7       	brne	.-54     	; 0x49ae <fputc+0x14>
    49e4:	2e 81       	ldd	r18, Y+6	; 0x06
    49e6:	3f 81       	ldd	r19, Y+7	; 0x07
    49e8:	2f 5f       	subi	r18, 0xFF	; 255
    49ea:	3f 4f       	sbci	r19, 0xFF	; 255
    49ec:	3f 83       	std	Y+7, r19	; 0x07
    49ee:	2e 83       	std	Y+6, r18	; 0x06
    49f0:	81 2f       	mov	r24, r17
    49f2:	90 2f       	mov	r25, r16
    49f4:	df 91       	pop	r29
    49f6:	cf 91       	pop	r28
    49f8:	1f 91       	pop	r17
    49fa:	0f 91       	pop	r16
    49fc:	08 95       	ret

000049fe <__ultoa_invert>:
    49fe:	fa 01       	movw	r30, r20
    4a00:	aa 27       	eor	r26, r26
    4a02:	28 30       	cpi	r18, 0x08	; 8
    4a04:	51 f1       	breq	.+84     	; 0x4a5a <__ultoa_invert+0x5c>
    4a06:	20 31       	cpi	r18, 0x10	; 16
    4a08:	81 f1       	breq	.+96     	; 0x4a6a <__ultoa_invert+0x6c>
    4a0a:	e8 94       	clt
    4a0c:	6f 93       	push	r22
    4a0e:	6e 7f       	andi	r22, 0xFE	; 254
    4a10:	6e 5f       	subi	r22, 0xFE	; 254
    4a12:	7f 4f       	sbci	r23, 0xFF	; 255
    4a14:	8f 4f       	sbci	r24, 0xFF	; 255
    4a16:	9f 4f       	sbci	r25, 0xFF	; 255
    4a18:	af 4f       	sbci	r26, 0xFF	; 255
    4a1a:	b1 e0       	ldi	r27, 0x01	; 1
    4a1c:	3e d0       	rcall	.+124    	; 0x4a9a <__ultoa_invert+0x9c>
    4a1e:	b4 e0       	ldi	r27, 0x04	; 4
    4a20:	3c d0       	rcall	.+120    	; 0x4a9a <__ultoa_invert+0x9c>
    4a22:	67 0f       	add	r22, r23
    4a24:	78 1f       	adc	r23, r24
    4a26:	89 1f       	adc	r24, r25
    4a28:	9a 1f       	adc	r25, r26
    4a2a:	a1 1d       	adc	r26, r1
    4a2c:	68 0f       	add	r22, r24
    4a2e:	79 1f       	adc	r23, r25
    4a30:	8a 1f       	adc	r24, r26
    4a32:	91 1d       	adc	r25, r1
    4a34:	a1 1d       	adc	r26, r1
    4a36:	6a 0f       	add	r22, r26
    4a38:	71 1d       	adc	r23, r1
    4a3a:	81 1d       	adc	r24, r1
    4a3c:	91 1d       	adc	r25, r1
    4a3e:	a1 1d       	adc	r26, r1
    4a40:	20 d0       	rcall	.+64     	; 0x4a82 <__ultoa_invert+0x84>
    4a42:	09 f4       	brne	.+2      	; 0x4a46 <__ultoa_invert+0x48>
    4a44:	68 94       	set
    4a46:	3f 91       	pop	r19
    4a48:	2a e0       	ldi	r18, 0x0A	; 10
    4a4a:	26 9f       	mul	r18, r22
    4a4c:	11 24       	eor	r1, r1
    4a4e:	30 19       	sub	r19, r0
    4a50:	30 5d       	subi	r19, 0xD0	; 208
    4a52:	31 93       	st	Z+, r19
    4a54:	de f6       	brtc	.-74     	; 0x4a0c <__ultoa_invert+0xe>
    4a56:	cf 01       	movw	r24, r30
    4a58:	08 95       	ret
    4a5a:	46 2f       	mov	r20, r22
    4a5c:	47 70       	andi	r20, 0x07	; 7
    4a5e:	40 5d       	subi	r20, 0xD0	; 208
    4a60:	41 93       	st	Z+, r20
    4a62:	b3 e0       	ldi	r27, 0x03	; 3
    4a64:	0f d0       	rcall	.+30     	; 0x4a84 <__ultoa_invert+0x86>
    4a66:	c9 f7       	brne	.-14     	; 0x4a5a <__ultoa_invert+0x5c>
    4a68:	f6 cf       	rjmp	.-20     	; 0x4a56 <__ultoa_invert+0x58>
    4a6a:	46 2f       	mov	r20, r22
    4a6c:	4f 70       	andi	r20, 0x0F	; 15
    4a6e:	40 5d       	subi	r20, 0xD0	; 208
    4a70:	4a 33       	cpi	r20, 0x3A	; 58
    4a72:	18 f0       	brcs	.+6      	; 0x4a7a <__ultoa_invert+0x7c>
    4a74:	49 5d       	subi	r20, 0xD9	; 217
    4a76:	31 fd       	sbrc	r19, 1
    4a78:	40 52       	subi	r20, 0x20	; 32
    4a7a:	41 93       	st	Z+, r20
    4a7c:	02 d0       	rcall	.+4      	; 0x4a82 <__ultoa_invert+0x84>
    4a7e:	a9 f7       	brne	.-22     	; 0x4a6a <__ultoa_invert+0x6c>
    4a80:	ea cf       	rjmp	.-44     	; 0x4a56 <__ultoa_invert+0x58>
    4a82:	b4 e0       	ldi	r27, 0x04	; 4
    4a84:	a6 95       	lsr	r26
    4a86:	97 95       	ror	r25
    4a88:	87 95       	ror	r24
    4a8a:	77 95       	ror	r23
    4a8c:	67 95       	ror	r22
    4a8e:	ba 95       	dec	r27
    4a90:	c9 f7       	brne	.-14     	; 0x4a84 <__ultoa_invert+0x86>
    4a92:	00 97       	sbiw	r24, 0x00	; 0
    4a94:	61 05       	cpc	r22, r1
    4a96:	71 05       	cpc	r23, r1
    4a98:	08 95       	ret
    4a9a:	9b 01       	movw	r18, r22
    4a9c:	ac 01       	movw	r20, r24
    4a9e:	0a 2e       	mov	r0, r26
    4aa0:	06 94       	lsr	r0
    4aa2:	57 95       	ror	r21
    4aa4:	47 95       	ror	r20
    4aa6:	37 95       	ror	r19
    4aa8:	27 95       	ror	r18
    4aaa:	ba 95       	dec	r27
    4aac:	c9 f7       	brne	.-14     	; 0x4aa0 <__ultoa_invert+0xa2>
    4aae:	62 0f       	add	r22, r18
    4ab0:	73 1f       	adc	r23, r19
    4ab2:	84 1f       	adc	r24, r20
    4ab4:	95 1f       	adc	r25, r21
    4ab6:	a0 1d       	adc	r26, r0
    4ab8:	08 95       	ret

00004aba <_exit>:
    4aba:	f8 94       	cli

00004abc <__stop_program>:
    4abc:	ff cf       	rjmp	.-2      	; 0x4abc <__stop_program>
