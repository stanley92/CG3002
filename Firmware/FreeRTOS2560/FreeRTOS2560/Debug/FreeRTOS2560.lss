
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000ac  00800200  00003570  00003604  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003570  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000c50  008002ac  008002ac  000036b0  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  000036b0  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000008e0  00000000  00000000  0000370c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00011f9d  00000000  00000000  00003fec  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00003541  00000000  00000000  00015f89  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00005ecf  00000000  00000000  000194ca  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00001b70  00000000  00000000  0001f39c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00004205  00000000  00000000  00020f0c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00008f02  00000000  00000000  00025111  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000938  00000000  00000000  0002e013  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	20 c2       	rjmp	.+1088   	; 0x442 <__ctors_end>
       2:	00 00       	nop
       4:	4e c2       	rjmp	.+1180   	; 0x4a2 <__bad_interrupt>
       6:	00 00       	nop
       8:	4c c2       	rjmp	.+1176   	; 0x4a2 <__bad_interrupt>
       a:	00 00       	nop
       c:	4a c2       	rjmp	.+1172   	; 0x4a2 <__bad_interrupt>
       e:	00 00       	nop
      10:	48 c2       	rjmp	.+1168   	; 0x4a2 <__bad_interrupt>
      12:	00 00       	nop
      14:	46 c2       	rjmp	.+1164   	; 0x4a2 <__bad_interrupt>
      16:	00 00       	nop
      18:	44 c2       	rjmp	.+1160   	; 0x4a2 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	42 c2       	rjmp	.+1156   	; 0x4a2 <__bad_interrupt>
      1e:	00 00       	nop
      20:	40 c2       	rjmp	.+1152   	; 0x4a2 <__bad_interrupt>
      22:	00 00       	nop
      24:	3e c2       	rjmp	.+1148   	; 0x4a2 <__bad_interrupt>
      26:	00 00       	nop
      28:	3c c2       	rjmp	.+1144   	; 0x4a2 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	3a c2       	rjmp	.+1140   	; 0x4a2 <__bad_interrupt>
      2e:	00 00       	nop
      30:	38 c2       	rjmp	.+1136   	; 0x4a2 <__bad_interrupt>
      32:	00 00       	nop
      34:	0c 94 fb 09 	jmp	0x13f6	; 0x13f6 <__vector_13>
      38:	34 c2       	rjmp	.+1128   	; 0x4a2 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	32 c2       	rjmp	.+1124   	; 0x4a2 <__bad_interrupt>
      3e:	00 00       	nop
      40:	30 c2       	rjmp	.+1120   	; 0x4a2 <__bad_interrupt>
      42:	00 00       	nop
      44:	2e c2       	rjmp	.+1116   	; 0x4a2 <__bad_interrupt>
      46:	00 00       	nop
      48:	2c c2       	rjmp	.+1112   	; 0x4a2 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	2a c2       	rjmp	.+1108   	; 0x4a2 <__bad_interrupt>
      4e:	00 00       	nop
      50:	28 c2       	rjmp	.+1104   	; 0x4a2 <__bad_interrupt>
      52:	00 00       	nop
      54:	26 c2       	rjmp	.+1100   	; 0x4a2 <__bad_interrupt>
      56:	00 00       	nop
      58:	24 c2       	rjmp	.+1096   	; 0x4a2 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	0c 94 d5 15 	jmp	0x2baa	; 0x2baa <__vector_23>
      60:	20 c2       	rjmp	.+1088   	; 0x4a2 <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 bc 14 	jmp	0x2978	; 0x2978 <__vector_25>
      68:	0c 94 fb 14 	jmp	0x29f6	; 0x29f6 <__vector_26>
      6c:	1a c2       	rjmp	.+1076   	; 0x4a2 <__bad_interrupt>
      6e:	00 00       	nop
      70:	18 c2       	rjmp	.+1072   	; 0x4a2 <__bad_interrupt>
      72:	00 00       	nop
      74:	16 c2       	rjmp	.+1068   	; 0x4a2 <__bad_interrupt>
      76:	00 00       	nop
      78:	14 c2       	rjmp	.+1064   	; 0x4a2 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	12 c2       	rjmp	.+1060   	; 0x4a2 <__bad_interrupt>
      7e:	00 00       	nop
      80:	10 c2       	rjmp	.+1056   	; 0x4a2 <__bad_interrupt>
      82:	00 00       	nop
      84:	0e c2       	rjmp	.+1052   	; 0x4a2 <__bad_interrupt>
      86:	00 00       	nop
      88:	0c c2       	rjmp	.+1048   	; 0x4a2 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	0a c2       	rjmp	.+1044   	; 0x4a2 <__bad_interrupt>
      8e:	00 00       	nop
      90:	08 c2       	rjmp	.+1040   	; 0x4a2 <__bad_interrupt>
      92:	00 00       	nop
      94:	06 c2       	rjmp	.+1036   	; 0x4a2 <__bad_interrupt>
      96:	00 00       	nop
      98:	04 c2       	rjmp	.+1032   	; 0x4a2 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	0c 94 5d 0e 	jmp	0x1cba	; 0x1cba <__vector_39>
      a0:	00 c2       	rjmp	.+1024   	; 0x4a2 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	fe c1       	rjmp	.+1020   	; 0x4a2 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	fc c1       	rjmp	.+1016   	; 0x4a2 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	fa c1       	rjmp	.+1012   	; 0x4a2 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	f8 c1       	rjmp	.+1008   	; 0x4a2 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	fe c7       	rjmp	.+4092   	; 0x10b2 <__vector_45>
      b6:	00 00       	nop
      b8:	f4 c1       	rjmp	.+1000   	; 0x4a2 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	f2 c1       	rjmp	.+996    	; 0x4a2 <__bad_interrupt>
      be:	00 00       	nop
      c0:	f0 c1       	rjmp	.+992    	; 0x4a2 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	ee c1       	rjmp	.+988    	; 0x4a2 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	ec c1       	rjmp	.+984    	; 0x4a2 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	ea c1       	rjmp	.+980    	; 0x4a2 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	e8 c1       	rjmp	.+976    	; 0x4a2 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	e6 c1       	rjmp	.+972    	; 0x4a2 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	e4 c1       	rjmp	.+968    	; 0x4a2 <__bad_interrupt>
      da:	00 00       	nop
      dc:	e2 c1       	rjmp	.+964    	; 0x4a2 <__bad_interrupt>
      de:	00 00       	nop
      e0:	e0 c1       	rjmp	.+960    	; 0x4a2 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	63 0f       	add	r22, r19
      e6:	66 0f       	add	r22, r22
      e8:	66 0f       	add	r22, r22
      ea:	66 0f       	add	r22, r22
      ec:	66 0f       	add	r22, r22
      ee:	66 0f       	add	r22, r22
      f0:	66 0f       	add	r22, r22
      f2:	66 0f       	add	r22, r22
      f4:	7d 0e       	add	r7, r29
      f6:	66 0f       	add	r22, r22
      f8:	66 0f       	add	r22, r22
      fa:	66 0f       	add	r22, r22
      fc:	66 0f       	add	r22, r22
      fe:	66 0f       	add	r22, r22
     100:	66 0f       	add	r22, r22
     102:	66 0f       	add	r22, r22
     104:	7d 0e       	add	r7, r29
     106:	66 0f       	add	r22, r22
     108:	66 0f       	add	r22, r22
     10a:	66 0f       	add	r22, r22
     10c:	66 0f       	add	r22, r22
     10e:	66 0f       	add	r22, r22
     110:	66 0f       	add	r22, r22
     112:	66 0f       	add	r22, r22
     114:	85 0e       	add	r8, r21
     116:	66 0f       	add	r22, r22
     118:	66 0f       	add	r22, r22
     11a:	66 0f       	add	r22, r22
     11c:	66 0f       	add	r22, r22
     11e:	66 0f       	add	r22, r22
     120:	66 0f       	add	r22, r22
     122:	66 0f       	add	r22, r22
     124:	aa 0e       	add	r10, r26
     126:	66 0f       	add	r22, r22
     128:	66 0f       	add	r22, r22
     12a:	66 0f       	add	r22, r22
     12c:	66 0f       	add	r22, r22
     12e:	66 0f       	add	r22, r22
     130:	66 0f       	add	r22, r22
     132:	66 0f       	add	r22, r22
     134:	85 0e       	add	r8, r21
     136:	66 0f       	add	r22, r22
     138:	66 0f       	add	r22, r22
     13a:	66 0f       	add	r22, r22
     13c:	66 0f       	add	r22, r22
     13e:	66 0f       	add	r22, r22
     140:	66 0f       	add	r22, r22
     142:	66 0f       	add	r22, r22
     144:	af 0e       	add	r10, r31
     146:	66 0f       	add	r22, r22
     148:	66 0f       	add	r22, r22
     14a:	66 0f       	add	r22, r22
     14c:	66 0f       	add	r22, r22
     14e:	66 0f       	add	r22, r22
     150:	66 0f       	add	r22, r22
     152:	66 0f       	add	r22, r22
     154:	b4 0e       	add	r11, r20
     156:	66 0f       	add	r22, r22
     158:	66 0f       	add	r22, r22
     15a:	66 0f       	add	r22, r22
     15c:	66 0f       	add	r22, r22
     15e:	66 0f       	add	r22, r22
     160:	66 0f       	add	r22, r22
     162:	66 0f       	add	r22, r22
     164:	c5 0e       	add	r12, r21
     166:	66 0f       	add	r22, r22
     168:	66 0f       	add	r22, r22
     16a:	66 0f       	add	r22, r22
     16c:	66 0f       	add	r22, r22
     16e:	66 0f       	add	r22, r22
     170:	66 0f       	add	r22, r22
     172:	66 0f       	add	r22, r22
     174:	ee 0e       	add	r14, r30
     176:	66 0f       	add	r22, r22
     178:	66 0f       	add	r22, r22
     17a:	66 0f       	add	r22, r22
     17c:	66 0f       	add	r22, r22
     17e:	66 0f       	add	r22, r22
     180:	66 0f       	add	r22, r22
     182:	66 0f       	add	r22, r22
     184:	b9 0e       	add	r11, r25
     186:	66 0f       	add	r22, r22
     188:	66 0f       	add	r22, r22
     18a:	66 0f       	add	r22, r22
     18c:	66 0f       	add	r22, r22
     18e:	66 0f       	add	r22, r22
     190:	66 0f       	add	r22, r22
     192:	66 0f       	add	r22, r22
     194:	d3 0e       	add	r13, r19
     196:	66 0f       	add	r22, r22
     198:	66 0f       	add	r22, r22
     19a:	66 0f       	add	r22, r22
     19c:	66 0f       	add	r22, r22
     19e:	66 0f       	add	r22, r22
     1a0:	66 0f       	add	r22, r22
     1a2:	66 0f       	add	r22, r22
     1a4:	f0 0e       	add	r15, r16
     1a6:	66 0f       	add	r22, r22
     1a8:	66 0f       	add	r22, r22
     1aa:	66 0f       	add	r22, r22
     1ac:	66 0f       	add	r22, r22
     1ae:	66 0f       	add	r22, r22
     1b0:	66 0f       	add	r22, r22
     1b2:	66 0f       	add	r22, r22
     1b4:	f0 0e       	add	r15, r16
     1b6:	66 0f       	add	r22, r22
     1b8:	66 0f       	add	r22, r22
     1ba:	66 0f       	add	r22, r22
     1bc:	66 0f       	add	r22, r22
     1be:	66 0f       	add	r22, r22
     1c0:	66 0f       	add	r22, r22
     1c2:	66 0f       	add	r22, r22
     1c4:	f0 0e       	add	r15, r16
     1c6:	66 0f       	add	r22, r22
     1c8:	66 0f       	add	r22, r22
     1ca:	66 0f       	add	r22, r22
     1cc:	66 0f       	add	r22, r22
     1ce:	66 0f       	add	r22, r22
     1d0:	66 0f       	add	r22, r22
     1d2:	66 0f       	add	r22, r22
     1d4:	f0 0e       	add	r15, r16
     1d6:	66 0f       	add	r22, r22
     1d8:	66 0f       	add	r22, r22
     1da:	66 0f       	add	r22, r22
     1dc:	66 0f       	add	r22, r22
     1de:	66 0f       	add	r22, r22
     1e0:	66 0f       	add	r22, r22
     1e2:	66 0f       	add	r22, r22
     1e4:	f9 0e       	add	r15, r25
     1e6:	66 0f       	add	r22, r22
     1e8:	66 0f       	add	r22, r22
     1ea:	66 0f       	add	r22, r22
     1ec:	66 0f       	add	r22, r22
     1ee:	66 0f       	add	r22, r22
     1f0:	66 0f       	add	r22, r22
     1f2:	66 0f       	add	r22, r22
     1f4:	2a 0f       	add	r18, r26
     1f6:	66 0f       	add	r22, r22
     1f8:	66 0f       	add	r22, r22
     1fa:	66 0f       	add	r22, r22
     1fc:	66 0f       	add	r22, r22
     1fe:	66 0f       	add	r22, r22
     200:	66 0f       	add	r22, r22
     202:	66 0f       	add	r22, r22
     204:	f9 0e       	add	r15, r25
     206:	66 0f       	add	r22, r22
     208:	66 0f       	add	r22, r22
     20a:	66 0f       	add	r22, r22
     20c:	66 0f       	add	r22, r22
     20e:	66 0f       	add	r22, r22
     210:	66 0f       	add	r22, r22
     212:	66 0f       	add	r22, r22
     214:	2a 0f       	add	r18, r26
     216:	66 0f       	add	r22, r22
     218:	66 0f       	add	r22, r22
     21a:	66 0f       	add	r22, r22
     21c:	66 0f       	add	r22, r22
     21e:	66 0f       	add	r22, r22
     220:	66 0f       	add	r22, r22
     222:	66 0f       	add	r22, r22
     224:	11 0f       	add	r17, r17
     226:	66 0f       	add	r22, r22
     228:	66 0f       	add	r22, r22
     22a:	66 0f       	add	r22, r22
     22c:	66 0f       	add	r22, r22
     22e:	66 0f       	add	r22, r22
     230:	66 0f       	add	r22, r22
     232:	66 0f       	add	r22, r22
     234:	2e 0f       	add	r18, r30
     236:	66 0f       	add	r22, r22
     238:	66 0f       	add	r22, r22
     23a:	66 0f       	add	r22, r22
     23c:	66 0f       	add	r22, r22
     23e:	66 0f       	add	r22, r22
     240:	66 0f       	add	r22, r22
     242:	66 0f       	add	r22, r22
     244:	2e 0f       	add	r18, r30
     246:	66 0f       	add	r22, r22
     248:	66 0f       	add	r22, r22
     24a:	66 0f       	add	r22, r22
     24c:	66 0f       	add	r22, r22
     24e:	66 0f       	add	r22, r22
     250:	66 0f       	add	r22, r22
     252:	66 0f       	add	r22, r22
     254:	43 0f       	add	r20, r19
     256:	66 0f       	add	r22, r22
     258:	66 0f       	add	r22, r22
     25a:	66 0f       	add	r22, r22
     25c:	66 0f       	add	r22, r22
     25e:	66 0f       	add	r22, r22
     260:	66 0f       	add	r22, r22
     262:	66 0f       	add	r22, r22
     264:	5d 0f       	add	r21, r29
     266:	66 0f       	add	r22, r22
     268:	66 0f       	add	r22, r22
     26a:	66 0f       	add	r22, r22
     26c:	66 0f       	add	r22, r22
     26e:	66 0f       	add	r22, r22
     270:	66 0f       	add	r22, r22
     272:	66 0f       	add	r22, r22
     274:	5d 0f       	add	r21, r29
     276:	07 63       	ori	r16, 0x37	; 55
     278:	42 36       	cpi	r20, 0x62	; 98
     27a:	b7 9b       	sbis	0x16, 7	; 22
     27c:	d8 a7       	std	Y+40, r29	; 0x28
     27e:	1a 39       	cpi	r17, 0x9A	; 154
     280:	68 56       	subi	r22, 0x68	; 104
     282:	18 ae       	std	Y+56, r1	; 0x38
     284:	ba ab       	std	Y+50, r27	; 0x32
     286:	55 8c       	ldd	r5, Z+29	; 0x1d
     288:	1d 3c       	cpi	r17, 0xCD	; 205
     28a:	b7 cc       	rjmp	.-1682   	; 0xfffffbfa <__eeprom_end+0xff7efbfa>
     28c:	57 63       	ori	r21, 0x37	; 55
     28e:	bd 6d       	ori	r27, 0xDD	; 221
     290:	ed fd       	.word	0xfded	; ????
     292:	75 3e       	cpi	r23, 0xE5	; 229
     294:	f6 17       	cp	r31, r22
     296:	72 31       	cpi	r23, 0x12	; 18
     298:	bf 00       	.word	0x00bf	; ????
     29a:	00 00       	nop
     29c:	80 3f       	cpi	r24, 0xF0	; 240
     29e:	08 00       	.word	0x0008	; ????
     2a0:	00 00       	nop
     2a2:	be 92       	st	-X, r11
     2a4:	24 49       	sbci	r18, 0x94	; 148
     2a6:	12 3e       	cpi	r17, 0xE2	; 226
     2a8:	ab aa       	std	Y+51, r10	; 0x33
     2aa:	aa 2a       	or	r10, r26
     2ac:	be cd       	rjmp	.-1156   	; 0xfffffe2a <__eeprom_end+0xff7efe2a>
     2ae:	cc cc       	rjmp	.-1640   	; 0xfffffc48 <__eeprom_end+0xff7efc48>
     2b0:	4c 3e       	cpi	r20, 0xEC	; 236
     2b2:	00 00       	nop
     2b4:	00 80       	ld	r0, Z
     2b6:	be ab       	std	Y+54, r27	; 0x36
     2b8:	aa aa       	std	Y+50, r10	; 0x32
     2ba:	aa 3e       	cpi	r26, 0xEA	; 234
     2bc:	00 00       	nop
     2be:	00 00       	nop
     2c0:	bf 00       	.word	0x00bf	; ????
     2c2:	00 00       	nop
     2c4:	80 3f       	cpi	r24, 0xF0	; 240
     2c6:	00 00       	nop
     2c8:	00 00       	nop
     2ca:	00 08       	sbc	r0, r0
     2cc:	41 78       	andi	r20, 0x81	; 129
     2ce:	d3 bb       	out	0x13, r29	; 19
     2d0:	43 87       	std	Z+11, r20	; 0x0b
     2d2:	d1 13       	cpse	r29, r17
     2d4:	3d 19       	sub	r19, r13
     2d6:	0e 3c       	cpi	r16, 0xCE	; 206
     2d8:	c3 bd       	out	0x23, r28	; 35
     2da:	42 82       	std	Z+2, r4	; 0x02
     2dc:	ad 2b       	or	r26, r29
     2de:	3e 68       	ori	r19, 0x8E	; 142
     2e0:	ec 82       	std	Y+4, r14	; 0x04
     2e2:	76 be       	out	0x36, r7	; 54
     2e4:	d9 8f       	std	Y+25, r29	; 0x19
     2e6:	e1 a9       	ldd	r30, Z+49	; 0x31
     2e8:	3e 4c       	sbci	r19, 0xCE	; 206
     2ea:	80 ef       	ldi	r24, 0xF0	; 240
     2ec:	ff be       	out	0x3f, r15	; 63
     2ee:	01 c4       	rjmp	.+2050   	; 0xaf2 <_ZN3LPS8writeRegEih+0x6>
     2f0:	ff 7f       	andi	r31, 0xFF	; 255
     2f2:	3f 00       	.word	0x003f	; ????
     2f4:	00 00       	nop
     2f6:	00 00       	nop
     2f8:	ec 16       	cp	r14, r28
     2fa:	f0 16       	cp	r15, r16
     2fc:	da 16       	cp	r13, r26
     2fe:	e0 16       	cp	r14, r16
     300:	e6 16       	cp	r14, r22
     302:	35 17       	cp	r19, r21
     304:	f4 16       	cp	r15, r20
     306:	fa 16       	cp	r15, r26
     308:	00 17       	cp	r16, r16
     30a:	06 17       	cp	r16, r22
     30c:	0c 17       	cp	r16, r28
     30e:	12 17       	cp	r17, r18
     310:	18 17       	cp	r17, r24
     312:	1e 17       	cp	r17, r30
     314:	35 17       	cp	r19, r21
     316:	24 17       	cp	r18, r20
     318:	2a 17       	cp	r18, r26
     31a:	30 17       	cp	r19, r16

0000031c <__trampolines_end>:
     31c:	00 00       	nop
     31e:	0a 0b       	sbc	r16, r26
     320:	02 09       	sbc	r16, r2
     322:	0c 0d       	add	r16, r12
     324:	0e 08       	sbc	r0, r14
     326:	07 03       	mulsu	r16, r23
     328:	04 01       	movw	r0, r8
	...
     346:	00 00       	nop
     348:	12 11       	cpse	r17, r2
     34a:	10 00       	.word	0x0010	; ????
	...

00000362 <digital_pin_to_bit_mask_PGM>:
     362:	01 02 10 20 20 08 08 10 20 40 10 20 40 80 02 01     ...  ... @. @...
     372:	02 01 08 04 02 01 01 02 04 08 10 20 40 80 80 40     ........... @..@
     382:	20 10 08 04 02 01 80 04 02 01 80 40 20 10 08 04      ..........@ ...
     392:	02 01 08 04 02 01 01 02 04 08 10 20 40 80 01 02     ........... @...
     3a2:	04 08 10 20 40 80                                   ... @.

000003a8 <digital_pin_to_port_PGM>:
     3a8:	05 05 05 05 07 05 08 08 08 08 02 02 02 02 0a 0a     ................
     3b8:	08 08 04 04 04 04 01 01 01 01 01 01 01 01 03 03     ................
     3c8:	03 03 03 03 03 03 04 07 07 07 0c 0c 0c 0c 0c 0c     ................
     3d8:	0c 0c 02 02 02 02 06 06 06 06 06 06 06 06 0b 0b     ................
     3e8:	0b 0b 0b 0b 0b 0b                                   ......

000003ee <port_to_input_PGM>:
     3ee:	00 00 20 00 23 00 26 00 29 00 2c 00 2f 00 32 00     .. .#.&.).,./.2.
     3fe:	00 01 00 00 03 01 06 01 09 01                       ..........

00000408 <port_to_output_PGM>:
     408:	00 00 22 00 25 00 28 00 2b 00 2e 00 31 00 34 00     ..".%.(.+...1.4.
     418:	02 01 00 00 05 01 08 01 0b 01                       ..........

00000422 <port_to_mode_PGM>:
     422:	00 00 21 00 24 00 27 00 2a 00 2d 00 30 00 33 00     ..!.$.'.*.-.0.3.
     432:	01 01 00 00 04 01 07 01 0a 01                       ..........

0000043c <__ctors_start>:
     43c:	b4 02       	muls	r27, r20
     43e:	4b 10       	cpse	r4, r11
     440:	24 15       	cp	r18, r4

00000442 <__ctors_end>:
     442:	11 24       	eor	r1, r1
     444:	1f be       	out	0x3f, r1	; 63
     446:	cf ef       	ldi	r28, 0xFF	; 255
     448:	d1 e2       	ldi	r29, 0x21	; 33
     44a:	de bf       	out	0x3e, r29	; 62
     44c:	cd bf       	out	0x3d, r28	; 61
     44e:	00 e0       	ldi	r16, 0x00	; 0
     450:	0c bf       	out	0x3c, r16	; 60

00000452 <__do_copy_data>:
     452:	12 e0       	ldi	r17, 0x02	; 2
     454:	a0 e0       	ldi	r26, 0x00	; 0
     456:	b2 e0       	ldi	r27, 0x02	; 2
     458:	e0 e7       	ldi	r30, 0x70	; 112
     45a:	f5 e3       	ldi	r31, 0x35	; 53
     45c:	00 e0       	ldi	r16, 0x00	; 0
     45e:	0b bf       	out	0x3b, r16	; 59
     460:	02 c0       	rjmp	.+4      	; 0x466 <__do_copy_data+0x14>
     462:	07 90       	elpm	r0, Z+
     464:	0d 92       	st	X+, r0
     466:	ac 3a       	cpi	r26, 0xAC	; 172
     468:	b1 07       	cpc	r27, r17
     46a:	d9 f7       	brne	.-10     	; 0x462 <__do_copy_data+0x10>

0000046c <__do_clear_bss>:
     46c:	2e e0       	ldi	r18, 0x0E	; 14
     46e:	ac ea       	ldi	r26, 0xAC	; 172
     470:	b2 e0       	ldi	r27, 0x02	; 2
     472:	01 c0       	rjmp	.+2      	; 0x476 <.do_clear_bss_start>

00000474 <.do_clear_bss_loop>:
     474:	1d 92       	st	X+, r1

00000476 <.do_clear_bss_start>:
     476:	ac 3f       	cpi	r26, 0xFC	; 252
     478:	b2 07       	cpc	r27, r18
     47a:	e1 f7       	brne	.-8      	; 0x474 <.do_clear_bss_loop>

0000047c <__do_global_ctors>:
     47c:	14 e0       	ldi	r17, 0x04	; 4
     47e:	c2 e4       	ldi	r28, 0x42	; 66
     480:	d4 e0       	ldi	r29, 0x04	; 4
     482:	00 e0       	ldi	r16, 0x00	; 0
     484:	06 c0       	rjmp	.+12     	; 0x492 <__do_global_ctors+0x16>
     486:	22 97       	sbiw	r28, 0x02	; 2
     488:	01 09       	sbc	r16, r1
     48a:	fe 01       	movw	r30, r28
     48c:	0b bf       	out	0x3b, r16	; 59
     48e:	0e 94 f6 17 	call	0x2fec	; 0x2fec <__tablejump_elpm__>
     492:	cc 33       	cpi	r28, 0x3C	; 60
     494:	d1 07       	cpc	r29, r17
     496:	80 e0       	ldi	r24, 0x00	; 0
     498:	08 07       	cpc	r16, r24
     49a:	a9 f7       	brne	.-22     	; 0x486 <__do_global_ctors+0xa>
     49c:	2c d0       	rcall	.+88     	; 0x4f6 <main>
     49e:	0c 94 b6 1a 	jmp	0x356c	; 0x356c <_exit>

000004a2 <__bad_interrupt>:
     4a2:	ae cd       	rjmp	.-1188   	; 0x0 <__vectors>

000004a4 <setup>:
	}
}*/
#define STACK_DEPTH 128//64

void vApplicationIdleHook()
{
     4a4:	26 e0       	ldi	r18, 0x06	; 6
     4a6:	40 e0       	ldi	r20, 0x00	; 0
     4a8:	52 ec       	ldi	r21, 0xC2	; 194
     4aa:	61 e0       	ldi	r22, 0x01	; 1
     4ac:	70 e0       	ldi	r23, 0x00	; 0
     4ae:	86 e5       	ldi	r24, 0x56	; 86
     4b0:	9e e0       	ldi	r25, 0x0E	; 14
     4b2:	0e 94 58 14 	call	0x28b0	; 0x28b0 <_ZN14HardwareSerial5beginEmh>
     4b6:	84 e0       	ldi	r24, 0x04	; 4
     4b8:	9e e0       	ldi	r25, 0x0E	; 14
     4ba:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN7TwoWire5beginEv>
     4be:	42 e0       	ldi	r20, 0x02	; 2
     4c0:	63 e0       	ldi	r22, 0x03	; 3
     4c2:	89 ed       	ldi	r24, 0xD9	; 217
     4c4:	96 e0       	ldi	r25, 0x06	; 6
     4c6:	d3 d1       	rcall	.+934    	; 0x86e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE>
     4c8:	89 ed       	ldi	r24, 0xD9	; 217
     4ca:	96 e0       	ldi	r25, 0x06	; 6
     4cc:	8f d1       	rcall	.+798    	; 0x7ec <_ZN3L3G13enableDefaultEv>
     4ce:	82 ed       	ldi	r24, 0xD2	; 210
     4d0:	96 e0       	ldi	r25, 0x06	; 6
     4d2:	38 d3       	rcall	.+1648   	; 0xb44 <_ZN3LPS13enableDefaultEv>
     4d4:	42 e0       	ldi	r20, 0x02	; 2
     4d6:	64 e0       	ldi	r22, 0x04	; 4
     4d8:	8c ea       	ldi	r24, 0xAC	; 172
     4da:	96 e0       	ldi	r25, 0x06	; 6
     4dc:	b6 d4       	rcall	.+2412   	; 0xe4a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE>
     4de:	8c ea       	ldi	r24, 0xAC	; 172
     4e0:	96 e0       	ldi	r25, 0x06	; 6
     4e2:	4a d4       	rcall	.+2196   	; 0xd78 <_ZN6LSM30313enableDefaultEv>
     4e4:	61 e0       	ldi	r22, 0x01	; 1
     4e6:	86 e1       	ldi	r24, 0x16	; 22
     4e8:	0e 94 36 17 	call	0x2e6c	; 0x2e6c <pinMode>
     4ec:	60 e0       	ldi	r22, 0x00	; 0
     4ee:	88 e1       	ldi	r24, 0x18	; 24
     4f0:	0c 94 36 17 	jmp	0x2e6c	; 0x2e6c <pinMode>
     4f4:	08 95       	ret

000004f6 <main>:
	//Do nothing
}

int main(void)
{
     4f6:	af 92       	push	r10
     4f8:	bf 92       	push	r11
     4fa:	cf 92       	push	r12
     4fc:	df 92       	push	r13
     4fe:	ef 92       	push	r14
     500:	ff 92       	push	r15
     502:	0f 93       	push	r16
     504:	cf 93       	push	r28
     506:	df 93       	push	r29
     508:	1f 92       	push	r1
     50a:	1f 92       	push	r1
     50c:	cd b7       	in	r28, 0x3d	; 61
     50e:	de b7       	in	r29, 0x3e	; 62
	init();
     510:	0e 94 6e 16 	call	0x2cdc	; 0x2cdc <init>
	setup();
     514:	c7 df       	rcall	.-114    	; 0x4a4 <setup>
	pinMode(12,OUTPUT);
     516:	61 e0       	ldi	r22, 0x01	; 1
     518:	8c e0       	ldi	r24, 0x0C	; 12
     51a:	0e 94 36 17 	call	0x2e6c	; 0x2e6c <pinMode>
	pinMode(13,OUTPUT);
     51e:	61 e0       	ldi	r22, 0x01	; 1
     520:	8d e0       	ldi	r24, 0x0D	; 13
     522:	0e 94 36 17 	call	0x2e6c	; 0x2e6c <pinMode>
	//Create tasks
	//xTaskCreate(task1, "Task 1", STACK_DEPTH, NULL, 6, &t1);
	//xTaskCreate(task2, "Task 2", STACK_DEPTH, NULL, 5, &t2);
//	xTaskCreate(printArray, "Task Gyro", STACK_DEPTH,NULL,0,&t1);
	//xTaskCreate(task_sonar1,"task sornar",STACK_DEPTH,NULL,5,&t2);
	xTaskCreate(task_baro, "Task Gyro", STACK_DEPTH,NULL,5,&t1);
     526:	a1 2c       	mov	r10, r1
     528:	b1 2c       	mov	r11, r1
     52a:	c1 2c       	mov	r12, r1
     52c:	d1 2c       	mov	r13, r1
     52e:	ce 01       	movw	r24, r28
     530:	01 96       	adiw	r24, 0x01	; 1
     532:	7c 01       	movw	r14, r24
     534:	05 e0       	ldi	r16, 0x05	; 5
     536:	20 e0       	ldi	r18, 0x00	; 0
     538:	30 e0       	ldi	r19, 0x00	; 0
     53a:	40 e8       	ldi	r20, 0x80	; 128
     53c:	50 e0       	ldi	r21, 0x00	; 0
     53e:	63 e2       	ldi	r22, 0x23	; 35
     540:	72 e0       	ldi	r23, 0x02	; 2
     542:	84 ef       	ldi	r24, 0xF4	; 244
     544:	92 e0       	ldi	r25, 0x02	; 2
     546:	ad d7       	rcall	.+3930   	; 0x14a2 <xTaskGenericCreate>
	//xTaskCreate(task_ir,"Task Accelerometer", STACK_DEPTH, NULL,6,&t2);
	
	vTaskStartScheduler();
     548:	0e 94 4b 0b 	call	0x1696	; 0x1696 <vTaskStartScheduler>
     54c:	80 e0       	ldi	r24, 0x00	; 0
     54e:	90 e0       	ldi	r25, 0x00	; 0
     550:	0f 90       	pop	r0
     552:	0f 90       	pop	r0
     554:	df 91       	pop	r29
     556:	cf 91       	pop	r28
     558:	0f 91       	pop	r16
     55a:	ff 90       	pop	r15
     55c:	ef 90       	pop	r14
     55e:	df 90       	pop	r13
     560:	cf 90       	pop	r12
     562:	bf 90       	pop	r11
     564:	af 90       	pop	r10
     566:	08 95       	ret

00000568 <_GLOBAL__sub_I_sonar>:
     568:	ef 92       	push	r14
     56a:	0f 93       	push	r16

/*sonar code*/
#define TRIGGER_PIN  22  // Arduino pin tied to trigger pin on the ultrasonic sensor.
#define ECHO_PIN     24  // Arduino pin tied to echo pin on the ultrasonic sensor.
#define MAX_DISTANCE 200 // Maximum distance we want to ping for (in centimeters). Maximum sensor distance is rated at 400-500cm.
NewPing sonar(TRIGGER_PIN, ECHO_PIN, MAX_DISTANCE); // NewPing setup of pins and maximum distance.
     56c:	28 ec       	ldi	r18, 0xC8	; 200
     56e:	30 e0       	ldi	r19, 0x00	; 0
     570:	48 e1       	ldi	r20, 0x18	; 24
     572:	66 e1       	ldi	r22, 0x16	; 22
     574:	89 e4       	ldi	r24, 0x49	; 73
     576:	97 e0       	ldi	r25, 0x07	; 7
     578:	44 d5       	rcall	.+2696   	; 0x1002 <_ZN7NewPingC1Ehhi>
};
//row and col are adjustable
byte rowPins[ROWS] = {33, 32, 31, 30}; //connect to the row pinouts of the keypad;
byte colPins[COLS] = {36, 35, 34}; //connect to the column pinouts of the keypad;

Keypad keypad = Keypad( makeKeymap(keys), rowPins, colPins, ROWS, COLS );
     57a:	0f 2e       	mov	r0, r31
     57c:	f3 e0       	ldi	r31, 0x03	; 3
     57e:	ef 2e       	mov	r14, r31
     580:	f0 2d       	mov	r31, r0
     582:	04 e0       	ldi	r16, 0x04	; 4
     584:	20 e0       	ldi	r18, 0x00	; 0
     586:	32 e0       	ldi	r19, 0x02	; 2
     588:	43 e0       	ldi	r20, 0x03	; 3
     58a:	52 e0       	ldi	r21, 0x02	; 2
     58c:	67 e0       	ldi	r22, 0x07	; 7
     58e:	72 e0       	ldi	r23, 0x02	; 2
     590:	85 ee       	ldi	r24, 0xE5	; 229
     592:	96 e0       	ldi	r25, 0x06	; 6
     594:	a9 d0       	rcall	.+338    	; 0x6e8 <_ZN6KeypadC1EPcPhS1_hh>
#define sensorIR 15               //Must be an analog pin
float sensorValue, inches, cm;    //Must be of type float for pow()
/*IR code*/

/*gyro code*/
L3G gyro;
     596:	89 ed       	ldi	r24, 0xD9	; 217
     598:	96 e0       	ldi	r25, 0x06	; 6
     59a:	01 d1       	rcall	.+514    	; 0x79e <_ZN3L3GC1Ev>
/*gyro code*/

/*baro code*/
LPS ps;
     59c:	82 ed       	ldi	r24, 0xD2	; 210
     59e:	96 e0       	ldi	r25, 0x06	; 6
     5a0:	88 d2       	rcall	.+1296   	; 0xab2 <_ZN3LPSC1Ev>
/*baro code*/

/*accelerometer code*/
LSM303 compass;
     5a2:	8c ea       	ldi	r24, 0xAC	; 172
     5a4:	96 e0       	ldi	r25, 0x06	; 6
     5a6:	81 d3       	rcall	.+1794   	; 0xcaa <_ZN6LSM303C1Ev>
	//xTaskCreate(task_sonar1,"task sornar",STACK_DEPTH,NULL,5,&t2);
	xTaskCreate(task_baro, "Task Gyro", STACK_DEPTH,NULL,5,&t1);
	//xTaskCreate(task_ir,"Task Accelerometer", STACK_DEPTH, NULL,6,&t2);
	
	vTaskStartScheduler();
     5a8:	0f 91       	pop	r16
     5aa:	ef 90       	pop	r14
     5ac:	08 95       	ret

000005ae <_Z10debugPrintPKc>:

char debugBuffer[1024];
//char debugBuffer[2048];
void debugPrint(const char *str)
{
	Serial.println(str);
     5ae:	bc 01       	movw	r22, r24
     5b0:	86 e5       	ldi	r24, 0x56	; 86
     5b2:	9e e0       	ldi	r25, 0x0E	; 14
     5b4:	0e 94 c5 15 	call	0x2b8a	; 0x2b8a <_ZN5Print7printlnEPKc>
	Serial.flush();
     5b8:	86 e5       	ldi	r24, 0x56	; 86
     5ba:	9e e0       	ldi	r25, 0x0E	; 14
     5bc:	0c 94 f1 13 	jmp	0x27e2	; 0x27e2 <_ZN14HardwareSerial5flushEv>
     5c0:	08 95       	ret

000005c2 <_Z7dprintfPKcz>:
}
void dprintf(const char *fmt, ...)
{
     5c2:	cf 93       	push	r28
     5c4:	df 93       	push	r29
     5c6:	cd b7       	in	r28, 0x3d	; 61
     5c8:	de b7       	in	r29, 0x3e	; 62
     5ca:	fe 01       	movw	r30, r28
     5cc:	36 96       	adiw	r30, 0x06	; 6
     5ce:	61 91       	ld	r22, Z+
     5d0:	71 91       	ld	r23, Z+
	va_list argptr;
	va_start(argptr, fmt);
	vsprintf(debugBuffer, fmt, argptr);
     5d2:	af 01       	movw	r20, r30
     5d4:	8c ea       	ldi	r24, 0xAC	; 172
     5d6:	92 e0       	ldi	r25, 0x02	; 2
     5d8:	0e 94 fa 17 	call	0x2ff4	; 0x2ff4 <vsprintf>
	va_end(argptr);
	debugPrint(debugBuffer);
     5dc:	8c ea       	ldi	r24, 0xAC	; 172
     5de:	92 e0       	ldi	r25, 0x02	; 2
     5e0:	e6 df       	rcall	.-52     	; 0x5ae <_Z10debugPrintPKc>
}
     5e2:	df 91       	pop	r29
     5e4:	cf 91       	pop	r28
     5e6:	08 95       	ret

000005e8 <_Z9task_baroPv>:
		//dprintf(" mbar\ta: ");
		//dprintf("%d",(int)altitude);
		//dprintf(" m\tt: ");
		//dprintf("%d",temperature);
		//dprintf(" deg C");
		dprintf("%d is pressure, %d is altitude, %d is temperature",(int) pressure,(int)  altitude,(int) temperature);
     5e8:	cd e2       	ldi	r28, 0x2D	; 45
     5ea:	d2 e0       	ldi	r29, 0x02	; 2

void task_baro(void* p){
	/*baro code*/ 
	while(1)
	{
		float pressure = ps.readPressureMillibars();
     5ec:	82 ed       	ldi	r24, 0xD2	; 210
     5ee:	96 e0       	ldi	r25, 0x06	; 6
     5f0:	0b d3       	rcall	.+1558   	; 0xc08 <_ZN3LPS21readPressureMillibarsEv>
     5f2:	6b 01       	movw	r12, r22
     5f4:	7c 01       	movw	r14, r24
		//dprintf("raw pressure is %d",(int) ((float)ps.readPressureRaw()/ 4096));
		float altitude = ps.pressureToAltitudeMeters(pressure);
     5f6:	20 e0       	ldi	r18, 0x00	; 0
     5f8:	30 e5       	ldi	r19, 0x50	; 80
     5fa:	4d e7       	ldi	r20, 0x7D	; 125
     5fc:	54 e4       	ldi	r21, 0x44	; 68
     5fe:	5f d2       	rcall	.+1214   	; 0xabe <_ZN3LPS24pressureToAltitudeMetersEff>
     600:	4b 01       	movw	r8, r22
     602:	5c 01       	movw	r10, r24
		float temperature = ps.readTemperatureC();
     604:	82 ed       	ldi	r24, 0xD2	; 210
     606:	96 e0       	ldi	r25, 0x06	; 6
     608:	3b d3       	rcall	.+1654   	; 0xc80 <_ZN3LPS16readTemperatureCEv>
		//dprintf(" mbar\ta: ");
		//dprintf("%d",(int)altitude);
		//dprintf(" m\tt: ");
		//dprintf("%d",temperature);
		//dprintf(" deg C");
		dprintf("%d is pressure, %d is altitude, %d is temperature",(int) pressure,(int)  altitude,(int) temperature);
     60a:	0e 94 1c 11 	call	0x2238	; 0x2238 <__fixsfsi>
     60e:	7f 93       	push	r23
     610:	6f 93       	push	r22
     612:	c5 01       	movw	r24, r10
     614:	b4 01       	movw	r22, r8
     616:	0e 94 1c 11 	call	0x2238	; 0x2238 <__fixsfsi>
     61a:	7f 93       	push	r23
     61c:	6f 93       	push	r22
     61e:	c7 01       	movw	r24, r14
     620:	b6 01       	movw	r22, r12
     622:	0e 94 1c 11 	call	0x2238	; 0x2238 <__fixsfsi>
     626:	7f 93       	push	r23
     628:	6f 93       	push	r22
     62a:	df 93       	push	r29
     62c:	cf 93       	push	r28
     62e:	c9 df       	rcall	.-110    	; 0x5c2 <_Z7dprintfPKcz>
		Serial.print(" mbar\ta: ");
		Serial.print(altitude);
		Serial.print(" m\tt: ");
		Serial.print(temperature);
		Serial.println(" deg C");
*/		delay(1000);
     630:	68 ee       	ldi	r22, 0xE8	; 232
     632:	73 e0       	ldi	r23, 0x03	; 3
     634:	80 e0       	ldi	r24, 0x00	; 0
     636:	90 e0       	ldi	r25, 0x00	; 0
     638:	0e 94 45 16 	call	0x2c8a	; 0x2c8a <delay>
		vTaskDelay(1000);
     63c:	88 ee       	ldi	r24, 0xE8	; 232
     63e:	93 e0       	ldi	r25, 0x03	; 3
     640:	0e 94 b3 0c 	call	0x1966	; 0x1966 <vTaskDelay>
     644:	8d b7       	in	r24, 0x3d	; 61
     646:	9e b7       	in	r25, 0x3e	; 62
     648:	08 96       	adiw	r24, 0x08	; 8
     64a:	0f b6       	in	r0, 0x3f	; 63
     64c:	f8 94       	cli
     64e:	9e bf       	out	0x3e, r25	; 62
     650:	0f be       	out	0x3f, r0	; 63
     652:	8d bf       	out	0x3d, r24	; 61
     654:	cb cf       	rjmp	.-106    	; 0x5ec <_Z9task_baroPv+0x4>

00000656 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     656:	cf 93       	push	r28
     658:	df 93       	push	r29
     65a:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     65c:	0e 94 74 0b 	call	0x16e8	; 0x16e8 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     660:	80 91 5b 07 	lds	r24, 0x075B
     664:	90 91 5c 07 	lds	r25, 0x075C
     668:	89 2b       	or	r24, r25
     66a:	31 f4       	brne	.+12     	; 0x678 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     66c:	80 e6       	ldi	r24, 0x60	; 96
     66e:	97 e0       	ldi	r25, 0x07	; 7
     670:	90 93 5c 07 	sts	0x075C, r25
     674:	80 93 5b 07 	sts	0x075B, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     678:	40 91 5d 07 	lds	r20, 0x075D
     67c:	50 91 5e 07 	lds	r21, 0x075E
     680:	9e 01       	movw	r18, r28
     682:	24 0f       	add	r18, r20
     684:	35 1f       	adc	r19, r21
     686:	2b 3d       	cpi	r18, 0xDB	; 219
     688:	85 e0       	ldi	r24, 0x05	; 5
     68a:	38 07       	cpc	r19, r24
     68c:	70 f4       	brcc	.+28     	; 0x6aa <pvPortMalloc+0x54>
     68e:	42 17       	cp	r20, r18
     690:	53 07       	cpc	r21, r19
     692:	70 f4       	brcc	.+28     	; 0x6b0 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     694:	c0 91 5b 07 	lds	r28, 0x075B
     698:	d0 91 5c 07 	lds	r29, 0x075C
     69c:	c4 0f       	add	r28, r20
     69e:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     6a0:	30 93 5e 07 	sts	0x075E, r19
     6a4:	20 93 5d 07 	sts	0x075D, r18
     6a8:	05 c0       	rjmp	.+10     	; 0x6b4 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     6aa:	c0 e0       	ldi	r28, 0x00	; 0
     6ac:	d0 e0       	ldi	r29, 0x00	; 0
     6ae:	02 c0       	rjmp	.+4      	; 0x6b4 <pvPortMalloc+0x5e>
     6b0:	c0 e0       	ldi	r28, 0x00	; 0
     6b2:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     6b4:	0e 94 35 0c 	call	0x186a	; 0x186a <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     6b8:	ce 01       	movw	r24, r28
     6ba:	df 91       	pop	r29
     6bc:	cf 91       	pop	r28
     6be:	08 95       	ret

000006c0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     6c0:	08 95       	ret

000006c2 <_ZN3KeyC1Ev>:
*/
#include <Key.h>


// default constructor
Key::Key() {
     6c2:	fc 01       	movw	r30, r24
	kchar = NO_KEY;
     6c4:	10 82       	st	Z, r1
	kstate = IDLE;
     6c6:	13 82       	std	Z+3, r1	; 0x03
	stateChanged = false;
     6c8:	14 82       	std	Z+4, r1	; 0x04
     6ca:	08 95       	ret

000006cc <_ZN6Keypad8pin_modeEhh>:
class Keypad : public Key {
public:

	Keypad(char *userKeymap, unsigned char *row, unsigned char *col, unsigned char numRows, unsigned char numCols);

	virtual void pin_mode(unsigned char pinNum, unsigned char mode) { pinMode(pinNum, mode); }
     6cc:	86 2f       	mov	r24, r22
     6ce:	64 2f       	mov	r22, r20
     6d0:	0c 94 36 17 	jmp	0x2e6c	; 0x2e6c <pinMode>
     6d4:	08 95       	ret

000006d6 <_ZN6Keypad9pin_writeEhb>:
	virtual void pin_write(unsigned char pinNum, bool level) { digitalWrite(pinNum, level); }
     6d6:	86 2f       	mov	r24, r22
     6d8:	64 2f       	mov	r22, r20
     6da:	0c 94 74 17 	jmp	0x2ee8	; 0x2ee8 <digitalWrite>
     6de:	08 95       	ret

000006e0 <_ZN6Keypad8pin_readEh>:
	virtual int  pin_read(unsigned char pinNum) { return digitalRead(pinNum); }
     6e0:	86 2f       	mov	r24, r22
     6e2:	0c 94 a4 17 	jmp	0x2f48	; 0x2f48 <digitalRead>
     6e6:	08 95       	ret

000006e8 <_ZN6KeypadC1EPcPhS1_hh>:
#include <Arduino.h>
#include <avr/io.h>
#include <Key.h>

// <<constructor>> Allows custom keymap, pin configuration, and keypad sizes.
Keypad::Keypad(char *userKeymap, unsigned char *row, unsigned char *col, unsigned char numRows, unsigned char numCols) {
     6e8:	4f 92       	push	r4
     6ea:	5f 92       	push	r5
     6ec:	6f 92       	push	r6
     6ee:	7f 92       	push	r7
     6f0:	8f 92       	push	r8
     6f2:	9f 92       	push	r9
     6f4:	af 92       	push	r10
     6f6:	bf 92       	push	r11
     6f8:	cf 92       	push	r12
     6fa:	df 92       	push	r13
     6fc:	ef 92       	push	r14
     6fe:	0f 93       	push	r16
     700:	cf 93       	push	r28
     702:	df 93       	push	r29
     704:	ec 01       	movw	r28, r24
     706:	4b 01       	movw	r8, r22
     708:	3a 01       	movw	r6, r20
     70a:	59 01       	movw	r10, r18
     70c:	02 96       	adiw	r24, 0x02	; 2
     70e:	d9 df       	rcall	.-78     	; 0x6c2 <_ZN3KeyC1Ev>
     710:	80 e8       	ldi	r24, 0x80	; 128
     712:	92 e0       	ldi	r25, 0x02	; 2
     714:	99 83       	std	Y+1, r25	; 0x01
     716:	88 83       	st	Y, r24
     718:	2e 01       	movw	r4, r28
     71a:	8b e1       	ldi	r24, 0x1B	; 27
     71c:	48 0e       	add	r4, r24
     71e:	51 1c       	adc	r5, r1
     720:	62 01       	movw	r12, r4
     722:	82 e3       	ldi	r24, 0x32	; 50
     724:	c8 0e       	add	r12, r24
     726:	d1 1c       	adc	r13, r1
     728:	c2 01       	movw	r24, r4
     72a:	cb df       	rcall	.-106    	; 0x6c2 <_ZN3KeyC1Ev>
     72c:	85 e0       	ldi	r24, 0x05	; 5
     72e:	48 0e       	add	r4, r24
     730:	51 1c       	adc	r5, r1
     732:	4c 14       	cp	r4, r12
     734:	5d 04       	cpc	r5, r13
     736:	c1 f7       	brne	.-16     	; 0x728 <_ZN6KeypadC1EPcPhS1_hh+0x40>
	rowPins = row;
     738:	fe 01       	movw	r30, r28
     73a:	e9 5a       	subi	r30, 0xA9	; 169
     73c:	ff 4f       	sbci	r31, 0xFF	; 255
     73e:	71 82       	std	Z+1, r7	; 0x01
     740:	60 82       	st	Z, r6
	columnPins = col;
     742:	32 96       	adiw	r30, 0x02	; 2
     744:	b1 82       	std	Z+1, r11	; 0x01
     746:	a0 82       	st	Z, r10
	sizeKpd.rows = numRows;
     748:	32 96       	adiw	r30, 0x02	; 2
     74a:	00 83       	st	Z, r16
	sizeKpd.columns = numCols;
     74c:	31 96       	adiw	r30, 0x01	; 1
     74e:	e0 82       	st	Z, r14
	single_key = false;
}

// Let the user define a keymap - assume the same row/column count as defined in constructor
void Keypad::begin(char *userKeymap) {
    keymap = userKeymap;
     750:	37 97       	sbiw	r30, 0x07	; 7
     752:	91 82       	std	Z+1, r9	; 0x01
     754:	80 82       	st	Z, r8
	return sizeof(key)/sizeof(Key);
}

// Minimum debounceTime is 1 mS. Any lower *will* slow down the loop().
void Keypad::setDebounceTime(uint debounce) {
	debounce<1 ? debounceTime=1 : debounceTime=debounce;
     756:	38 96       	adiw	r30, 0x08	; 8
     758:	8a e0       	ldi	r24, 0x0A	; 10
     75a:	90 e0       	ldi	r25, 0x00	; 0
     75c:	91 83       	std	Z+1, r25	; 0x01
     75e:	80 83       	st	Z, r24
}

void Keypad::setHoldTime(uint hold) {
    holdTime = hold;
     760:	32 96       	adiw	r30, 0x02	; 2
     762:	84 ef       	ldi	r24, 0xF4	; 244
     764:	91 e0       	ldi	r25, 0x01	; 1
     766:	91 83       	std	Z+1, r25	; 0x01
     768:	80 83       	st	Z, r24

	begin(userKeymap);

	setDebounceTime(10);
	setHoldTime(500);
	keypadEventListener = 0;
     76a:	33 96       	adiw	r30, 0x03	; 3
     76c:	11 82       	std	Z+1, r1	; 0x01
     76e:	10 82       	st	Z, r1

	startTime = 0;
     770:	71 97       	sbiw	r30, 0x11	; 17
     772:	10 82       	st	Z, r1
     774:	11 82       	std	Z+1, r1	; 0x01
     776:	12 82       	std	Z+2, r1	; 0x02
     778:	13 82       	std	Z+3, r1	; 0x03
	single_key = false;
     77a:	cf 59       	subi	r28, 0x9F	; 159
     77c:	df 4f       	sbci	r29, 0xFF	; 255
     77e:	18 82       	st	Y, r1
}
     780:	df 91       	pop	r29
     782:	cf 91       	pop	r28
     784:	0f 91       	pop	r16
     786:	ef 90       	pop	r14
     788:	df 90       	pop	r13
     78a:	cf 90       	pop	r12
     78c:	bf 90       	pop	r11
     78e:	af 90       	pop	r10
     790:	9f 90       	pop	r9
     792:	8f 90       	pop	r8
     794:	7f 90       	pop	r7
     796:	6f 90       	pop	r6
     798:	5f 90       	pop	r5
     79a:	4f 90       	pop	r4
     79c:	08 95       	ret

0000079e <_ZN3L3GC1Ev>:

  // combine high and low bytes
  g.x = (int16_t)(xhg << 8 | xlg);
  g.y = (int16_t)(yhg << 8 | ylg);
  g.z = (int16_t)(zhg << 8 | zlg);
}
     79e:	fc 01       	movw	r30, r24
     7a0:	83 e0       	ldi	r24, 0x03	; 3
     7a2:	87 83       	std	Z+7, r24	; 0x07
     7a4:	12 86       	std	Z+10, r1	; 0x0a
     7a6:	11 86       	std	Z+9, r1	; 0x09
     7a8:	13 86       	std	Z+11, r1	; 0x0b
     7aa:	08 95       	ret

000007ac <_ZN3L3G8writeRegEhh>:
     7ac:	0f 93       	push	r16
     7ae:	1f 93       	push	r17
     7b0:	cf 93       	push	r28
     7b2:	df 93       	push	r29
     7b4:	ec 01       	movw	r28, r24
     7b6:	06 2f       	mov	r16, r22
     7b8:	14 2f       	mov	r17, r20
     7ba:	68 85       	ldd	r22, Y+8	; 0x08
     7bc:	84 e0       	ldi	r24, 0x04	; 4
     7be:	9e e0       	ldi	r25, 0x0E	; 14
     7c0:	0e 94 2c 10 	call	0x2058	; 0x2058 <_ZN7TwoWire17beginTransmissionEh>
     7c4:	60 2f       	mov	r22, r16
     7c6:	84 e0       	ldi	r24, 0x04	; 4
     7c8:	9e e0       	ldi	r25, 0x0E	; 14
     7ca:	0e 94 d3 0f 	call	0x1fa6	; 0x1fa6 <_ZN7TwoWire5writeEh>
     7ce:	61 2f       	mov	r22, r17
     7d0:	84 e0       	ldi	r24, 0x04	; 4
     7d2:	9e e0       	ldi	r25, 0x0E	; 14
     7d4:	0e 94 d3 0f 	call	0x1fa6	; 0x1fa6 <_ZN7TwoWire5writeEh>
     7d8:	84 e0       	ldi	r24, 0x04	; 4
     7da:	9e e0       	ldi	r25, 0x0E	; 14
     7dc:	0e 94 48 10 	call	0x2090	; 0x2090 <_ZN7TwoWire15endTransmissionEv>
     7e0:	8e 83       	std	Y+6, r24	; 0x06
     7e2:	df 91       	pop	r29
     7e4:	cf 91       	pop	r28
     7e6:	1f 91       	pop	r17
     7e8:	0f 91       	pop	r16
     7ea:	08 95       	ret

000007ec <_ZN3L3G13enableDefaultEv>:
     7ec:	cf 93       	push	r28
     7ee:	df 93       	push	r29
     7f0:	ec 01       	movw	r28, r24
     7f2:	8f 81       	ldd	r24, Y+7	; 0x07
     7f4:	82 30       	cpi	r24, 0x02	; 2
     7f6:	21 f4       	brne	.+8      	; 0x800 <_ZN3L3G13enableDefaultEv+0x14>
     7f8:	40 e0       	ldi	r20, 0x00	; 0
     7fa:	69 e3       	ldi	r22, 0x39	; 57
     7fc:	ce 01       	movw	r24, r28
     7fe:	d6 df       	rcall	.-84     	; 0x7ac <_ZN3L3G8writeRegEhh>
     800:	40 e0       	ldi	r20, 0x00	; 0
     802:	63 e2       	ldi	r22, 0x23	; 35
     804:	ce 01       	movw	r24, r28
     806:	d2 df       	rcall	.-92     	; 0x7ac <_ZN3L3G8writeRegEhh>
     808:	4f e6       	ldi	r20, 0x6F	; 111
     80a:	60 e2       	ldi	r22, 0x20	; 32
     80c:	ce 01       	movw	r24, r28
     80e:	ce df       	rcall	.-100    	; 0x7ac <_ZN3L3G8writeRegEhh>
     810:	df 91       	pop	r29
     812:	cf 91       	pop	r28
     814:	08 95       	ret

00000816 <_ZN3L3G7testRegEhNS_7regAddrE>:
}

// Private Methods //////////////////////////////////////////////////////////////

int L3G::testReg(byte address, regAddr reg)
{
     816:	cf 93       	push	r28
     818:	df 93       	push	r29
     81a:	c6 2f       	mov	r28, r22
     81c:	d4 2f       	mov	r29, r20
  Wire.beginTransmission(address);
     81e:	84 e0       	ldi	r24, 0x04	; 4
     820:	9e e0       	ldi	r25, 0x0E	; 14
     822:	0e 94 2c 10 	call	0x2058	; 0x2058 <_ZN7TwoWire17beginTransmissionEh>
  Wire.write((byte)reg);
     826:	6d 2f       	mov	r22, r29
     828:	84 e0       	ldi	r24, 0x04	; 4
     82a:	9e e0       	ldi	r25, 0x0E	; 14
     82c:	0e 94 d3 0f 	call	0x1fa6	; 0x1fa6 <_ZN7TwoWire5writeEh>
  if (Wire.endTransmission() != 0)
     830:	84 e0       	ldi	r24, 0x04	; 4
     832:	9e e0       	ldi	r25, 0x0E	; 14
     834:	0e 94 48 10 	call	0x2090	; 0x2090 <_ZN7TwoWire15endTransmissionEv>
     838:	81 11       	cpse	r24, r1
     83a:	11 c0       	rjmp	.+34     	; 0x85e <_ZN3L3G7testRegEhNS_7regAddrE+0x48>
  {
    return TEST_REG_ERROR;
  }

  Wire.requestFrom(address, (byte)1);
     83c:	41 e0       	ldi	r20, 0x01	; 1
     83e:	6c 2f       	mov	r22, r28
     840:	84 e0       	ldi	r24, 0x04	; 4
     842:	9e e0       	ldi	r25, 0x0E	; 14
     844:	0e 94 29 10 	call	0x2052	; 0x2052 <_ZN7TwoWire11requestFromEhh>
  if (Wire.available())
     848:	84 e0       	ldi	r24, 0x04	; 4
     84a:	9e e0       	ldi	r25, 0x0E	; 14
     84c:	0e 94 79 0f 	call	0x1ef2	; 0x1ef2 <_ZN7TwoWire9availableEv>
     850:	89 2b       	or	r24, r25
     852:	41 f0       	breq	.+16     	; 0x864 <_ZN3L3G7testRegEhNS_7regAddrE+0x4e>
  {
    return Wire.read();
     854:	84 e0       	ldi	r24, 0x04	; 4
     856:	9e e0       	ldi	r25, 0x0E	; 14
     858:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <_ZN7TwoWire4readEv>
     85c:	05 c0       	rjmp	.+10     	; 0x868 <_ZN3L3G7testRegEhNS_7regAddrE+0x52>
{
  Wire.beginTransmission(address);
  Wire.write((byte)reg);
  if (Wire.endTransmission() != 0)
  {
    return TEST_REG_ERROR;
     85e:	8f ef       	ldi	r24, 0xFF	; 255
     860:	9f ef       	ldi	r25, 0xFF	; 255
     862:	02 c0       	rjmp	.+4      	; 0x868 <_ZN3L3G7testRegEhNS_7regAddrE+0x52>
  {
    return Wire.read();
  }
  else
  {
    return TEST_REG_ERROR;
     864:	8f ef       	ldi	r24, 0xFF	; 255
     866:	9f ef       	ldi	r25, 0xFF	; 255
  }
}
     868:	df 91       	pop	r29
     86a:	cf 91       	pop	r28
     86c:	08 95       	ret

0000086e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE>:
{
  return io_timeout;
}

bool L3G::init(deviceType device, sa0State sa0)
{
     86e:	0f 93       	push	r16
     870:	1f 93       	push	r17
     872:	cf 93       	push	r28
     874:	df 93       	push	r29
     876:	ec 01       	movw	r28, r24
     878:	16 2f       	mov	r17, r22
     87a:	04 2f       	mov	r16, r20
  int id;
  
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
     87c:	63 30       	cpi	r22, 0x03	; 3
     87e:	09 f4       	brne	.+2      	; 0x882 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x14>
     880:	56 c0       	rjmp	.+172    	; 0x92e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xc0>
     882:	42 30       	cpi	r20, 0x02	; 2
     884:	c9 f5       	brne	.+114    	; 0x8f8 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x8a>
     886:	56 c0       	rjmp	.+172    	; 0x934 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xc6>
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
        if (device == device_auto)
     888:	13 30       	cpi	r17, 0x03	; 3
     88a:	09 f0       	breq	.+2      	; 0x88e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x20>
     88c:	58 c0       	rjmp	.+176    	; 0x93e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xd0>
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     88e:	87 3d       	cpi	r24, 0xD7	; 215
     890:	91 05       	cpc	r25, r1
     892:	09 f4       	brne	.+2      	; 0x896 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x28>
     894:	58 c0       	rjmp	.+176    	; 0x946 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xd8>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
     896:	01 e0       	ldi	r16, 0x01	; 1
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     898:	11 e0       	ldi	r17, 0x01	; 1
     89a:	2c c0       	rjmp	.+88     	; 0x8f4 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
        }
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     89c:	01 30       	cpi	r16, 0x01	; 1
     89e:	91 f0       	breq	.+36     	; 0x8c4 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x56>
     8a0:	4f e0       	ldi	r20, 0x0F	; 15
     8a2:	6a e6       	ldi	r22, 0x6A	; 106
     8a4:	ce 01       	movw	r24, r28
     8a6:	b7 df       	rcall	.-146    	; 0x816 <_ZN3L3G7testRegEhNS_7regAddrE>
     8a8:	8f 3f       	cpi	r24, 0xFF	; 255
     8aa:	2f ef       	ldi	r18, 0xFF	; 255
     8ac:	92 07       	cpc	r25, r18
     8ae:	51 f0       	breq	.+20     	; 0x8c4 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x56>
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
        if (device == device_auto)
     8b0:	13 30       	cpi	r17, 0x03	; 3
     8b2:	09 f0       	breq	.+2      	; 0x8b6 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x48>
     8b4:	46 c0       	rjmp	.+140    	; 0x942 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xd4>
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     8b6:	87 3d       	cpi	r24, 0xD7	; 215
     8b8:	91 05       	cpc	r25, r1
     8ba:	09 f0       	breq	.+2      	; 0x8be <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x50>
     8bc:	47 c0       	rjmp	.+142    	; 0x94c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xde>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
     8be:	00 e0       	ldi	r16, 0x00	; 0
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     8c0:	12 e0       	ldi	r17, 0x02	; 2
     8c2:	18 c0       	rjmp	.+48     	; 0x8f4 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
        }
      }
    }
    
    // check for L3G4200D if device is still unidentified or was specified to be this type
    if (device == device_auto || device == device_4200D)
     8c4:	13 30       	cpi	r17, 0x03	; 3
     8c6:	11 f0       	breq	.+4      	; 0x8cc <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5e>
     8c8:	11 11       	cpse	r17, r1
     8ca:	14 c0       	rjmp	.+40     	; 0x8f4 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
    {
      if (sa0 != sa0_low && testReg(L3G4200D_SA0_HIGH_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
     8cc:	00 23       	and	r16, r16
     8ce:	49 f0       	breq	.+18     	; 0x8e2 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x74>
     8d0:	4f e0       	ldi	r20, 0x0F	; 15
     8d2:	69 e6       	ldi	r22, 0x69	; 105
     8d4:	ce 01       	movw	r24, r28
     8d6:	9f df       	rcall	.-194    	; 0x816 <_ZN3L3G7testRegEhNS_7regAddrE>
     8d8:	83 3d       	cpi	r24, 0xD3	; 211
     8da:	91 05       	cpc	r25, r1
     8dc:	d1 f1       	breq	.+116    	; 0x952 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xe4>
      {
        // device responds to address 1101001; it's a 4200D with SA0 high
        device = device_4200D;
        sa0 = sa0_high;
      }
      else if (sa0 != sa0_high && testReg(L3G4200D_SA0_LOW_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
     8de:	01 30       	cpi	r16, 0x01	; 1
     8e0:	39 f0       	breq	.+14     	; 0x8f0 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x82>
     8e2:	4f e0       	ldi	r20, 0x0F	; 15
     8e4:	68 e6       	ldi	r22, 0x68	; 104
     8e6:	ce 01       	movw	r24, r28
     8e8:	96 df       	rcall	.-212    	; 0x816 <_ZN3L3G7testRegEhNS_7regAddrE>
     8ea:	83 3d       	cpi	r24, 0xD3	; 211
     8ec:	91 05       	cpc	r25, r1
     8ee:	99 f1       	breq	.+102    	; 0x956 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xe8>
        sa0 = sa0_low;
      }
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
     8f0:	13 30       	cpi	r17, 0x03	; 3
     8f2:	b9 f0       	breq	.+46     	; 0x922 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xb4>
     8f4:	02 30       	cpi	r16, 0x02	; 2
     8f6:	b9 f0       	breq	.+46     	; 0x926 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xb8>
    {
      return false;
    }
  }
  
  _device = device;
     8f8:	1f 83       	std	Y+7, r17	; 0x07

  // set device address
  switch (device)
     8fa:	11 23       	and	r17, r17
     8fc:	51 f0       	breq	.+20     	; 0x912 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xa4>
     8fe:	13 30       	cpi	r17, 0x03	; 3
     900:	a0 f4       	brcc	.+40     	; 0x92a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xbc>
  {
    case device_D20H:
    case device_D20:
      address = (sa0 == sa0_high) ? D20_SA0_HIGH_ADDRESS : D20_SA0_LOW_ADDRESS;
     902:	01 30       	cpi	r16, 0x01	; 1
     904:	11 f4       	brne	.+4      	; 0x90a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x9c>
     906:	8b e6       	ldi	r24, 0x6B	; 107
     908:	01 c0       	rjmp	.+2      	; 0x90c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x9e>
     90a:	8a e6       	ldi	r24, 0x6A	; 106
     90c:	88 87       	std	Y+8, r24	; 0x08
    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
  }
  
  return true;
     90e:	81 e0       	ldi	r24, 0x01	; 1
  switch (device)
  {
    case device_D20H:
    case device_D20:
      address = (sa0 == sa0_high) ? D20_SA0_HIGH_ADDRESS : D20_SA0_LOW_ADDRESS;
      break;
     910:	41 c0       	rjmp	.+130    	; 0x994 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>

    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
     912:	01 30       	cpi	r16, 0x01	; 1
     914:	11 f4       	brne	.+4      	; 0x91a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xac>
     916:	89 e6       	ldi	r24, 0x69	; 105
     918:	01 c0       	rjmp	.+2      	; 0x91c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xae>
     91a:	88 e6       	ldi	r24, 0x68	; 104
     91c:	88 87       	std	Y+8, r24	; 0x08
      break;
  }
  
  return true;
     91e:	81 e0       	ldi	r24, 0x01	; 1
      address = (sa0 == sa0_high) ? D20_SA0_HIGH_ADDRESS : D20_SA0_LOW_ADDRESS;
      break;

    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
     920:	39 c0       	rjmp	.+114    	; 0x994 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
    {
      return false;
     922:	80 e0       	ldi	r24, 0x00	; 0
     924:	37 c0       	rjmp	.+110    	; 0x994 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
     926:	80 e0       	ldi	r24, 0x00	; 0
     928:	35 c0       	rjmp	.+106    	; 0x994 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
  }
  
  return true;
     92a:	81 e0       	ldi	r24, 0x01	; 1
     92c:	33 c0       	rjmp	.+102    	; 0x994 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
  {
    // check for L3GD20H, D20 if device is unidentified or was specified to be one of these types
    if (device == device_auto || device == device_D20H || device == device_D20)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     92e:	44 23       	and	r20, r20
     930:	41 f1       	breq	.+80     	; 0x982 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x114>
     932:	1e c0       	rjmp	.+60     	; 0x970 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x102>
  
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
  {
    // check for L3GD20H, D20 if device is unidentified or was specified to be one of these types
    if (device == device_auto || device == device_D20H || device == device_D20)
     934:	8f ef       	ldi	r24, 0xFF	; 255
     936:	86 0f       	add	r24, r22
     938:	83 30       	cpi	r24, 0x03	; 3
     93a:	30 f6       	brcc	.-116    	; 0x8c8 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5a>
     93c:	0f c0       	rjmp	.+30     	; 0x95c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xee>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
     93e:	01 e0       	ldi	r16, 0x01	; 1
     940:	c3 cf       	rjmp	.-122    	; 0x8c8 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5a>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
     942:	00 e0       	ldi	r16, 0x00	; 0
     944:	c1 cf       	rjmp	.-126    	; 0x8c8 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5a>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
     946:	01 e0       	ldi	r16, 0x01	; 1
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     948:	12 e0       	ldi	r17, 0x02	; 2
     94a:	d4 cf       	rjmp	.-88     	; 0x8f4 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
     94c:	00 e0       	ldi	r16, 0x00	; 0
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     94e:	11 e0       	ldi	r17, 0x01	; 1
     950:	d1 cf       	rjmp	.-94     	; 0x8f4 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
    {
      if (sa0 != sa0_low && testReg(L3G4200D_SA0_HIGH_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
      {
        // device responds to address 1101001; it's a 4200D with SA0 high
        device = device_4200D;
        sa0 = sa0_high;
     952:	01 e0       	ldi	r16, 0x01	; 1
     954:	01 c0       	rjmp	.+2      	; 0x958 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xea>
      }
      else if (sa0 != sa0_high && testReg(L3G4200D_SA0_LOW_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
      {
        // device responds to address 1101000; it's a 4200D with SA0 low
        device = device_4200D;
        sa0 = sa0_low;
     956:	00 e0       	ldi	r16, 0x00	; 0
    {
      return false;
    }
  }
  
  _device = device;
     958:	1f 82       	std	Y+7, r1	; 0x07
     95a:	db cf       	rjmp	.-74     	; 0x912 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xa4>
  {
    // check for L3GD20H, D20 if device is unidentified or was specified to be one of these types
    if (device == device_auto || device == device_D20H || device == device_D20)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     95c:	4f e0       	ldi	r20, 0x0F	; 15
     95e:	6b e6       	ldi	r22, 0x6B	; 107
     960:	ce 01       	movw	r24, r28
     962:	59 df       	rcall	.-334    	; 0x816 <_ZN3L3G7testRegEhNS_7regAddrE>
     964:	8f 3f       	cpi	r24, 0xFF	; 255
     966:	2f ef       	ldi	r18, 0xFF	; 255
     968:	92 07       	cpc	r25, r18
     96a:	09 f0       	breq	.+2      	; 0x96e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x100>
     96c:	8d cf       	rjmp	.-230    	; 0x888 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x1a>
     96e:	98 cf       	rjmp	.-208    	; 0x8a0 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x32>
     970:	4f e0       	ldi	r20, 0x0F	; 15
     972:	6b e6       	ldi	r22, 0x6B	; 107
     974:	50 df       	rcall	.-352    	; 0x816 <_ZN3L3G7testRegEhNS_7regAddrE>
     976:	8f 3f       	cpi	r24, 0xFF	; 255
     978:	2f ef       	ldi	r18, 0xFF	; 255
     97a:	92 07       	cpc	r25, r18
     97c:	09 f0       	breq	.+2      	; 0x980 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x112>
     97e:	87 cf       	rjmp	.-242    	; 0x88e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x20>
     980:	8d cf       	rjmp	.-230    	; 0x89c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x2e>
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
        }
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     982:	4f e0       	ldi	r20, 0x0F	; 15
     984:	6a e6       	ldi	r22, 0x6A	; 106
     986:	47 df       	rcall	.-370    	; 0x816 <_ZN3L3G7testRegEhNS_7regAddrE>
     988:	8f 3f       	cpi	r24, 0xFF	; 255
     98a:	2f ef       	ldi	r18, 0xFF	; 255
     98c:	92 07       	cpc	r25, r18
     98e:	09 f0       	breq	.+2      	; 0x992 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x124>
     990:	92 cf       	rjmp	.-220    	; 0x8b6 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x48>
     992:	98 cf       	rjmp	.-208    	; 0x8c4 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x56>
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
  }
  
  return true;
}
     994:	df 91       	pop	r29
     996:	cf 91       	pop	r28
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	08 95       	ret

0000099e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     99e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     9a0:	03 96       	adiw	r24, 0x03	; 3
     9a2:	92 83       	std	Z+2, r25	; 0x02
     9a4:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     9a6:	2f ef       	ldi	r18, 0xFF	; 255
     9a8:	3f ef       	ldi	r19, 0xFF	; 255
     9aa:	34 83       	std	Z+4, r19	; 0x04
     9ac:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     9ae:	96 83       	std	Z+6, r25	; 0x06
     9b0:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     9b2:	90 87       	std	Z+8, r25	; 0x08
     9b4:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     9b6:	10 82       	st	Z, r1
     9b8:	08 95       	ret

000009ba <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     9ba:	fc 01       	movw	r30, r24
     9bc:	11 86       	std	Z+9, r1	; 0x09
     9be:	10 86       	std	Z+8, r1	; 0x08
     9c0:	08 95       	ret

000009c2 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     9c2:	cf 93       	push	r28
     9c4:	df 93       	push	r29
     9c6:	9c 01       	movw	r18, r24
     9c8:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     9ca:	dc 01       	movw	r26, r24
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	cd 91       	ld	r28, X+
     9d0:	dc 91       	ld	r29, X
     9d2:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     9d4:	d3 83       	std	Z+3, r29	; 0x03
     9d6:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     9d8:	8c 81       	ldd	r24, Y+4	; 0x04
     9da:	9d 81       	ldd	r25, Y+5	; 0x05
     9dc:	95 83       	std	Z+5, r25	; 0x05
     9de:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     9e0:	8c 81       	ldd	r24, Y+4	; 0x04
     9e2:	9d 81       	ldd	r25, Y+5	; 0x05
     9e4:	dc 01       	movw	r26, r24
     9e6:	13 96       	adiw	r26, 0x03	; 3
     9e8:	7c 93       	st	X, r23
     9ea:	6e 93       	st	-X, r22
     9ec:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     9ee:	7d 83       	std	Y+5, r23	; 0x05
     9f0:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     9f2:	31 87       	std	Z+9, r19	; 0x09
     9f4:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     9f6:	f9 01       	movw	r30, r18
     9f8:	80 81       	ld	r24, Z
     9fa:	8f 5f       	subi	r24, 0xFF	; 255
     9fc:	80 83       	st	Z, r24
}
     9fe:	df 91       	pop	r29
     a00:	cf 91       	pop	r28
     a02:	08 95       	ret

00000a04 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     a04:	cf 93       	push	r28
     a06:	df 93       	push	r29
     a08:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     a0a:	48 81       	ld	r20, Y
     a0c:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     a0e:	4f 3f       	cpi	r20, 0xFF	; 255
     a10:	2f ef       	ldi	r18, 0xFF	; 255
     a12:	52 07       	cpc	r21, r18
     a14:	21 f4       	brne	.+8      	; 0xa1e <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     a16:	fc 01       	movw	r30, r24
     a18:	a7 81       	ldd	r26, Z+7	; 0x07
     a1a:	b0 85       	ldd	r27, Z+8	; 0x08
     a1c:	0d c0       	rjmp	.+26     	; 0xa38 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     a1e:	dc 01       	movw	r26, r24
     a20:	13 96       	adiw	r26, 0x03	; 3
     a22:	12 96       	adiw	r26, 0x02	; 2
     a24:	ed 91       	ld	r30, X+
     a26:	fc 91       	ld	r31, X
     a28:	13 97       	sbiw	r26, 0x03	; 3
     a2a:	20 81       	ld	r18, Z
     a2c:	31 81       	ldd	r19, Z+1	; 0x01
     a2e:	42 17       	cp	r20, r18
     a30:	53 07       	cpc	r21, r19
     a32:	10 f0       	brcs	.+4      	; 0xa38 <vListInsert+0x34>
     a34:	df 01       	movw	r26, r30
     a36:	f5 cf       	rjmp	.-22     	; 0xa22 <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     a38:	12 96       	adiw	r26, 0x02	; 2
     a3a:	ed 91       	ld	r30, X+
     a3c:	fc 91       	ld	r31, X
     a3e:	13 97       	sbiw	r26, 0x03	; 3
     a40:	fb 83       	std	Y+3, r31	; 0x03
     a42:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     a44:	d5 83       	std	Z+5, r29	; 0x05
     a46:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     a48:	bd 83       	std	Y+5, r27	; 0x05
     a4a:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     a4c:	13 96       	adiw	r26, 0x03	; 3
     a4e:	dc 93       	st	X, r29
     a50:	ce 93       	st	-X, r28
     a52:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     a54:	99 87       	std	Y+9, r25	; 0x09
     a56:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     a58:	fc 01       	movw	r30, r24
     a5a:	20 81       	ld	r18, Z
     a5c:	2f 5f       	subi	r18, 0xFF	; 255
     a5e:	20 83       	st	Z, r18
}
     a60:	df 91       	pop	r29
     a62:	cf 91       	pop	r28
     a64:	08 95       	ret

00000a66 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     a66:	cf 93       	push	r28
     a68:	df 93       	push	r29
     a6a:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     a6c:	a0 85       	ldd	r26, Z+8	; 0x08
     a6e:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     a70:	c2 81       	ldd	r28, Z+2	; 0x02
     a72:	d3 81       	ldd	r29, Z+3	; 0x03
     a74:	84 81       	ldd	r24, Z+4	; 0x04
     a76:	95 81       	ldd	r25, Z+5	; 0x05
     a78:	9d 83       	std	Y+5, r25	; 0x05
     a7a:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     a7c:	c4 81       	ldd	r28, Z+4	; 0x04
     a7e:	d5 81       	ldd	r29, Z+5	; 0x05
     a80:	82 81       	ldd	r24, Z+2	; 0x02
     a82:	93 81       	ldd	r25, Z+3	; 0x03
     a84:	9b 83       	std	Y+3, r25	; 0x03
     a86:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     a88:	11 96       	adiw	r26, 0x01	; 1
     a8a:	cd 91       	ld	r28, X+
     a8c:	dc 91       	ld	r29, X
     a8e:	12 97       	sbiw	r26, 0x02	; 2
     a90:	ce 17       	cp	r28, r30
     a92:	df 07       	cpc	r29, r31
     a94:	31 f4       	brne	.+12     	; 0xaa2 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     a96:	8c 81       	ldd	r24, Y+4	; 0x04
     a98:	9d 81       	ldd	r25, Y+5	; 0x05
     a9a:	12 96       	adiw	r26, 0x02	; 2
     a9c:	9c 93       	st	X, r25
     a9e:	8e 93       	st	-X, r24
     aa0:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     aa2:	11 86       	std	Z+9, r1	; 0x09
     aa4:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     aa6:	8c 91       	ld	r24, X
     aa8:	81 50       	subi	r24, 0x01	; 1
     aaa:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     aac:	df 91       	pop	r29
     aae:	cf 91       	pop	r28
     ab0:	08 95       	ret

00000ab2 <_ZN3LPSC1Ev>:

// reads pressure in inches of mercury (inHg)
float LPS::readPressureInchesHg(void)
{
  return (float)readPressureRaw() / 138706.5;
}
     ab2:	22 e0       	ldi	r18, 0x02	; 2
     ab4:	fc 01       	movw	r30, r24
     ab6:	20 83       	st	Z, r18
     ab8:	2d e5       	ldi	r18, 0x5D	; 93
     aba:	21 83       	std	Z+1, r18	; 0x01
     abc:	08 95       	ret

00000abe <_ZN3LPS24pressureToAltitudeMetersEff>:
     abe:	0e 94 b4 10 	call	0x2168	; 0x2168 <__divsf3>
     ac2:	2e e4       	ldi	r18, 0x4E	; 78
     ac4:	34 ed       	ldi	r19, 0xD4	; 212
     ac6:	42 e4       	ldi	r20, 0x42	; 66
     ac8:	5e e3       	ldi	r21, 0x3E	; 62
     aca:	0e 94 6a 12 	call	0x24d4	; 0x24d4 <pow>
     ace:	9b 01       	movw	r18, r22
     ad0:	ac 01       	movw	r20, r24
     ad2:	60 e0       	ldi	r22, 0x00	; 0
     ad4:	70 e0       	ldi	r23, 0x00	; 0
     ad6:	80 e8       	ldi	r24, 0x80	; 128
     ad8:	9f e3       	ldi	r25, 0x3F	; 63
     ada:	0e 94 4f 10 	call	0x209e	; 0x209e <__subsf3>
     ade:	2d ec       	ldi	r18, 0xCD	; 205
     ae0:	3a e2       	ldi	r19, 0x2A	; 42
     ae2:	4d e2       	ldi	r20, 0x2D	; 45
     ae4:	57 e4       	ldi	r21, 0x47	; 71
     ae6:	0c 94 07 12 	jmp	0x240e	; 0x240e <__mulsf3>
     aea:	08 95       	ret

00000aec <_ZN3LPS8writeRegEih>:
     aec:	1f 93       	push	r17
     aee:	cf 93       	push	r28
     af0:	df 93       	push	r29
     af2:	eb 01       	movw	r28, r22
     af4:	14 2f       	mov	r17, r20
     af6:	dd 23       	and	r29, r29
     af8:	3c f4       	brge	.+14     	; 0xb08 <_ZN3LPS8writeRegEih+0x1c>
     afa:	fc 01       	movw	r30, r24
     afc:	e6 1b       	sub	r30, r22
     afe:	f7 0b       	sbc	r31, r23
     b00:	c2 81       	ldd	r28, Z+2	; 0x02
     b02:	dd 27       	eor	r29, r29
     b04:	c7 fd       	sbrc	r28, 7
     b06:	d0 95       	com	r29
     b08:	fc 01       	movw	r30, r24
     b0a:	61 81       	ldd	r22, Z+1	; 0x01
     b0c:	84 e0       	ldi	r24, 0x04	; 4
     b0e:	9e e0       	ldi	r25, 0x0E	; 14
     b10:	0e 94 2c 10 	call	0x2058	; 0x2058 <_ZN7TwoWire17beginTransmissionEh>
     b14:	e0 91 04 0e 	lds	r30, 0x0E04
     b18:	f0 91 05 0e 	lds	r31, 0x0E05
     b1c:	01 90       	ld	r0, Z+
     b1e:	f0 81       	ld	r31, Z
     b20:	e0 2d       	mov	r30, r0
     b22:	6c 2f       	mov	r22, r28
     b24:	84 e0       	ldi	r24, 0x04	; 4
     b26:	9e e0       	ldi	r25, 0x0E	; 14
     b28:	19 95       	eicall
     b2a:	61 2f       	mov	r22, r17
     b2c:	84 e0       	ldi	r24, 0x04	; 4
     b2e:	9e e0       	ldi	r25, 0x0E	; 14
     b30:	0e 94 d3 0f 	call	0x1fa6	; 0x1fa6 <_ZN7TwoWire5writeEh>
     b34:	84 e0       	ldi	r24, 0x04	; 4
     b36:	9e e0       	ldi	r25, 0x0E	; 14
     b38:	0e 94 48 10 	call	0x2090	; 0x2090 <_ZN7TwoWire15endTransmissionEv>
     b3c:	df 91       	pop	r29
     b3e:	cf 91       	pop	r28
     b40:	1f 91       	pop	r17
     b42:	08 95       	ret

00000b44 <_ZN3LPS13enableDefaultEv>:
     b44:	fc 01       	movw	r30, r24
     b46:	20 81       	ld	r18, Z
     b48:	21 30       	cpi	r18, 0x01	; 1
     b4a:	29 f4       	brne	.+10     	; 0xb56 <_ZN3LPS13enableDefaultEv+0x12>
     b4c:	40 eb       	ldi	r20, 0xB0	; 176
     b4e:	60 e2       	ldi	r22, 0x20	; 32
     b50:	70 e0       	ldi	r23, 0x00	; 0
     b52:	cc cf       	rjmp	.-104    	; 0xaec <_ZN3LPS8writeRegEih>
     b54:	08 95       	ret
     b56:	21 11       	cpse	r18, r1
     b58:	04 c0       	rjmp	.+8      	; 0xb62 <_ZN3LPS13enableDefaultEv+0x1e>
     b5a:	40 ee       	ldi	r20, 0xE0	; 224
     b5c:	60 e2       	ldi	r22, 0x20	; 32
     b5e:	70 e0       	ldi	r23, 0x00	; 0
     b60:	c5 cf       	rjmp	.-118    	; 0xaec <_ZN3LPS8writeRegEih>
     b62:	08 95       	ret

00000b64 <_ZN3LPS15readPressureRawEv>:
     b64:	0f 93       	push	r16
     b66:	1f 93       	push	r17
     b68:	cf 93       	push	r28
     b6a:	df 93       	push	r29
     b6c:	8c 01       	movw	r16, r24
     b6e:	fc 01       	movw	r30, r24
     b70:	61 81       	ldd	r22, Z+1	; 0x01
     b72:	84 e0       	ldi	r24, 0x04	; 4
     b74:	9e e0       	ldi	r25, 0x0E	; 14
     b76:	0e 94 2c 10 	call	0x2058	; 0x2058 <_ZN7TwoWire17beginTransmissionEh>
     b7a:	e0 91 04 0e 	lds	r30, 0x0E04
     b7e:	f0 91 05 0e 	lds	r31, 0x0E05
     b82:	01 90       	ld	r0, Z+
     b84:	f0 81       	ld	r31, Z
     b86:	e0 2d       	mov	r30, r0
     b88:	68 ea       	ldi	r22, 0xA8	; 168
     b8a:	84 e0       	ldi	r24, 0x04	; 4
     b8c:	9e e0       	ldi	r25, 0x0E	; 14
     b8e:	19 95       	eicall
     b90:	84 e0       	ldi	r24, 0x04	; 4
     b92:	9e e0       	ldi	r25, 0x0E	; 14
     b94:	0e 94 48 10 	call	0x2090	; 0x2090 <_ZN7TwoWire15endTransmissionEv>
     b98:	43 e0       	ldi	r20, 0x03	; 3
     b9a:	f8 01       	movw	r30, r16
     b9c:	61 81       	ldd	r22, Z+1	; 0x01
     b9e:	84 e0       	ldi	r24, 0x04	; 4
     ba0:	9e e0       	ldi	r25, 0x0E	; 14
     ba2:	0e 94 29 10 	call	0x2052	; 0x2052 <_ZN7TwoWire11requestFromEhh>
     ba6:	84 e0       	ldi	r24, 0x04	; 4
     ba8:	9e e0       	ldi	r25, 0x0E	; 14
     baa:	0e 94 79 0f 	call	0x1ef2	; 0x1ef2 <_ZN7TwoWire9availableEv>
     bae:	03 97       	sbiw	r24, 0x03	; 3
     bb0:	d4 f3       	brlt	.-12     	; 0xba6 <_ZN3LPS15readPressureRawEv+0x42>
     bb2:	84 e0       	ldi	r24, 0x04	; 4
     bb4:	9e e0       	ldi	r25, 0x0E	; 14
     bb6:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <_ZN7TwoWire4readEv>
     bba:	08 2f       	mov	r16, r24
     bbc:	84 e0       	ldi	r24, 0x04	; 4
     bbe:	9e e0       	ldi	r25, 0x0E	; 14
     bc0:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <_ZN7TwoWire4readEv>
     bc4:	18 2f       	mov	r17, r24
     bc6:	84 e0       	ldi	r24, 0x04	; 4
     bc8:	9e e0       	ldi	r25, 0x0E	; 14
     bca:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <_ZN7TwoWire4readEv>
     bce:	48 2f       	mov	r20, r24
     bd0:	55 27       	eor	r21, r21
     bd2:	47 fd       	sbrc	r20, 7
     bd4:	50 95       	com	r21
     bd6:	65 2f       	mov	r22, r21
     bd8:	75 2f       	mov	r23, r21
     bda:	ba 01       	movw	r22, r20
     bdc:	55 27       	eor	r21, r21
     bde:	44 27       	eor	r20, r20
     be0:	40 2b       	or	r20, r16
     be2:	d1 2f       	mov	r29, r17
     be4:	f0 e0       	ldi	r31, 0x00	; 0
     be6:	cf 2f       	mov	r28, r31
     be8:	ce 01       	movw	r24, r28
     bea:	a0 e0       	ldi	r26, 0x00	; 0
     bec:	b0 e0       	ldi	r27, 0x00	; 0
     bee:	8a 01       	movw	r16, r20
     bf0:	9b 01       	movw	r18, r22
     bf2:	08 2b       	or	r16, r24
     bf4:	19 2b       	or	r17, r25
     bf6:	2a 2b       	or	r18, r26
     bf8:	3b 2b       	or	r19, r27
     bfa:	c9 01       	movw	r24, r18
     bfc:	b8 01       	movw	r22, r16
     bfe:	df 91       	pop	r29
     c00:	cf 91       	pop	r28
     c02:	1f 91       	pop	r17
     c04:	0f 91       	pop	r16
     c06:	08 95       	ret

00000c08 <_ZN3LPS21readPressureMillibarsEv>:
     c08:	ad df       	rcall	.-166    	; 0xb64 <_ZN3LPS15readPressureRawEv>
     c0a:	0e 94 4f 11 	call	0x229e	; 0x229e <__floatsisf>
     c0e:	20 e0       	ldi	r18, 0x00	; 0
     c10:	30 e0       	ldi	r19, 0x00	; 0
     c12:	40 e8       	ldi	r20, 0x80	; 128
     c14:	59 e3       	ldi	r21, 0x39	; 57
     c16:	0c 94 07 12 	jmp	0x240e	; 0x240e <__mulsf3>
     c1a:	08 95       	ret

00000c1c <_ZN3LPS18readTemperatureRawEv>:
  return 108.5 + (float)readTemperatureRaw() / 480 * 1.8;
}

// reads temperature and returns raw 16-bit sensor output
int16_t LPS::readTemperatureRaw(void)
{
     c1c:	cf 93       	push	r28
     c1e:	df 93       	push	r29
     c20:	ec 01       	movw	r28, r24
  Wire.beginTransmission(address);
     c22:	69 81       	ldd	r22, Y+1	; 0x01
     c24:	84 e0       	ldi	r24, 0x04	; 4
     c26:	9e e0       	ldi	r25, 0x0E	; 14
     c28:	0e 94 2c 10 	call	0x2058	; 0x2058 <_ZN7TwoWire17beginTransmissionEh>
    void onRequest( void (*)(void) );

    inline size_t write(unsigned long n) { return write((uint8_t)n); }
    inline size_t write(long n) { return write((uint8_t)n); }
    inline size_t write(unsigned int n) { return write((uint8_t)n); }
    inline size_t write(int n) { return write((uint8_t)n); }
     c2c:	e0 91 04 0e 	lds	r30, 0x0E04
     c30:	f0 91 05 0e 	lds	r31, 0x0E05
     c34:	01 90       	ld	r0, Z+
     c36:	f0 81       	ld	r31, Z
     c38:	e0 2d       	mov	r30, r0
     c3a:	6b ea       	ldi	r22, 0xAB	; 171
     c3c:	84 e0       	ldi	r24, 0x04	; 4
     c3e:	9e e0       	ldi	r25, 0x0E	; 14
     c40:	19 95       	eicall
  // assert MSB to enable register address auto-increment
  Wire.write(TEMP_OUT_L | (1 << 7));
  Wire.endTransmission();
     c42:	84 e0       	ldi	r24, 0x04	; 4
     c44:	9e e0       	ldi	r25, 0x0E	; 14
     c46:	0e 94 48 10 	call	0x2090	; 0x2090 <_ZN7TwoWire15endTransmissionEv>
  Wire.requestFrom(address, (byte)2);
     c4a:	42 e0       	ldi	r20, 0x02	; 2
     c4c:	69 81       	ldd	r22, Y+1	; 0x01
     c4e:	84 e0       	ldi	r24, 0x04	; 4
     c50:	9e e0       	ldi	r25, 0x0E	; 14
     c52:	0e 94 29 10 	call	0x2052	; 0x2052 <_ZN7TwoWire11requestFromEhh>

  while (Wire.available() < 2);
     c56:	84 e0       	ldi	r24, 0x04	; 4
     c58:	9e e0       	ldi	r25, 0x0E	; 14
     c5a:	0e 94 79 0f 	call	0x1ef2	; 0x1ef2 <_ZN7TwoWire9availableEv>
     c5e:	02 97       	sbiw	r24, 0x02	; 2
     c60:	d4 f3       	brlt	.-12     	; 0xc56 <_ZN3LPS18readTemperatureRawEv+0x3a>

  uint8_t tl = Wire.read();
     c62:	84 e0       	ldi	r24, 0x04	; 4
     c64:	9e e0       	ldi	r25, 0x0E	; 14
     c66:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <_ZN7TwoWire4readEv>
     c6a:	c8 2f       	mov	r28, r24
  uint8_t th = Wire.read();
     c6c:	84 e0       	ldi	r24, 0x04	; 4
     c6e:	9e e0       	ldi	r25, 0x0E	; 14
     c70:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <_ZN7TwoWire4readEv>

  // combine bytes
  return (int16_t)(th << 8 | tl);
     c74:	98 2f       	mov	r25, r24
     c76:	88 27       	eor	r24, r24
}
     c78:	8c 2b       	or	r24, r28
     c7a:	df 91       	pop	r29
     c7c:	cf 91       	pop	r28
     c7e:	08 95       	ret

00000c80 <_ZN3LPS16readTemperatureCEv>:
}

// reads temperature in degrees C
float LPS::readTemperatureC(void)
{
  return 42.5 + (float)readTemperatureRaw() / 480;
     c80:	cd df       	rcall	.-102    	; 0xc1c <_ZN3LPS18readTemperatureRawEv>
     c82:	bc 01       	movw	r22, r24
     c84:	88 27       	eor	r24, r24
     c86:	77 fd       	sbrc	r23, 7
     c88:	80 95       	com	r24
     c8a:	98 2f       	mov	r25, r24
     c8c:	0e 94 4f 11 	call	0x229e	; 0x229e <__floatsisf>
     c90:	20 e0       	ldi	r18, 0x00	; 0
     c92:	30 e0       	ldi	r19, 0x00	; 0
     c94:	40 ef       	ldi	r20, 0xF0	; 240
     c96:	53 e4       	ldi	r21, 0x43	; 67
     c98:	0e 94 b4 10 	call	0x2168	; 0x2168 <__divsf3>
     c9c:	20 e0       	ldi	r18, 0x00	; 0
     c9e:	30 e0       	ldi	r19, 0x00	; 0
     ca0:	4a e2       	ldi	r20, 0x2A	; 42
     ca2:	52 e4       	ldi	r21, 0x42	; 66
     ca4:	0c 94 50 10 	jmp	0x20a0	; 0x20a0 <__addsf3>
}
     ca8:	08 95       	ret

00000caa <_ZN6LSM303C1Ev>:
// Reads all 6 channels of the LSM303 and stores them in the object variables
void LSM303::read(void)
{
  readAcc();
  readMag();
}
     caa:	cf 93       	push	r28
     cac:	df 93       	push	r29
     cae:	ec 01       	movw	r28, r24
     cb0:	86 e0       	ldi	r24, 0x06	; 6
     cb2:	e5 e1       	ldi	r30, 0x15	; 21
     cb4:	f2 e0       	ldi	r31, 0x02	; 2
     cb6:	de 01       	movw	r26, r28
     cb8:	52 96       	adiw	r26, 0x12	; 18
     cba:	01 90       	ld	r0, Z+
     cbc:	0d 92       	st	X+, r0
     cbe:	8a 95       	dec	r24
     cc0:	e1 f7       	brne	.-8      	; 0xcba <_ZN6LSM303C1Ev+0x10>
     cc2:	86 e0       	ldi	r24, 0x06	; 6
     cc4:	eb e1       	ldi	r30, 0x1B	; 27
     cc6:	f2 e0       	ldi	r31, 0x02	; 2
     cc8:	de 01       	movw	r26, r28
     cca:	1c 96       	adiw	r26, 0x0c	; 12
     ccc:	01 90       	ld	r0, Z+
     cce:	0d 92       	st	X+, r0
     cd0:	8a 95       	dec	r24
     cd2:	e1 f7       	brne	.-8      	; 0xccc <_ZN6LSM303C1Ev+0x22>
     cd4:	84 e0       	ldi	r24, 0x04	; 4
     cd6:	89 8f       	std	Y+25, r24	; 0x19
     cd8:	1c a2       	std	Y+36, r1	; 0x24
     cda:	1b a2       	std	Y+35, r1	; 0x23
     cdc:	1d a2       	std	Y+37, r1	; 0x25
     cde:	df 91       	pop	r29
     ce0:	cf 91       	pop	r28
     ce2:	08 95       	ret

00000ce4 <_ZN6LSM30311writeAccRegEhh>:
     ce4:	0f 93       	push	r16
     ce6:	1f 93       	push	r17
     ce8:	cf 93       	push	r28
     cea:	df 93       	push	r29
     cec:	ec 01       	movw	r28, r24
     cee:	06 2f       	mov	r16, r22
     cf0:	14 2f       	mov	r17, r20
     cf2:	6a 8d       	ldd	r22, Y+26	; 0x1a
     cf4:	84 e0       	ldi	r24, 0x04	; 4
     cf6:	9e e0       	ldi	r25, 0x0E	; 14
     cf8:	0e 94 2c 10 	call	0x2058	; 0x2058 <_ZN7TwoWire17beginTransmissionEh>
     cfc:	60 2f       	mov	r22, r16
     cfe:	84 e0       	ldi	r24, 0x04	; 4
     d00:	9e e0       	ldi	r25, 0x0E	; 14
     d02:	0e 94 d3 0f 	call	0x1fa6	; 0x1fa6 <_ZN7TwoWire5writeEh>
     d06:	61 2f       	mov	r22, r17
     d08:	84 e0       	ldi	r24, 0x04	; 4
     d0a:	9e e0       	ldi	r25, 0x0E	; 14
     d0c:	0e 94 d3 0f 	call	0x1fa6	; 0x1fa6 <_ZN7TwoWire5writeEh>
     d10:	84 e0       	ldi	r24, 0x04	; 4
     d12:	9e e0       	ldi	r25, 0x0E	; 14
     d14:	0e 94 48 10 	call	0x2090	; 0x2090 <_ZN7TwoWire15endTransmissionEv>
     d18:	88 8f       	std	Y+24, r24	; 0x18
     d1a:	df 91       	pop	r29
     d1c:	cf 91       	pop	r28
     d1e:	1f 91       	pop	r17
     d20:	0f 91       	pop	r16
     d22:	08 95       	ret

00000d24 <_ZN6LSM30311writeMagRegEhh>:
     d24:	0f 93       	push	r16
     d26:	1f 93       	push	r17
     d28:	cf 93       	push	r28
     d2a:	df 93       	push	r29
     d2c:	ec 01       	movw	r28, r24
     d2e:	06 2f       	mov	r16, r22
     d30:	14 2f       	mov	r17, r20
     d32:	6b 8d       	ldd	r22, Y+27	; 0x1b
     d34:	84 e0       	ldi	r24, 0x04	; 4
     d36:	9e e0       	ldi	r25, 0x0E	; 14
     d38:	0e 94 2c 10 	call	0x2058	; 0x2058 <_ZN7TwoWire17beginTransmissionEh>
     d3c:	60 2f       	mov	r22, r16
     d3e:	84 e0       	ldi	r24, 0x04	; 4
     d40:	9e e0       	ldi	r25, 0x0E	; 14
     d42:	0e 94 d3 0f 	call	0x1fa6	; 0x1fa6 <_ZN7TwoWire5writeEh>
     d46:	61 2f       	mov	r22, r17
     d48:	84 e0       	ldi	r24, 0x04	; 4
     d4a:	9e e0       	ldi	r25, 0x0E	; 14
     d4c:	0e 94 d3 0f 	call	0x1fa6	; 0x1fa6 <_ZN7TwoWire5writeEh>
     d50:	84 e0       	ldi	r24, 0x04	; 4
     d52:	9e e0       	ldi	r25, 0x0E	; 14
     d54:	0e 94 48 10 	call	0x2090	; 0x2090 <_ZN7TwoWire15endTransmissionEv>
     d58:	88 8f       	std	Y+24, r24	; 0x18
     d5a:	df 91       	pop	r29
     d5c:	cf 91       	pop	r28
     d5e:	1f 91       	pop	r17
     d60:	0f 91       	pop	r16
     d62:	08 95       	ret

00000d64 <_ZN6LSM3038writeRegEhh>:
     d64:	fc 01       	movw	r30, r24
     d66:	21 8d       	ldd	r18, Z+25	; 0x19
     d68:	23 30       	cpi	r18, 0x03	; 3
     d6a:	11 f0       	breq	.+4      	; 0xd70 <_ZN6LSM3038writeRegEhh+0xc>
     d6c:	60 32       	cpi	r22, 0x20	; 32
     d6e:	10 f4       	brcc	.+4      	; 0xd74 <_ZN6LSM3038writeRegEhh+0x10>
     d70:	d9 cf       	rjmp	.-78     	; 0xd24 <_ZN6LSM30311writeMagRegEhh>
     d72:	08 95       	ret
     d74:	b7 cf       	rjmp	.-146    	; 0xce4 <_ZN6LSM30311writeAccRegEhh>
     d76:	08 95       	ret

00000d78 <_ZN6LSM30313enableDefaultEv>:
     d78:	cf 93       	push	r28
     d7a:	df 93       	push	r29
     d7c:	ec 01       	movw	r28, r24
     d7e:	89 8d       	ldd	r24, Y+25	; 0x19
     d80:	83 30       	cpi	r24, 0x03	; 3
     d82:	a9 f4       	brne	.+42     	; 0xdae <_ZN6LSM30313enableDefaultEv+0x36>
     d84:	40 e0       	ldi	r20, 0x00	; 0
     d86:	61 e2       	ldi	r22, 0x21	; 33
     d88:	ce 01       	movw	r24, r28
     d8a:	ec df       	rcall	.-40     	; 0xd64 <_ZN6LSM3038writeRegEhh>
     d8c:	47 e5       	ldi	r20, 0x57	; 87
     d8e:	60 e2       	ldi	r22, 0x20	; 32
     d90:	ce 01       	movw	r24, r28
     d92:	e8 df       	rcall	.-48     	; 0xd64 <_ZN6LSM3038writeRegEhh>
     d94:	44 e6       	ldi	r20, 0x64	; 100
     d96:	64 e2       	ldi	r22, 0x24	; 36
     d98:	ce 01       	movw	r24, r28
     d9a:	e4 df       	rcall	.-56     	; 0xd64 <_ZN6LSM3038writeRegEhh>
     d9c:	40 e2       	ldi	r20, 0x20	; 32
     d9e:	65 e2       	ldi	r22, 0x25	; 37
     da0:	ce 01       	movw	r24, r28
     da2:	e0 df       	rcall	.-64     	; 0xd64 <_ZN6LSM3038writeRegEhh>
     da4:	40 e0       	ldi	r20, 0x00	; 0
     da6:	66 e2       	ldi	r22, 0x26	; 38
     da8:	ce 01       	movw	r24, r28
     daa:	dc df       	rcall	.-72     	; 0xd64 <_ZN6LSM3038writeRegEhh>
     dac:	1f c0       	rjmp	.+62     	; 0xdec <_ZN6LSM30313enableDefaultEv+0x74>
     dae:	82 30       	cpi	r24, 0x02	; 2
     db0:	49 f4       	brne	.+18     	; 0xdc4 <_ZN6LSM30313enableDefaultEv+0x4c>
     db2:	48 e0       	ldi	r20, 0x08	; 8
     db4:	63 e2       	ldi	r22, 0x23	; 35
     db6:	ce 01       	movw	r24, r28
     db8:	95 df       	rcall	.-214    	; 0xce4 <_ZN6LSM30311writeAccRegEhh>
     dba:	47 e4       	ldi	r20, 0x47	; 71
     dbc:	60 e2       	ldi	r22, 0x20	; 32
     dbe:	ce 01       	movw	r24, r28
     dc0:	91 df       	rcall	.-222    	; 0xce4 <_ZN6LSM30311writeAccRegEhh>
     dc2:	08 c0       	rjmp	.+16     	; 0xdd4 <_ZN6LSM30313enableDefaultEv+0x5c>
     dc4:	40 e0       	ldi	r20, 0x00	; 0
     dc6:	63 e2       	ldi	r22, 0x23	; 35
     dc8:	ce 01       	movw	r24, r28
     dca:	8c df       	rcall	.-232    	; 0xce4 <_ZN6LSM30311writeAccRegEhh>
     dcc:	47 e2       	ldi	r20, 0x27	; 39
     dce:	60 e2       	ldi	r22, 0x20	; 32
     dd0:	ce 01       	movw	r24, r28
     dd2:	88 df       	rcall	.-240    	; 0xce4 <_ZN6LSM30311writeAccRegEhh>
     dd4:	4c e0       	ldi	r20, 0x0C	; 12
     dd6:	60 e0       	ldi	r22, 0x00	; 0
     dd8:	ce 01       	movw	r24, r28
     dda:	a4 df       	rcall	.-184    	; 0xd24 <_ZN6LSM30311writeMagRegEhh>
     ddc:	40 e2       	ldi	r20, 0x20	; 32
     dde:	61 e0       	ldi	r22, 0x01	; 1
     de0:	ce 01       	movw	r24, r28
     de2:	a0 df       	rcall	.-192    	; 0xd24 <_ZN6LSM30311writeMagRegEhh>
     de4:	40 e0       	ldi	r20, 0x00	; 0
     de6:	62 e0       	ldi	r22, 0x02	; 2
     de8:	ce 01       	movw	r24, r28
     dea:	9c df       	rcall	.-200    	; 0xd24 <_ZN6LSM30311writeMagRegEhh>
     dec:	df 91       	pop	r29
     dee:	cf 91       	pop	r28
     df0:	08 95       	ret

00000df2 <_ZN6LSM3037testRegEhNS_7regAddrE>:
}

// Private Methods //////////////////////////////////////////////////////////////

int LSM303::testReg(byte address, regAddr reg)
{
     df2:	cf 93       	push	r28
     df4:	df 93       	push	r29
     df6:	c6 2f       	mov	r28, r22
     df8:	d4 2f       	mov	r29, r20
  Wire.beginTransmission(address);
     dfa:	84 e0       	ldi	r24, 0x04	; 4
     dfc:	9e e0       	ldi	r25, 0x0E	; 14
     dfe:	0e 94 2c 10 	call	0x2058	; 0x2058 <_ZN7TwoWire17beginTransmissionEh>
  Wire.write((byte)reg);
     e02:	6d 2f       	mov	r22, r29
     e04:	84 e0       	ldi	r24, 0x04	; 4
     e06:	9e e0       	ldi	r25, 0x0E	; 14
     e08:	0e 94 d3 0f 	call	0x1fa6	; 0x1fa6 <_ZN7TwoWire5writeEh>
  if (Wire.endTransmission() != 0)
     e0c:	84 e0       	ldi	r24, 0x04	; 4
     e0e:	9e e0       	ldi	r25, 0x0E	; 14
     e10:	0e 94 48 10 	call	0x2090	; 0x2090 <_ZN7TwoWire15endTransmissionEv>
     e14:	81 11       	cpse	r24, r1
     e16:	11 c0       	rjmp	.+34     	; 0xe3a <_ZN6LSM3037testRegEhNS_7regAddrE+0x48>
  {
    return TEST_REG_ERROR;
  }

  Wire.requestFrom(address, (byte)1);
     e18:	41 e0       	ldi	r20, 0x01	; 1
     e1a:	6c 2f       	mov	r22, r28
     e1c:	84 e0       	ldi	r24, 0x04	; 4
     e1e:	9e e0       	ldi	r25, 0x0E	; 14
     e20:	0e 94 29 10 	call	0x2052	; 0x2052 <_ZN7TwoWire11requestFromEhh>
  if (Wire.available())
     e24:	84 e0       	ldi	r24, 0x04	; 4
     e26:	9e e0       	ldi	r25, 0x0E	; 14
     e28:	0e 94 79 0f 	call	0x1ef2	; 0x1ef2 <_ZN7TwoWire9availableEv>
     e2c:	89 2b       	or	r24, r25
     e2e:	41 f0       	breq	.+16     	; 0xe40 <_ZN6LSM3037testRegEhNS_7regAddrE+0x4e>
  {
    return Wire.read();
     e30:	84 e0       	ldi	r24, 0x04	; 4
     e32:	9e e0       	ldi	r25, 0x0E	; 14
     e34:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <_ZN7TwoWire4readEv>
     e38:	05 c0       	rjmp	.+10     	; 0xe44 <_ZN6LSM3037testRegEhNS_7regAddrE+0x52>
{
  Wire.beginTransmission(address);
  Wire.write((byte)reg);
  if (Wire.endTransmission() != 0)
  {
    return TEST_REG_ERROR;
     e3a:	8f ef       	ldi	r24, 0xFF	; 255
     e3c:	9f ef       	ldi	r25, 0xFF	; 255
     e3e:	02 c0       	rjmp	.+4      	; 0xe44 <_ZN6LSM3037testRegEhNS_7regAddrE+0x52>
  {
    return Wire.read();
  }
  else
  {
    return TEST_REG_ERROR;
     e40:	8f ef       	ldi	r24, 0xFF	; 255
     e42:	9f ef       	ldi	r25, 0xFF	; 255
  }
     e44:	df 91       	pop	r29
     e46:	cf 91       	pop	r28
     e48:	08 95       	ret

00000e4a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE>:
{
  return io_timeout;
}

bool LSM303::init(deviceType device, sa0State sa0)
{
     e4a:	0f 93       	push	r16
     e4c:	1f 93       	push	r17
     e4e:	cf 93       	push	r28
     e50:	df 93       	push	r29
     e52:	ec 01       	movw	r28, r24
     e54:	16 2f       	mov	r17, r22
     e56:	04 2f       	mov	r16, r20
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
     e58:	64 30       	cpi	r22, 0x04	; 4
     e5a:	09 f4       	brne	.+2      	; 0xe5e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x14>
     e5c:	ad c0       	rjmp	.+346    	; 0xfb8 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x16e>
     e5e:	42 30       	cpi	r20, 0x02	; 2
     e60:	09 f0       	breq	.+2      	; 0xe64 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1a>
     e62:	47 c0       	rjmp	.+142    	; 0xef2 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
     e64:	ad c0       	rjmp	.+346    	; 0xfc0 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x176>
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
     e66:	4f e0       	ldi	r20, 0x0F	; 15
     e68:	6d e1       	ldi	r22, 0x1D	; 29
     e6a:	ce 01       	movw	r24, r28
     e6c:	c2 df       	rcall	.-124    	; 0xdf2 <_ZN6LSM3037testRegEhNS_7regAddrE>
     e6e:	89 34       	cpi	r24, 0x49	; 73
     e70:	91 05       	cpc	r25, r1
     e72:	09 f4       	brne	.+2      	; 0xe76 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x2c>
     e74:	ab c0       	rjmp	.+342    	; 0xfcc <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x182>
        // device responds to address 0011101 with D ID; it's a D with SA0 high
        device = device_D;
        sa0 = sa0_high;
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(D_SA0_LOW_ADDRESS, WHO_AM_I) == D_WHO_ID)
     e76:	01 30       	cpi	r16, 0x01	; 1
     e78:	41 f0       	breq	.+16     	; 0xe8a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x40>
     e7a:	4f e0       	ldi	r20, 0x0F	; 15
     e7c:	6e e1       	ldi	r22, 0x1E	; 30
     e7e:	ce 01       	movw	r24, r28
     e80:	b8 df       	rcall	.-144    	; 0xdf2 <_ZN6LSM3037testRegEhNS_7regAddrE>
     e82:	89 34       	cpi	r24, 0x49	; 73
     e84:	91 05       	cpc	r25, r1
     e86:	09 f4       	brne	.+2      	; 0xe8a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x40>
     e88:	a3 c0       	rjmp	.+326    	; 0xfd0 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x186>
        sa0 = sa0_low;
      }
    }
    
    // check for LSM303DLHC, DLM, DLH if device is still unidentified or was specified to be one of these types
    if (device == device_auto || device == device_DLHC || device == device_DLM || device == device_DLH)
     e8a:	14 30       	cpi	r17, 0x04	; 4
     e8c:	11 f0       	breq	.+4      	; 0xe92 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x48>
     e8e:	13 30       	cpi	r17, 0x03	; 3
     e90:	68 f5       	brcc	.+90     	; 0xeec <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa2>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
     e92:	00 23       	and	r16, r16
     e94:	a9 f0       	breq	.+42     	; 0xec0 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x76>
     e96:	40 e2       	ldi	r20, 0x20	; 32
     e98:	69 e1       	ldi	r22, 0x19	; 25
     e9a:	ce 01       	movw	r24, r28
     e9c:	aa df       	rcall	.-172    	; 0xdf2 <_ZN6LSM3037testRegEhNS_7regAddrE>
     e9e:	01 96       	adiw	r24, 0x01	; 1
     ea0:	69 f0       	breq	.+26     	; 0xebc <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x72>
      {
        // device responds to address 0011001; it's a DLHC, DLM with SA0 high, or DLH with SA0 high
        sa0 = sa0_high;
        if (device == device_auto)
     ea2:	14 30       	cpi	r17, 0x04	; 4
     ea4:	09 f0       	breq	.+2      	; 0xea8 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x5e>
     ea6:	99 c0       	rjmp	.+306    	; 0xfda <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x190>
          // DLHC seems to respond to WHO_AM_I request the same way as DLM, even though this
          // register isn't documented in its datasheet. Since the DLHC accelerometer address is the
          // same as the DLM with SA0 high, but Pololu DLM boards pull SA0 low by default, we'll
          // guess that a device whose accelerometer responds to the SA0 high address and whose
          // magnetometer gives the DLM ID is actually a DLHC.
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLHC : device_DLH;
     ea8:	4f e0       	ldi	r20, 0x0F	; 15
     eaa:	6e e1       	ldi	r22, 0x1E	; 30
     eac:	ce 01       	movw	r24, r28
     eae:	a1 df       	rcall	.-190    	; 0xdf2 <_ZN6LSM3037testRegEhNS_7regAddrE>
     eb0:	cc 97       	sbiw	r24, 0x3c	; 60
     eb2:	09 f0       	breq	.+2      	; 0xeb6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x6c>
     eb4:	94 c0       	rjmp	.+296    	; 0xfde <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x194>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011001; it's a DLHC, DLM with SA0 high, or DLH with SA0 high
        sa0 = sa0_high;
     eb6:	01 e0       	ldi	r16, 0x01	; 1
          // DLHC seems to respond to WHO_AM_I request the same way as DLM, even though this
          // register isn't documented in its datasheet. Since the DLHC accelerometer address is the
          // same as the DLM with SA0 high, but Pololu DLM boards pull SA0 low by default, we'll
          // guess that a device whose accelerometer responds to the SA0 high address and whose
          // magnetometer gives the DLM ID is actually a DLHC.
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLHC : device_DLH;
     eb8:	12 e0       	ldi	r17, 0x02	; 2
     eba:	1b c0       	rjmp	.+54     	; 0xef2 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
        }
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(DLM_DLH_ACC_SA0_LOW_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
     ebc:	01 30       	cpi	r16, 0x01	; 1
     ebe:	99 f0       	breq	.+38     	; 0xee6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x9c>
     ec0:	40 e2       	ldi	r20, 0x20	; 32
     ec2:	68 e1       	ldi	r22, 0x18	; 24
     ec4:	ce 01       	movw	r24, r28
     ec6:	95 df       	rcall	.-214    	; 0xdf2 <_ZN6LSM3037testRegEhNS_7regAddrE>
     ec8:	01 96       	adiw	r24, 0x01	; 1
     eca:	69 f0       	breq	.+26     	; 0xee6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x9c>
      {
        // device responds to address 0011000; it's a DLM with SA0 low or DLH with SA0 low
        sa0 = sa0_low;
        if (device == device_auto)
     ecc:	14 30       	cpi	r17, 0x04	; 4
     ece:	09 f0       	breq	.+2      	; 0xed2 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x88>
     ed0:	89 c0       	rjmp	.+274    	; 0xfe4 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x19a>
        {
          // use magnetometer WHO_AM_I register to determine device type
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLM : device_DLH;
     ed2:	4f e0       	ldi	r20, 0x0F	; 15
     ed4:	6e e1       	ldi	r22, 0x1E	; 30
     ed6:	ce 01       	movw	r24, r28
     ed8:	8c df       	rcall	.-232    	; 0xdf2 <_ZN6LSM3037testRegEhNS_7regAddrE>
     eda:	11 e0       	ldi	r17, 0x01	; 1
     edc:	cc 97       	sbiw	r24, 0x3c	; 60
     ede:	09 f0       	breq	.+2      	; 0xee2 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x98>
     ee0:	10 e0       	ldi	r17, 0x00	; 0
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(DLM_DLH_ACC_SA0_LOW_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011000; it's a DLM with SA0 low or DLH with SA0 low
        sa0 = sa0_low;
     ee2:	00 e0       	ldi	r16, 0x00	; 0
     ee4:	06 c0       	rjmp	.+12     	; 0xef2 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
        }
      }
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
     ee6:	14 30       	cpi	r17, 0x04	; 4
     ee8:	09 f4       	brne	.+2      	; 0xeec <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa2>
     eea:	60 c0       	rjmp	.+192    	; 0xfac <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x162>
     eec:	02 30       	cpi	r16, 0x02	; 2
     eee:	09 f4       	brne	.+2      	; 0xef2 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
     ef0:	5f c0       	rjmp	.+190    	; 0xfb0 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x166>
    {
      return false;
    }
  }
  
  _device = device;
     ef2:	19 8f       	std	Y+25, r17	; 0x19
  
  // set device addresses and translated register addresses
  switch (device)
     ef4:	11 30       	cpi	r17, 0x01	; 1
     ef6:	71 f1       	breq	.+92     	; 0xf54 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x10a>
     ef8:	08 f4       	brcc	.+2      	; 0xefc <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xb2>
     efa:	42 c0       	rjmp	.+132    	; 0xf80 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x136>
     efc:	12 30       	cpi	r17, 0x02	; 2
     efe:	c1 f0       	breq	.+48     	; 0xf30 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xe6>
     f00:	13 30       	cpi	r17, 0x03	; 3
     f02:	09 f0       	breq	.+2      	; 0xf06 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xbc>
     f04:	57 c0       	rjmp	.+174    	; 0xfb4 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x16a>
  {
    case device_D:
      acc_address = mag_address = (sa0 == sa0_high) ? D_SA0_HIGH_ADDRESS : D_SA0_LOW_ADDRESS;
     f06:	01 30       	cpi	r16, 0x01	; 1
     f08:	11 f4       	brne	.+4      	; 0xf0e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xc4>
     f0a:	8d e1       	ldi	r24, 0x1D	; 29
     f0c:	01 c0       	rjmp	.+2      	; 0xf10 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xc6>
     f0e:	8e e1       	ldi	r24, 0x1E	; 30
     f10:	8b 8f       	std	Y+27, r24	; 0x1b
     f12:	8a 8f       	std	Y+26, r24	; 0x1a
      translated_regs[-OUT_X_L_M] = D_OUT_X_L_M;
     f14:	88 e0       	ldi	r24, 0x08	; 8
     f16:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_X_H_M] = D_OUT_X_H_M;
     f18:	89 e0       	ldi	r24, 0x09	; 9
     f1a:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_Y_L_M] = D_OUT_Y_L_M;
     f1c:	8a e0       	ldi	r24, 0x0A	; 10
     f1e:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Y_H_M] = D_OUT_Y_H_M;
     f20:	8b e0       	ldi	r24, 0x0B	; 11
     f22:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Z_L_M] = D_OUT_Z_L_M;
     f24:	8c e0       	ldi	r24, 0x0C	; 12
     f26:	8a a3       	std	Y+34, r24	; 0x22
      translated_regs[-OUT_Z_H_M] = D_OUT_Z_H_M;
     f28:	8d e0       	ldi	r24, 0x0D	; 13
     f2a:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
     f2c:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_H_M] = D_OUT_X_H_M;
      translated_regs[-OUT_Y_L_M] = D_OUT_Y_L_M;
      translated_regs[-OUT_Y_H_M] = D_OUT_Y_H_M;
      translated_regs[-OUT_Z_L_M] = D_OUT_Z_L_M;
      translated_regs[-OUT_Z_H_M] = D_OUT_Z_H_M;
      break;
     f2e:	64 c0       	rjmp	.+200    	; 0xff8 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>

    case device_DLHC:
      acc_address = DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS; // DLHC doesn't have configurable SA0 but uses same acc address as DLM/DLH with SA0 high
     f30:	89 e1       	ldi	r24, 0x19	; 25
     f32:	8a 8f       	std	Y+26, r24	; 0x1a
      mag_address = DLHC_DLM_DLH_MAG_ADDRESS;
     f34:	8e e1       	ldi	r24, 0x1E	; 30
     f36:	8b 8f       	std	Y+27, r24	; 0x1b
      translated_regs[-OUT_X_H_M] = DLHC_OUT_X_H_M;
     f38:	83 e0       	ldi	r24, 0x03	; 3
     f3a:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_X_L_M] = DLHC_OUT_X_L_M;
     f3c:	84 e0       	ldi	r24, 0x04	; 4
     f3e:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_Y_H_M] = DLHC_OUT_Y_H_M;
     f40:	87 e0       	ldi	r24, 0x07	; 7
     f42:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Y_L_M] = DLHC_OUT_Y_L_M;
     f44:	88 e0       	ldi	r24, 0x08	; 8
     f46:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Z_H_M] = DLHC_OUT_Z_H_M;
     f48:	85 e0       	ldi	r24, 0x05	; 5
     f4a:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_L_M] = DLHC_OUT_Z_L_M;
     f4c:	86 e0       	ldi	r24, 0x06	; 6
     f4e:	8a a3       	std	Y+34, r24	; 0x22
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
     f50:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_L_M] = DLHC_OUT_X_L_M;
      translated_regs[-OUT_Y_H_M] = DLHC_OUT_Y_H_M;
      translated_regs[-OUT_Y_L_M] = DLHC_OUT_Y_L_M;
      translated_regs[-OUT_Z_H_M] = DLHC_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLHC_OUT_Z_L_M;
      break;
     f52:	52 c0       	rjmp	.+164    	; 0xff8 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>

    case device_DLM:
      acc_address = (sa0 == sa0_high) ? DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS : DLM_DLH_ACC_SA0_LOW_ADDRESS;
     f54:	01 30       	cpi	r16, 0x01	; 1
     f56:	11 f4       	brne	.+4      	; 0xf5c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x112>
     f58:	89 e1       	ldi	r24, 0x19	; 25
     f5a:	01 c0       	rjmp	.+2      	; 0xf5e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x114>
     f5c:	88 e1       	ldi	r24, 0x18	; 24
     f5e:	8a 8f       	std	Y+26, r24	; 0x1a
      mag_address = DLHC_DLM_DLH_MAG_ADDRESS;
     f60:	8e e1       	ldi	r24, 0x1E	; 30
     f62:	8b 8f       	std	Y+27, r24	; 0x1b
      translated_regs[-OUT_X_H_M] = DLM_OUT_X_H_M;
     f64:	83 e0       	ldi	r24, 0x03	; 3
     f66:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_X_L_M] = DLM_OUT_X_L_M;
     f68:	84 e0       	ldi	r24, 0x04	; 4
     f6a:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_Y_H_M] = DLM_OUT_Y_H_M;
     f6c:	87 e0       	ldi	r24, 0x07	; 7
     f6e:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Y_L_M] = DLM_OUT_Y_L_M;
     f70:	88 e0       	ldi	r24, 0x08	; 8
     f72:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Z_H_M] = DLM_OUT_Z_H_M;
     f74:	85 e0       	ldi	r24, 0x05	; 5
     f76:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_L_M] = DLM_OUT_Z_L_M;
     f78:	86 e0       	ldi	r24, 0x06	; 6
     f7a:	8a a3       	std	Y+34, r24	; 0x22
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
     f7c:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_L_M] = DLM_OUT_X_L_M;
      translated_regs[-OUT_Y_H_M] = DLM_OUT_Y_H_M;
      translated_regs[-OUT_Y_L_M] = DLM_OUT_Y_L_M;
      translated_regs[-OUT_Z_H_M] = DLM_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLM_OUT_Z_L_M;
      break;
     f7e:	3c c0       	rjmp	.+120    	; 0xff8 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>

    case device_DLH:
      acc_address = (sa0 == sa0_high) ? DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS : DLM_DLH_ACC_SA0_LOW_ADDRESS;
     f80:	01 30       	cpi	r16, 0x01	; 1
     f82:	11 f4       	brne	.+4      	; 0xf88 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x13e>
     f84:	89 e1       	ldi	r24, 0x19	; 25
     f86:	01 c0       	rjmp	.+2      	; 0xf8a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x140>
     f88:	88 e1       	ldi	r24, 0x18	; 24
     f8a:	8a 8f       	std	Y+26, r24	; 0x1a
      mag_address = DLHC_DLM_DLH_MAG_ADDRESS;
     f8c:	8e e1       	ldi	r24, 0x1E	; 30
     f8e:	8b 8f       	std	Y+27, r24	; 0x1b
      translated_regs[-OUT_X_H_M] = DLH_OUT_X_H_M;
     f90:	83 e0       	ldi	r24, 0x03	; 3
     f92:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_X_L_M] = DLH_OUT_X_L_M;
     f94:	84 e0       	ldi	r24, 0x04	; 4
     f96:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_Y_H_M] = DLH_OUT_Y_H_M;
     f98:	85 e0       	ldi	r24, 0x05	; 5
     f9a:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Y_L_M] = DLH_OUT_Y_L_M;
     f9c:	86 e0       	ldi	r24, 0x06	; 6
     f9e:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
     fa0:	87 e0       	ldi	r24, 0x07	; 7
     fa2:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
     fa4:	88 e0       	ldi	r24, 0x08	; 8
     fa6:	8a a3       	std	Y+34, r24	; 0x22
      break;
  }
  
  return true;
     fa8:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_L_M] = DLH_OUT_X_L_M;
      translated_regs[-OUT_Y_H_M] = DLH_OUT_Y_H_M;
      translated_regs[-OUT_Y_L_M] = DLH_OUT_Y_L_M;
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
     faa:	26 c0       	rjmp	.+76     	; 0xff8 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
    {
      return false;
     fac:	80 e0       	ldi	r24, 0x00	; 0
     fae:	24 c0       	rjmp	.+72     	; 0xff8 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
     fb0:	80 e0       	ldi	r24, 0x00	; 0
     fb2:	22 c0       	rjmp	.+68     	; 0xff8 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
     fb4:	81 e0       	ldi	r24, 0x01	; 1
     fb6:	20 c0       	rjmp	.+64     	; 0xff8 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
     fb8:	44 23       	and	r20, r20
     fba:	09 f4       	brne	.+2      	; 0xfbe <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x174>
     fbc:	5e cf       	rjmp	.-324    	; 0xe7a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x30>
     fbe:	53 cf       	rjmp	.-346    	; 0xe66 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1c>
{
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
     fc0:	8d ef       	ldi	r24, 0xFD	; 253
     fc2:	86 0f       	add	r24, r22
     fc4:	82 30       	cpi	r24, 0x02	; 2
     fc6:	08 f0       	brcs	.+2      	; 0xfca <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x180>
     fc8:	62 cf       	rjmp	.-316    	; 0xe8e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x44>
     fca:	0e c0       	rjmp	.+28     	; 0xfe8 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x19e>
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
      {
        // device responds to address 0011101 with D ID; it's a D with SA0 high
        device = device_D;
        sa0 = sa0_high;
     fcc:	01 e0       	ldi	r16, 0x01	; 1
     fce:	03 c0       	rjmp	.+6      	; 0xfd6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x18c>
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(D_SA0_LOW_ADDRESS, WHO_AM_I) == D_WHO_ID)
      {
        // device responds to address 0011110 with D ID; it's a D with SA0 low
        device = device_D;
        sa0 = sa0_low;
     fd0:	00 e0       	ldi	r16, 0x00	; 0
     fd2:	01 c0       	rjmp	.+2      	; 0xfd6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x18c>
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
      {
        // device responds to address 0011101 with D ID; it's a D with SA0 high
        device = device_D;
        sa0 = sa0_high;
     fd4:	01 e0       	ldi	r16, 0x01	; 1
     fd6:	13 e0       	ldi	r17, 0x03	; 3
     fd8:	89 cf       	rjmp	.-238    	; 0xeec <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa2>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011001; it's a DLHC, DLM with SA0 high, or DLH with SA0 high
        sa0 = sa0_high;
     fda:	01 e0       	ldi	r16, 0x01	; 1
     fdc:	8a cf       	rjmp	.-236    	; 0xef2 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
     fde:	01 e0       	ldi	r16, 0x01	; 1
          // DLHC seems to respond to WHO_AM_I request the same way as DLM, even though this
          // register isn't documented in its datasheet. Since the DLHC accelerometer address is the
          // same as the DLM with SA0 high, but Pololu DLM boards pull SA0 low by default, we'll
          // guess that a device whose accelerometer responds to the SA0 high address and whose
          // magnetometer gives the DLM ID is actually a DLHC.
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLHC : device_DLH;
     fe0:	10 e0       	ldi	r17, 0x00	; 0
     fe2:	87 cf       	rjmp	.-242    	; 0xef2 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(DLM_DLH_ACC_SA0_LOW_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011000; it's a DLM with SA0 low or DLH with SA0 low
        sa0 = sa0_low;
     fe4:	00 e0       	ldi	r16, 0x00	; 0
     fe6:	85 cf       	rjmp	.-246    	; 0xef2 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
     fe8:	4f e0       	ldi	r20, 0x0F	; 15
     fea:	6d e1       	ldi	r22, 0x1D	; 29
     fec:	ce 01       	movw	r24, r28
     fee:	01 df       	rcall	.-510    	; 0xdf2 <_ZN6LSM3037testRegEhNS_7regAddrE>
     ff0:	89 34       	cpi	r24, 0x49	; 73
     ff2:	91 05       	cpc	r25, r1
     ff4:	79 f3       	breq	.-34     	; 0xfd4 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x18a>
     ff6:	41 cf       	rjmp	.-382    	; 0xe7a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x30>
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
}
     ff8:	df 91       	pop	r29
     ffa:	cf 91       	pop	r28
     ffc:	1f 91       	pop	r17
     ffe:	0f 91       	pop	r16
    1000:	08 95       	ret

00001002 <_ZN7NewPingC1Ehhi>:
	TIMSK4 = (1<<TOIE4); // Enable Timer4 interrupt.
//#else
	//OCR2A = 249;           // Every count is 4uS, so 1ms = 250 counts - 1.
	//TIMSK2 |= (1<<OCIE2A); // Enable Timer2 interrupt.
//#endif
}
    1002:	cf 93       	push	r28
    1004:	df 93       	push	r29
    1006:	dc 01       	movw	r26, r24
    1008:	70 e0       	ldi	r23, 0x00	; 0
    100a:	fb 01       	movw	r30, r22
    100c:	ee 59       	subi	r30, 0x9E	; 158
    100e:	fc 4f       	sbci	r31, 0xFC	; 252
    1010:	e4 91       	lpm	r30, Z
    1012:	14 96       	adiw	r26, 0x04	; 4
    1014:	ec 93       	st	X, r30
    1016:	14 97       	sbiw	r26, 0x04	; 4
    1018:	50 e0       	ldi	r21, 0x00	; 0
    101a:	fa 01       	movw	r30, r20
    101c:	ee 59       	subi	r30, 0x9E	; 158
    101e:	fc 4f       	sbci	r31, 0xFC	; 252
    1020:	e4 91       	lpm	r30, Z
    1022:	15 96       	adiw	r26, 0x05	; 5
    1024:	ec 93       	st	X, r30
    1026:	15 97       	sbiw	r26, 0x05	; 5
    1028:	68 55       	subi	r22, 0x58	; 88
    102a:	7c 4f       	sbci	r23, 0xFC	; 252
    102c:	fb 01       	movw	r30, r22
    102e:	84 91       	lpm	r24, Z
    1030:	90 e0       	ldi	r25, 0x00	; 0
    1032:	88 0f       	add	r24, r24
    1034:	99 1f       	adc	r25, r25
    1036:	88 5f       	subi	r24, 0xF8	; 248
    1038:	9b 4f       	sbci	r25, 0xFB	; 251
    103a:	fc 01       	movw	r30, r24
    103c:	c5 91       	lpm	r28, Z+
    103e:	d4 91       	lpm	r29, Z
    1040:	17 96       	adiw	r26, 0x07	; 7
    1042:	dc 93       	st	X, r29
    1044:	ce 93       	st	-X, r28
    1046:	16 97       	sbiw	r26, 0x06	; 6
    1048:	fa 01       	movw	r30, r20
    104a:	e8 55       	subi	r30, 0x58	; 88
    104c:	fc 4f       	sbci	r31, 0xFC	; 252
    104e:	84 91       	lpm	r24, Z
    1050:	90 e0       	ldi	r25, 0x00	; 0
    1052:	88 0f       	add	r24, r24
    1054:	99 1f       	adc	r25, r25
    1056:	82 51       	subi	r24, 0x12	; 18
    1058:	9c 4f       	sbci	r25, 0xFC	; 252
    105a:	fc 01       	movw	r30, r24
    105c:	45 91       	lpm	r20, Z+
    105e:	54 91       	lpm	r21, Z
    1060:	1b 96       	adiw	r26, 0x0b	; 11
    1062:	5c 93       	st	X, r21
    1064:	4e 93       	st	-X, r20
    1066:	1a 97       	sbiw	r26, 0x0a	; 10
    1068:	fb 01       	movw	r30, r22
    106a:	64 91       	lpm	r22, Z
    106c:	e6 2f       	mov	r30, r22
    106e:	f0 e0       	ldi	r31, 0x00	; 0
    1070:	ee 0f       	add	r30, r30
    1072:	ff 1f       	adc	r31, r31
    1074:	ee 5d       	subi	r30, 0xDE	; 222
    1076:	fb 4f       	sbci	r31, 0xFB	; 251
    1078:	85 91       	lpm	r24, Z+
    107a:	94 91       	lpm	r25, Z
    107c:	19 96       	adiw	r26, 0x09	; 9
    107e:	9c 93       	st	X, r25
    1080:	8e 93       	st	-X, r24
    1082:	18 97       	sbiw	r26, 0x08	; 8
    1084:	82 2f       	mov	r24, r18
    1086:	93 2f       	mov	r25, r19
    1088:	85 3f       	cpi	r24, 0xF5	; 245
    108a:	f1 e0       	ldi	r31, 0x01	; 1
    108c:	9f 07       	cpc	r25, r31
    108e:	14 f0       	brlt	.+4      	; 0x1094 <_ZN7NewPingC1Ehhi+0x92>
    1090:	84 ef       	ldi	r24, 0xF4	; 244
    1092:	91 e0       	ldi	r25, 0x01	; 1
    1094:	49 e3       	ldi	r20, 0x39	; 57
    1096:	48 9f       	mul	r20, r24
    1098:	90 01       	movw	r18, r0
    109a:	49 9f       	mul	r20, r25
    109c:	30 0d       	add	r19, r0
    109e:	11 24       	eor	r1, r1
    10a0:	c9 01       	movw	r24, r18
    10a2:	4c 96       	adiw	r24, 0x1c	; 28
    10a4:	1d 96       	adiw	r26, 0x0d	; 13
    10a6:	9c 93       	st	X, r25
    10a8:	8e 93       	st	-X, r24
    10aa:	1c 97       	sbiw	r26, 0x0c	; 12
    10ac:	df 91       	pop	r29
    10ae:	cf 91       	pop	r28
    10b0:	08 95       	ret

000010b2 <__vector_45>:
	}
}


//#if defined (__AVR_ATmega32U4__) // Use Timer4 for ATmega32U4 (Teensy/Leonardo).
ISR(TIMER4_OVF_vect) {
    10b2:	1f 92       	push	r1
    10b4:	0f 92       	push	r0
    10b6:	0f b6       	in	r0, 0x3f	; 63
    10b8:	0f 92       	push	r0
    10ba:	11 24       	eor	r1, r1
    10bc:	0b b6       	in	r0, 0x3b	; 59
    10be:	0f 92       	push	r0
    10c0:	2f 93       	push	r18
    10c2:	3f 93       	push	r19
    10c4:	4f 93       	push	r20
    10c6:	5f 93       	push	r21
    10c8:	6f 93       	push	r22
    10ca:	7f 93       	push	r23
    10cc:	8f 93       	push	r24
    10ce:	9f 93       	push	r25
    10d0:	af 93       	push	r26
    10d2:	bf 93       	push	r27
    10d4:	ef 93       	push	r30
    10d6:	ff 93       	push	r31
//#else
//ISR(TIMER2_COMPA_vect) {
//#endif
	if(intFunc) intFunc(); // If wrapped function is set, call it.
    10d8:	e0 91 3b 0d 	lds	r30, 0x0D3B
    10dc:	f0 91 3c 0d 	lds	r31, 0x0D3C
    10e0:	30 97       	sbiw	r30, 0x00	; 0
    10e2:	09 f0       	breq	.+2      	; 0x10e6 <__vector_45+0x34>
    10e4:	19 95       	eicall
}
    10e6:	ff 91       	pop	r31
    10e8:	ef 91       	pop	r30
    10ea:	bf 91       	pop	r27
    10ec:	af 91       	pop	r26
    10ee:	9f 91       	pop	r25
    10f0:	8f 91       	pop	r24
    10f2:	7f 91       	pop	r23
    10f4:	6f 91       	pop	r22
    10f6:	5f 91       	pop	r21
    10f8:	4f 91       	pop	r20
    10fa:	3f 91       	pop	r19
    10fc:	2f 91       	pop	r18
    10fe:	0f 90       	pop	r0
    1100:	0b be       	out	0x3b, r0	; 59
    1102:	0f 90       	pop	r0
    1104:	0f be       	out	0x3f, r0	; 63
    1106:	0f 90       	pop	r0
    1108:	1f 90       	pop	r1
    110a:	18 95       	reti

0000110c <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    110c:	31 e1       	ldi	r19, 0x11	; 17
    110e:	fc 01       	movw	r30, r24
    1110:	30 83       	st	Z, r19
    1112:	31 97       	sbiw	r30, 0x01	; 1
    1114:	22 e2       	ldi	r18, 0x22	; 34
    1116:	20 83       	st	Z, r18
    1118:	31 97       	sbiw	r30, 0x01	; 1
    111a:	a3 e3       	ldi	r26, 0x33	; 51
    111c:	a0 83       	st	Z, r26
    111e:	31 97       	sbiw	r30, 0x01	; 1
    1120:	60 83       	st	Z, r22
    1122:	31 97       	sbiw	r30, 0x01	; 1
    1124:	70 83       	st	Z, r23
    1126:	31 97       	sbiw	r30, 0x01	; 1
    1128:	10 82       	st	Z, r1
    112a:	31 97       	sbiw	r30, 0x01	; 1
    112c:	10 82       	st	Z, r1
    112e:	31 97       	sbiw	r30, 0x01	; 1
    1130:	60 e8       	ldi	r22, 0x80	; 128
    1132:	60 83       	st	Z, r22
    1134:	31 97       	sbiw	r30, 0x01	; 1
    1136:	10 82       	st	Z, r1
    1138:	31 97       	sbiw	r30, 0x01	; 1
    113a:	10 82       	st	Z, r1
    113c:	31 97       	sbiw	r30, 0x01	; 1
    113e:	10 82       	st	Z, r1
    1140:	31 97       	sbiw	r30, 0x01	; 1
    1142:	62 e0       	ldi	r22, 0x02	; 2
    1144:	60 83       	st	Z, r22
    1146:	31 97       	sbiw	r30, 0x01	; 1
    1148:	63 e0       	ldi	r22, 0x03	; 3
    114a:	60 83       	st	Z, r22
    114c:	31 97       	sbiw	r30, 0x01	; 1
    114e:	64 e0       	ldi	r22, 0x04	; 4
    1150:	60 83       	st	Z, r22
    1152:	31 97       	sbiw	r30, 0x01	; 1
    1154:	65 e0       	ldi	r22, 0x05	; 5
    1156:	60 83       	st	Z, r22
    1158:	31 97       	sbiw	r30, 0x01	; 1
    115a:	66 e0       	ldi	r22, 0x06	; 6
    115c:	60 83       	st	Z, r22
    115e:	31 97       	sbiw	r30, 0x01	; 1
    1160:	67 e0       	ldi	r22, 0x07	; 7
    1162:	60 83       	st	Z, r22
    1164:	31 97       	sbiw	r30, 0x01	; 1
    1166:	68 e0       	ldi	r22, 0x08	; 8
    1168:	60 83       	st	Z, r22
    116a:	31 97       	sbiw	r30, 0x01	; 1
    116c:	69 e0       	ldi	r22, 0x09	; 9
    116e:	60 83       	st	Z, r22
    1170:	31 97       	sbiw	r30, 0x01	; 1
    1172:	60 e1       	ldi	r22, 0x10	; 16
    1174:	60 83       	st	Z, r22
    1176:	31 97       	sbiw	r30, 0x01	; 1
    1178:	30 83       	st	Z, r19
    117a:	31 97       	sbiw	r30, 0x01	; 1
    117c:	32 e1       	ldi	r19, 0x12	; 18
    117e:	30 83       	st	Z, r19
    1180:	31 97       	sbiw	r30, 0x01	; 1
    1182:	33 e1       	ldi	r19, 0x13	; 19
    1184:	30 83       	st	Z, r19
    1186:	31 97       	sbiw	r30, 0x01	; 1
    1188:	34 e1       	ldi	r19, 0x14	; 20
    118a:	30 83       	st	Z, r19
    118c:	31 97       	sbiw	r30, 0x01	; 1
    118e:	35 e1       	ldi	r19, 0x15	; 21
    1190:	30 83       	st	Z, r19
    1192:	31 97       	sbiw	r30, 0x01	; 1
    1194:	36 e1       	ldi	r19, 0x16	; 22
    1196:	30 83       	st	Z, r19
    1198:	31 97       	sbiw	r30, 0x01	; 1
    119a:	37 e1       	ldi	r19, 0x17	; 23
    119c:	30 83       	st	Z, r19
    119e:	31 97       	sbiw	r30, 0x01	; 1
    11a0:	38 e1       	ldi	r19, 0x18	; 24
    11a2:	30 83       	st	Z, r19
    11a4:	31 97       	sbiw	r30, 0x01	; 1
    11a6:	39 e1       	ldi	r19, 0x19	; 25
    11a8:	30 83       	st	Z, r19
    11aa:	31 97       	sbiw	r30, 0x01	; 1
    11ac:	30 e2       	ldi	r19, 0x20	; 32
    11ae:	30 83       	st	Z, r19
    11b0:	31 97       	sbiw	r30, 0x01	; 1
    11b2:	31 e2       	ldi	r19, 0x21	; 33
    11b4:	30 83       	st	Z, r19
    11b6:	31 97       	sbiw	r30, 0x01	; 1
    11b8:	20 83       	st	Z, r18
    11ba:	31 97       	sbiw	r30, 0x01	; 1
    11bc:	23 e2       	ldi	r18, 0x23	; 35
    11be:	20 83       	st	Z, r18
    11c0:	31 97       	sbiw	r30, 0x01	; 1
    11c2:	40 83       	st	Z, r20
    11c4:	31 97       	sbiw	r30, 0x01	; 1
    11c6:	50 83       	st	Z, r21
    11c8:	31 97       	sbiw	r30, 0x01	; 1
    11ca:	26 e2       	ldi	r18, 0x26	; 38
    11cc:	20 83       	st	Z, r18
    11ce:	31 97       	sbiw	r30, 0x01	; 1
    11d0:	27 e2       	ldi	r18, 0x27	; 39
    11d2:	20 83       	st	Z, r18
    11d4:	31 97       	sbiw	r30, 0x01	; 1
    11d6:	28 e2       	ldi	r18, 0x28	; 40
    11d8:	20 83       	st	Z, r18
    11da:	31 97       	sbiw	r30, 0x01	; 1
    11dc:	29 e2       	ldi	r18, 0x29	; 41
    11de:	20 83       	st	Z, r18
    11e0:	31 97       	sbiw	r30, 0x01	; 1
    11e2:	20 e3       	ldi	r18, 0x30	; 48
    11e4:	20 83       	st	Z, r18
    11e6:	31 97       	sbiw	r30, 0x01	; 1
    11e8:	21 e3       	ldi	r18, 0x31	; 49
    11ea:	20 83       	st	Z, r18
    11ec:	89 97       	sbiw	r24, 0x29	; 41
    11ee:	08 95       	ret

000011f0 <xPortStartScheduler>:
    11f0:	82 e0       	ldi	r24, 0x02	; 2
    11f2:	80 93 b0 00 	sts	0x00B0, r24
    11f6:	10 92 b2 00 	sts	0x00B2, r1
    11fa:	80 e3       	ldi	r24, 0x30	; 48
    11fc:	80 93 b3 00 	sts	0x00B3, r24
    1200:	e0 e7       	ldi	r30, 0x70	; 112
    1202:	f0 e0       	ldi	r31, 0x00	; 0
    1204:	80 81       	ld	r24, Z
    1206:	82 60       	ori	r24, 0x02	; 2
    1208:	80 83       	st	Z, r24
    120a:	83 e0       	ldi	r24, 0x03	; 3
    120c:	80 93 b1 00 	sts	0x00B1, r24
    1210:	a0 91 94 0d 	lds	r26, 0x0D94
    1214:	b0 91 95 0d 	lds	r27, 0x0D95
    1218:	cd 91       	ld	r28, X+
    121a:	cd bf       	out	0x3d, r28	; 61
    121c:	dd 91       	ld	r29, X+
    121e:	de bf       	out	0x3e, r29	; 62
    1220:	ff 91       	pop	r31
    1222:	ef 91       	pop	r30
    1224:	df 91       	pop	r29
    1226:	cf 91       	pop	r28
    1228:	bf 91       	pop	r27
    122a:	af 91       	pop	r26
    122c:	9f 91       	pop	r25
    122e:	8f 91       	pop	r24
    1230:	7f 91       	pop	r23
    1232:	6f 91       	pop	r22
    1234:	5f 91       	pop	r21
    1236:	4f 91       	pop	r20
    1238:	3f 91       	pop	r19
    123a:	2f 91       	pop	r18
    123c:	1f 91       	pop	r17
    123e:	0f 91       	pop	r16
    1240:	ff 90       	pop	r15
    1242:	ef 90       	pop	r14
    1244:	df 90       	pop	r13
    1246:	cf 90       	pop	r12
    1248:	bf 90       	pop	r11
    124a:	af 90       	pop	r10
    124c:	9f 90       	pop	r9
    124e:	8f 90       	pop	r8
    1250:	7f 90       	pop	r7
    1252:	6f 90       	pop	r6
    1254:	5f 90       	pop	r5
    1256:	4f 90       	pop	r4
    1258:	3f 90       	pop	r3
    125a:	2f 90       	pop	r2
    125c:	1f 90       	pop	r1
    125e:	0f 90       	pop	r0
    1260:	0c be       	out	0x3c, r0	; 60
    1262:	0f 90       	pop	r0
    1264:	0b be       	out	0x3b, r0	; 59
    1266:	0f 90       	pop	r0
    1268:	0f be       	out	0x3f, r0	; 63
    126a:	0f 90       	pop	r0
    126c:	08 95       	ret
    126e:	81 e0       	ldi	r24, 0x01	; 1
    1270:	08 95       	ret

00001272 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1272:	0f 92       	push	r0
    1274:	0f b6       	in	r0, 0x3f	; 63
    1276:	f8 94       	cli
    1278:	0f 92       	push	r0
    127a:	0b b6       	in	r0, 0x3b	; 59
    127c:	0f 92       	push	r0
    127e:	0c b6       	in	r0, 0x3c	; 60
    1280:	0f 92       	push	r0
    1282:	1f 92       	push	r1
    1284:	11 24       	eor	r1, r1
    1286:	2f 92       	push	r2
    1288:	3f 92       	push	r3
    128a:	4f 92       	push	r4
    128c:	5f 92       	push	r5
    128e:	6f 92       	push	r6
    1290:	7f 92       	push	r7
    1292:	8f 92       	push	r8
    1294:	9f 92       	push	r9
    1296:	af 92       	push	r10
    1298:	bf 92       	push	r11
    129a:	cf 92       	push	r12
    129c:	df 92       	push	r13
    129e:	ef 92       	push	r14
    12a0:	ff 92       	push	r15
    12a2:	0f 93       	push	r16
    12a4:	1f 93       	push	r17
    12a6:	2f 93       	push	r18
    12a8:	3f 93       	push	r19
    12aa:	4f 93       	push	r20
    12ac:	5f 93       	push	r21
    12ae:	6f 93       	push	r22
    12b0:	7f 93       	push	r23
    12b2:	8f 93       	push	r24
    12b4:	9f 93       	push	r25
    12b6:	af 93       	push	r26
    12b8:	bf 93       	push	r27
    12ba:	cf 93       	push	r28
    12bc:	df 93       	push	r29
    12be:	ef 93       	push	r30
    12c0:	ff 93       	push	r31
    12c2:	a0 91 94 0d 	lds	r26, 0x0D94
    12c6:	b0 91 95 0d 	lds	r27, 0x0D95
    12ca:	0d b6       	in	r0, 0x3d	; 61
    12cc:	0d 92       	st	X+, r0
    12ce:	0e b6       	in	r0, 0x3e	; 62
    12d0:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    12d2:	9c d3       	rcall	.+1848   	; 0x1a0c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    12d4:	a0 91 94 0d 	lds	r26, 0x0D94
    12d8:	b0 91 95 0d 	lds	r27, 0x0D95
    12dc:	cd 91       	ld	r28, X+
    12de:	cd bf       	out	0x3d, r28	; 61
    12e0:	dd 91       	ld	r29, X+
    12e2:	de bf       	out	0x3e, r29	; 62
    12e4:	ff 91       	pop	r31
    12e6:	ef 91       	pop	r30
    12e8:	df 91       	pop	r29
    12ea:	cf 91       	pop	r28
    12ec:	bf 91       	pop	r27
    12ee:	af 91       	pop	r26
    12f0:	9f 91       	pop	r25
    12f2:	8f 91       	pop	r24
    12f4:	7f 91       	pop	r23
    12f6:	6f 91       	pop	r22
    12f8:	5f 91       	pop	r21
    12fa:	4f 91       	pop	r20
    12fc:	3f 91       	pop	r19
    12fe:	2f 91       	pop	r18
    1300:	1f 91       	pop	r17
    1302:	0f 91       	pop	r16
    1304:	ff 90       	pop	r15
    1306:	ef 90       	pop	r14
    1308:	df 90       	pop	r13
    130a:	cf 90       	pop	r12
    130c:	bf 90       	pop	r11
    130e:	af 90       	pop	r10
    1310:	9f 90       	pop	r9
    1312:	8f 90       	pop	r8
    1314:	7f 90       	pop	r7
    1316:	6f 90       	pop	r6
    1318:	5f 90       	pop	r5
    131a:	4f 90       	pop	r4
    131c:	3f 90       	pop	r3
    131e:	2f 90       	pop	r2
    1320:	1f 90       	pop	r1
    1322:	0f 90       	pop	r0
    1324:	0c be       	out	0x3c, r0	; 60
    1326:	0f 90       	pop	r0
    1328:	0b be       	out	0x3b, r0	; 59
    132a:	0f 90       	pop	r0
    132c:	0f be       	out	0x3f, r0	; 63
    132e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1330:	08 95       	ret

00001332 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1332:	0f 92       	push	r0
    1334:	0f b6       	in	r0, 0x3f	; 63
    1336:	f8 94       	cli
    1338:	0f 92       	push	r0
    133a:	0b b6       	in	r0, 0x3b	; 59
    133c:	0f 92       	push	r0
    133e:	0c b6       	in	r0, 0x3c	; 60
    1340:	0f 92       	push	r0
    1342:	1f 92       	push	r1
    1344:	11 24       	eor	r1, r1
    1346:	2f 92       	push	r2
    1348:	3f 92       	push	r3
    134a:	4f 92       	push	r4
    134c:	5f 92       	push	r5
    134e:	6f 92       	push	r6
    1350:	7f 92       	push	r7
    1352:	8f 92       	push	r8
    1354:	9f 92       	push	r9
    1356:	af 92       	push	r10
    1358:	bf 92       	push	r11
    135a:	cf 92       	push	r12
    135c:	df 92       	push	r13
    135e:	ef 92       	push	r14
    1360:	ff 92       	push	r15
    1362:	0f 93       	push	r16
    1364:	1f 93       	push	r17
    1366:	2f 93       	push	r18
    1368:	3f 93       	push	r19
    136a:	4f 93       	push	r20
    136c:	5f 93       	push	r21
    136e:	6f 93       	push	r22
    1370:	7f 93       	push	r23
    1372:	8f 93       	push	r24
    1374:	9f 93       	push	r25
    1376:	af 93       	push	r26
    1378:	bf 93       	push	r27
    137a:	cf 93       	push	r28
    137c:	df 93       	push	r29
    137e:	ef 93       	push	r30
    1380:	ff 93       	push	r31
    1382:	a0 91 94 0d 	lds	r26, 0x0D94
    1386:	b0 91 95 0d 	lds	r27, 0x0D95
    138a:	0d b6       	in	r0, 0x3d	; 61
    138c:	0d 92       	st	X+, r0
    138e:	0e b6       	in	r0, 0x3e	; 62
    1390:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1392:	b0 d1       	rcall	.+864    	; 0x16f4 <xTaskIncrementTick>
    1394:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    1396:	3a d3       	rcall	.+1652   	; 0x1a0c <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1398:	a0 91 94 0d 	lds	r26, 0x0D94
    139c:	b0 91 95 0d 	lds	r27, 0x0D95
    13a0:	cd 91       	ld	r28, X+
    13a2:	cd bf       	out	0x3d, r28	; 61
    13a4:	dd 91       	ld	r29, X+
    13a6:	de bf       	out	0x3e, r29	; 62
    13a8:	ff 91       	pop	r31
    13aa:	ef 91       	pop	r30
    13ac:	df 91       	pop	r29
    13ae:	cf 91       	pop	r28
    13b0:	bf 91       	pop	r27
    13b2:	af 91       	pop	r26
    13b4:	9f 91       	pop	r25
    13b6:	8f 91       	pop	r24
    13b8:	7f 91       	pop	r23
    13ba:	6f 91       	pop	r22
    13bc:	5f 91       	pop	r21
    13be:	4f 91       	pop	r20
    13c0:	3f 91       	pop	r19
    13c2:	2f 91       	pop	r18
    13c4:	1f 91       	pop	r17
    13c6:	0f 91       	pop	r16
    13c8:	ff 90       	pop	r15
    13ca:	ef 90       	pop	r14
    13cc:	df 90       	pop	r13
    13ce:	cf 90       	pop	r12
    13d0:	bf 90       	pop	r11
    13d2:	af 90       	pop	r10
    13d4:	9f 90       	pop	r9
    13d6:	8f 90       	pop	r8
    13d8:	7f 90       	pop	r7
    13da:	6f 90       	pop	r6
    13dc:	5f 90       	pop	r5
    13de:	4f 90       	pop	r4
    13e0:	3f 90       	pop	r3
    13e2:	2f 90       	pop	r2
    13e4:	1f 90       	pop	r1
    13e6:	0f 90       	pop	r0
    13e8:	0c be       	out	0x3c, r0	; 60
    13ea:	0f 90       	pop	r0
    13ec:	0b be       	out	0x3b, r0	; 59
    13ee:	0f 90       	pop	r0
    13f0:	0f be       	out	0x3f, r0	; 63
    13f2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    13f4:	08 95       	ret

000013f6 <__vector_13>:
	 */
	
	//ISR(TIMER0_COMPA_vect,ISR_NAKED) //comeback timer2
	ISR(TIMER2_COMPA_vect,ISR_NAKED)
	{
		vPortYieldFromTick();
    13f6:	9d df       	rcall	.-198    	; 0x1332 <vPortYieldFromTick>
		asm volatile ( "reti" );
    13f8:	18 95       	reti

000013fa <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    13fa:	e0 91 5c 0d 	lds	r30, 0x0D5C
    13fe:	f0 91 5d 0d 	lds	r31, 0x0D5D
    1402:	80 81       	ld	r24, Z
    1404:	81 11       	cpse	r24, r1
    1406:	07 c0       	rjmp	.+14     	; 0x1416 <prvResetNextTaskUnblockTime+0x1c>
    1408:	8f ef       	ldi	r24, 0xFF	; 255
    140a:	9f ef       	ldi	r25, 0xFF	; 255
    140c:	90 93 14 02 	sts	0x0214, r25
    1410:	80 93 13 02 	sts	0x0213, r24
    1414:	08 95       	ret
    1416:	e0 91 5c 0d 	lds	r30, 0x0D5C
    141a:	f0 91 5d 0d 	lds	r31, 0x0D5D
    141e:	05 80       	ldd	r0, Z+5	; 0x05
    1420:	f6 81       	ldd	r31, Z+6	; 0x06
    1422:	e0 2d       	mov	r30, r0
    1424:	06 80       	ldd	r0, Z+6	; 0x06
    1426:	f7 81       	ldd	r31, Z+7	; 0x07
    1428:	e0 2d       	mov	r30, r0
    142a:	82 81       	ldd	r24, Z+2	; 0x02
    142c:	93 81       	ldd	r25, Z+3	; 0x03
    142e:	90 93 14 02 	sts	0x0214, r25
    1432:	80 93 13 02 	sts	0x0213, r24
    1436:	08 95       	ret

00001438 <prvAddCurrentTaskToDelayedList>:
    1438:	cf 93       	push	r28
    143a:	df 93       	push	r29
    143c:	ec 01       	movw	r28, r24
    143e:	e0 91 94 0d 	lds	r30, 0x0D94
    1442:	f0 91 95 0d 	lds	r31, 0x0D95
    1446:	93 83       	std	Z+3, r25	; 0x03
    1448:	82 83       	std	Z+2, r24	; 0x02
    144a:	80 91 44 0d 	lds	r24, 0x0D44
    144e:	90 91 45 0d 	lds	r25, 0x0D45
    1452:	c8 17       	cp	r28, r24
    1454:	d9 07       	cpc	r29, r25
    1456:	60 f4       	brcc	.+24     	; 0x1470 <prvAddCurrentTaskToDelayedList+0x38>
    1458:	60 91 94 0d 	lds	r22, 0x0D94
    145c:	70 91 95 0d 	lds	r23, 0x0D95
    1460:	80 91 5a 0d 	lds	r24, 0x0D5A
    1464:	90 91 5b 0d 	lds	r25, 0x0D5B
    1468:	6e 5f       	subi	r22, 0xFE	; 254
    146a:	7f 4f       	sbci	r23, 0xFF	; 255
    146c:	cb da       	rcall	.-2666   	; 0xa04 <vListInsert>
    146e:	16 c0       	rjmp	.+44     	; 0x149c <prvAddCurrentTaskToDelayedList+0x64>
    1470:	60 91 94 0d 	lds	r22, 0x0D94
    1474:	70 91 95 0d 	lds	r23, 0x0D95
    1478:	80 91 5c 0d 	lds	r24, 0x0D5C
    147c:	90 91 5d 0d 	lds	r25, 0x0D5D
    1480:	6e 5f       	subi	r22, 0xFE	; 254
    1482:	7f 4f       	sbci	r23, 0xFF	; 255
    1484:	bf da       	rcall	.-2690   	; 0xa04 <vListInsert>
    1486:	80 91 13 02 	lds	r24, 0x0213
    148a:	90 91 14 02 	lds	r25, 0x0214
    148e:	c8 17       	cp	r28, r24
    1490:	d9 07       	cpc	r29, r25
    1492:	20 f4       	brcc	.+8      	; 0x149c <prvAddCurrentTaskToDelayedList+0x64>
    1494:	d0 93 14 02 	sts	0x0214, r29
    1498:	c0 93 13 02 	sts	0x0213, r28
    149c:	df 91       	pop	r29
    149e:	cf 91       	pop	r28
    14a0:	08 95       	ret

000014a2 <xTaskGenericCreate>:
    14a2:	4f 92       	push	r4
    14a4:	5f 92       	push	r5
    14a6:	6f 92       	push	r6
    14a8:	7f 92       	push	r7
    14aa:	8f 92       	push	r8
    14ac:	9f 92       	push	r9
    14ae:	af 92       	push	r10
    14b0:	bf 92       	push	r11
    14b2:	cf 92       	push	r12
    14b4:	df 92       	push	r13
    14b6:	ef 92       	push	r14
    14b8:	ff 92       	push	r15
    14ba:	0f 93       	push	r16
    14bc:	1f 93       	push	r17
    14be:	cf 93       	push	r28
    14c0:	df 93       	push	r29
    14c2:	4c 01       	movw	r8, r24
    14c4:	5b 01       	movw	r10, r22
    14c6:	2a 01       	movw	r4, r20
    14c8:	39 01       	movw	r6, r18
    14ca:	81 e2       	ldi	r24, 0x21	; 33
    14cc:	90 e0       	ldi	r25, 0x00	; 0
    14ce:	c3 d8       	rcall	.-3706   	; 0x656 <pvPortMalloc>
    14d0:	ec 01       	movw	r28, r24
    14d2:	00 97       	sbiw	r24, 0x00	; 0
    14d4:	09 f4       	brne	.+2      	; 0x14d8 <xTaskGenericCreate+0x36>
    14d6:	cd c0       	rjmp	.+410    	; 0x1672 <xTaskGenericCreate+0x1d0>
    14d8:	c1 14       	cp	r12, r1
    14da:	d1 04       	cpc	r13, r1
    14dc:	09 f0       	breq	.+2      	; 0x14e0 <xTaskGenericCreate+0x3e>
    14de:	b2 c0       	rjmp	.+356    	; 0x1644 <xTaskGenericCreate+0x1a2>
    14e0:	c2 01       	movw	r24, r4
    14e2:	b9 d8       	rcall	.-3726   	; 0x656 <pvPortMalloc>
    14e4:	98 8f       	std	Y+24, r25	; 0x18
    14e6:	8f 8b       	std	Y+23, r24	; 0x17
    14e8:	89 2b       	or	r24, r25
    14ea:	09 f0       	breq	.+2      	; 0x14ee <xTaskGenericCreate+0x4c>
    14ec:	ad c0       	rjmp	.+346    	; 0x1648 <xTaskGenericCreate+0x1a6>
    14ee:	ce 01       	movw	r24, r28
    14f0:	e7 d8       	rcall	.-3634   	; 0x6c0 <vPortFree>
    14f2:	bf c0       	rjmp	.+382    	; 0x1672 <xTaskGenericCreate+0x1d0>
    14f4:	cf 01       	movw	r24, r30
    14f6:	31 91       	ld	r19, Z+
    14f8:	da 01       	movw	r26, r20
    14fa:	3d 93       	st	X+, r19
    14fc:	ad 01       	movw	r20, r26
    14fe:	dc 01       	movw	r26, r24
    1500:	8c 91       	ld	r24, X
    1502:	88 23       	and	r24, r24
    1504:	11 f0       	breq	.+4      	; 0x150a <xTaskGenericCreate+0x68>
    1506:	21 50       	subi	r18, 0x01	; 1
    1508:	a9 f7       	brne	.-22     	; 0x14f4 <xTaskGenericCreate+0x52>
    150a:	18 a2       	std	Y+32, r1	; 0x20
    150c:	10 2f       	mov	r17, r16
    150e:	04 30       	cpi	r16, 0x04	; 4
    1510:	08 f0       	brcs	.+2      	; 0x1514 <xTaskGenericCreate+0x72>
    1512:	13 e0       	ldi	r17, 0x03	; 3
    1514:	1e 8b       	std	Y+22, r17	; 0x16
    1516:	5e 01       	movw	r10, r28
    1518:	b2 e0       	ldi	r27, 0x02	; 2
    151a:	ab 0e       	add	r10, r27
    151c:	b1 1c       	adc	r11, r1
    151e:	c5 01       	movw	r24, r10
    1520:	4c da       	rcall	.-2920   	; 0x9ba <vListInitialiseItem>
    1522:	ce 01       	movw	r24, r28
    1524:	0c 96       	adiw	r24, 0x0c	; 12
    1526:	49 da       	rcall	.-2926   	; 0x9ba <vListInitialiseItem>
    1528:	d9 87       	std	Y+9, r29	; 0x09
    152a:	c8 87       	std	Y+8, r28	; 0x08
    152c:	84 e0       	ldi	r24, 0x04	; 4
    152e:	90 e0       	ldi	r25, 0x00	; 0
    1530:	81 1b       	sub	r24, r17
    1532:	91 09       	sbc	r25, r1
    1534:	9d 87       	std	Y+13, r25	; 0x0d
    1536:	8c 87       	std	Y+12, r24	; 0x0c
    1538:	db 8b       	std	Y+19, r29	; 0x13
    153a:	ca 8b       	std	Y+18, r28	; 0x12
    153c:	a3 01       	movw	r20, r6
    153e:	b4 01       	movw	r22, r8
    1540:	c6 01       	movw	r24, r12
    1542:	e4 dd       	rcall	.-1080   	; 0x110c <pxPortInitialiseStack>
    1544:	99 83       	std	Y+1, r25	; 0x01
    1546:	88 83       	st	Y, r24
    1548:	e1 14       	cp	r14, r1
    154a:	f1 04       	cpc	r15, r1
    154c:	19 f0       	breq	.+6      	; 0x1554 <xTaskGenericCreate+0xb2>
    154e:	f7 01       	movw	r30, r14
    1550:	d1 83       	std	Z+1, r29	; 0x01
    1552:	c0 83       	st	Z, r28
    1554:	0f b6       	in	r0, 0x3f	; 63
    1556:	f8 94       	cli
    1558:	0f 92       	push	r0
    155a:	80 91 46 0d 	lds	r24, 0x0D46
    155e:	8f 5f       	subi	r24, 0xFF	; 255
    1560:	80 93 46 0d 	sts	0x0D46, r24
    1564:	80 91 94 0d 	lds	r24, 0x0D94
    1568:	90 91 95 0d 	lds	r25, 0x0D95
    156c:	89 2b       	or	r24, r25
    156e:	69 f5       	brne	.+90     	; 0x15ca <xTaskGenericCreate+0x128>
    1570:	d0 93 95 0d 	sts	0x0D95, r29
    1574:	c0 93 94 0d 	sts	0x0D94, r28
    1578:	80 91 46 0d 	lds	r24, 0x0D46
    157c:	81 30       	cpi	r24, 0x01	; 1
    157e:	a1 f5       	brne	.+104    	; 0x15e8 <xTaskGenericCreate+0x146>
    1580:	80 e7       	ldi	r24, 0x70	; 112
    1582:	9d e0       	ldi	r25, 0x0D	; 13
    1584:	0c da       	rcall	.-3048   	; 0x99e <vListInitialise>
    1586:	89 e7       	ldi	r24, 0x79	; 121
    1588:	9d e0       	ldi	r25, 0x0D	; 13
    158a:	09 da       	rcall	.-3054   	; 0x99e <vListInitialise>
    158c:	82 e8       	ldi	r24, 0x82	; 130
    158e:	9d e0       	ldi	r25, 0x0D	; 13
    1590:	06 da       	rcall	.-3060   	; 0x99e <vListInitialise>
    1592:	8b e8       	ldi	r24, 0x8B	; 139
    1594:	9d e0       	ldi	r25, 0x0D	; 13
    1596:	03 da       	rcall	.-3066   	; 0x99e <vListInitialise>
    1598:	87 e6       	ldi	r24, 0x67	; 103
    159a:	9d e0       	ldi	r25, 0x0D	; 13
    159c:	00 da       	rcall	.-3072   	; 0x99e <vListInitialise>
    159e:	8e e5       	ldi	r24, 0x5E	; 94
    15a0:	9d e0       	ldi	r25, 0x0D	; 13
    15a2:	fd d9       	rcall	.-3078   	; 0x99e <vListInitialise>
    15a4:	81 e5       	ldi	r24, 0x51	; 81
    15a6:	9d e0       	ldi	r25, 0x0D	; 13
    15a8:	fa d9       	rcall	.-3084   	; 0x99e <vListInitialise>
    15aa:	88 e4       	ldi	r24, 0x48	; 72
    15ac:	9d e0       	ldi	r25, 0x0D	; 13
    15ae:	f7 d9       	rcall	.-3090   	; 0x99e <vListInitialise>
    15b0:	87 e6       	ldi	r24, 0x67	; 103
    15b2:	9d e0       	ldi	r25, 0x0D	; 13
    15b4:	90 93 5d 0d 	sts	0x0D5D, r25
    15b8:	80 93 5c 0d 	sts	0x0D5C, r24
    15bc:	8e e5       	ldi	r24, 0x5E	; 94
    15be:	9d e0       	ldi	r25, 0x0D	; 13
    15c0:	90 93 5b 0d 	sts	0x0D5B, r25
    15c4:	80 93 5a 0d 	sts	0x0D5A, r24
    15c8:	0f c0       	rjmp	.+30     	; 0x15e8 <xTaskGenericCreate+0x146>
    15ca:	80 91 42 0d 	lds	r24, 0x0D42
    15ce:	81 11       	cpse	r24, r1
    15d0:	0b c0       	rjmp	.+22     	; 0x15e8 <xTaskGenericCreate+0x146>
    15d2:	e0 91 94 0d 	lds	r30, 0x0D94
    15d6:	f0 91 95 0d 	lds	r31, 0x0D95
    15da:	86 89       	ldd	r24, Z+22	; 0x16
    15dc:	08 17       	cp	r16, r24
    15de:	20 f0       	brcs	.+8      	; 0x15e8 <xTaskGenericCreate+0x146>
    15e0:	d0 93 95 0d 	sts	0x0D95, r29
    15e4:	c0 93 94 0d 	sts	0x0D94, r28
    15e8:	80 91 3e 0d 	lds	r24, 0x0D3E
    15ec:	8f 5f       	subi	r24, 0xFF	; 255
    15ee:	80 93 3e 0d 	sts	0x0D3E, r24
    15f2:	8e 89       	ldd	r24, Y+22	; 0x16
    15f4:	90 91 43 0d 	lds	r25, 0x0D43
    15f8:	98 17       	cp	r25, r24
    15fa:	10 f4       	brcc	.+4      	; 0x1600 <xTaskGenericCreate+0x15e>
    15fc:	80 93 43 0d 	sts	0x0D43, r24
    1600:	90 e0       	ldi	r25, 0x00	; 0
    1602:	9c 01       	movw	r18, r24
    1604:	22 0f       	add	r18, r18
    1606:	33 1f       	adc	r19, r19
    1608:	22 0f       	add	r18, r18
    160a:	33 1f       	adc	r19, r19
    160c:	22 0f       	add	r18, r18
    160e:	33 1f       	adc	r19, r19
    1610:	82 0f       	add	r24, r18
    1612:	93 1f       	adc	r25, r19
    1614:	b5 01       	movw	r22, r10
    1616:	80 59       	subi	r24, 0x90	; 144
    1618:	92 4f       	sbci	r25, 0xF2	; 242
    161a:	d3 d9       	rcall	.-3162   	; 0x9c2 <vListInsertEnd>
    161c:	0f 90       	pop	r0
    161e:	0f be       	out	0x3f, r0	; 63
    1620:	80 91 42 0d 	lds	r24, 0x0D42
    1624:	88 23       	and	r24, r24
    1626:	51 f0       	breq	.+20     	; 0x163c <xTaskGenericCreate+0x19a>
    1628:	e0 91 94 0d 	lds	r30, 0x0D94
    162c:	f0 91 95 0d 	lds	r31, 0x0D95
    1630:	86 89       	ldd	r24, Z+22	; 0x16
    1632:	80 17       	cp	r24, r16
    1634:	28 f4       	brcc	.+10     	; 0x1640 <xTaskGenericCreate+0x19e>
    1636:	1d de       	rcall	.-966    	; 0x1272 <vPortYield>
    1638:	81 e0       	ldi	r24, 0x01	; 1
    163a:	1c c0       	rjmp	.+56     	; 0x1674 <xTaskGenericCreate+0x1d2>
    163c:	81 e0       	ldi	r24, 0x01	; 1
    163e:	1a c0       	rjmp	.+52     	; 0x1674 <xTaskGenericCreate+0x1d2>
    1640:	81 e0       	ldi	r24, 0x01	; 1
    1642:	18 c0       	rjmp	.+48     	; 0x1674 <xTaskGenericCreate+0x1d2>
    1644:	d8 8e       	std	Y+24, r13	; 0x18
    1646:	cf 8a       	std	Y+23, r12	; 0x17
    1648:	f1 e0       	ldi	r31, 0x01	; 1
    164a:	4f 1a       	sub	r4, r31
    164c:	51 08       	sbc	r5, r1
    164e:	cf 88       	ldd	r12, Y+23	; 0x17
    1650:	d8 8c       	ldd	r13, Y+24	; 0x18
    1652:	c4 0c       	add	r12, r4
    1654:	d5 1c       	adc	r13, r5
    1656:	d5 01       	movw	r26, r10
    1658:	8c 91       	ld	r24, X
    165a:	89 8f       	std	Y+25, r24	; 0x19
    165c:	8c 91       	ld	r24, X
    165e:	88 23       	and	r24, r24
    1660:	09 f4       	brne	.+2      	; 0x1664 <xTaskGenericCreate+0x1c2>
    1662:	53 cf       	rjmp	.-346    	; 0x150a <xTaskGenericCreate+0x68>
    1664:	ae 01       	movw	r20, r28
    1666:	46 5e       	subi	r20, 0xE6	; 230
    1668:	5f 4f       	sbci	r21, 0xFF	; 255
    166a:	f5 01       	movw	r30, r10
    166c:	31 96       	adiw	r30, 0x01	; 1
    166e:	27 e0       	ldi	r18, 0x07	; 7
    1670:	41 cf       	rjmp	.-382    	; 0x14f4 <xTaskGenericCreate+0x52>
    1672:	8f ef       	ldi	r24, 0xFF	; 255
    1674:	df 91       	pop	r29
    1676:	cf 91       	pop	r28
    1678:	1f 91       	pop	r17
    167a:	0f 91       	pop	r16
    167c:	ff 90       	pop	r15
    167e:	ef 90       	pop	r14
    1680:	df 90       	pop	r13
    1682:	cf 90       	pop	r12
    1684:	bf 90       	pop	r11
    1686:	af 90       	pop	r10
    1688:	9f 90       	pop	r9
    168a:	8f 90       	pop	r8
    168c:	7f 90       	pop	r7
    168e:	6f 90       	pop	r6
    1690:	5f 90       	pop	r5
    1692:	4f 90       	pop	r4
    1694:	08 95       	ret

00001696 <vTaskStartScheduler>:
    1696:	af 92       	push	r10
    1698:	bf 92       	push	r11
    169a:	cf 92       	push	r12
    169c:	df 92       	push	r13
    169e:	ef 92       	push	r14
    16a0:	ff 92       	push	r15
    16a2:	0f 93       	push	r16
    16a4:	a1 2c       	mov	r10, r1
    16a6:	b1 2c       	mov	r11, r1
    16a8:	c1 2c       	mov	r12, r1
    16aa:	d1 2c       	mov	r13, r1
    16ac:	e1 2c       	mov	r14, r1
    16ae:	f1 2c       	mov	r15, r1
    16b0:	00 e0       	ldi	r16, 0x00	; 0
    16b2:	20 e0       	ldi	r18, 0x00	; 0
    16b4:	30 e0       	ldi	r19, 0x00	; 0
    16b6:	45 e5       	ldi	r20, 0x55	; 85
    16b8:	50 e0       	ldi	r21, 0x00	; 0
    16ba:	66 e8       	ldi	r22, 0x86	; 134
    16bc:	72 e0       	ldi	r23, 0x02	; 2
    16be:	8e ec       	ldi	r24, 0xCE	; 206
    16c0:	9c e0       	ldi	r25, 0x0C	; 12
    16c2:	ef de       	rcall	.-546    	; 0x14a2 <xTaskGenericCreate>
    16c4:	81 30       	cpi	r24, 0x01	; 1
    16c6:	41 f4       	brne	.+16     	; 0x16d8 <vTaskStartScheduler+0x42>
    16c8:	f8 94       	cli
    16ca:	80 93 42 0d 	sts	0x0D42, r24
    16ce:	10 92 45 0d 	sts	0x0D45, r1
    16d2:	10 92 44 0d 	sts	0x0D44, r1
    16d6:	8c dd       	rcall	.-1256   	; 0x11f0 <xPortStartScheduler>
    16d8:	0f 91       	pop	r16
    16da:	ff 90       	pop	r15
    16dc:	ef 90       	pop	r14
    16de:	df 90       	pop	r13
    16e0:	cf 90       	pop	r12
    16e2:	bf 90       	pop	r11
    16e4:	af 90       	pop	r10
    16e6:	08 95       	ret

000016e8 <vTaskSuspendAll>:
    16e8:	80 91 3d 0d 	lds	r24, 0x0D3D
    16ec:	8f 5f       	subi	r24, 0xFF	; 255
    16ee:	80 93 3d 0d 	sts	0x0D3D, r24
    16f2:	08 95       	ret

000016f4 <xTaskIncrementTick>:
    16f4:	cf 92       	push	r12
    16f6:	df 92       	push	r13
    16f8:	ef 92       	push	r14
    16fa:	ff 92       	push	r15
    16fc:	0f 93       	push	r16
    16fe:	1f 93       	push	r17
    1700:	cf 93       	push	r28
    1702:	df 93       	push	r29
    1704:	80 91 3d 0d 	lds	r24, 0x0D3D
    1708:	81 11       	cpse	r24, r1
    170a:	96 c0       	rjmp	.+300    	; 0x1838 <xTaskIncrementTick+0x144>
    170c:	80 91 44 0d 	lds	r24, 0x0D44
    1710:	90 91 45 0d 	lds	r25, 0x0D45
    1714:	01 96       	adiw	r24, 0x01	; 1
    1716:	90 93 45 0d 	sts	0x0D45, r25
    171a:	80 93 44 0d 	sts	0x0D44, r24
    171e:	e0 90 44 0d 	lds	r14, 0x0D44
    1722:	f0 90 45 0d 	lds	r15, 0x0D45
    1726:	e1 14       	cp	r14, r1
    1728:	f1 04       	cpc	r15, r1
    172a:	b1 f4       	brne	.+44     	; 0x1758 <xTaskIncrementTick+0x64>
    172c:	80 91 5c 0d 	lds	r24, 0x0D5C
    1730:	90 91 5d 0d 	lds	r25, 0x0D5D
    1734:	20 91 5a 0d 	lds	r18, 0x0D5A
    1738:	30 91 5b 0d 	lds	r19, 0x0D5B
    173c:	30 93 5d 0d 	sts	0x0D5D, r19
    1740:	20 93 5c 0d 	sts	0x0D5C, r18
    1744:	90 93 5b 0d 	sts	0x0D5B, r25
    1748:	80 93 5a 0d 	sts	0x0D5A, r24
    174c:	80 91 3f 0d 	lds	r24, 0x0D3F
    1750:	8f 5f       	subi	r24, 0xFF	; 255
    1752:	80 93 3f 0d 	sts	0x0D3F, r24
    1756:	51 de       	rcall	.-862    	; 0x13fa <prvResetNextTaskUnblockTime>
    1758:	80 91 13 02 	lds	r24, 0x0213
    175c:	90 91 14 02 	lds	r25, 0x0214
    1760:	e8 16       	cp	r14, r24
    1762:	f9 06       	cpc	r15, r25
    1764:	08 f4       	brcc	.+2      	; 0x1768 <xTaskIncrementTick+0x74>
    1766:	51 c0       	rjmp	.+162    	; 0x180a <xTaskIncrementTick+0x116>
    1768:	d1 2c       	mov	r13, r1
    176a:	cc 24       	eor	r12, r12
    176c:	c3 94       	inc	r12
    176e:	01 c0       	rjmp	.+2      	; 0x1772 <xTaskIncrementTick+0x7e>
    1770:	dc 2c       	mov	r13, r12
    1772:	e0 91 5c 0d 	lds	r30, 0x0D5C
    1776:	f0 91 5d 0d 	lds	r31, 0x0D5D
    177a:	80 81       	ld	r24, Z
    177c:	81 11       	cpse	r24, r1
    177e:	07 c0       	rjmp	.+14     	; 0x178e <xTaskIncrementTick+0x9a>
    1780:	8f ef       	ldi	r24, 0xFF	; 255
    1782:	9f ef       	ldi	r25, 0xFF	; 255
    1784:	90 93 14 02 	sts	0x0214, r25
    1788:	80 93 13 02 	sts	0x0213, r24
    178c:	3f c0       	rjmp	.+126    	; 0x180c <xTaskIncrementTick+0x118>
    178e:	e0 91 5c 0d 	lds	r30, 0x0D5C
    1792:	f0 91 5d 0d 	lds	r31, 0x0D5D
    1796:	05 80       	ldd	r0, Z+5	; 0x05
    1798:	f6 81       	ldd	r31, Z+6	; 0x06
    179a:	e0 2d       	mov	r30, r0
    179c:	c6 81       	ldd	r28, Z+6	; 0x06
    179e:	d7 81       	ldd	r29, Z+7	; 0x07
    17a0:	2a 81       	ldd	r18, Y+2	; 0x02
    17a2:	3b 81       	ldd	r19, Y+3	; 0x03
    17a4:	e2 16       	cp	r14, r18
    17a6:	f3 06       	cpc	r15, r19
    17a8:	28 f4       	brcc	.+10     	; 0x17b4 <xTaskIncrementTick+0xc0>
    17aa:	30 93 14 02 	sts	0x0214, r19
    17ae:	20 93 13 02 	sts	0x0213, r18
    17b2:	2c c0       	rjmp	.+88     	; 0x180c <xTaskIncrementTick+0x118>
    17b4:	8e 01       	movw	r16, r28
    17b6:	0e 5f       	subi	r16, 0xFE	; 254
    17b8:	1f 4f       	sbci	r17, 0xFF	; 255
    17ba:	c8 01       	movw	r24, r16
    17bc:	54 d9       	rcall	.-3416   	; 0xa66 <uxListRemove>
    17be:	8c 89       	ldd	r24, Y+20	; 0x14
    17c0:	9d 89       	ldd	r25, Y+21	; 0x15
    17c2:	89 2b       	or	r24, r25
    17c4:	19 f0       	breq	.+6      	; 0x17cc <xTaskIncrementTick+0xd8>
    17c6:	ce 01       	movw	r24, r28
    17c8:	0c 96       	adiw	r24, 0x0c	; 12
    17ca:	4d d9       	rcall	.-3430   	; 0xa66 <uxListRemove>
    17cc:	2e 89       	ldd	r18, Y+22	; 0x16
    17ce:	80 91 43 0d 	lds	r24, 0x0D43
    17d2:	82 17       	cp	r24, r18
    17d4:	10 f4       	brcc	.+4      	; 0x17da <xTaskIncrementTick+0xe6>
    17d6:	20 93 43 0d 	sts	0x0D43, r18
    17da:	30 e0       	ldi	r19, 0x00	; 0
    17dc:	c9 01       	movw	r24, r18
    17de:	88 0f       	add	r24, r24
    17e0:	99 1f       	adc	r25, r25
    17e2:	88 0f       	add	r24, r24
    17e4:	99 1f       	adc	r25, r25
    17e6:	88 0f       	add	r24, r24
    17e8:	99 1f       	adc	r25, r25
    17ea:	82 0f       	add	r24, r18
    17ec:	93 1f       	adc	r25, r19
    17ee:	b8 01       	movw	r22, r16
    17f0:	80 59       	subi	r24, 0x90	; 144
    17f2:	92 4f       	sbci	r25, 0xF2	; 242
    17f4:	e6 d8       	rcall	.-3636   	; 0x9c2 <vListInsertEnd>
    17f6:	e0 91 94 0d 	lds	r30, 0x0D94
    17fa:	f0 91 95 0d 	lds	r31, 0x0D95
    17fe:	9e 89       	ldd	r25, Y+22	; 0x16
    1800:	86 89       	ldd	r24, Z+22	; 0x16
    1802:	98 17       	cp	r25, r24
    1804:	08 f0       	brcs	.+2      	; 0x1808 <xTaskIncrementTick+0x114>
    1806:	b4 cf       	rjmp	.-152    	; 0x1770 <xTaskIncrementTick+0x7c>
    1808:	b4 cf       	rjmp	.-152    	; 0x1772 <xTaskIncrementTick+0x7e>
    180a:	d1 2c       	mov	r13, r1
    180c:	e0 91 94 0d 	lds	r30, 0x0D94
    1810:	f0 91 95 0d 	lds	r31, 0x0D95
    1814:	86 89       	ldd	r24, Z+22	; 0x16
    1816:	90 e0       	ldi	r25, 0x00	; 0
    1818:	fc 01       	movw	r30, r24
    181a:	ee 0f       	add	r30, r30
    181c:	ff 1f       	adc	r31, r31
    181e:	ee 0f       	add	r30, r30
    1820:	ff 1f       	adc	r31, r31
    1822:	ee 0f       	add	r30, r30
    1824:	ff 1f       	adc	r31, r31
    1826:	8e 0f       	add	r24, r30
    1828:	9f 1f       	adc	r25, r31
    182a:	fc 01       	movw	r30, r24
    182c:	e0 59       	subi	r30, 0x90	; 144
    182e:	f2 4f       	sbci	r31, 0xF2	; 242
    1830:	80 81       	ld	r24, Z
    1832:	82 30       	cpi	r24, 0x02	; 2
    1834:	40 f4       	brcc	.+16     	; 0x1846 <xTaskIncrementTick+0x152>
    1836:	09 c0       	rjmp	.+18     	; 0x184a <xTaskIncrementTick+0x156>
    1838:	80 91 41 0d 	lds	r24, 0x0D41
    183c:	8f 5f       	subi	r24, 0xFF	; 255
    183e:	80 93 41 0d 	sts	0x0D41, r24
    1842:	d1 2c       	mov	r13, r1
    1844:	02 c0       	rjmp	.+4      	; 0x184a <xTaskIncrementTick+0x156>
    1846:	dd 24       	eor	r13, r13
    1848:	d3 94       	inc	r13
    184a:	80 91 40 0d 	lds	r24, 0x0D40
    184e:	88 23       	and	r24, r24
    1850:	11 f0       	breq	.+4      	; 0x1856 <xTaskIncrementTick+0x162>
    1852:	dd 24       	eor	r13, r13
    1854:	d3 94       	inc	r13
    1856:	8d 2d       	mov	r24, r13
    1858:	df 91       	pop	r29
    185a:	cf 91       	pop	r28
    185c:	1f 91       	pop	r17
    185e:	0f 91       	pop	r16
    1860:	ff 90       	pop	r15
    1862:	ef 90       	pop	r14
    1864:	df 90       	pop	r13
    1866:	cf 90       	pop	r12
    1868:	08 95       	ret

0000186a <xTaskResumeAll>:
    186a:	df 92       	push	r13
    186c:	ef 92       	push	r14
    186e:	ff 92       	push	r15
    1870:	0f 93       	push	r16
    1872:	1f 93       	push	r17
    1874:	cf 93       	push	r28
    1876:	df 93       	push	r29
    1878:	0f b6       	in	r0, 0x3f	; 63
    187a:	f8 94       	cli
    187c:	0f 92       	push	r0
    187e:	80 91 3d 0d 	lds	r24, 0x0D3D
    1882:	81 50       	subi	r24, 0x01	; 1
    1884:	80 93 3d 0d 	sts	0x0D3D, r24
    1888:	80 91 3d 0d 	lds	r24, 0x0D3D
    188c:	81 11       	cpse	r24, r1
    188e:	5c c0       	rjmp	.+184    	; 0x1948 <xTaskResumeAll+0xde>
    1890:	80 91 46 0d 	lds	r24, 0x0D46
    1894:	88 23       	and	r24, r24
    1896:	09 f4       	brne	.+2      	; 0x189a <xTaskResumeAll+0x30>
    1898:	59 c0       	rjmp	.+178    	; 0x194c <xTaskResumeAll+0xe2>
    189a:	0f 2e       	mov	r0, r31
    189c:	f1 e5       	ldi	r31, 0x51	; 81
    189e:	ef 2e       	mov	r14, r31
    18a0:	fd e0       	ldi	r31, 0x0D	; 13
    18a2:	ff 2e       	mov	r15, r31
    18a4:	f0 2d       	mov	r31, r0
    18a6:	dd 24       	eor	r13, r13
    18a8:	d3 94       	inc	r13
    18aa:	2d c0       	rjmp	.+90     	; 0x1906 <xTaskResumeAll+0x9c>
    18ac:	e0 91 56 0d 	lds	r30, 0x0D56
    18b0:	f0 91 57 0d 	lds	r31, 0x0D57
    18b4:	c6 81       	ldd	r28, Z+6	; 0x06
    18b6:	d7 81       	ldd	r29, Z+7	; 0x07
    18b8:	ce 01       	movw	r24, r28
    18ba:	0c 96       	adiw	r24, 0x0c	; 12
    18bc:	d4 d8       	rcall	.-3672   	; 0xa66 <uxListRemove>
    18be:	8e 01       	movw	r16, r28
    18c0:	0e 5f       	subi	r16, 0xFE	; 254
    18c2:	1f 4f       	sbci	r17, 0xFF	; 255
    18c4:	c8 01       	movw	r24, r16
    18c6:	cf d8       	rcall	.-3682   	; 0xa66 <uxListRemove>
    18c8:	8e 89       	ldd	r24, Y+22	; 0x16
    18ca:	90 91 43 0d 	lds	r25, 0x0D43
    18ce:	98 17       	cp	r25, r24
    18d0:	10 f4       	brcc	.+4      	; 0x18d6 <xTaskResumeAll+0x6c>
    18d2:	80 93 43 0d 	sts	0x0D43, r24
    18d6:	90 e0       	ldi	r25, 0x00	; 0
    18d8:	9c 01       	movw	r18, r24
    18da:	22 0f       	add	r18, r18
    18dc:	33 1f       	adc	r19, r19
    18de:	22 0f       	add	r18, r18
    18e0:	33 1f       	adc	r19, r19
    18e2:	22 0f       	add	r18, r18
    18e4:	33 1f       	adc	r19, r19
    18e6:	82 0f       	add	r24, r18
    18e8:	93 1f       	adc	r25, r19
    18ea:	b8 01       	movw	r22, r16
    18ec:	80 59       	subi	r24, 0x90	; 144
    18ee:	92 4f       	sbci	r25, 0xF2	; 242
    18f0:	68 d8       	rcall	.-3888   	; 0x9c2 <vListInsertEnd>
    18f2:	e0 91 94 0d 	lds	r30, 0x0D94
    18f6:	f0 91 95 0d 	lds	r31, 0x0D95
    18fa:	9e 89       	ldd	r25, Y+22	; 0x16
    18fc:	86 89       	ldd	r24, Z+22	; 0x16
    18fe:	98 17       	cp	r25, r24
    1900:	10 f0       	brcs	.+4      	; 0x1906 <xTaskResumeAll+0x9c>
    1902:	d0 92 40 0d 	sts	0x0D40, r13
    1906:	f7 01       	movw	r30, r14
    1908:	80 81       	ld	r24, Z
    190a:	81 11       	cpse	r24, r1
    190c:	cf cf       	rjmp	.-98     	; 0x18ac <xTaskResumeAll+0x42>
    190e:	80 91 41 0d 	lds	r24, 0x0D41
    1912:	88 23       	and	r24, r24
    1914:	91 f0       	breq	.+36     	; 0x193a <xTaskResumeAll+0xd0>
    1916:	80 91 41 0d 	lds	r24, 0x0D41
    191a:	88 23       	and	r24, r24
    191c:	71 f0       	breq	.+28     	; 0x193a <xTaskResumeAll+0xd0>
    191e:	c1 e0       	ldi	r28, 0x01	; 1
    1920:	e9 de       	rcall	.-558    	; 0x16f4 <xTaskIncrementTick>
    1922:	81 11       	cpse	r24, r1
    1924:	c0 93 40 0d 	sts	0x0D40, r28
    1928:	80 91 41 0d 	lds	r24, 0x0D41
    192c:	81 50       	subi	r24, 0x01	; 1
    192e:	80 93 41 0d 	sts	0x0D41, r24
    1932:	80 91 41 0d 	lds	r24, 0x0D41
    1936:	81 11       	cpse	r24, r1
    1938:	f3 cf       	rjmp	.-26     	; 0x1920 <xTaskResumeAll+0xb6>
    193a:	80 91 40 0d 	lds	r24, 0x0D40
    193e:	81 30       	cpi	r24, 0x01	; 1
    1940:	39 f4       	brne	.+14     	; 0x1950 <xTaskResumeAll+0xe6>
    1942:	97 dc       	rcall	.-1746   	; 0x1272 <vPortYield>
    1944:	81 e0       	ldi	r24, 0x01	; 1
    1946:	05 c0       	rjmp	.+10     	; 0x1952 <xTaskResumeAll+0xe8>
    1948:	80 e0       	ldi	r24, 0x00	; 0
    194a:	03 c0       	rjmp	.+6      	; 0x1952 <xTaskResumeAll+0xe8>
    194c:	80 e0       	ldi	r24, 0x00	; 0
    194e:	01 c0       	rjmp	.+2      	; 0x1952 <xTaskResumeAll+0xe8>
    1950:	80 e0       	ldi	r24, 0x00	; 0
    1952:	0f 90       	pop	r0
    1954:	0f be       	out	0x3f, r0	; 63
    1956:	df 91       	pop	r29
    1958:	cf 91       	pop	r28
    195a:	1f 91       	pop	r17
    195c:	0f 91       	pop	r16
    195e:	ff 90       	pop	r15
    1960:	ef 90       	pop	r14
    1962:	df 90       	pop	r13
    1964:	08 95       	ret

00001966 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    1966:	cf 93       	push	r28
    1968:	df 93       	push	r29
    196a:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    196c:	00 97       	sbiw	r24, 0x00	; 0
    196e:	91 f0       	breq	.+36     	; 0x1994 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    1970:	bb de       	rcall	.-650    	; 0x16e8 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1972:	80 91 44 0d 	lds	r24, 0x0D44
    1976:	90 91 45 0d 	lds	r25, 0x0D45
    197a:	c8 0f       	add	r28, r24
    197c:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    197e:	80 91 94 0d 	lds	r24, 0x0D94
    1982:	90 91 95 0d 	lds	r25, 0x0D95
    1986:	02 96       	adiw	r24, 0x02	; 2
    1988:	6e d8       	rcall	.-3876   	; 0xa66 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    198a:	ce 01       	movw	r24, r28
    198c:	55 dd       	rcall	.-1366   	; 0x1438 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    198e:	6d df       	rcall	.-294    	; 0x186a <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1990:	81 11       	cpse	r24, r1
    1992:	01 c0       	rjmp	.+2      	; 0x1996 <vTaskDelay+0x30>
		{
			portYIELD_WITHIN_API();
    1994:	6e dc       	rcall	.-1828   	; 0x1272 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1996:	df 91       	pop	r29
    1998:	cf 91       	pop	r28
    199a:	08 95       	ret

0000199c <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    199c:	0f 2e       	mov	r0, r31
    199e:	f0 e7       	ldi	r31, 0x70	; 112
    19a0:	ef 2e       	mov	r14, r31
    19a2:	fd e0       	ldi	r31, 0x0D	; 13
    19a4:	ff 2e       	mov	r15, r31
    19a6:	f0 2d       	mov	r31, r0
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    19a8:	c8 e4       	ldi	r28, 0x48	; 72
    19aa:	dd e0       	ldi	r29, 0x0D	; 13
    19ac:	25 c0       	rjmp	.+74     	; 0x19f8 <prvIdleTask+0x5c>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    19ae:	9c de       	rcall	.-712    	; 0x16e8 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    19b0:	18 81       	ld	r17, Y
			}
			( void ) xTaskResumeAll();
    19b2:	5b df       	rcall	.-330    	; 0x186a <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    19b4:	11 23       	and	r17, r17
    19b6:	01 f1       	breq	.+64     	; 0x19f8 <prvIdleTask+0x5c>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    19b8:	0f b6       	in	r0, 0x3f	; 63
    19ba:	f8 94       	cli
    19bc:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    19be:	e0 91 4d 0d 	lds	r30, 0x0D4D
    19c2:	f0 91 4e 0d 	lds	r31, 0x0D4E
    19c6:	06 81       	ldd	r16, Z+6	; 0x06
    19c8:	17 81       	ldd	r17, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    19ca:	c8 01       	movw	r24, r16
    19cc:	02 96       	adiw	r24, 0x02	; 2
    19ce:	4b d8       	rcall	.-3946   	; 0xa66 <uxListRemove>
					--uxCurrentNumberOfTasks;
    19d0:	80 91 46 0d 	lds	r24, 0x0D46
    19d4:	81 50       	subi	r24, 0x01	; 1
    19d6:	80 93 46 0d 	sts	0x0D46, r24
					--uxTasksDeleted;
    19da:	80 91 47 0d 	lds	r24, 0x0D47
    19de:	81 50       	subi	r24, 0x01	; 1
    19e0:	80 93 47 0d 	sts	0x0D47, r24
				}
				taskEXIT_CRITICAL();
    19e4:	0f 90       	pop	r0
    19e6:	0f be       	out	0x3f, r0	; 63
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
		vPortFreeAligned( pxTCB->pxStack );
    19e8:	f8 01       	movw	r30, r16
    19ea:	87 89       	ldd	r24, Z+23	; 0x17
    19ec:	90 8d       	ldd	r25, Z+24	; 0x18
    19ee:	0e 94 60 03 	call	0x6c0	; 0x6c0 <vPortFree>
		vPortFree( pxTCB );
    19f2:	c8 01       	movw	r24, r16
    19f4:	0e 94 60 03 	call	0x6c0	; 0x6c0 <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    19f8:	80 91 47 0d 	lds	r24, 0x0D47
    19fc:	81 11       	cpse	r24, r1
    19fe:	d7 cf       	rjmp	.-82     	; 0x19ae <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    1a00:	f7 01       	movw	r30, r14
    1a02:	80 81       	ld	r24, Z
    1a04:	82 30       	cpi	r24, 0x02	; 2
    1a06:	c0 f3       	brcs	.-16     	; 0x19f8 <prvIdleTask+0x5c>
			{
				taskYIELD();
    1a08:	34 dc       	rcall	.-1944   	; 0x1272 <vPortYield>
    1a0a:	f6 cf       	rjmp	.-20     	; 0x19f8 <prvIdleTask+0x5c>

00001a0c <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    1a0c:	80 91 3d 0d 	lds	r24, 0x0D3D
    1a10:	88 23       	and	r24, r24
    1a12:	21 f0       	breq	.+8      	; 0x1a1c <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    1a14:	81 e0       	ldi	r24, 0x01	; 1
    1a16:	80 93 40 0d 	sts	0x0D40, r24
    1a1a:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    1a1c:	10 92 40 0d 	sts	0x0D40, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    1a20:	80 91 43 0d 	lds	r24, 0x0D43
    1a24:	90 e0       	ldi	r25, 0x00	; 0
    1a26:	fc 01       	movw	r30, r24
    1a28:	ee 0f       	add	r30, r30
    1a2a:	ff 1f       	adc	r31, r31
    1a2c:	ee 0f       	add	r30, r30
    1a2e:	ff 1f       	adc	r31, r31
    1a30:	ee 0f       	add	r30, r30
    1a32:	ff 1f       	adc	r31, r31
    1a34:	8e 0f       	add	r24, r30
    1a36:	9f 1f       	adc	r25, r31
    1a38:	fc 01       	movw	r30, r24
    1a3a:	e0 59       	subi	r30, 0x90	; 144
    1a3c:	f2 4f       	sbci	r31, 0xF2	; 242
    1a3e:	80 81       	ld	r24, Z
    1a40:	81 11       	cpse	r24, r1
    1a42:	17 c0       	rjmp	.+46     	; 0x1a72 <vTaskSwitchContext+0x66>
    1a44:	80 91 43 0d 	lds	r24, 0x0D43
    1a48:	81 50       	subi	r24, 0x01	; 1
    1a4a:	80 93 43 0d 	sts	0x0D43, r24
    1a4e:	80 91 43 0d 	lds	r24, 0x0D43
    1a52:	90 e0       	ldi	r25, 0x00	; 0
    1a54:	fc 01       	movw	r30, r24
    1a56:	ee 0f       	add	r30, r30
    1a58:	ff 1f       	adc	r31, r31
    1a5a:	ee 0f       	add	r30, r30
    1a5c:	ff 1f       	adc	r31, r31
    1a5e:	ee 0f       	add	r30, r30
    1a60:	ff 1f       	adc	r31, r31
    1a62:	8e 0f       	add	r24, r30
    1a64:	9f 1f       	adc	r25, r31
    1a66:	fc 01       	movw	r30, r24
    1a68:	e0 59       	subi	r30, 0x90	; 144
    1a6a:	f2 4f       	sbci	r31, 0xF2	; 242
    1a6c:	80 81       	ld	r24, Z
    1a6e:	88 23       	and	r24, r24
    1a70:	49 f3       	breq	.-46     	; 0x1a44 <vTaskSwitchContext+0x38>
    1a72:	e0 91 43 0d 	lds	r30, 0x0D43
    1a76:	f0 e0       	ldi	r31, 0x00	; 0
    1a78:	cf 01       	movw	r24, r30
    1a7a:	88 0f       	add	r24, r24
    1a7c:	99 1f       	adc	r25, r25
    1a7e:	88 0f       	add	r24, r24
    1a80:	99 1f       	adc	r25, r25
    1a82:	88 0f       	add	r24, r24
    1a84:	99 1f       	adc	r25, r25
    1a86:	e8 0f       	add	r30, r24
    1a88:	f9 1f       	adc	r31, r25
    1a8a:	e0 59       	subi	r30, 0x90	; 144
    1a8c:	f2 4f       	sbci	r31, 0xF2	; 242
    1a8e:	a1 81       	ldd	r26, Z+1	; 0x01
    1a90:	b2 81       	ldd	r27, Z+2	; 0x02
    1a92:	12 96       	adiw	r26, 0x02	; 2
    1a94:	0d 90       	ld	r0, X+
    1a96:	bc 91       	ld	r27, X
    1a98:	a0 2d       	mov	r26, r0
    1a9a:	b2 83       	std	Z+2, r27	; 0x02
    1a9c:	a1 83       	std	Z+1, r26	; 0x01
    1a9e:	cf 01       	movw	r24, r30
    1aa0:	03 96       	adiw	r24, 0x03	; 3
    1aa2:	a8 17       	cp	r26, r24
    1aa4:	b9 07       	cpc	r27, r25
    1aa6:	31 f4       	brne	.+12     	; 0x1ab4 <vTaskSwitchContext+0xa8>
    1aa8:	12 96       	adiw	r26, 0x02	; 2
    1aaa:	8d 91       	ld	r24, X+
    1aac:	9c 91       	ld	r25, X
    1aae:	13 97       	sbiw	r26, 0x03	; 3
    1ab0:	92 83       	std	Z+2, r25	; 0x02
    1ab2:	81 83       	std	Z+1, r24	; 0x01
    1ab4:	01 80       	ldd	r0, Z+1	; 0x01
    1ab6:	f2 81       	ldd	r31, Z+2	; 0x02
    1ab8:	e0 2d       	mov	r30, r0
    1aba:	86 81       	ldd	r24, Z+6	; 0x06
    1abc:	97 81       	ldd	r25, Z+7	; 0x07
    1abe:	90 93 95 0d 	sts	0x0D95, r25
    1ac2:	80 93 94 0d 	sts	0x0D94, r24
    1ac6:	08 95       	ret

00001ac8 <twi_init>:
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    1ac8:	10 92 03 0e 	sts	0x0E03, r1
    1acc:	81 e0       	ldi	r24, 0x01	; 1
    1ace:	80 93 01 0e 	sts	0x0E01, r24
    1ad2:	10 92 00 0e 	sts	0x0E00, r1
    1ad6:	61 e0       	ldi	r22, 0x01	; 1
    1ad8:	84 e1       	ldi	r24, 0x14	; 20
    1ada:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <digitalWrite>
    1ade:	61 e0       	ldi	r22, 0x01	; 1
    1ae0:	85 e1       	ldi	r24, 0x15	; 21
    1ae2:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <digitalWrite>
    1ae6:	e9 eb       	ldi	r30, 0xB9	; 185
    1ae8:	f0 e0       	ldi	r31, 0x00	; 0
    1aea:	80 81       	ld	r24, Z
    1aec:	8e 7f       	andi	r24, 0xFE	; 254
    1aee:	80 83       	st	Z, r24
    1af0:	80 81       	ld	r24, Z
    1af2:	8d 7f       	andi	r24, 0xFD	; 253
    1af4:	80 83       	st	Z, r24
    1af6:	88 e4       	ldi	r24, 0x48	; 72
    1af8:	80 93 b8 00 	sts	0x00B8, r24
    1afc:	85 e4       	ldi	r24, 0x45	; 69
    1afe:	80 93 bc 00 	sts	0x00BC, r24
    1b02:	08 95       	ret

00001b04 <twi_readFrom>:
    1b04:	41 32       	cpi	r20, 0x21	; 33
    1b06:	08 f0       	brcs	.+2      	; 0x1b0a <twi_readFrom+0x6>
    1b08:	45 c0       	rjmp	.+138    	; 0x1b94 <twi_readFrom+0x90>
    1b0a:	90 91 03 0e 	lds	r25, 0x0E03
    1b0e:	91 11       	cpse	r25, r1
    1b10:	fc cf       	rjmp	.-8      	; 0x1b0a <twi_readFrom+0x6>
    1b12:	91 e0       	ldi	r25, 0x01	; 1
    1b14:	90 93 03 0e 	sts	0x0E03, r25
    1b18:	20 93 01 0e 	sts	0x0E01, r18
    1b1c:	2f ef       	ldi	r18, 0xFF	; 255
    1b1e:	20 93 96 0d 	sts	0x0D96, r18
    1b22:	10 92 db 0d 	sts	0x0DDB, r1
    1b26:	24 0f       	add	r18, r20
    1b28:	20 93 da 0d 	sts	0x0DDA, r18
    1b2c:	90 93 02 0e 	sts	0x0E02, r25
    1b30:	90 91 02 0e 	lds	r25, 0x0E02
    1b34:	88 0f       	add	r24, r24
    1b36:	89 2b       	or	r24, r25
    1b38:	80 93 02 0e 	sts	0x0E02, r24
    1b3c:	80 91 00 0e 	lds	r24, 0x0E00
    1b40:	81 30       	cpi	r24, 0x01	; 1
    1b42:	51 f4       	brne	.+20     	; 0x1b58 <twi_readFrom+0x54>
    1b44:	10 92 00 0e 	sts	0x0E00, r1
    1b48:	80 91 02 0e 	lds	r24, 0x0E02
    1b4c:	80 93 bb 00 	sts	0x00BB, r24
    1b50:	85 ec       	ldi	r24, 0xC5	; 197
    1b52:	80 93 bc 00 	sts	0x00BC, r24
    1b56:	03 c0       	rjmp	.+6      	; 0x1b5e <twi_readFrom+0x5a>
    1b58:	85 ee       	ldi	r24, 0xE5	; 229
    1b5a:	80 93 bc 00 	sts	0x00BC, r24
    1b5e:	80 91 03 0e 	lds	r24, 0x0E03
    1b62:	81 30       	cpi	r24, 0x01	; 1
    1b64:	e1 f3       	breq	.-8      	; 0x1b5e <twi_readFrom+0x5a>
    1b66:	80 91 db 0d 	lds	r24, 0x0DDB
    1b6a:	84 17       	cp	r24, r20
    1b6c:	10 f4       	brcc	.+4      	; 0x1b72 <twi_readFrom+0x6e>
    1b6e:	40 91 db 0d 	lds	r20, 0x0DDB
    1b72:	44 23       	and	r20, r20
    1b74:	89 f0       	breq	.+34     	; 0x1b98 <twi_readFrom+0x94>
    1b76:	ec ed       	ldi	r30, 0xDC	; 220
    1b78:	fd e0       	ldi	r31, 0x0D	; 13
    1b7a:	a6 2f       	mov	r26, r22
    1b7c:	b7 2f       	mov	r27, r23
    1b7e:	2f ef       	ldi	r18, 0xFF	; 255
    1b80:	24 0f       	add	r18, r20
    1b82:	30 e0       	ldi	r19, 0x00	; 0
    1b84:	23 52       	subi	r18, 0x23	; 35
    1b86:	32 4f       	sbci	r19, 0xF2	; 242
    1b88:	91 91       	ld	r25, Z+
    1b8a:	9d 93       	st	X+, r25
    1b8c:	e2 17       	cp	r30, r18
    1b8e:	f3 07       	cpc	r31, r19
    1b90:	d9 f7       	brne	.-10     	; 0x1b88 <twi_readFrom+0x84>
    1b92:	04 c0       	rjmp	.+8      	; 0x1b9c <twi_readFrom+0x98>
    1b94:	80 e0       	ldi	r24, 0x00	; 0
    1b96:	08 95       	ret
    1b98:	84 2f       	mov	r24, r20
    1b9a:	08 95       	ret
    1b9c:	84 2f       	mov	r24, r20
    1b9e:	08 95       	ret

00001ba0 <twi_writeTo>:
    1ba0:	0f 93       	push	r16
    1ba2:	41 32       	cpi	r20, 0x21	; 33
    1ba4:	08 f0       	brcs	.+2      	; 0x1ba8 <twi_writeTo+0x8>
    1ba6:	50 c0       	rjmp	.+160    	; 0x1c48 <twi_writeTo+0xa8>
    1ba8:	90 91 03 0e 	lds	r25, 0x0E03
    1bac:	91 11       	cpse	r25, r1
    1bae:	fc cf       	rjmp	.-8      	; 0x1ba8 <twi_writeTo+0x8>
    1bb0:	92 e0       	ldi	r25, 0x02	; 2
    1bb2:	90 93 03 0e 	sts	0x0E03, r25
    1bb6:	00 93 01 0e 	sts	0x0E01, r16
    1bba:	9f ef       	ldi	r25, 0xFF	; 255
    1bbc:	90 93 96 0d 	sts	0x0D96, r25
    1bc0:	10 92 db 0d 	sts	0x0DDB, r1
    1bc4:	40 93 da 0d 	sts	0x0DDA, r20
    1bc8:	44 23       	and	r20, r20
    1bca:	69 f0       	breq	.+26     	; 0x1be6 <twi_writeTo+0x46>
    1bcc:	fb 01       	movw	r30, r22
    1bce:	ac ed       	ldi	r26, 0xDC	; 220
    1bd0:	bd e0       	ldi	r27, 0x0D	; 13
    1bd2:	6f 5f       	subi	r22, 0xFF	; 255
    1bd4:	7f 4f       	sbci	r23, 0xFF	; 255
    1bd6:	41 50       	subi	r20, 0x01	; 1
    1bd8:	64 0f       	add	r22, r20
    1bda:	71 1d       	adc	r23, r1
    1bdc:	91 91       	ld	r25, Z+
    1bde:	9d 93       	st	X+, r25
    1be0:	e6 17       	cp	r30, r22
    1be2:	f7 07       	cpc	r31, r23
    1be4:	d9 f7       	brne	.-10     	; 0x1bdc <twi_writeTo+0x3c>
    1be6:	10 92 02 0e 	sts	0x0E02, r1
    1bea:	90 91 02 0e 	lds	r25, 0x0E02
    1bee:	88 0f       	add	r24, r24
    1bf0:	89 2b       	or	r24, r25
    1bf2:	80 93 02 0e 	sts	0x0E02, r24
    1bf6:	80 91 00 0e 	lds	r24, 0x0E00
    1bfa:	81 30       	cpi	r24, 0x01	; 1
    1bfc:	51 f4       	brne	.+20     	; 0x1c12 <twi_writeTo+0x72>
    1bfe:	10 92 00 0e 	sts	0x0E00, r1
    1c02:	80 91 02 0e 	lds	r24, 0x0E02
    1c06:	80 93 bb 00 	sts	0x00BB, r24
    1c0a:	85 ec       	ldi	r24, 0xC5	; 197
    1c0c:	80 93 bc 00 	sts	0x00BC, r24
    1c10:	03 c0       	rjmp	.+6      	; 0x1c18 <twi_writeTo+0x78>
    1c12:	85 ee       	ldi	r24, 0xE5	; 229
    1c14:	80 93 bc 00 	sts	0x00BC, r24
    1c18:	22 23       	and	r18, r18
    1c1a:	41 f0       	breq	.+16     	; 0x1c2c <twi_writeTo+0x8c>
    1c1c:	80 91 03 0e 	lds	r24, 0x0E03
    1c20:	82 30       	cpi	r24, 0x02	; 2
    1c22:	21 f4       	brne	.+8      	; 0x1c2c <twi_writeTo+0x8c>
    1c24:	80 91 03 0e 	lds	r24, 0x0E03
    1c28:	82 30       	cpi	r24, 0x02	; 2
    1c2a:	e1 f3       	breq	.-8      	; 0x1c24 <twi_writeTo+0x84>
    1c2c:	80 91 96 0d 	lds	r24, 0x0D96
    1c30:	8f 3f       	cpi	r24, 0xFF	; 255
    1c32:	61 f0       	breq	.+24     	; 0x1c4c <twi_writeTo+0xac>
    1c34:	80 91 96 0d 	lds	r24, 0x0D96
    1c38:	80 32       	cpi	r24, 0x20	; 32
    1c3a:	51 f0       	breq	.+20     	; 0x1c50 <twi_writeTo+0xb0>
    1c3c:	80 91 96 0d 	lds	r24, 0x0D96
    1c40:	80 33       	cpi	r24, 0x30	; 48
    1c42:	41 f4       	brne	.+16     	; 0x1c54 <twi_writeTo+0xb4>
    1c44:	83 e0       	ldi	r24, 0x03	; 3
    1c46:	07 c0       	rjmp	.+14     	; 0x1c56 <twi_writeTo+0xb6>
    1c48:	81 e0       	ldi	r24, 0x01	; 1
    1c4a:	05 c0       	rjmp	.+10     	; 0x1c56 <twi_writeTo+0xb6>
    1c4c:	80 e0       	ldi	r24, 0x00	; 0
    1c4e:	03 c0       	rjmp	.+6      	; 0x1c56 <twi_writeTo+0xb6>
    1c50:	82 e0       	ldi	r24, 0x02	; 2
    1c52:	01 c0       	rjmp	.+2      	; 0x1c56 <twi_writeTo+0xb6>
    1c54:	84 e0       	ldi	r24, 0x04	; 4
    1c56:	0f 91       	pop	r16
    1c58:	08 95       	ret

00001c5a <twi_transmit>:
    1c5a:	61 32       	cpi	r22, 0x21	; 33
    1c5c:	a8 f4       	brcc	.+42     	; 0x1c88 <twi_transmit+0x2e>
    1c5e:	20 91 03 0e 	lds	r18, 0x0E03
    1c62:	24 30       	cpi	r18, 0x04	; 4
    1c64:	99 f4       	brne	.+38     	; 0x1c8c <twi_transmit+0x32>
    1c66:	60 93 b8 0d 	sts	0x0DB8, r22
    1c6a:	66 23       	and	r22, r22
    1c6c:	89 f0       	breq	.+34     	; 0x1c90 <twi_transmit+0x36>
    1c6e:	fc 01       	movw	r30, r24
    1c70:	aa eb       	ldi	r26, 0xBA	; 186
    1c72:	bd e0       	ldi	r27, 0x0D	; 13
    1c74:	01 96       	adiw	r24, 0x01	; 1
    1c76:	61 50       	subi	r22, 0x01	; 1
    1c78:	86 0f       	add	r24, r22
    1c7a:	91 1d       	adc	r25, r1
    1c7c:	21 91       	ld	r18, Z+
    1c7e:	2d 93       	st	X+, r18
    1c80:	e8 17       	cp	r30, r24
    1c82:	f9 07       	cpc	r31, r25
    1c84:	d9 f7       	brne	.-10     	; 0x1c7c <twi_transmit+0x22>
    1c86:	06 c0       	rjmp	.+12     	; 0x1c94 <twi_transmit+0x3a>
    1c88:	81 e0       	ldi	r24, 0x01	; 1
    1c8a:	08 95       	ret
    1c8c:	82 e0       	ldi	r24, 0x02	; 2
    1c8e:	08 95       	ret
    1c90:	80 e0       	ldi	r24, 0x00	; 0
    1c92:	08 95       	ret
    1c94:	80 e0       	ldi	r24, 0x00	; 0
    1c96:	08 95       	ret

00001c98 <twi_stop>:
 * Output   none
 */
void twi_stop(void)
{
  // send stop condition
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);
    1c98:	85 ed       	ldi	r24, 0xD5	; 213
    1c9a:	80 93 bc 00 	sts	0x00BC, r24

  // wait for stop condition to be exectued on bus
  // TWINT is not set after a stop condition!
  while(TWCR & _BV(TWSTO)){
    1c9e:	ec eb       	ldi	r30, 0xBC	; 188
    1ca0:	f0 e0       	ldi	r31, 0x00	; 0
    1ca2:	80 81       	ld	r24, Z
    1ca4:	84 fd       	sbrc	r24, 4
    1ca6:	fd cf       	rjmp	.-6      	; 0x1ca2 <twi_stop+0xa>
    continue;
  }

  // update twi state
  twi_state = TWI_READY;
    1ca8:	10 92 03 0e 	sts	0x0E03, r1
    1cac:	08 95       	ret

00001cae <twi_releaseBus>:
 * Output   none
 */
void twi_releaseBus(void)
{
  // release bus
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);
    1cae:	85 ec       	ldi	r24, 0xC5	; 197
    1cb0:	80 93 bc 00 	sts	0x00BC, r24

  // update twi state
  twi_state = TWI_READY;
    1cb4:	10 92 03 0e 	sts	0x0E03, r1
    1cb8:	08 95       	ret

00001cba <__vector_39>:
}

ISR(TWI_vect)
{
    1cba:	1f 92       	push	r1
    1cbc:	0f 92       	push	r0
    1cbe:	0f b6       	in	r0, 0x3f	; 63
    1cc0:	0f 92       	push	r0
    1cc2:	11 24       	eor	r1, r1
    1cc4:	0b b6       	in	r0, 0x3b	; 59
    1cc6:	0f 92       	push	r0
    1cc8:	2f 93       	push	r18
    1cca:	3f 93       	push	r19
    1ccc:	4f 93       	push	r20
    1cce:	5f 93       	push	r21
    1cd0:	6f 93       	push	r22
    1cd2:	7f 93       	push	r23
    1cd4:	8f 93       	push	r24
    1cd6:	9f 93       	push	r25
    1cd8:	af 93       	push	r26
    1cda:	bf 93       	push	r27
    1cdc:	ef 93       	push	r30
    1cde:	ff 93       	push	r31
  switch(TW_STATUS){
    1ce0:	80 91 b9 00 	lds	r24, 0x00B9
    1ce4:	88 7f       	andi	r24, 0xF8	; 248
    1ce6:	90 e0       	ldi	r25, 0x00	; 0
    1ce8:	89 3c       	cpi	r24, 0xC9	; 201
    1cea:	91 05       	cpc	r25, r1
    1cec:	08 f0       	brcs	.+2      	; 0x1cf0 <__vector_39+0x36>
    1cee:	ee c0       	rjmp	.+476    	; 0x1ecc <__vector_39+0x212>
    1cf0:	fc 01       	movw	r30, r24
    1cf2:	ee 58       	subi	r30, 0x8E	; 142
    1cf4:	ff 4f       	sbci	r31, 0xFF	; 255
    1cf6:	0c 94 f0 17 	jmp	0x2fe0	; 0x2fe0 <__tablejump2__>
    // All Master
    case TW_START:     // sent start condition
    case TW_REP_START: // sent repeated start condition
      // copy device address and r/w bit to output register and ack
      TWDR = twi_slarw;
    1cfa:	80 91 02 0e 	lds	r24, 0x0E02
    1cfe:	80 93 bb 00 	sts	0x00BB, r24
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    1d02:	85 ec       	ldi	r24, 0xC5	; 197
    1d04:	80 93 bc 00 	sts	0x00BC, r24
    1d08:	e1 c0       	rjmp	.+450    	; 0x1ecc <__vector_39+0x212>

    // Master Transmitter
    case TW_MT_SLA_ACK:  // slave receiver acked address
    case TW_MT_DATA_ACK: // slave receiver acked data
      // if there is data to send, send it, otherwise stop 
      if(twi_masterBufferIndex < twi_masterBufferLength){
    1d0a:	90 91 db 0d 	lds	r25, 0x0DDB
    1d0e:	80 91 da 0d 	lds	r24, 0x0DDA
    1d12:	98 17       	cp	r25, r24
    1d14:	80 f4       	brcc	.+32     	; 0x1d36 <__vector_39+0x7c>
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
    1d16:	e0 91 db 0d 	lds	r30, 0x0DDB
    1d1a:	81 e0       	ldi	r24, 0x01	; 1
    1d1c:	8e 0f       	add	r24, r30
    1d1e:	80 93 db 0d 	sts	0x0DDB, r24
    1d22:	f0 e0       	ldi	r31, 0x00	; 0
    1d24:	e4 52       	subi	r30, 0x24	; 36
    1d26:	f2 4f       	sbci	r31, 0xF2	; 242
    1d28:	80 81       	ld	r24, Z
    1d2a:	80 93 bb 00 	sts	0x00BB, r24
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    1d2e:	85 ec       	ldi	r24, 0xC5	; 197
    1d30:	80 93 bc 00 	sts	0x00BC, r24
    1d34:	cb c0       	rjmp	.+406    	; 0x1ecc <__vector_39+0x212>
      if(twi_masterBufferIndex < twi_masterBufferLength){
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
        twi_reply(1);
      }else{
	if (twi_sendStop)
    1d36:	80 91 01 0e 	lds	r24, 0x0E01
    1d3a:	88 23       	and	r24, r24
    1d3c:	11 f0       	breq	.+4      	; 0x1d42 <__vector_39+0x88>
          twi_stop();
    1d3e:	ac df       	rcall	.-168    	; 0x1c98 <twi_stop>
    1d40:	c5 c0       	rjmp	.+394    	; 0x1ecc <__vector_39+0x212>
	else {
	  twi_inRepStart = true;	// we're gonna send the START
    1d42:	81 e0       	ldi	r24, 0x01	; 1
    1d44:	80 93 00 0e 	sts	0x0E00, r24
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
    1d48:	84 ea       	ldi	r24, 0xA4	; 164
    1d4a:	80 93 bc 00 	sts	0x00BC, r24
	  twi_state = TWI_READY;
    1d4e:	10 92 03 0e 	sts	0x0E03, r1
    1d52:	bc c0       	rjmp	.+376    	; 0x1ecc <__vector_39+0x212>
	}
      }
      break;
    case TW_MT_SLA_NACK:  // address sent, nack received
      twi_error = TW_MT_SLA_NACK;
    1d54:	80 e2       	ldi	r24, 0x20	; 32
    1d56:	80 93 96 0d 	sts	0x0D96, r24
      twi_stop();
    1d5a:	9e df       	rcall	.-196    	; 0x1c98 <twi_stop>
      break;
    1d5c:	b7 c0       	rjmp	.+366    	; 0x1ecc <__vector_39+0x212>
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
    1d5e:	80 e3       	ldi	r24, 0x30	; 48
    1d60:	80 93 96 0d 	sts	0x0D96, r24
      twi_stop();
    1d64:	99 df       	rcall	.-206    	; 0x1c98 <twi_stop>
      break;
    1d66:	b2 c0       	rjmp	.+356    	; 0x1ecc <__vector_39+0x212>
    case TW_MT_ARB_LOST: // lost bus arbitration
      twi_error = TW_MT_ARB_LOST;
    1d68:	88 e3       	ldi	r24, 0x38	; 56
    1d6a:	80 93 96 0d 	sts	0x0D96, r24
      twi_releaseBus();
    1d6e:	9f df       	rcall	.-194    	; 0x1cae <twi_releaseBus>
      break;
    1d70:	ad c0       	rjmp	.+346    	; 0x1ecc <__vector_39+0x212>

    // Master Receiver
    case TW_MR_DATA_ACK: // data received, ack sent
      // put byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
    1d72:	e0 91 db 0d 	lds	r30, 0x0DDB
    1d76:	81 e0       	ldi	r24, 0x01	; 1
    1d78:	8e 0f       	add	r24, r30
    1d7a:	80 93 db 0d 	sts	0x0DDB, r24
    1d7e:	80 91 bb 00 	lds	r24, 0x00BB
    1d82:	f0 e0       	ldi	r31, 0x00	; 0
    1d84:	e4 52       	subi	r30, 0x24	; 36
    1d86:	f2 4f       	sbci	r31, 0xF2	; 242
    1d88:	80 83       	st	Z, r24
    case TW_MR_SLA_ACK:  // address sent, ack received
      // ack if more bytes are expected, otherwise nack
      if(twi_masterBufferIndex < twi_masterBufferLength){
    1d8a:	90 91 db 0d 	lds	r25, 0x0DDB
    1d8e:	80 91 da 0d 	lds	r24, 0x0DDA
    1d92:	98 17       	cp	r25, r24
    1d94:	20 f4       	brcc	.+8      	; 0x1d9e <__vector_39+0xe4>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    1d96:	85 ec       	ldi	r24, 0xC5	; 197
    1d98:	80 93 bc 00 	sts	0x00BC, r24
    1d9c:	97 c0       	rjmp	.+302    	; 0x1ecc <__vector_39+0x212>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    1d9e:	85 e8       	ldi	r24, 0x85	; 133
    1da0:	80 93 bc 00 	sts	0x00BC, r24
    1da4:	93 c0       	rjmp	.+294    	; 0x1ecc <__vector_39+0x212>
        twi_reply(0);
      }
      break;
    case TW_MR_DATA_NACK: // data received, nack sent
      // put final byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
    1da6:	e0 91 db 0d 	lds	r30, 0x0DDB
    1daa:	81 e0       	ldi	r24, 0x01	; 1
    1dac:	8e 0f       	add	r24, r30
    1dae:	80 93 db 0d 	sts	0x0DDB, r24
    1db2:	80 91 bb 00 	lds	r24, 0x00BB
    1db6:	f0 e0       	ldi	r31, 0x00	; 0
    1db8:	e4 52       	subi	r30, 0x24	; 36
    1dba:	f2 4f       	sbci	r31, 0xF2	; 242
    1dbc:	80 83       	st	Z, r24
	if (twi_sendStop)
    1dbe:	80 91 01 0e 	lds	r24, 0x0E01
    1dc2:	88 23       	and	r24, r24
    1dc4:	11 f0       	breq	.+4      	; 0x1dca <__vector_39+0x110>
          twi_stop();
    1dc6:	68 df       	rcall	.-304    	; 0x1c98 <twi_stop>
    1dc8:	81 c0       	rjmp	.+258    	; 0x1ecc <__vector_39+0x212>
	else {
	  twi_inRepStart = true;	// we're gonna send the START
    1dca:	81 e0       	ldi	r24, 0x01	; 1
    1dcc:	80 93 00 0e 	sts	0x0E00, r24
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
    1dd0:	84 ea       	ldi	r24, 0xA4	; 164
    1dd2:	80 93 bc 00 	sts	0x00BC, r24
	  twi_state = TWI_READY;
    1dd6:	10 92 03 0e 	sts	0x0E03, r1
    1dda:	78 c0       	rjmp	.+240    	; 0x1ecc <__vector_39+0x212>
	}    
	break;
    case TW_MR_SLA_NACK: // address sent, nack received
      twi_stop();
    1ddc:	5d df       	rcall	.-326    	; 0x1c98 <twi_stop>
      break;
    1dde:	76 c0       	rjmp	.+236    	; 0x1ecc <__vector_39+0x212>
    case TW_SR_SLA_ACK:   // addressed, returned ack
    case TW_SR_GCALL_ACK: // addressed generally, returned ack
    case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack
    case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack
      // enter slave receiver mode
      twi_state = TWI_SRX;
    1de0:	83 e0       	ldi	r24, 0x03	; 3
    1de2:	80 93 03 0e 	sts	0x0E03, r24
      // indicate that rx buffer can be overwritten and ack
      twi_rxBufferIndex = 0;
    1de6:	10 92 97 0d 	sts	0x0D97, r1
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    1dea:	85 ec       	ldi	r24, 0xC5	; 197
    1dec:	80 93 bc 00 	sts	0x00BC, r24
    1df0:	6d c0       	rjmp	.+218    	; 0x1ecc <__vector_39+0x212>
      twi_reply(1);
      break;
    case TW_SR_DATA_ACK:       // data received, returned ack
    case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack
      // if there is still room in the rx buffer
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
    1df2:	80 91 97 0d 	lds	r24, 0x0D97
    1df6:	80 32       	cpi	r24, 0x20	; 32
    1df8:	80 f4       	brcc	.+32     	; 0x1e1a <__vector_39+0x160>
        // put byte in buffer and ack
        twi_rxBuffer[twi_rxBufferIndex++] = TWDR;
    1dfa:	e0 91 97 0d 	lds	r30, 0x0D97
    1dfe:	81 e0       	ldi	r24, 0x01	; 1
    1e00:	8e 0f       	add	r24, r30
    1e02:	80 93 97 0d 	sts	0x0D97, r24
    1e06:	80 91 bb 00 	lds	r24, 0x00BB
    1e0a:	f0 e0       	ldi	r31, 0x00	; 0
    1e0c:	e8 56       	subi	r30, 0x68	; 104
    1e0e:	f2 4f       	sbci	r31, 0xF2	; 242
    1e10:	80 83       	st	Z, r24
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    1e12:	85 ec       	ldi	r24, 0xC5	; 197
    1e14:	80 93 bc 00 	sts	0x00BC, r24
    1e18:	59 c0       	rjmp	.+178    	; 0x1ecc <__vector_39+0x212>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    1e1a:	85 e8       	ldi	r24, 0x85	; 133
    1e1c:	80 93 bc 00 	sts	0x00BC, r24
    1e20:	55 c0       	rjmp	.+170    	; 0x1ecc <__vector_39+0x212>
        twi_reply(0);
      }
      break;
    case TW_SR_STOP: // stop or repeated start condition received
      // put a null char after data if there's room
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
    1e22:	80 91 97 0d 	lds	r24, 0x0D97
    1e26:	80 32       	cpi	r24, 0x20	; 32
    1e28:	30 f4       	brcc	.+12     	; 0x1e36 <__vector_39+0x17c>
        twi_rxBuffer[twi_rxBufferIndex] = '\0';
    1e2a:	e0 91 97 0d 	lds	r30, 0x0D97
    1e2e:	f0 e0       	ldi	r31, 0x00	; 0
    1e30:	e8 56       	subi	r30, 0x68	; 104
    1e32:	f2 4f       	sbci	r31, 0xF2	; 242
    1e34:	10 82       	st	Z, r1
      }
      // sends ack and stops interface for clock stretching
      twi_stop();
    1e36:	30 df       	rcall	.-416    	; 0x1c98 <twi_stop>
      // callback to user defined callback
      twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);
    1e38:	60 91 97 0d 	lds	r22, 0x0D97
    1e3c:	70 e0       	ldi	r23, 0x00	; 0
    1e3e:	e0 91 fc 0d 	lds	r30, 0x0DFC
    1e42:	f0 91 fd 0d 	lds	r31, 0x0DFD
    1e46:	88 e9       	ldi	r24, 0x98	; 152
    1e48:	9d e0       	ldi	r25, 0x0D	; 13
    1e4a:	19 95       	eicall
      // since we submit rx buffer to "wire" library, we can reset it
      twi_rxBufferIndex = 0;
    1e4c:	10 92 97 0d 	sts	0x0D97, r1
      // ack future responses and leave slave receiver state
      twi_releaseBus();
    1e50:	2e df       	rcall	.-420    	; 0x1cae <twi_releaseBus>
      break;
    1e52:	3c c0       	rjmp	.+120    	; 0x1ecc <__vector_39+0x212>
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    1e54:	85 e8       	ldi	r24, 0x85	; 133
    1e56:	80 93 bc 00 	sts	0x00BC, r24
    1e5a:	38 c0       	rjmp	.+112    	; 0x1ecc <__vector_39+0x212>
    
    // Slave Transmitter
    case TW_ST_SLA_ACK:          // addressed, returned ack
    case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack
      // enter slave transmitter mode
      twi_state = TWI_STX;
    1e5c:	84 e0       	ldi	r24, 0x04	; 4
    1e5e:	80 93 03 0e 	sts	0x0E03, r24
      // ready the tx buffer index for iteration
      twi_txBufferIndex = 0;
    1e62:	10 92 b9 0d 	sts	0x0DB9, r1
      // set tx buffer length to be zero, to verify if user changes it
      twi_txBufferLength = 0;
    1e66:	10 92 b8 0d 	sts	0x0DB8, r1
      // request for txBuffer to be filled and length to be set
      // note: user must call twi_transmit(bytes, length) to do this
      twi_onSlaveTransmit();
    1e6a:	e0 91 fe 0d 	lds	r30, 0x0DFE
    1e6e:	f0 91 ff 0d 	lds	r31, 0x0DFF
    1e72:	19 95       	eicall
      // if they didn't change buffer & length, initialize it
      if(0 == twi_txBufferLength){
    1e74:	80 91 b8 0d 	lds	r24, 0x0DB8
    1e78:	81 11       	cpse	r24, r1
    1e7a:	05 c0       	rjmp	.+10     	; 0x1e86 <__vector_39+0x1cc>
        twi_txBufferLength = 1;
    1e7c:	81 e0       	ldi	r24, 0x01	; 1
    1e7e:	80 93 b8 0d 	sts	0x0DB8, r24
        twi_txBuffer[0] = 0x00;
    1e82:	10 92 ba 0d 	sts	0x0DBA, r1
      }
      // transmit first byte from buffer, fall
    case TW_ST_DATA_ACK: // byte sent, ack returned
      // copy data to output register
      TWDR = twi_txBuffer[twi_txBufferIndex++];
    1e86:	e0 91 b9 0d 	lds	r30, 0x0DB9
    1e8a:	81 e0       	ldi	r24, 0x01	; 1
    1e8c:	8e 0f       	add	r24, r30
    1e8e:	80 93 b9 0d 	sts	0x0DB9, r24
    1e92:	f0 e0       	ldi	r31, 0x00	; 0
    1e94:	e6 54       	subi	r30, 0x46	; 70
    1e96:	f2 4f       	sbci	r31, 0xF2	; 242
    1e98:	80 81       	ld	r24, Z
    1e9a:	80 93 bb 00 	sts	0x00BB, r24
      // if there is more to send, ack, otherwise nack
      if(twi_txBufferIndex < twi_txBufferLength){
    1e9e:	90 91 b9 0d 	lds	r25, 0x0DB9
    1ea2:	80 91 b8 0d 	lds	r24, 0x0DB8
    1ea6:	98 17       	cp	r25, r24
    1ea8:	20 f4       	brcc	.+8      	; 0x1eb2 <__vector_39+0x1f8>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    1eaa:	85 ec       	ldi	r24, 0xC5	; 197
    1eac:	80 93 bc 00 	sts	0x00BC, r24
    1eb0:	0d c0       	rjmp	.+26     	; 0x1ecc <__vector_39+0x212>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    1eb2:	85 e8       	ldi	r24, 0x85	; 133
    1eb4:	80 93 bc 00 	sts	0x00BC, r24
    1eb8:	09 c0       	rjmp	.+18     	; 0x1ecc <__vector_39+0x212>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    1eba:	85 ec       	ldi	r24, 0xC5	; 197
    1ebc:	80 93 bc 00 	sts	0x00BC, r24
    case TW_ST_DATA_NACK: // received nack, we are done 
    case TW_ST_LAST_DATA: // received ack, but we are done already!
      // ack future responses
      twi_reply(1);
      // leave slave receiver state
      twi_state = TWI_READY;
    1ec0:	10 92 03 0e 	sts	0x0E03, r1
      break;
    1ec4:	03 c0       	rjmp	.+6      	; 0x1ecc <__vector_39+0x212>

    // All
    case TW_NO_INFO:   // no state information
      break;
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
    1ec6:	10 92 96 0d 	sts	0x0D96, r1
      twi_stop();
    1eca:	e6 de       	rcall	.-564    	; 0x1c98 <twi_stop>
      break;
  }
}
    1ecc:	ff 91       	pop	r31
    1ece:	ef 91       	pop	r30
    1ed0:	bf 91       	pop	r27
    1ed2:	af 91       	pop	r26
    1ed4:	9f 91       	pop	r25
    1ed6:	8f 91       	pop	r24
    1ed8:	7f 91       	pop	r23
    1eda:	6f 91       	pop	r22
    1edc:	5f 91       	pop	r21
    1ede:	4f 91       	pop	r20
    1ee0:	3f 91       	pop	r19
    1ee2:	2f 91       	pop	r18
    1ee4:	0f 90       	pop	r0
    1ee6:	0b be       	out	0x3b, r0	; 59
    1ee8:	0f 90       	pop	r0
    1eea:	0f be       	out	0x3f, r0	; 63
    1eec:	0f 90       	pop	r0
    1eee:	1f 90       	pop	r1
    1ef0:	18 95       	reti

00001ef2 <_ZN7TwoWire9availableEv>:
}

// sets function called on slave read
void TwoWire::onRequest( void (*function)(void) )
{
  user_onRequest = function;
    1ef2:	80 91 34 0e 	lds	r24, 0x0E34
    1ef6:	90 e0       	ldi	r25, 0x00	; 0
    1ef8:	20 91 35 0e 	lds	r18, 0x0E35
    1efc:	82 1b       	sub	r24, r18
    1efe:	91 09       	sbc	r25, r1
    1f00:	08 95       	ret

00001f02 <_ZN7TwoWire4readEv>:
    1f02:	20 91 35 0e 	lds	r18, 0x0E35
    1f06:	80 91 34 0e 	lds	r24, 0x0E34
    1f0a:	28 17       	cp	r18, r24
    1f0c:	50 f4       	brcc	.+20     	; 0x1f22 <_ZN7TwoWire4readEv+0x20>
    1f0e:	e2 2f       	mov	r30, r18
    1f10:	f0 e0       	ldi	r31, 0x00	; 0
    1f12:	ea 5c       	subi	r30, 0xCA	; 202
    1f14:	f1 4f       	sbci	r31, 0xF1	; 241
    1f16:	80 81       	ld	r24, Z
    1f18:	90 e0       	ldi	r25, 0x00	; 0
    1f1a:	2f 5f       	subi	r18, 0xFF	; 255
    1f1c:	20 93 35 0e 	sts	0x0E35, r18
    1f20:	08 95       	ret
    1f22:	8f ef       	ldi	r24, 0xFF	; 255
    1f24:	9f ef       	ldi	r25, 0xFF	; 255
    1f26:	08 95       	ret

00001f28 <_ZN7TwoWire4peekEv>:
    1f28:	e0 91 35 0e 	lds	r30, 0x0E35
    1f2c:	80 91 34 0e 	lds	r24, 0x0E34
    1f30:	e8 17       	cp	r30, r24
    1f32:	30 f4       	brcc	.+12     	; 0x1f40 <_ZN7TwoWire4peekEv+0x18>
    1f34:	f0 e0       	ldi	r31, 0x00	; 0
    1f36:	ea 5c       	subi	r30, 0xCA	; 202
    1f38:	f1 4f       	sbci	r31, 0xF1	; 241
    1f3a:	80 81       	ld	r24, Z
    1f3c:	90 e0       	ldi	r25, 0x00	; 0
    1f3e:	08 95       	ret
    1f40:	8f ef       	ldi	r24, 0xFF	; 255
    1f42:	9f ef       	ldi	r25, 0xFF	; 255
    1f44:	08 95       	ret

00001f46 <_ZN7TwoWire5flushEv>:
    1f46:	08 95       	ret

00001f48 <_ZN7TwoWire5writeEPKhj>:
    1f48:	cf 92       	push	r12
    1f4a:	df 92       	push	r13
    1f4c:	ef 92       	push	r14
    1f4e:	ff 92       	push	r15
    1f50:	0f 93       	push	r16
    1f52:	1f 93       	push	r17
    1f54:	cf 93       	push	r28
    1f56:	df 93       	push	r29
    1f58:	8c 01       	movw	r16, r24
    1f5a:	7b 01       	movw	r14, r22
    1f5c:	6a 01       	movw	r12, r20
    1f5e:	80 91 10 0e 	lds	r24, 0x0E10
    1f62:	88 23       	and	r24, r24
    1f64:	99 f0       	breq	.+38     	; 0x1f8c <_ZN7TwoWire5writeEPKhj+0x44>
    1f66:	41 15       	cp	r20, r1
    1f68:	51 05       	cpc	r21, r1
    1f6a:	99 f0       	breq	.+38     	; 0x1f92 <_ZN7TwoWire5writeEPKhj+0x4a>
    1f6c:	eb 01       	movw	r28, r22
    1f6e:	e4 0e       	add	r14, r20
    1f70:	f5 1e       	adc	r15, r21
    1f72:	69 91       	ld	r22, Y+
    1f74:	d8 01       	movw	r26, r16
    1f76:	ed 91       	ld	r30, X+
    1f78:	fc 91       	ld	r31, X
    1f7a:	01 90       	ld	r0, Z+
    1f7c:	f0 81       	ld	r31, Z
    1f7e:	e0 2d       	mov	r30, r0
    1f80:	c8 01       	movw	r24, r16
    1f82:	19 95       	eicall
    1f84:	ce 15       	cp	r28, r14
    1f86:	df 05       	cpc	r29, r15
    1f88:	a1 f7       	brne	.-24     	; 0x1f72 <_ZN7TwoWire5writeEPKhj+0x2a>
    1f8a:	03 c0       	rjmp	.+6      	; 0x1f92 <_ZN7TwoWire5writeEPKhj+0x4a>
    1f8c:	64 2f       	mov	r22, r20
    1f8e:	c7 01       	movw	r24, r14
    1f90:	64 de       	rcall	.-824    	; 0x1c5a <twi_transmit>
    1f92:	c6 01       	movw	r24, r12
    1f94:	df 91       	pop	r29
    1f96:	cf 91       	pop	r28
    1f98:	1f 91       	pop	r17
    1f9a:	0f 91       	pop	r16
    1f9c:	ff 90       	pop	r15
    1f9e:	ef 90       	pop	r14
    1fa0:	df 90       	pop	r13
    1fa2:	cf 90       	pop	r12
    1fa4:	08 95       	ret

00001fa6 <_ZN7TwoWire5writeEh>:
    1fa6:	cf 93       	push	r28
    1fa8:	df 93       	push	r29
    1faa:	1f 92       	push	r1
    1fac:	cd b7       	in	r28, 0x3d	; 61
    1fae:	de b7       	in	r29, 0x3e	; 62
    1fb0:	69 83       	std	Y+1, r22	; 0x01
    1fb2:	20 91 10 0e 	lds	r18, 0x0E10
    1fb6:	22 23       	and	r18, r18
    1fb8:	e1 f0       	breq	.+56     	; 0x1ff2 <_ZN7TwoWire5writeEh+0x4c>
    1fba:	20 91 11 0e 	lds	r18, 0x0E11
    1fbe:	20 32       	cpi	r18, 0x20	; 32
    1fc0:	40 f0       	brcs	.+16     	; 0x1fd2 <_ZN7TwoWire5writeEh+0x2c>
    1fc2:	21 e0       	ldi	r18, 0x01	; 1
    1fc4:	30 e0       	ldi	r19, 0x00	; 0
    1fc6:	fc 01       	movw	r30, r24
    1fc8:	33 83       	std	Z+3, r19	; 0x03
    1fca:	22 83       	std	Z+2, r18	; 0x02
    1fcc:	80 e0       	ldi	r24, 0x00	; 0
    1fce:	90 e0       	ldi	r25, 0x00	; 0
    1fd0:	16 c0       	rjmp	.+44     	; 0x1ffe <_ZN7TwoWire5writeEh+0x58>
    1fd2:	80 91 12 0e 	lds	r24, 0x0E12
    1fd6:	e8 2f       	mov	r30, r24
    1fd8:	f0 e0       	ldi	r31, 0x00	; 0
    1fda:	ed 5e       	subi	r30, 0xED	; 237
    1fdc:	f1 4f       	sbci	r31, 0xF1	; 241
    1fde:	99 81       	ldd	r25, Y+1	; 0x01
    1fe0:	90 83       	st	Z, r25
    1fe2:	8f 5f       	subi	r24, 0xFF	; 255
    1fe4:	80 93 12 0e 	sts	0x0E12, r24
    1fe8:	80 93 11 0e 	sts	0x0E11, r24
    1fec:	81 e0       	ldi	r24, 0x01	; 1
    1fee:	90 e0       	ldi	r25, 0x00	; 0
    1ff0:	06 c0       	rjmp	.+12     	; 0x1ffe <_ZN7TwoWire5writeEh+0x58>
    1ff2:	61 e0       	ldi	r22, 0x01	; 1
    1ff4:	ce 01       	movw	r24, r28
    1ff6:	01 96       	adiw	r24, 0x01	; 1
    1ff8:	30 de       	rcall	.-928    	; 0x1c5a <twi_transmit>
    1ffa:	81 e0       	ldi	r24, 0x01	; 1
    1ffc:	90 e0       	ldi	r25, 0x00	; 0
    1ffe:	0f 90       	pop	r0
    2000:	df 91       	pop	r29
    2002:	cf 91       	pop	r28
    2004:	08 95       	ret

00002006 <_ZN7TwoWireC1Ev>:
    2006:	fc 01       	movw	r30, r24
    2008:	13 82       	std	Z+3, r1	; 0x03
    200a:	12 82       	std	Z+2, r1	; 0x02
    200c:	48 ee       	ldi	r20, 0xE8	; 232
    200e:	53 e0       	ldi	r21, 0x03	; 3
    2010:	60 e0       	ldi	r22, 0x00	; 0
    2012:	70 e0       	ldi	r23, 0x00	; 0
    2014:	44 83       	std	Z+4, r20	; 0x04
    2016:	55 83       	std	Z+5, r21	; 0x05
    2018:	66 83       	std	Z+6, r22	; 0x06
    201a:	77 83       	std	Z+7, r23	; 0x07
    201c:	8f e8       	ldi	r24, 0x8F	; 143
    201e:	92 e0       	ldi	r25, 0x02	; 2
    2020:	91 83       	std	Z+1, r25	; 0x01
    2022:	80 83       	st	Z, r24
    2024:	08 95       	ret

00002026 <_ZN7TwoWire5beginEv>:
    2026:	10 92 35 0e 	sts	0x0E35, r1
    202a:	10 92 34 0e 	sts	0x0E34, r1
    202e:	10 92 12 0e 	sts	0x0E12, r1
    2032:	10 92 11 0e 	sts	0x0E11, r1
    2036:	48 cd       	rjmp	.-1392   	; 0x1ac8 <twi_init>
    2038:	08 95       	ret

0000203a <_ZN7TwoWire11requestFromEhhh>:
    203a:	86 2f       	mov	r24, r22
    203c:	41 32       	cpi	r20, 0x21	; 33
    203e:	08 f0       	brcs	.+2      	; 0x2042 <_ZN7TwoWire11requestFromEhhh+0x8>
    2040:	40 e2       	ldi	r20, 0x20	; 32
    2042:	66 e3       	ldi	r22, 0x36	; 54
    2044:	7e e0       	ldi	r23, 0x0E	; 14
    2046:	5e dd       	rcall	.-1348   	; 0x1b04 <twi_readFrom>
    2048:	10 92 35 0e 	sts	0x0E35, r1
    204c:	80 93 34 0e 	sts	0x0E34, r24
    2050:	08 95       	ret

00002052 <_ZN7TwoWire11requestFromEhh>:
    2052:	21 e0       	ldi	r18, 0x01	; 1
    2054:	f2 cf       	rjmp	.-28     	; 0x203a <_ZN7TwoWire11requestFromEhhh>
    2056:	08 95       	ret

00002058 <_ZN7TwoWire17beginTransmissionEh>:
    2058:	81 e0       	ldi	r24, 0x01	; 1
    205a:	80 93 10 0e 	sts	0x0E10, r24
    205e:	60 93 33 0e 	sts	0x0E33, r22
    2062:	10 92 12 0e 	sts	0x0E12, r1
    2066:	10 92 11 0e 	sts	0x0E11, r1
    206a:	08 95       	ret

0000206c <_ZN7TwoWire15endTransmissionEh>:
    206c:	0f 93       	push	r16
    206e:	06 2f       	mov	r16, r22
    2070:	21 e0       	ldi	r18, 0x01	; 1
    2072:	40 91 11 0e 	lds	r20, 0x0E11
    2076:	63 e1       	ldi	r22, 0x13	; 19
    2078:	7e e0       	ldi	r23, 0x0E	; 14
    207a:	80 91 33 0e 	lds	r24, 0x0E33
    207e:	90 dd       	rcall	.-1248   	; 0x1ba0 <twi_writeTo>
    2080:	10 92 12 0e 	sts	0x0E12, r1
    2084:	10 92 11 0e 	sts	0x0E11, r1
    2088:	10 92 10 0e 	sts	0x0E10, r1
    208c:	0f 91       	pop	r16
    208e:	08 95       	ret

00002090 <_ZN7TwoWire15endTransmissionEv>:
    2090:	61 e0       	ldi	r22, 0x01	; 1
    2092:	ec cf       	rjmp	.-40     	; 0x206c <_ZN7TwoWire15endTransmissionEh>
    2094:	08 95       	ret

00002096 <_GLOBAL__sub_I__ZN7TwoWire8rxBufferE>:
}

// Preinstantiate Objects //////////////////////////////////////////////////////

TwoWire Wire = TwoWire();
    2096:	84 e0       	ldi	r24, 0x04	; 4
    2098:	9e e0       	ldi	r25, 0x0E	; 14
    209a:	b5 cf       	rjmp	.-150    	; 0x2006 <_ZN7TwoWireC1Ev>
    209c:	08 95       	ret

0000209e <__subsf3>:
    209e:	50 58       	subi	r21, 0x80	; 128

000020a0 <__addsf3>:
    20a0:	bb 27       	eor	r27, r27
    20a2:	aa 27       	eor	r26, r26
    20a4:	0e d0       	rcall	.+28     	; 0x20c2 <__addsf3x>
    20a6:	72 c1       	rjmp	.+740    	; 0x238c <__fp_round>
    20a8:	63 d1       	rcall	.+710    	; 0x2370 <__fp_pscA>
    20aa:	30 f0       	brcs	.+12     	; 0x20b8 <__addsf3+0x18>
    20ac:	68 d1       	rcall	.+720    	; 0x237e <__fp_pscB>
    20ae:	20 f0       	brcs	.+8      	; 0x20b8 <__addsf3+0x18>
    20b0:	31 f4       	brne	.+12     	; 0x20be <__addsf3+0x1e>
    20b2:	9f 3f       	cpi	r25, 0xFF	; 255
    20b4:	11 f4       	brne	.+4      	; 0x20ba <__addsf3+0x1a>
    20b6:	1e f4       	brtc	.+6      	; 0x20be <__addsf3+0x1e>
    20b8:	33 c1       	rjmp	.+614    	; 0x2320 <__fp_nan>
    20ba:	0e f4       	brtc	.+2      	; 0x20be <__addsf3+0x1e>
    20bc:	e0 95       	com	r30
    20be:	e7 fb       	bst	r30, 7
    20c0:	29 c1       	rjmp	.+594    	; 0x2314 <__fp_inf>

000020c2 <__addsf3x>:
    20c2:	e9 2f       	mov	r30, r25
    20c4:	74 d1       	rcall	.+744    	; 0x23ae <__fp_split3>
    20c6:	80 f3       	brcs	.-32     	; 0x20a8 <__addsf3+0x8>
    20c8:	ba 17       	cp	r27, r26
    20ca:	62 07       	cpc	r22, r18
    20cc:	73 07       	cpc	r23, r19
    20ce:	84 07       	cpc	r24, r20
    20d0:	95 07       	cpc	r25, r21
    20d2:	18 f0       	brcs	.+6      	; 0x20da <__addsf3x+0x18>
    20d4:	71 f4       	brne	.+28     	; 0x20f2 <__addsf3x+0x30>
    20d6:	9e f5       	brtc	.+102    	; 0x213e <__addsf3x+0x7c>
    20d8:	8c c1       	rjmp	.+792    	; 0x23f2 <__fp_zero>
    20da:	0e f4       	brtc	.+2      	; 0x20de <__addsf3x+0x1c>
    20dc:	e0 95       	com	r30
    20de:	0b 2e       	mov	r0, r27
    20e0:	ba 2f       	mov	r27, r26
    20e2:	a0 2d       	mov	r26, r0
    20e4:	0b 01       	movw	r0, r22
    20e6:	b9 01       	movw	r22, r18
    20e8:	90 01       	movw	r18, r0
    20ea:	0c 01       	movw	r0, r24
    20ec:	ca 01       	movw	r24, r20
    20ee:	a0 01       	movw	r20, r0
    20f0:	11 24       	eor	r1, r1
    20f2:	ff 27       	eor	r31, r31
    20f4:	59 1b       	sub	r21, r25
    20f6:	99 f0       	breq	.+38     	; 0x211e <__addsf3x+0x5c>
    20f8:	59 3f       	cpi	r21, 0xF9	; 249
    20fa:	50 f4       	brcc	.+20     	; 0x2110 <__addsf3x+0x4e>
    20fc:	50 3e       	cpi	r21, 0xE0	; 224
    20fe:	68 f1       	brcs	.+90     	; 0x215a <__addsf3x+0x98>
    2100:	1a 16       	cp	r1, r26
    2102:	f0 40       	sbci	r31, 0x00	; 0
    2104:	a2 2f       	mov	r26, r18
    2106:	23 2f       	mov	r18, r19
    2108:	34 2f       	mov	r19, r20
    210a:	44 27       	eor	r20, r20
    210c:	58 5f       	subi	r21, 0xF8	; 248
    210e:	f3 cf       	rjmp	.-26     	; 0x20f6 <__addsf3x+0x34>
    2110:	46 95       	lsr	r20
    2112:	37 95       	ror	r19
    2114:	27 95       	ror	r18
    2116:	a7 95       	ror	r26
    2118:	f0 40       	sbci	r31, 0x00	; 0
    211a:	53 95       	inc	r21
    211c:	c9 f7       	brne	.-14     	; 0x2110 <__addsf3x+0x4e>
    211e:	7e f4       	brtc	.+30     	; 0x213e <__addsf3x+0x7c>
    2120:	1f 16       	cp	r1, r31
    2122:	ba 0b       	sbc	r27, r26
    2124:	62 0b       	sbc	r22, r18
    2126:	73 0b       	sbc	r23, r19
    2128:	84 0b       	sbc	r24, r20
    212a:	ba f0       	brmi	.+46     	; 0x215a <__addsf3x+0x98>
    212c:	91 50       	subi	r25, 0x01	; 1
    212e:	a1 f0       	breq	.+40     	; 0x2158 <__addsf3x+0x96>
    2130:	ff 0f       	add	r31, r31
    2132:	bb 1f       	adc	r27, r27
    2134:	66 1f       	adc	r22, r22
    2136:	77 1f       	adc	r23, r23
    2138:	88 1f       	adc	r24, r24
    213a:	c2 f7       	brpl	.-16     	; 0x212c <__addsf3x+0x6a>
    213c:	0e c0       	rjmp	.+28     	; 0x215a <__addsf3x+0x98>
    213e:	ba 0f       	add	r27, r26
    2140:	62 1f       	adc	r22, r18
    2142:	73 1f       	adc	r23, r19
    2144:	84 1f       	adc	r24, r20
    2146:	48 f4       	brcc	.+18     	; 0x215a <__addsf3x+0x98>
    2148:	87 95       	ror	r24
    214a:	77 95       	ror	r23
    214c:	67 95       	ror	r22
    214e:	b7 95       	ror	r27
    2150:	f7 95       	ror	r31
    2152:	9e 3f       	cpi	r25, 0xFE	; 254
    2154:	08 f0       	brcs	.+2      	; 0x2158 <__addsf3x+0x96>
    2156:	b3 cf       	rjmp	.-154    	; 0x20be <__addsf3+0x1e>
    2158:	93 95       	inc	r25
    215a:	88 0f       	add	r24, r24
    215c:	08 f0       	brcs	.+2      	; 0x2160 <__addsf3x+0x9e>
    215e:	99 27       	eor	r25, r25
    2160:	ee 0f       	add	r30, r30
    2162:	97 95       	ror	r25
    2164:	87 95       	ror	r24
    2166:	08 95       	ret

00002168 <__divsf3>:
    2168:	0c d0       	rcall	.+24     	; 0x2182 <__divsf3x>
    216a:	10 c1       	rjmp	.+544    	; 0x238c <__fp_round>
    216c:	08 d1       	rcall	.+528    	; 0x237e <__fp_pscB>
    216e:	40 f0       	brcs	.+16     	; 0x2180 <__divsf3+0x18>
    2170:	ff d0       	rcall	.+510    	; 0x2370 <__fp_pscA>
    2172:	30 f0       	brcs	.+12     	; 0x2180 <__divsf3+0x18>
    2174:	21 f4       	brne	.+8      	; 0x217e <__divsf3+0x16>
    2176:	5f 3f       	cpi	r21, 0xFF	; 255
    2178:	19 f0       	breq	.+6      	; 0x2180 <__divsf3+0x18>
    217a:	cc c0       	rjmp	.+408    	; 0x2314 <__fp_inf>
    217c:	51 11       	cpse	r21, r1
    217e:	3a c1       	rjmp	.+628    	; 0x23f4 <__fp_szero>
    2180:	cf c0       	rjmp	.+414    	; 0x2320 <__fp_nan>

00002182 <__divsf3x>:
    2182:	15 d1       	rcall	.+554    	; 0x23ae <__fp_split3>
    2184:	98 f3       	brcs	.-26     	; 0x216c <__divsf3+0x4>

00002186 <__divsf3_pse>:
    2186:	99 23       	and	r25, r25
    2188:	c9 f3       	breq	.-14     	; 0x217c <__divsf3+0x14>
    218a:	55 23       	and	r21, r21
    218c:	b1 f3       	breq	.-20     	; 0x217a <__divsf3+0x12>
    218e:	95 1b       	sub	r25, r21
    2190:	55 0b       	sbc	r21, r21
    2192:	bb 27       	eor	r27, r27
    2194:	aa 27       	eor	r26, r26
    2196:	62 17       	cp	r22, r18
    2198:	73 07       	cpc	r23, r19
    219a:	84 07       	cpc	r24, r20
    219c:	38 f0       	brcs	.+14     	; 0x21ac <__divsf3_pse+0x26>
    219e:	9f 5f       	subi	r25, 0xFF	; 255
    21a0:	5f 4f       	sbci	r21, 0xFF	; 255
    21a2:	22 0f       	add	r18, r18
    21a4:	33 1f       	adc	r19, r19
    21a6:	44 1f       	adc	r20, r20
    21a8:	aa 1f       	adc	r26, r26
    21aa:	a9 f3       	breq	.-22     	; 0x2196 <__divsf3_pse+0x10>
    21ac:	33 d0       	rcall	.+102    	; 0x2214 <__stack+0x15>
    21ae:	0e 2e       	mov	r0, r30
    21b0:	3a f0       	brmi	.+14     	; 0x21c0 <__divsf3_pse+0x3a>
    21b2:	e0 e8       	ldi	r30, 0x80	; 128
    21b4:	30 d0       	rcall	.+96     	; 0x2216 <__stack+0x17>
    21b6:	91 50       	subi	r25, 0x01	; 1
    21b8:	50 40       	sbci	r21, 0x00	; 0
    21ba:	e6 95       	lsr	r30
    21bc:	00 1c       	adc	r0, r0
    21be:	ca f7       	brpl	.-14     	; 0x21b2 <__divsf3_pse+0x2c>
    21c0:	29 d0       	rcall	.+82     	; 0x2214 <__stack+0x15>
    21c2:	fe 2f       	mov	r31, r30
    21c4:	27 d0       	rcall	.+78     	; 0x2214 <__stack+0x15>
    21c6:	66 0f       	add	r22, r22
    21c8:	77 1f       	adc	r23, r23
    21ca:	88 1f       	adc	r24, r24
    21cc:	bb 1f       	adc	r27, r27
    21ce:	26 17       	cp	r18, r22
    21d0:	37 07       	cpc	r19, r23
    21d2:	48 07       	cpc	r20, r24
    21d4:	ab 07       	cpc	r26, r27
    21d6:	b0 e8       	ldi	r27, 0x80	; 128
    21d8:	09 f0       	breq	.+2      	; 0x21dc <__divsf3_pse+0x56>
    21da:	bb 0b       	sbc	r27, r27
    21dc:	80 2d       	mov	r24, r0
    21de:	bf 01       	movw	r22, r30
    21e0:	ff 27       	eor	r31, r31
    21e2:	93 58       	subi	r25, 0x83	; 131
    21e4:	5f 4f       	sbci	r21, 0xFF	; 255
    21e6:	2a f0       	brmi	.+10     	; 0x21f2 <__divsf3_pse+0x6c>
    21e8:	9e 3f       	cpi	r25, 0xFE	; 254
    21ea:	51 05       	cpc	r21, r1
    21ec:	68 f0       	brcs	.+26     	; 0x2208 <__stack+0x9>
    21ee:	92 c0       	rjmp	.+292    	; 0x2314 <__fp_inf>
    21f0:	01 c1       	rjmp	.+514    	; 0x23f4 <__fp_szero>
    21f2:	5f 3f       	cpi	r21, 0xFF	; 255
    21f4:	ec f3       	brlt	.-6      	; 0x21f0 <__divsf3_pse+0x6a>
    21f6:	98 3e       	cpi	r25, 0xE8	; 232
    21f8:	dc f3       	brlt	.-10     	; 0x21f0 <__divsf3_pse+0x6a>
    21fa:	86 95       	lsr	r24
    21fc:	77 95       	ror	r23
    21fe:	67 95       	ror	r22
    2200:	b7 95       	ror	r27
    2202:	f7 95       	ror	r31
    2204:	9f 5f       	subi	r25, 0xFF	; 255
    2206:	c9 f7       	brne	.-14     	; 0x21fa <__divsf3_pse+0x74>
    2208:	88 0f       	add	r24, r24
    220a:	91 1d       	adc	r25, r1
    220c:	96 95       	lsr	r25
    220e:	87 95       	ror	r24
    2210:	97 f9       	bld	r25, 7
    2212:	08 95       	ret
    2214:	e1 e0       	ldi	r30, 0x01	; 1
    2216:	66 0f       	add	r22, r22
    2218:	77 1f       	adc	r23, r23
    221a:	88 1f       	adc	r24, r24
    221c:	bb 1f       	adc	r27, r27
    221e:	62 17       	cp	r22, r18
    2220:	73 07       	cpc	r23, r19
    2222:	84 07       	cpc	r24, r20
    2224:	ba 07       	cpc	r27, r26
    2226:	20 f0       	brcs	.+8      	; 0x2230 <__stack+0x31>
    2228:	62 1b       	sub	r22, r18
    222a:	73 0b       	sbc	r23, r19
    222c:	84 0b       	sbc	r24, r20
    222e:	ba 0b       	sbc	r27, r26
    2230:	ee 1f       	adc	r30, r30
    2232:	88 f7       	brcc	.-30     	; 0x2216 <__stack+0x17>
    2234:	e0 95       	com	r30
    2236:	08 95       	ret

00002238 <__fixsfsi>:
    2238:	04 d0       	rcall	.+8      	; 0x2242 <__fixunssfsi>
    223a:	68 94       	set
    223c:	b1 11       	cpse	r27, r1
    223e:	da c0       	rjmp	.+436    	; 0x23f4 <__fp_szero>
    2240:	08 95       	ret

00002242 <__fixunssfsi>:
    2242:	bd d0       	rcall	.+378    	; 0x23be <__fp_splitA>
    2244:	88 f0       	brcs	.+34     	; 0x2268 <__fixunssfsi+0x26>
    2246:	9f 57       	subi	r25, 0x7F	; 127
    2248:	90 f0       	brcs	.+36     	; 0x226e <__fixunssfsi+0x2c>
    224a:	b9 2f       	mov	r27, r25
    224c:	99 27       	eor	r25, r25
    224e:	b7 51       	subi	r27, 0x17	; 23
    2250:	a0 f0       	brcs	.+40     	; 0x227a <__fixunssfsi+0x38>
    2252:	d1 f0       	breq	.+52     	; 0x2288 <__fixunssfsi+0x46>
    2254:	66 0f       	add	r22, r22
    2256:	77 1f       	adc	r23, r23
    2258:	88 1f       	adc	r24, r24
    225a:	99 1f       	adc	r25, r25
    225c:	1a f0       	brmi	.+6      	; 0x2264 <__fixunssfsi+0x22>
    225e:	ba 95       	dec	r27
    2260:	c9 f7       	brne	.-14     	; 0x2254 <__fixunssfsi+0x12>
    2262:	12 c0       	rjmp	.+36     	; 0x2288 <__fixunssfsi+0x46>
    2264:	b1 30       	cpi	r27, 0x01	; 1
    2266:	81 f0       	breq	.+32     	; 0x2288 <__fixunssfsi+0x46>
    2268:	c4 d0       	rcall	.+392    	; 0x23f2 <__fp_zero>
    226a:	b1 e0       	ldi	r27, 0x01	; 1
    226c:	08 95       	ret
    226e:	c1 c0       	rjmp	.+386    	; 0x23f2 <__fp_zero>
    2270:	67 2f       	mov	r22, r23
    2272:	78 2f       	mov	r23, r24
    2274:	88 27       	eor	r24, r24
    2276:	b8 5f       	subi	r27, 0xF8	; 248
    2278:	39 f0       	breq	.+14     	; 0x2288 <__fixunssfsi+0x46>
    227a:	b9 3f       	cpi	r27, 0xF9	; 249
    227c:	cc f3       	brlt	.-14     	; 0x2270 <__fixunssfsi+0x2e>
    227e:	86 95       	lsr	r24
    2280:	77 95       	ror	r23
    2282:	67 95       	ror	r22
    2284:	b3 95       	inc	r27
    2286:	d9 f7       	brne	.-10     	; 0x227e <__fixunssfsi+0x3c>
    2288:	3e f4       	brtc	.+14     	; 0x2298 <__fixunssfsi+0x56>
    228a:	90 95       	com	r25
    228c:	80 95       	com	r24
    228e:	70 95       	com	r23
    2290:	61 95       	neg	r22
    2292:	7f 4f       	sbci	r23, 0xFF	; 255
    2294:	8f 4f       	sbci	r24, 0xFF	; 255
    2296:	9f 4f       	sbci	r25, 0xFF	; 255
    2298:	08 95       	ret

0000229a <__floatunsisf>:
    229a:	e8 94       	clt
    229c:	09 c0       	rjmp	.+18     	; 0x22b0 <__floatsisf+0x12>

0000229e <__floatsisf>:
    229e:	97 fb       	bst	r25, 7
    22a0:	3e f4       	brtc	.+14     	; 0x22b0 <__floatsisf+0x12>
    22a2:	90 95       	com	r25
    22a4:	80 95       	com	r24
    22a6:	70 95       	com	r23
    22a8:	61 95       	neg	r22
    22aa:	7f 4f       	sbci	r23, 0xFF	; 255
    22ac:	8f 4f       	sbci	r24, 0xFF	; 255
    22ae:	9f 4f       	sbci	r25, 0xFF	; 255
    22b0:	99 23       	and	r25, r25
    22b2:	a9 f0       	breq	.+42     	; 0x22de <__floatsisf+0x40>
    22b4:	f9 2f       	mov	r31, r25
    22b6:	96 e9       	ldi	r25, 0x96	; 150
    22b8:	bb 27       	eor	r27, r27
    22ba:	93 95       	inc	r25
    22bc:	f6 95       	lsr	r31
    22be:	87 95       	ror	r24
    22c0:	77 95       	ror	r23
    22c2:	67 95       	ror	r22
    22c4:	b7 95       	ror	r27
    22c6:	f1 11       	cpse	r31, r1
    22c8:	f8 cf       	rjmp	.-16     	; 0x22ba <__floatsisf+0x1c>
    22ca:	fa f4       	brpl	.+62     	; 0x230a <__floatsisf+0x6c>
    22cc:	bb 0f       	add	r27, r27
    22ce:	11 f4       	brne	.+4      	; 0x22d4 <__floatsisf+0x36>
    22d0:	60 ff       	sbrs	r22, 0
    22d2:	1b c0       	rjmp	.+54     	; 0x230a <__floatsisf+0x6c>
    22d4:	6f 5f       	subi	r22, 0xFF	; 255
    22d6:	7f 4f       	sbci	r23, 0xFF	; 255
    22d8:	8f 4f       	sbci	r24, 0xFF	; 255
    22da:	9f 4f       	sbci	r25, 0xFF	; 255
    22dc:	16 c0       	rjmp	.+44     	; 0x230a <__floatsisf+0x6c>
    22de:	88 23       	and	r24, r24
    22e0:	11 f0       	breq	.+4      	; 0x22e6 <__floatsisf+0x48>
    22e2:	96 e9       	ldi	r25, 0x96	; 150
    22e4:	11 c0       	rjmp	.+34     	; 0x2308 <__floatsisf+0x6a>
    22e6:	77 23       	and	r23, r23
    22e8:	21 f0       	breq	.+8      	; 0x22f2 <__floatsisf+0x54>
    22ea:	9e e8       	ldi	r25, 0x8E	; 142
    22ec:	87 2f       	mov	r24, r23
    22ee:	76 2f       	mov	r23, r22
    22f0:	05 c0       	rjmp	.+10     	; 0x22fc <__floatsisf+0x5e>
    22f2:	66 23       	and	r22, r22
    22f4:	71 f0       	breq	.+28     	; 0x2312 <__floatsisf+0x74>
    22f6:	96 e8       	ldi	r25, 0x86	; 134
    22f8:	86 2f       	mov	r24, r22
    22fa:	70 e0       	ldi	r23, 0x00	; 0
    22fc:	60 e0       	ldi	r22, 0x00	; 0
    22fe:	2a f0       	brmi	.+10     	; 0x230a <__floatsisf+0x6c>
    2300:	9a 95       	dec	r25
    2302:	66 0f       	add	r22, r22
    2304:	77 1f       	adc	r23, r23
    2306:	88 1f       	adc	r24, r24
    2308:	da f7       	brpl	.-10     	; 0x2300 <__floatsisf+0x62>
    230a:	88 0f       	add	r24, r24
    230c:	96 95       	lsr	r25
    230e:	87 95       	ror	r24
    2310:	97 f9       	bld	r25, 7
    2312:	08 95       	ret

00002314 <__fp_inf>:
    2314:	97 f9       	bld	r25, 7
    2316:	9f 67       	ori	r25, 0x7F	; 127
    2318:	80 e8       	ldi	r24, 0x80	; 128
    231a:	70 e0       	ldi	r23, 0x00	; 0
    231c:	60 e0       	ldi	r22, 0x00	; 0
    231e:	08 95       	ret

00002320 <__fp_nan>:
    2320:	9f ef       	ldi	r25, 0xFF	; 255
    2322:	80 ec       	ldi	r24, 0xC0	; 192
    2324:	08 95       	ret

00002326 <__fp_powser>:
    2326:	df 93       	push	r29
    2328:	cf 93       	push	r28
    232a:	1f 93       	push	r17
    232c:	0f 93       	push	r16
    232e:	ff 92       	push	r15
    2330:	ef 92       	push	r14
    2332:	df 92       	push	r13
    2334:	7b 01       	movw	r14, r22
    2336:	8c 01       	movw	r16, r24
    2338:	68 94       	set
    233a:	05 c0       	rjmp	.+10     	; 0x2346 <__fp_powser+0x20>
    233c:	da 2e       	mov	r13, r26
    233e:	ef 01       	movw	r28, r30
    2340:	72 d0       	rcall	.+228    	; 0x2426 <__mulsf3x>
    2342:	fe 01       	movw	r30, r28
    2344:	e8 94       	clt
    2346:	a5 91       	lpm	r26, Z+
    2348:	25 91       	lpm	r18, Z+
    234a:	35 91       	lpm	r19, Z+
    234c:	45 91       	lpm	r20, Z+
    234e:	55 91       	lpm	r21, Z+
    2350:	ae f3       	brts	.-22     	; 0x233c <__fp_powser+0x16>
    2352:	ef 01       	movw	r28, r30
    2354:	b6 de       	rcall	.-660    	; 0x20c2 <__addsf3x>
    2356:	fe 01       	movw	r30, r28
    2358:	97 01       	movw	r18, r14
    235a:	a8 01       	movw	r20, r16
    235c:	da 94       	dec	r13
    235e:	79 f7       	brne	.-34     	; 0x233e <__fp_powser+0x18>
    2360:	df 90       	pop	r13
    2362:	ef 90       	pop	r14
    2364:	ff 90       	pop	r15
    2366:	0f 91       	pop	r16
    2368:	1f 91       	pop	r17
    236a:	cf 91       	pop	r28
    236c:	df 91       	pop	r29
    236e:	08 95       	ret

00002370 <__fp_pscA>:
    2370:	00 24       	eor	r0, r0
    2372:	0a 94       	dec	r0
    2374:	16 16       	cp	r1, r22
    2376:	17 06       	cpc	r1, r23
    2378:	18 06       	cpc	r1, r24
    237a:	09 06       	cpc	r0, r25
    237c:	08 95       	ret

0000237e <__fp_pscB>:
    237e:	00 24       	eor	r0, r0
    2380:	0a 94       	dec	r0
    2382:	12 16       	cp	r1, r18
    2384:	13 06       	cpc	r1, r19
    2386:	14 06       	cpc	r1, r20
    2388:	05 06       	cpc	r0, r21
    238a:	08 95       	ret

0000238c <__fp_round>:
    238c:	09 2e       	mov	r0, r25
    238e:	03 94       	inc	r0
    2390:	00 0c       	add	r0, r0
    2392:	11 f4       	brne	.+4      	; 0x2398 <__fp_round+0xc>
    2394:	88 23       	and	r24, r24
    2396:	52 f0       	brmi	.+20     	; 0x23ac <__fp_round+0x20>
    2398:	bb 0f       	add	r27, r27
    239a:	40 f4       	brcc	.+16     	; 0x23ac <__fp_round+0x20>
    239c:	bf 2b       	or	r27, r31
    239e:	11 f4       	brne	.+4      	; 0x23a4 <__fp_round+0x18>
    23a0:	60 ff       	sbrs	r22, 0
    23a2:	04 c0       	rjmp	.+8      	; 0x23ac <__fp_round+0x20>
    23a4:	6f 5f       	subi	r22, 0xFF	; 255
    23a6:	7f 4f       	sbci	r23, 0xFF	; 255
    23a8:	8f 4f       	sbci	r24, 0xFF	; 255
    23aa:	9f 4f       	sbci	r25, 0xFF	; 255
    23ac:	08 95       	ret

000023ae <__fp_split3>:
    23ae:	57 fd       	sbrc	r21, 7
    23b0:	90 58       	subi	r25, 0x80	; 128
    23b2:	44 0f       	add	r20, r20
    23b4:	55 1f       	adc	r21, r21
    23b6:	59 f0       	breq	.+22     	; 0x23ce <__fp_splitA+0x10>
    23b8:	5f 3f       	cpi	r21, 0xFF	; 255
    23ba:	71 f0       	breq	.+28     	; 0x23d8 <__fp_splitA+0x1a>
    23bc:	47 95       	ror	r20

000023be <__fp_splitA>:
    23be:	88 0f       	add	r24, r24
    23c0:	97 fb       	bst	r25, 7
    23c2:	99 1f       	adc	r25, r25
    23c4:	61 f0       	breq	.+24     	; 0x23de <__fp_splitA+0x20>
    23c6:	9f 3f       	cpi	r25, 0xFF	; 255
    23c8:	79 f0       	breq	.+30     	; 0x23e8 <__fp_splitA+0x2a>
    23ca:	87 95       	ror	r24
    23cc:	08 95       	ret
    23ce:	12 16       	cp	r1, r18
    23d0:	13 06       	cpc	r1, r19
    23d2:	14 06       	cpc	r1, r20
    23d4:	55 1f       	adc	r21, r21
    23d6:	f2 cf       	rjmp	.-28     	; 0x23bc <__fp_split3+0xe>
    23d8:	46 95       	lsr	r20
    23da:	f1 df       	rcall	.-30     	; 0x23be <__fp_splitA>
    23dc:	08 c0       	rjmp	.+16     	; 0x23ee <__fp_splitA+0x30>
    23de:	16 16       	cp	r1, r22
    23e0:	17 06       	cpc	r1, r23
    23e2:	18 06       	cpc	r1, r24
    23e4:	99 1f       	adc	r25, r25
    23e6:	f1 cf       	rjmp	.-30     	; 0x23ca <__fp_splitA+0xc>
    23e8:	86 95       	lsr	r24
    23ea:	71 05       	cpc	r23, r1
    23ec:	61 05       	cpc	r22, r1
    23ee:	08 94       	sec
    23f0:	08 95       	ret

000023f2 <__fp_zero>:
    23f2:	e8 94       	clt

000023f4 <__fp_szero>:
    23f4:	bb 27       	eor	r27, r27
    23f6:	66 27       	eor	r22, r22
    23f8:	77 27       	eor	r23, r23
    23fa:	cb 01       	movw	r24, r22
    23fc:	97 f9       	bld	r25, 7
    23fe:	08 95       	ret

00002400 <inverse>:
    2400:	9b 01       	movw	r18, r22
    2402:	ac 01       	movw	r20, r24
    2404:	60 e0       	ldi	r22, 0x00	; 0
    2406:	70 e0       	ldi	r23, 0x00	; 0
    2408:	80 e8       	ldi	r24, 0x80	; 128
    240a:	9f e3       	ldi	r25, 0x3F	; 63
    240c:	ad ce       	rjmp	.-678    	; 0x2168 <__divsf3>

0000240e <__mulsf3>:
    240e:	0b d0       	rcall	.+22     	; 0x2426 <__mulsf3x>
    2410:	bd cf       	rjmp	.-134    	; 0x238c <__fp_round>
    2412:	ae df       	rcall	.-164    	; 0x2370 <__fp_pscA>
    2414:	28 f0       	brcs	.+10     	; 0x2420 <__mulsf3+0x12>
    2416:	b3 df       	rcall	.-154    	; 0x237e <__fp_pscB>
    2418:	18 f0       	brcs	.+6      	; 0x2420 <__mulsf3+0x12>
    241a:	95 23       	and	r25, r21
    241c:	09 f0       	breq	.+2      	; 0x2420 <__mulsf3+0x12>
    241e:	7a cf       	rjmp	.-268    	; 0x2314 <__fp_inf>
    2420:	7f cf       	rjmp	.-258    	; 0x2320 <__fp_nan>
    2422:	11 24       	eor	r1, r1
    2424:	e7 cf       	rjmp	.-50     	; 0x23f4 <__fp_szero>

00002426 <__mulsf3x>:
    2426:	c3 df       	rcall	.-122    	; 0x23ae <__fp_split3>
    2428:	a0 f3       	brcs	.-24     	; 0x2412 <__mulsf3+0x4>

0000242a <__mulsf3_pse>:
    242a:	95 9f       	mul	r25, r21
    242c:	d1 f3       	breq	.-12     	; 0x2422 <__mulsf3+0x14>
    242e:	95 0f       	add	r25, r21
    2430:	50 e0       	ldi	r21, 0x00	; 0
    2432:	55 1f       	adc	r21, r21
    2434:	62 9f       	mul	r22, r18
    2436:	f0 01       	movw	r30, r0
    2438:	72 9f       	mul	r23, r18
    243a:	bb 27       	eor	r27, r27
    243c:	f0 0d       	add	r31, r0
    243e:	b1 1d       	adc	r27, r1
    2440:	63 9f       	mul	r22, r19
    2442:	aa 27       	eor	r26, r26
    2444:	f0 0d       	add	r31, r0
    2446:	b1 1d       	adc	r27, r1
    2448:	aa 1f       	adc	r26, r26
    244a:	64 9f       	mul	r22, r20
    244c:	66 27       	eor	r22, r22
    244e:	b0 0d       	add	r27, r0
    2450:	a1 1d       	adc	r26, r1
    2452:	66 1f       	adc	r22, r22
    2454:	82 9f       	mul	r24, r18
    2456:	22 27       	eor	r18, r18
    2458:	b0 0d       	add	r27, r0
    245a:	a1 1d       	adc	r26, r1
    245c:	62 1f       	adc	r22, r18
    245e:	73 9f       	mul	r23, r19
    2460:	b0 0d       	add	r27, r0
    2462:	a1 1d       	adc	r26, r1
    2464:	62 1f       	adc	r22, r18
    2466:	83 9f       	mul	r24, r19
    2468:	a0 0d       	add	r26, r0
    246a:	61 1d       	adc	r22, r1
    246c:	22 1f       	adc	r18, r18
    246e:	74 9f       	mul	r23, r20
    2470:	33 27       	eor	r19, r19
    2472:	a0 0d       	add	r26, r0
    2474:	61 1d       	adc	r22, r1
    2476:	23 1f       	adc	r18, r19
    2478:	84 9f       	mul	r24, r20
    247a:	60 0d       	add	r22, r0
    247c:	21 1d       	adc	r18, r1
    247e:	82 2f       	mov	r24, r18
    2480:	76 2f       	mov	r23, r22
    2482:	6a 2f       	mov	r22, r26
    2484:	11 24       	eor	r1, r1
    2486:	9f 57       	subi	r25, 0x7F	; 127
    2488:	50 40       	sbci	r21, 0x00	; 0
    248a:	8a f0       	brmi	.+34     	; 0x24ae <__mulsf3_pse+0x84>
    248c:	e1 f0       	breq	.+56     	; 0x24c6 <__mulsf3_pse+0x9c>
    248e:	88 23       	and	r24, r24
    2490:	4a f0       	brmi	.+18     	; 0x24a4 <__mulsf3_pse+0x7a>
    2492:	ee 0f       	add	r30, r30
    2494:	ff 1f       	adc	r31, r31
    2496:	bb 1f       	adc	r27, r27
    2498:	66 1f       	adc	r22, r22
    249a:	77 1f       	adc	r23, r23
    249c:	88 1f       	adc	r24, r24
    249e:	91 50       	subi	r25, 0x01	; 1
    24a0:	50 40       	sbci	r21, 0x00	; 0
    24a2:	a9 f7       	brne	.-22     	; 0x248e <__mulsf3_pse+0x64>
    24a4:	9e 3f       	cpi	r25, 0xFE	; 254
    24a6:	51 05       	cpc	r21, r1
    24a8:	70 f0       	brcs	.+28     	; 0x24c6 <__mulsf3_pse+0x9c>
    24aa:	34 cf       	rjmp	.-408    	; 0x2314 <__fp_inf>
    24ac:	a3 cf       	rjmp	.-186    	; 0x23f4 <__fp_szero>
    24ae:	5f 3f       	cpi	r21, 0xFF	; 255
    24b0:	ec f3       	brlt	.-6      	; 0x24ac <__mulsf3_pse+0x82>
    24b2:	98 3e       	cpi	r25, 0xE8	; 232
    24b4:	dc f3       	brlt	.-10     	; 0x24ac <__mulsf3_pse+0x82>
    24b6:	86 95       	lsr	r24
    24b8:	77 95       	ror	r23
    24ba:	67 95       	ror	r22
    24bc:	b7 95       	ror	r27
    24be:	f7 95       	ror	r31
    24c0:	e7 95       	ror	r30
    24c2:	9f 5f       	subi	r25, 0xFF	; 255
    24c4:	c1 f7       	brne	.-16     	; 0x24b6 <__mulsf3_pse+0x8c>
    24c6:	fe 2b       	or	r31, r30
    24c8:	88 0f       	add	r24, r24
    24ca:	91 1d       	adc	r25, r1
    24cc:	96 95       	lsr	r25
    24ce:	87 95       	ror	r24
    24d0:	97 f9       	bld	r25, 7
    24d2:	08 95       	ret

000024d4 <pow>:
    24d4:	fa 01       	movw	r30, r20
    24d6:	ee 0f       	add	r30, r30
    24d8:	ff 1f       	adc	r31, r31
    24da:	30 96       	adiw	r30, 0x00	; 0
    24dc:	21 05       	cpc	r18, r1
    24de:	31 05       	cpc	r19, r1
    24e0:	99 f1       	breq	.+102    	; 0x2548 <pow+0x74>
    24e2:	61 15       	cp	r22, r1
    24e4:	71 05       	cpc	r23, r1
    24e6:	61 f4       	brne	.+24     	; 0x2500 <pow+0x2c>
    24e8:	80 38       	cpi	r24, 0x80	; 128
    24ea:	bf e3       	ldi	r27, 0x3F	; 63
    24ec:	9b 07       	cpc	r25, r27
    24ee:	49 f1       	breq	.+82     	; 0x2542 <pow+0x6e>
    24f0:	68 94       	set
    24f2:	90 38       	cpi	r25, 0x80	; 128
    24f4:	81 05       	cpc	r24, r1
    24f6:	61 f0       	breq	.+24     	; 0x2510 <pow+0x3c>
    24f8:	80 38       	cpi	r24, 0x80	; 128
    24fa:	bf ef       	ldi	r27, 0xFF	; 255
    24fc:	9b 07       	cpc	r25, r27
    24fe:	41 f0       	breq	.+16     	; 0x2510 <pow+0x3c>
    2500:	99 23       	and	r25, r25
    2502:	42 f5       	brpl	.+80     	; 0x2554 <pow+0x80>
    2504:	ff 3f       	cpi	r31, 0xFF	; 255
    2506:	e1 05       	cpc	r30, r1
    2508:	31 05       	cpc	r19, r1
    250a:	21 05       	cpc	r18, r1
    250c:	11 f1       	breq	.+68     	; 0x2552 <pow+0x7e>
    250e:	e8 94       	clt
    2510:	08 94       	sec
    2512:	e7 95       	ror	r30
    2514:	d9 01       	movw	r26, r18
    2516:	aa 23       	and	r26, r26
    2518:	29 f4       	brne	.+10     	; 0x2524 <pow+0x50>
    251a:	ab 2f       	mov	r26, r27
    251c:	be 2f       	mov	r27, r30
    251e:	f8 5f       	subi	r31, 0xF8	; 248
    2520:	d0 f3       	brcs	.-12     	; 0x2516 <pow+0x42>
    2522:	10 c0       	rjmp	.+32     	; 0x2544 <pow+0x70>
    2524:	ff 5f       	subi	r31, 0xFF	; 255
    2526:	70 f4       	brcc	.+28     	; 0x2544 <pow+0x70>
    2528:	a6 95       	lsr	r26
    252a:	e0 f7       	brcc	.-8      	; 0x2524 <pow+0x50>
    252c:	f7 39       	cpi	r31, 0x97	; 151
    252e:	50 f0       	brcs	.+20     	; 0x2544 <pow+0x70>
    2530:	19 f0       	breq	.+6      	; 0x2538 <pow+0x64>
    2532:	ff 3a       	cpi	r31, 0xAF	; 175
    2534:	38 f4       	brcc	.+14     	; 0x2544 <pow+0x70>
    2536:	9f 77       	andi	r25, 0x7F	; 127
    2538:	9f 93       	push	r25
    253a:	0c d0       	rcall	.+24     	; 0x2554 <pow+0x80>
    253c:	0f 90       	pop	r0
    253e:	07 fc       	sbrc	r0, 7
    2540:	90 58       	subi	r25, 0x80	; 128
    2542:	08 95       	ret
    2544:	3e f0       	brts	.+14     	; 0x2554 <pow+0x80>
    2546:	ec ce       	rjmp	.-552    	; 0x2320 <__fp_nan>
    2548:	60 e0       	ldi	r22, 0x00	; 0
    254a:	70 e0       	ldi	r23, 0x00	; 0
    254c:	80 e8       	ldi	r24, 0x80	; 128
    254e:	9f e3       	ldi	r25, 0x3F	; 63
    2550:	08 95       	ret
    2552:	4f e7       	ldi	r20, 0x7F	; 127
    2554:	9f 77       	andi	r25, 0x7F	; 127
    2556:	5f 93       	push	r21
    2558:	4f 93       	push	r20
    255a:	3f 93       	push	r19
    255c:	2f 93       	push	r18
    255e:	80 d0       	rcall	.+256    	; 0x2660 <log>
    2560:	2f 91       	pop	r18
    2562:	3f 91       	pop	r19
    2564:	4f 91       	pop	r20
    2566:	5f 91       	pop	r21
    2568:	52 df       	rcall	.-348    	; 0x240e <__mulsf3>
    256a:	05 c0       	rjmp	.+10     	; 0x2576 <exp>
    256c:	19 f4       	brne	.+6      	; 0x2574 <pow+0xa0>
    256e:	0e f0       	brts	.+2      	; 0x2572 <pow+0x9e>
    2570:	d1 ce       	rjmp	.-606    	; 0x2314 <__fp_inf>
    2572:	3f cf       	rjmp	.-386    	; 0x23f2 <__fp_zero>
    2574:	d5 ce       	rjmp	.-598    	; 0x2320 <__fp_nan>

00002576 <exp>:
    2576:	23 df       	rcall	.-442    	; 0x23be <__fp_splitA>
    2578:	c8 f3       	brcs	.-14     	; 0x256c <pow+0x98>
    257a:	96 38       	cpi	r25, 0x86	; 134
    257c:	c0 f7       	brcc	.-16     	; 0x256e <pow+0x9a>
    257e:	07 f8       	bld	r0, 7
    2580:	0f 92       	push	r0
    2582:	e8 94       	clt
    2584:	2b e3       	ldi	r18, 0x3B	; 59
    2586:	3a ea       	ldi	r19, 0xAA	; 170
    2588:	48 eb       	ldi	r20, 0xB8	; 184
    258a:	5f e7       	ldi	r21, 0x7F	; 127
    258c:	4e df       	rcall	.-356    	; 0x242a <__mulsf3_pse>
    258e:	0f 92       	push	r0
    2590:	0f 92       	push	r0
    2592:	0f 92       	push	r0
    2594:	4d b7       	in	r20, 0x3d	; 61
    2596:	5e b7       	in	r21, 0x3e	; 62
    2598:	0f 92       	push	r0
    259a:	a2 d0       	rcall	.+324    	; 0x26e0 <modf>
    259c:	e6 e7       	ldi	r30, 0x76	; 118
    259e:	f2 e0       	ldi	r31, 0x02	; 2
    25a0:	c2 de       	rcall	.-636    	; 0x2326 <__fp_powser>
    25a2:	4f 91       	pop	r20
    25a4:	5f 91       	pop	r21
    25a6:	ef 91       	pop	r30
    25a8:	ff 91       	pop	r31
    25aa:	e5 95       	asr	r30
    25ac:	ee 1f       	adc	r30, r30
    25ae:	ff 1f       	adc	r31, r31
    25b0:	49 f0       	breq	.+18     	; 0x25c4 <exp+0x4e>
    25b2:	fe 57       	subi	r31, 0x7E	; 126
    25b4:	e0 68       	ori	r30, 0x80	; 128
    25b6:	44 27       	eor	r20, r20
    25b8:	ee 0f       	add	r30, r30
    25ba:	44 1f       	adc	r20, r20
    25bc:	fa 95       	dec	r31
    25be:	e1 f7       	brne	.-8      	; 0x25b8 <exp+0x42>
    25c0:	41 95       	neg	r20
    25c2:	55 0b       	sbc	r21, r21
    25c4:	14 d0       	rcall	.+40     	; 0x25ee <ldexp>
    25c6:	0f 90       	pop	r0
    25c8:	07 fe       	sbrs	r0, 7
    25ca:	1a cf       	rjmp	.-460    	; 0x2400 <inverse>
    25cc:	08 95       	ret

000025ce <__fp_mpack>:
    25ce:	9f 3f       	cpi	r25, 0xFF	; 255
    25d0:	31 f0       	breq	.+12     	; 0x25de <__fp_mpack_finite+0xc>

000025d2 <__fp_mpack_finite>:
    25d2:	91 50       	subi	r25, 0x01	; 1
    25d4:	20 f4       	brcc	.+8      	; 0x25de <__fp_mpack_finite+0xc>
    25d6:	87 95       	ror	r24
    25d8:	77 95       	ror	r23
    25da:	67 95       	ror	r22
    25dc:	b7 95       	ror	r27
    25de:	88 0f       	add	r24, r24
    25e0:	91 1d       	adc	r25, r1
    25e2:	96 95       	lsr	r25
    25e4:	87 95       	ror	r24
    25e6:	97 f9       	bld	r25, 7
    25e8:	08 95       	ret
    25ea:	94 ce       	rjmp	.-728    	; 0x2314 <__fp_inf>
    25ec:	f0 cf       	rjmp	.-32     	; 0x25ce <__fp_mpack>

000025ee <ldexp>:
    25ee:	e7 de       	rcall	.-562    	; 0x23be <__fp_splitA>
    25f0:	e8 f3       	brcs	.-6      	; 0x25ec <__fp_mpack_finite+0x1a>
    25f2:	99 23       	and	r25, r25
    25f4:	d9 f3       	breq	.-10     	; 0x25ec <__fp_mpack_finite+0x1a>
    25f6:	94 0f       	add	r25, r20
    25f8:	51 1d       	adc	r21, r1
    25fa:	bb f3       	brvs	.-18     	; 0x25ea <__fp_mpack_finite+0x18>
    25fc:	91 50       	subi	r25, 0x01	; 1
    25fe:	50 40       	sbci	r21, 0x00	; 0
    2600:	94 f0       	brlt	.+36     	; 0x2626 <ldexp+0x38>
    2602:	59 f0       	breq	.+22     	; 0x261a <ldexp+0x2c>
    2604:	88 23       	and	r24, r24
    2606:	32 f0       	brmi	.+12     	; 0x2614 <ldexp+0x26>
    2608:	66 0f       	add	r22, r22
    260a:	77 1f       	adc	r23, r23
    260c:	88 1f       	adc	r24, r24
    260e:	91 50       	subi	r25, 0x01	; 1
    2610:	50 40       	sbci	r21, 0x00	; 0
    2612:	c1 f7       	brne	.-16     	; 0x2604 <ldexp+0x16>
    2614:	9e 3f       	cpi	r25, 0xFE	; 254
    2616:	51 05       	cpc	r21, r1
    2618:	44 f7       	brge	.-48     	; 0x25ea <__fp_mpack_finite+0x18>
    261a:	88 0f       	add	r24, r24
    261c:	91 1d       	adc	r25, r1
    261e:	96 95       	lsr	r25
    2620:	87 95       	ror	r24
    2622:	97 f9       	bld	r25, 7
    2624:	08 95       	ret
    2626:	5f 3f       	cpi	r21, 0xFF	; 255
    2628:	ac f0       	brlt	.+42     	; 0x2654 <ldexp+0x66>
    262a:	98 3e       	cpi	r25, 0xE8	; 232
    262c:	9c f0       	brlt	.+38     	; 0x2654 <ldexp+0x66>
    262e:	bb 27       	eor	r27, r27
    2630:	86 95       	lsr	r24
    2632:	77 95       	ror	r23
    2634:	67 95       	ror	r22
    2636:	b7 95       	ror	r27
    2638:	08 f4       	brcc	.+2      	; 0x263c <ldexp+0x4e>
    263a:	b1 60       	ori	r27, 0x01	; 1
    263c:	93 95       	inc	r25
    263e:	c1 f7       	brne	.-16     	; 0x2630 <ldexp+0x42>
    2640:	bb 0f       	add	r27, r27
    2642:	58 f7       	brcc	.-42     	; 0x261a <ldexp+0x2c>
    2644:	11 f4       	brne	.+4      	; 0x264a <ldexp+0x5c>
    2646:	60 ff       	sbrs	r22, 0
    2648:	e8 cf       	rjmp	.-48     	; 0x261a <ldexp+0x2c>
    264a:	6f 5f       	subi	r22, 0xFF	; 255
    264c:	7f 4f       	sbci	r23, 0xFF	; 255
    264e:	8f 4f       	sbci	r24, 0xFF	; 255
    2650:	9f 4f       	sbci	r25, 0xFF	; 255
    2652:	e3 cf       	rjmp	.-58     	; 0x261a <ldexp+0x2c>
    2654:	cf ce       	rjmp	.-610    	; 0x23f4 <__fp_szero>
    2656:	0e f0       	brts	.+2      	; 0x265a <ldexp+0x6c>
    2658:	ba cf       	rjmp	.-140    	; 0x25ce <__fp_mpack>
    265a:	62 ce       	rjmp	.-828    	; 0x2320 <__fp_nan>
    265c:	68 94       	set
    265e:	5a ce       	rjmp	.-844    	; 0x2314 <__fp_inf>

00002660 <log>:
    2660:	ae de       	rcall	.-676    	; 0x23be <__fp_splitA>
    2662:	c8 f3       	brcs	.-14     	; 0x2656 <ldexp+0x68>
    2664:	99 23       	and	r25, r25
    2666:	d1 f3       	breq	.-12     	; 0x265c <ldexp+0x6e>
    2668:	c6 f3       	brts	.-16     	; 0x265a <ldexp+0x6c>
    266a:	df 93       	push	r29
    266c:	cf 93       	push	r28
    266e:	1f 93       	push	r17
    2670:	0f 93       	push	r16
    2672:	ff 92       	push	r15
    2674:	c9 2f       	mov	r28, r25
    2676:	dd 27       	eor	r29, r29
    2678:	88 23       	and	r24, r24
    267a:	2a f0       	brmi	.+10     	; 0x2686 <log+0x26>
    267c:	21 97       	sbiw	r28, 0x01	; 1
    267e:	66 0f       	add	r22, r22
    2680:	77 1f       	adc	r23, r23
    2682:	88 1f       	adc	r24, r24
    2684:	da f7       	brpl	.-10     	; 0x267c <log+0x1c>
    2686:	20 e0       	ldi	r18, 0x00	; 0
    2688:	30 e0       	ldi	r19, 0x00	; 0
    268a:	40 e8       	ldi	r20, 0x80	; 128
    268c:	5f eb       	ldi	r21, 0xBF	; 191
    268e:	9f e3       	ldi	r25, 0x3F	; 63
    2690:	88 39       	cpi	r24, 0x98	; 152
    2692:	20 f0       	brcs	.+8      	; 0x269c <log+0x3c>
    2694:	80 3e       	cpi	r24, 0xE0	; 224
    2696:	30 f0       	brcs	.+12     	; 0x26a4 <log+0x44>
    2698:	21 96       	adiw	r28, 0x01	; 1
    269a:	8f 77       	andi	r24, 0x7F	; 127
    269c:	01 dd       	rcall	.-1534   	; 0x20a0 <__addsf3>
    269e:	ee e9       	ldi	r30, 0x9E	; 158
    26a0:	f2 e0       	ldi	r31, 0x02	; 2
    26a2:	03 c0       	rjmp	.+6      	; 0x26aa <log+0x4a>
    26a4:	fd dc       	rcall	.-1542   	; 0x20a0 <__addsf3>
    26a6:	eb ec       	ldi	r30, 0xCB	; 203
    26a8:	f2 e0       	ldi	r31, 0x02	; 2
    26aa:	3d de       	rcall	.-902    	; 0x2326 <__fp_powser>
    26ac:	8b 01       	movw	r16, r22
    26ae:	be 01       	movw	r22, r28
    26b0:	ec 01       	movw	r28, r24
    26b2:	fb 2e       	mov	r15, r27
    26b4:	6f 57       	subi	r22, 0x7F	; 127
    26b6:	71 09       	sbc	r23, r1
    26b8:	75 95       	asr	r23
    26ba:	77 1f       	adc	r23, r23
    26bc:	88 0b       	sbc	r24, r24
    26be:	99 0b       	sbc	r25, r25
    26c0:	ee dd       	rcall	.-1060   	; 0x229e <__floatsisf>
    26c2:	28 e1       	ldi	r18, 0x18	; 24
    26c4:	32 e7       	ldi	r19, 0x72	; 114
    26c6:	41 e3       	ldi	r20, 0x31	; 49
    26c8:	5f e3       	ldi	r21, 0x3F	; 63
    26ca:	ad de       	rcall	.-678    	; 0x2426 <__mulsf3x>
    26cc:	af 2d       	mov	r26, r15
    26ce:	98 01       	movw	r18, r16
    26d0:	ae 01       	movw	r20, r28
    26d2:	ff 90       	pop	r15
    26d4:	0f 91       	pop	r16
    26d6:	1f 91       	pop	r17
    26d8:	cf 91       	pop	r28
    26da:	df 91       	pop	r29
    26dc:	f2 dc       	rcall	.-1564   	; 0x20c2 <__addsf3x>
    26de:	56 ce       	rjmp	.-852    	; 0x238c <__fp_round>

000026e0 <modf>:
    26e0:	fa 01       	movw	r30, r20
    26e2:	dc 01       	movw	r26, r24
    26e4:	aa 0f       	add	r26, r26
    26e6:	bb 1f       	adc	r27, r27
    26e8:	9b 01       	movw	r18, r22
    26ea:	ac 01       	movw	r20, r24
    26ec:	bf 57       	subi	r27, 0x7F	; 127
    26ee:	28 f4       	brcc	.+10     	; 0x26fa <modf+0x1a>
    26f0:	22 27       	eor	r18, r18
    26f2:	33 27       	eor	r19, r19
    26f4:	44 27       	eor	r20, r20
    26f6:	50 78       	andi	r21, 0x80	; 128
    26f8:	1f c0       	rjmp	.+62     	; 0x2738 <modf+0x58>
    26fa:	b7 51       	subi	r27, 0x17	; 23
    26fc:	88 f4       	brcc	.+34     	; 0x2720 <modf+0x40>
    26fe:	ab 2f       	mov	r26, r27
    2700:	00 24       	eor	r0, r0
    2702:	46 95       	lsr	r20
    2704:	37 95       	ror	r19
    2706:	27 95       	ror	r18
    2708:	01 1c       	adc	r0, r1
    270a:	a3 95       	inc	r26
    270c:	d2 f3       	brmi	.-12     	; 0x2702 <modf+0x22>
    270e:	00 20       	and	r0, r0
    2710:	69 f0       	breq	.+26     	; 0x272c <modf+0x4c>
    2712:	22 0f       	add	r18, r18
    2714:	33 1f       	adc	r19, r19
    2716:	44 1f       	adc	r20, r20
    2718:	b3 95       	inc	r27
    271a:	da f3       	brmi	.-10     	; 0x2712 <modf+0x32>
    271c:	0d d0       	rcall	.+26     	; 0x2738 <modf+0x58>
    271e:	bf cc       	rjmp	.-1666   	; 0x209e <__subsf3>
    2720:	61 30       	cpi	r22, 0x01	; 1
    2722:	71 05       	cpc	r23, r1
    2724:	a0 e8       	ldi	r26, 0x80	; 128
    2726:	8a 07       	cpc	r24, r26
    2728:	b9 46       	sbci	r27, 0x69	; 105
    272a:	30 f4       	brcc	.+12     	; 0x2738 <modf+0x58>
    272c:	9b 01       	movw	r18, r22
    272e:	ac 01       	movw	r20, r24
    2730:	66 27       	eor	r22, r22
    2732:	77 27       	eor	r23, r23
    2734:	88 27       	eor	r24, r24
    2736:	90 78       	andi	r25, 0x80	; 128
    2738:	30 96       	adiw	r30, 0x00	; 0
    273a:	21 f0       	breq	.+8      	; 0x2744 <modf+0x64>
    273c:	20 83       	st	Z, r18
    273e:	31 83       	std	Z+1, r19	; 0x01
    2740:	42 83       	std	Z+2, r20	; 0x02
    2742:	53 83       	std	Z+3, r21	; 0x03
    2744:	08 95       	ret

00002746 <_ZN14HardwareSerial9availableEv>:
#endif
#if defined(HAVE_HWSERIAL2)
  if (Serial2_available && serialEvent2 && Serial2_available()) serialEvent2();
#endif
#if defined(HAVE_HWSERIAL3)
  if (Serial3_available && serialEvent3 && Serial3_available()) serialEvent3();
    2746:	fc 01       	movw	r30, r24
    2748:	81 8d       	ldd	r24, Z+25	; 0x19
    274a:	22 8d       	ldd	r18, Z+26	; 0x1a
    274c:	90 e0       	ldi	r25, 0x00	; 0
    274e:	80 5c       	subi	r24, 0xC0	; 192
    2750:	9f 4f       	sbci	r25, 0xFF	; 255
    2752:	82 1b       	sub	r24, r18
    2754:	91 09       	sbc	r25, r1
    2756:	8f 73       	andi	r24, 0x3F	; 63
    2758:	99 27       	eor	r25, r25
    275a:	08 95       	ret

0000275c <_ZN14HardwareSerial4peekEv>:
    275c:	fc 01       	movw	r30, r24
    275e:	91 8d       	ldd	r25, Z+25	; 0x19
    2760:	82 8d       	ldd	r24, Z+26	; 0x1a
    2762:	98 17       	cp	r25, r24
    2764:	31 f0       	breq	.+12     	; 0x2772 <_ZN14HardwareSerial4peekEv+0x16>
    2766:	82 8d       	ldd	r24, Z+26	; 0x1a
    2768:	e8 0f       	add	r30, r24
    276a:	f1 1d       	adc	r31, r1
    276c:	85 8d       	ldd	r24, Z+29	; 0x1d
    276e:	90 e0       	ldi	r25, 0x00	; 0
    2770:	08 95       	ret
    2772:	8f ef       	ldi	r24, 0xFF	; 255
    2774:	9f ef       	ldi	r25, 0xFF	; 255
    2776:	08 95       	ret

00002778 <_ZN14HardwareSerial4readEv>:
    2778:	fc 01       	movw	r30, r24
    277a:	91 8d       	ldd	r25, Z+25	; 0x19
    277c:	82 8d       	ldd	r24, Z+26	; 0x1a
    277e:	98 17       	cp	r25, r24
    2780:	61 f0       	breq	.+24     	; 0x279a <_ZN14HardwareSerial4readEv+0x22>
    2782:	82 8d       	ldd	r24, Z+26	; 0x1a
    2784:	df 01       	movw	r26, r30
    2786:	a8 0f       	add	r26, r24
    2788:	b1 1d       	adc	r27, r1
    278a:	5d 96       	adiw	r26, 0x1d	; 29
    278c:	8c 91       	ld	r24, X
    278e:	92 8d       	ldd	r25, Z+26	; 0x1a
    2790:	9f 5f       	subi	r25, 0xFF	; 255
    2792:	9f 73       	andi	r25, 0x3F	; 63
    2794:	92 8f       	std	Z+26, r25	; 0x1a
    2796:	90 e0       	ldi	r25, 0x00	; 0
    2798:	08 95       	ret
    279a:	8f ef       	ldi	r24, 0xFF	; 255
    279c:	9f ef       	ldi	r25, 0xFF	; 255
    279e:	08 95       	ret

000027a0 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
}

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
    27a0:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
    27a2:	84 8d       	ldd	r24, Z+28	; 0x1c
    27a4:	df 01       	movw	r26, r30
    27a6:	a8 0f       	add	r26, r24
    27a8:	b1 1d       	adc	r27, r1
    27aa:	a3 5a       	subi	r26, 0xA3	; 163
    27ac:	bf 4f       	sbci	r27, 0xFF	; 255
    27ae:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
    27b0:	84 8d       	ldd	r24, Z+28	; 0x1c
    27b2:	90 e0       	ldi	r25, 0x00	; 0
    27b4:	01 96       	adiw	r24, 0x01	; 1
    27b6:	8f 73       	andi	r24, 0x3F	; 63
    27b8:	90 78       	andi	r25, 0x80	; 128
    27ba:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
    27bc:	a6 89       	ldd	r26, Z+22	; 0x16
    27be:	b7 89       	ldd	r27, Z+23	; 0x17
    27c0:	2c 93       	st	X, r18

  // clear the TXC bit -- "can be cleared by writing a one to its bit
  // location". This makes sure flush() won't return until the bytes
  // actually got written
  sbi(*_ucsra, TXC0);
    27c2:	a0 89       	ldd	r26, Z+16	; 0x10
    27c4:	b1 89       	ldd	r27, Z+17	; 0x11
    27c6:	8c 91       	ld	r24, X
    27c8:	80 64       	ori	r24, 0x40	; 64
    27ca:	8c 93       	st	X, r24

  if (_tx_buffer_head == _tx_buffer_tail) {
    27cc:	93 8d       	ldd	r25, Z+27	; 0x1b
    27ce:	84 8d       	ldd	r24, Z+28	; 0x1c
    27d0:	98 13       	cpse	r25, r24
    27d2:	06 c0       	rjmp	.+12     	; 0x27e0 <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x40>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
    27d4:	02 88       	ldd	r0, Z+18	; 0x12
    27d6:	f3 89       	ldd	r31, Z+19	; 0x13
    27d8:	e0 2d       	mov	r30, r0
    27da:	80 81       	ld	r24, Z
    27dc:	8f 7d       	andi	r24, 0xDF	; 223
    27de:	80 83       	st	Z, r24
    27e0:	08 95       	ret

000027e2 <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
    27e2:	cf 93       	push	r28
    27e4:	df 93       	push	r29
    27e6:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    27e8:	88 8d       	ldd	r24, Y+24	; 0x18
    27ea:	81 11       	cpse	r24, r1
    27ec:	0a c0       	rjmp	.+20     	; 0x2802 <_ZN14HardwareSerial5flushEv+0x20>
    27ee:	1a c0       	rjmp	.+52     	; 0x2824 <_ZN14HardwareSerial5flushEv+0x42>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
    27f0:	0f b6       	in	r0, 0x3f	; 63
    27f2:	07 fc       	sbrc	r0, 7
    27f4:	08 c0       	rjmp	.+16     	; 0x2806 <_ZN14HardwareSerial5flushEv+0x24>
    27f6:	80 81       	ld	r24, Z
    27f8:	85 ff       	sbrs	r24, 5
    27fa:	05 c0       	rjmp	.+10     	; 0x2806 <_ZN14HardwareSerial5flushEv+0x24>
    27fc:	0d c0       	rjmp	.+26     	; 0x2818 <_ZN14HardwareSerial5flushEv+0x36>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
	  _tx_udr_empty_irq();
    27fe:	ce 01       	movw	r24, r28
    2800:	cf df       	rcall	.-98     	; 0x27a0 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    2802:	ea 89       	ldd	r30, Y+18	; 0x12
    2804:	fb 89       	ldd	r31, Y+19	; 0x13
    2806:	80 81       	ld	r24, Z
    2808:	85 fd       	sbrc	r24, 5
    280a:	f2 cf       	rjmp	.-28     	; 0x27f0 <_ZN14HardwareSerial5flushEv+0xe>
    280c:	a8 89       	ldd	r26, Y+16	; 0x10
    280e:	b9 89       	ldd	r27, Y+17	; 0x11
    2810:	8c 91       	ld	r24, X
    2812:	86 ff       	sbrs	r24, 6
    2814:	ed cf       	rjmp	.-38     	; 0x27f0 <_ZN14HardwareSerial5flushEv+0xe>
    2816:	06 c0       	rjmp	.+12     	; 0x2824 <_ZN14HardwareSerial5flushEv+0x42>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
    2818:	a8 89       	ldd	r26, Y+16	; 0x10
    281a:	b9 89       	ldd	r27, Y+17	; 0x11
    281c:	8c 91       	ld	r24, X
    281e:	85 ff       	sbrs	r24, 5
    2820:	f2 cf       	rjmp	.-28     	; 0x2806 <_ZN14HardwareSerial5flushEv+0x24>
    2822:	ed cf       	rjmp	.-38     	; 0x27fe <_ZN14HardwareSerial5flushEv+0x1c>
	  _tx_udr_empty_irq();
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
    2824:	df 91       	pop	r29
    2826:	cf 91       	pop	r28
    2828:	08 95       	ret

0000282a <_ZN14HardwareSerial5writeEh>:

size_t HardwareSerial::write(uint8_t c)
{
    282a:	0f 93       	push	r16
    282c:	1f 93       	push	r17
    282e:	cf 93       	push	r28
    2830:	df 93       	push	r29
    2832:	ec 01       	movw	r28, r24
    2834:	16 2f       	mov	r17, r22
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    2836:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2838:	8c 8d       	ldd	r24, Y+28	; 0x1c
    283a:	98 13       	cpse	r25, r24
    283c:	23 c0       	rjmp	.+70     	; 0x2884 <_ZN14HardwareSerial5writeEh+0x5a>
    283e:	e8 89       	ldd	r30, Y+16	; 0x10
    2840:	f9 89       	ldd	r31, Y+17	; 0x11
    2842:	80 81       	ld	r24, Z
    2844:	85 fd       	sbrc	r24, 5
    2846:	25 c0       	rjmp	.+74     	; 0x2892 <_ZN14HardwareSerial5writeEh+0x68>
    2848:	1d c0       	rjmp	.+58     	; 0x2884 <_ZN14HardwareSerial5writeEh+0x5a>
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    if (bit_is_clear(SREG, SREG_I)) {
    284a:	0f b6       	in	r0, 0x3f	; 63
    284c:	07 fc       	sbrc	r0, 7
    284e:	07 c0       	rjmp	.+14     	; 0x285e <_ZN14HardwareSerial5writeEh+0x34>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
    2850:	e8 89       	ldd	r30, Y+16	; 0x10
    2852:	f9 89       	ldd	r31, Y+17	; 0x11
    2854:	80 81       	ld	r24, Z
    2856:	85 ff       	sbrs	r24, 5
    2858:	02 c0       	rjmp	.+4      	; 0x285e <_ZN14HardwareSerial5writeEh+0x34>
	_tx_udr_empty_irq();
    285a:	ce 01       	movw	r24, r28
    285c:	a1 df       	rcall	.-190    	; 0x27a0 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    285e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2860:	09 17       	cp	r16, r25
    2862:	99 f3       	breq	.-26     	; 0x284a <_ZN14HardwareSerial5writeEh+0x20>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
    2864:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2866:	fe 01       	movw	r30, r28
    2868:	e8 0f       	add	r30, r24
    286a:	f1 1d       	adc	r31, r1
    286c:	e3 5a       	subi	r30, 0xA3	; 163
    286e:	ff 4f       	sbci	r31, 0xFF	; 255
    2870:	10 83       	st	Z, r17
  _tx_buffer_head = i;
    2872:	0b 8f       	std	Y+27, r16	; 0x1b
	
  sbi(*_ucsrb, UDRIE0);
    2874:	ea 89       	ldd	r30, Y+18	; 0x12
    2876:	fb 89       	ldd	r31, Y+19	; 0x13
    2878:	80 81       	ld	r24, Z
    287a:	80 62       	ori	r24, 0x20	; 32
    287c:	80 83       	st	Z, r24
  _written = true;
    287e:	81 e0       	ldi	r24, 0x01	; 1
    2880:	88 8f       	std	Y+24, r24	; 0x18
  
  return 1;
    2882:	0f c0       	rjmp	.+30     	; 0x28a2 <_ZN14HardwareSerial5writeEh+0x78>
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    *_udr = c;
    sbi(*_ucsra, TXC0);
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
    2884:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2886:	90 e0       	ldi	r25, 0x00	; 0
    2888:	01 96       	adiw	r24, 0x01	; 1
    288a:	8f 73       	andi	r24, 0x3F	; 63
    288c:	90 78       	andi	r25, 0x80	; 128
    288e:	08 2f       	mov	r16, r24
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    2890:	e6 cf       	rjmp	.-52     	; 0x285e <_ZN14HardwareSerial5writeEh+0x34>
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    *_udr = c;
    2892:	ee 89       	ldd	r30, Y+22	; 0x16
    2894:	ff 89       	ldd	r31, Y+23	; 0x17
    2896:	60 83       	st	Z, r22
    sbi(*_ucsra, TXC0);
    2898:	e8 89       	ldd	r30, Y+16	; 0x10
    289a:	f9 89       	ldd	r31, Y+17	; 0x11
    289c:	80 81       	ld	r24, Z
    289e:	80 64       	ori	r24, 0x40	; 64
    28a0:	80 83       	st	Z, r24
	
  sbi(*_ucsrb, UDRIE0);
  _written = true;
  
  return 1;
}
    28a2:	81 e0       	ldi	r24, 0x01	; 1
    28a4:	90 e0       	ldi	r25, 0x00	; 0
    28a6:	df 91       	pop	r29
    28a8:	cf 91       	pop	r28
    28aa:	1f 91       	pop	r17
    28ac:	0f 91       	pop	r16
    28ae:	08 95       	ret

000028b0 <_ZN14HardwareSerial5beginEmh>:
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
    28b0:	cf 92       	push	r12
    28b2:	df 92       	push	r13
    28b4:	ef 92       	push	r14
    28b6:	ff 92       	push	r15
    28b8:	1f 93       	push	r17
    28ba:	cf 93       	push	r28
    28bc:	df 93       	push	r29
    28be:	ec 01       	movw	r28, r24
    28c0:	6a 01       	movw	r12, r20
    28c2:	7b 01       	movw	r14, r22
    28c4:	12 2f       	mov	r17, r18
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
    28c6:	e8 89       	ldd	r30, Y+16	; 0x10
    28c8:	f9 89       	ldd	r31, Y+17	; 0x11
    28ca:	82 e0       	ldi	r24, 0x02	; 2
    28cc:	80 83       	st	Z, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    28ce:	41 15       	cp	r20, r1
    28d0:	81 ee       	ldi	r24, 0xE1	; 225
    28d2:	58 07       	cpc	r21, r24
    28d4:	61 05       	cpc	r22, r1
    28d6:	71 05       	cpc	r23, r1
    28d8:	a9 f0       	breq	.+42     	; 0x2904 <_ZN14HardwareSerial5beginEmh+0x54>
// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
    28da:	60 e0       	ldi	r22, 0x00	; 0
    28dc:	79 e0       	ldi	r23, 0x09	; 9
    28de:	8d e3       	ldi	r24, 0x3D	; 61
    28e0:	90 e0       	ldi	r25, 0x00	; 0
    28e2:	a7 01       	movw	r20, r14
    28e4:	96 01       	movw	r18, r12
    28e6:	5a d3       	rcall	.+1716   	; 0x2f9c <__udivmodsi4>
    28e8:	ba 01       	movw	r22, r20
    28ea:	a9 01       	movw	r20, r18
    28ec:	41 50       	subi	r20, 0x01	; 1
    28ee:	51 09       	sbc	r21, r1
    28f0:	61 09       	sbc	r22, r1
    28f2:	71 09       	sbc	r23, r1
    28f4:	76 95       	lsr	r23
    28f6:	67 95       	ror	r22
    28f8:	57 95       	ror	r21
    28fa:	47 95       	ror	r20
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    28fc:	41 15       	cp	r20, r1
    28fe:	80 e1       	ldi	r24, 0x10	; 16
    2900:	58 07       	cpc	r21, r24
    2902:	a0 f0       	brcs	.+40     	; 0x292c <_ZN14HardwareSerial5beginEmh+0x7c>
  {
    *_ucsra = 0;
    2904:	e8 89       	ldd	r30, Y+16	; 0x10
    2906:	f9 89       	ldd	r31, Y+17	; 0x11
    2908:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
    290a:	60 e8       	ldi	r22, 0x80	; 128
    290c:	74 e8       	ldi	r23, 0x84	; 132
    290e:	8e e1       	ldi	r24, 0x1E	; 30
    2910:	90 e0       	ldi	r25, 0x00	; 0
    2912:	a7 01       	movw	r20, r14
    2914:	96 01       	movw	r18, r12
    2916:	42 d3       	rcall	.+1668   	; 0x2f9c <__udivmodsi4>
    2918:	ba 01       	movw	r22, r20
    291a:	a9 01       	movw	r20, r18
    291c:	41 50       	subi	r20, 0x01	; 1
    291e:	51 09       	sbc	r21, r1
    2920:	61 09       	sbc	r22, r1
    2922:	71 09       	sbc	r23, r1
    2924:	76 95       	lsr	r23
    2926:	67 95       	ror	r22
    2928:	57 95       	ror	r21
    292a:	47 95       	ror	r20
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
    292c:	ec 85       	ldd	r30, Y+12	; 0x0c
    292e:	fd 85       	ldd	r31, Y+13	; 0x0d
    2930:	50 83       	st	Z, r21
  *_ubrrl = baud_setting;
    2932:	ee 85       	ldd	r30, Y+14	; 0x0e
    2934:	ff 85       	ldd	r31, Y+15	; 0x0f
    2936:	40 83       	st	Z, r20

  _written = false;
    2938:	18 8e       	std	Y+24, r1	; 0x18

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
    293a:	ec 89       	ldd	r30, Y+20	; 0x14
    293c:	fd 89       	ldd	r31, Y+21	; 0x15
    293e:	10 83       	st	Z, r17
  
  sbi(*_ucsrb, RXEN0);
    2940:	ea 89       	ldd	r30, Y+18	; 0x12
    2942:	fb 89       	ldd	r31, Y+19	; 0x13
    2944:	80 81       	ld	r24, Z
    2946:	80 61       	ori	r24, 0x10	; 16
    2948:	80 83       	st	Z, r24
  sbi(*_ucsrb, TXEN0);
    294a:	ea 89       	ldd	r30, Y+18	; 0x12
    294c:	fb 89       	ldd	r31, Y+19	; 0x13
    294e:	80 81       	ld	r24, Z
    2950:	88 60       	ori	r24, 0x08	; 8
    2952:	80 83       	st	Z, r24
  sbi(*_ucsrb, RXCIE0);
    2954:	ea 89       	ldd	r30, Y+18	; 0x12
    2956:	fb 89       	ldd	r31, Y+19	; 0x13
    2958:	80 81       	ld	r24, Z
    295a:	80 68       	ori	r24, 0x80	; 128
    295c:	80 83       	st	Z, r24
  cbi(*_ucsrb, UDRIE0);
    295e:	ea 89       	ldd	r30, Y+18	; 0x12
    2960:	fb 89       	ldd	r31, Y+19	; 0x13
    2962:	80 81       	ld	r24, Z
    2964:	8f 7d       	andi	r24, 0xDF	; 223
    2966:	80 83       	st	Z, r24
}
    2968:	df 91       	pop	r29
    296a:	cf 91       	pop	r28
    296c:	1f 91       	pop	r17
    296e:	ff 90       	pop	r15
    2970:	ef 90       	pop	r14
    2972:	df 90       	pop	r13
    2974:	cf 90       	pop	r12
    2976:	08 95       	ret

00002978 <__vector_25>:

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
}
    2978:	1f 92       	push	r1
    297a:	0f 92       	push	r0
    297c:	0f b6       	in	r0, 0x3f	; 63
    297e:	0f 92       	push	r0
    2980:	11 24       	eor	r1, r1
    2982:	0b b6       	in	r0, 0x3b	; 59
    2984:	0f 92       	push	r0
    2986:	2f 93       	push	r18
    2988:	8f 93       	push	r24
    298a:	9f 93       	push	r25
    298c:	af 93       	push	r26
    298e:	bf 93       	push	r27
    2990:	ef 93       	push	r30
    2992:	ff 93       	push	r31
    2994:	e0 91 66 0e 	lds	r30, 0x0E66
    2998:	f0 91 67 0e 	lds	r31, 0x0E67
    299c:	80 81       	ld	r24, Z
    299e:	82 fd       	sbrc	r24, 2
    29a0:	17 c0       	rjmp	.+46     	; 0x29d0 <__vector_25+0x58>
    29a2:	e0 91 6c 0e 	lds	r30, 0x0E6C
    29a6:	f0 91 6d 0e 	lds	r31, 0x0E6D
    29aa:	20 81       	ld	r18, Z
    29ac:	80 91 6f 0e 	lds	r24, 0x0E6F
    29b0:	8f 5f       	subi	r24, 0xFF	; 255
    29b2:	8f 73       	andi	r24, 0x3F	; 63
    29b4:	90 91 70 0e 	lds	r25, 0x0E70
    29b8:	89 17       	cp	r24, r25
    29ba:	79 f0       	breq	.+30     	; 0x29da <__vector_25+0x62>
    29bc:	ef e6       	ldi	r30, 0x6F	; 111
    29be:	fe e0       	ldi	r31, 0x0E	; 14
    29c0:	a0 81       	ld	r26, Z
    29c2:	b0 e0       	ldi	r27, 0x00	; 0
    29c4:	aa 5a       	subi	r26, 0xAA	; 170
    29c6:	b1 4f       	sbci	r27, 0xF1	; 241
    29c8:	5d 96       	adiw	r26, 0x1d	; 29
    29ca:	2c 93       	st	X, r18
    29cc:	80 83       	st	Z, r24
    29ce:	05 c0       	rjmp	.+10     	; 0x29da <__vector_25+0x62>
    29d0:	e0 91 6c 0e 	lds	r30, 0x0E6C
    29d4:	f0 91 6d 0e 	lds	r31, 0x0E6D
    29d8:	80 81       	ld	r24, Z
    29da:	ff 91       	pop	r31
    29dc:	ef 91       	pop	r30
    29de:	bf 91       	pop	r27
    29e0:	af 91       	pop	r26
    29e2:	9f 91       	pop	r25
    29e4:	8f 91       	pop	r24
    29e6:	2f 91       	pop	r18
    29e8:	0f 90       	pop	r0
    29ea:	0b be       	out	0x3b, r0	; 59
    29ec:	0f 90       	pop	r0
    29ee:	0f be       	out	0x3f, r0	; 63
    29f0:	0f 90       	pop	r0
    29f2:	1f 90       	pop	r1
    29f4:	18 95       	reti

000029f6 <__vector_26>:
    29f6:	1f 92       	push	r1
    29f8:	0f 92       	push	r0
    29fa:	0f b6       	in	r0, 0x3f	; 63
    29fc:	0f 92       	push	r0
    29fe:	11 24       	eor	r1, r1
    2a00:	0b b6       	in	r0, 0x3b	; 59
    2a02:	0f 92       	push	r0
    2a04:	2f 93       	push	r18
    2a06:	3f 93       	push	r19
    2a08:	4f 93       	push	r20
    2a0a:	5f 93       	push	r21
    2a0c:	6f 93       	push	r22
    2a0e:	7f 93       	push	r23
    2a10:	8f 93       	push	r24
    2a12:	9f 93       	push	r25
    2a14:	af 93       	push	r26
    2a16:	bf 93       	push	r27
    2a18:	ef 93       	push	r30
    2a1a:	ff 93       	push	r31
    2a1c:	86 e5       	ldi	r24, 0x56	; 86
    2a1e:	9e e0       	ldi	r25, 0x0E	; 14
    2a20:	bf de       	rcall	.-642    	; 0x27a0 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    2a22:	ff 91       	pop	r31
    2a24:	ef 91       	pop	r30
    2a26:	bf 91       	pop	r27
    2a28:	af 91       	pop	r26
    2a2a:	9f 91       	pop	r25
    2a2c:	8f 91       	pop	r24
    2a2e:	7f 91       	pop	r23
    2a30:	6f 91       	pop	r22
    2a32:	5f 91       	pop	r21
    2a34:	4f 91       	pop	r20
    2a36:	3f 91       	pop	r19
    2a38:	2f 91       	pop	r18
    2a3a:	0f 90       	pop	r0
    2a3c:	0b be       	out	0x3b, r0	; 59
    2a3e:	0f 90       	pop	r0
    2a40:	0f be       	out	0x3f, r0	; 63
    2a42:	0f 90       	pop	r0
    2a44:	1f 90       	pop	r1
    2a46:	18 95       	reti

00002a48 <_GLOBAL__sub_I___vector_25>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
    2a48:	10 92 59 0e 	sts	0x0E59, r1
    2a4c:	10 92 58 0e 	sts	0x0E58, r1
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
    2a50:	88 ee       	ldi	r24, 0xE8	; 232
    2a52:	93 e0       	ldi	r25, 0x03	; 3
    2a54:	a0 e0       	ldi	r26, 0x00	; 0
    2a56:	b0 e0       	ldi	r27, 0x00	; 0
    2a58:	80 93 5a 0e 	sts	0x0E5A, r24
    2a5c:	90 93 5b 0e 	sts	0x0E5B, r25
    2a60:	a0 93 5c 0e 	sts	0x0E5C, r26
    2a64:	b0 93 5d 0e 	sts	0x0E5D, r27
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
    2a68:	8f e9       	ldi	r24, 0x9F	; 159
    2a6a:	92 e0       	ldi	r25, 0x02	; 2
    2a6c:	90 93 57 0e 	sts	0x0E57, r25
    2a70:	80 93 56 0e 	sts	0x0E56, r24
    2a74:	85 ec       	ldi	r24, 0xC5	; 197
    2a76:	90 e0       	ldi	r25, 0x00	; 0
    2a78:	90 93 63 0e 	sts	0x0E63, r25
    2a7c:	80 93 62 0e 	sts	0x0E62, r24
    2a80:	84 ec       	ldi	r24, 0xC4	; 196
    2a82:	90 e0       	ldi	r25, 0x00	; 0
    2a84:	90 93 65 0e 	sts	0x0E65, r25
    2a88:	80 93 64 0e 	sts	0x0E64, r24
    2a8c:	80 ec       	ldi	r24, 0xC0	; 192
    2a8e:	90 e0       	ldi	r25, 0x00	; 0
    2a90:	90 93 67 0e 	sts	0x0E67, r25
    2a94:	80 93 66 0e 	sts	0x0E66, r24
    2a98:	81 ec       	ldi	r24, 0xC1	; 193
    2a9a:	90 e0       	ldi	r25, 0x00	; 0
    2a9c:	90 93 69 0e 	sts	0x0E69, r25
    2aa0:	80 93 68 0e 	sts	0x0E68, r24
    2aa4:	82 ec       	ldi	r24, 0xC2	; 194
    2aa6:	90 e0       	ldi	r25, 0x00	; 0
    2aa8:	90 93 6b 0e 	sts	0x0E6B, r25
    2aac:	80 93 6a 0e 	sts	0x0E6A, r24
    2ab0:	86 ec       	ldi	r24, 0xC6	; 198
    2ab2:	90 e0       	ldi	r25, 0x00	; 0
    2ab4:	90 93 6d 0e 	sts	0x0E6D, r25
    2ab8:	80 93 6c 0e 	sts	0x0E6C, r24
    2abc:	10 92 6f 0e 	sts	0x0E6F, r1
    2ac0:	10 92 70 0e 	sts	0x0E70, r1
    2ac4:	10 92 71 0e 	sts	0x0E71, r1
    2ac8:	10 92 72 0e 	sts	0x0E72, r1
    2acc:	08 95       	ret

00002ace <_ZN5Print5writeEPKhj>:
size_t Print::println(const String &s)
{
  size_t n = print(s);
  n += println();
  return n;
}
    2ace:	cf 92       	push	r12
    2ad0:	df 92       	push	r13
    2ad2:	ef 92       	push	r14
    2ad4:	ff 92       	push	r15
    2ad6:	0f 93       	push	r16
    2ad8:	1f 93       	push	r17
    2ada:	cf 93       	push	r28
    2adc:	df 93       	push	r29
    2ade:	6c 01       	movw	r12, r24
    2ae0:	41 15       	cp	r20, r1
    2ae2:	51 05       	cpc	r21, r1
    2ae4:	b1 f0       	breq	.+44     	; 0x2b12 <_ZN5Print5writeEPKhj+0x44>
    2ae6:	06 2f       	mov	r16, r22
    2ae8:	17 2f       	mov	r17, r23
    2aea:	ea 01       	movw	r28, r20
    2aec:	e1 2c       	mov	r14, r1
    2aee:	f1 2c       	mov	r15, r1
    2af0:	d8 01       	movw	r26, r16
    2af2:	6d 91       	ld	r22, X+
    2af4:	8d 01       	movw	r16, r26
    2af6:	d6 01       	movw	r26, r12
    2af8:	ed 91       	ld	r30, X+
    2afa:	fc 91       	ld	r31, X
    2afc:	01 90       	ld	r0, Z+
    2afe:	f0 81       	ld	r31, Z
    2b00:	e0 2d       	mov	r30, r0
    2b02:	c6 01       	movw	r24, r12
    2b04:	19 95       	eicall
    2b06:	e8 0e       	add	r14, r24
    2b08:	f9 1e       	adc	r15, r25
    2b0a:	21 97       	sbiw	r28, 0x01	; 1
    2b0c:	20 97       	sbiw	r28, 0x00	; 0
    2b0e:	81 f7       	brne	.-32     	; 0x2af0 <_ZN5Print5writeEPKhj+0x22>
    2b10:	02 c0       	rjmp	.+4      	; 0x2b16 <_ZN5Print5writeEPKhj+0x48>
    2b12:	e1 2c       	mov	r14, r1
    2b14:	f1 2c       	mov	r15, r1
    2b16:	c7 01       	movw	r24, r14
    2b18:	df 91       	pop	r29
    2b1a:	cf 91       	pop	r28
    2b1c:	1f 91       	pop	r17
    2b1e:	0f 91       	pop	r16
    2b20:	ff 90       	pop	r15
    2b22:	ef 90       	pop	r14
    2b24:	df 90       	pop	r13
    2b26:	cf 90       	pop	r12
    2b28:	08 95       	ret

00002b2a <_ZN5Print5printEPKc>:
    2b2a:	61 15       	cp	r22, r1
    2b2c:	71 05       	cpc	r23, r1
    2b2e:	81 f0       	breq	.+32     	; 0x2b50 <_ZN5Print5printEPKc+0x26>
    2b30:	fb 01       	movw	r30, r22
    2b32:	01 90       	ld	r0, Z+
    2b34:	00 20       	and	r0, r0
    2b36:	e9 f7       	brne	.-6      	; 0x2b32 <_ZN5Print5printEPKc+0x8>
    2b38:	31 97       	sbiw	r30, 0x01	; 1
    2b3a:	af 01       	movw	r20, r30
    2b3c:	46 1b       	sub	r20, r22
    2b3e:	57 0b       	sbc	r21, r23
    2b40:	dc 01       	movw	r26, r24
    2b42:	ed 91       	ld	r30, X+
    2b44:	fc 91       	ld	r31, X
    2b46:	02 80       	ldd	r0, Z+2	; 0x02
    2b48:	f3 81       	ldd	r31, Z+3	; 0x03
    2b4a:	e0 2d       	mov	r30, r0
    2b4c:	19 95       	eicall
    2b4e:	08 95       	ret
    2b50:	80 e0       	ldi	r24, 0x00	; 0
    2b52:	90 e0       	ldi	r25, 0x00	; 0
    2b54:	08 95       	ret

00002b56 <_ZN5Print5printEc>:
    2b56:	dc 01       	movw	r26, r24
    2b58:	ed 91       	ld	r30, X+
    2b5a:	fc 91       	ld	r31, X
    2b5c:	01 90       	ld	r0, Z+
    2b5e:	f0 81       	ld	r31, Z
    2b60:	e0 2d       	mov	r30, r0
    2b62:	19 95       	eicall
    2b64:	08 95       	ret

00002b66 <_ZN5Print7printlnEv>:
    2b66:	0f 93       	push	r16
    2b68:	1f 93       	push	r17
    2b6a:	cf 93       	push	r28
    2b6c:	df 93       	push	r29
    2b6e:	ec 01       	movw	r28, r24
    2b70:	6d e0       	ldi	r22, 0x0D	; 13
    2b72:	f1 df       	rcall	.-30     	; 0x2b56 <_ZN5Print5printEc>
    2b74:	8c 01       	movw	r16, r24
    2b76:	6a e0       	ldi	r22, 0x0A	; 10
    2b78:	ce 01       	movw	r24, r28
    2b7a:	ed df       	rcall	.-38     	; 0x2b56 <_ZN5Print5printEc>
    2b7c:	80 0f       	add	r24, r16
    2b7e:	91 1f       	adc	r25, r17
    2b80:	df 91       	pop	r29
    2b82:	cf 91       	pop	r28
    2b84:	1f 91       	pop	r17
    2b86:	0f 91       	pop	r16
    2b88:	08 95       	ret

00002b8a <_ZN5Print7printlnEPKc>:

size_t Print::println(const char c[])
{
    2b8a:	0f 93       	push	r16
    2b8c:	1f 93       	push	r17
    2b8e:	cf 93       	push	r28
    2b90:	df 93       	push	r29
    2b92:	ec 01       	movw	r28, r24
  size_t n = print(c);
    2b94:	ca df       	rcall	.-108    	; 0x2b2a <_ZN5Print5printEPKc>
    2b96:	8c 01       	movw	r16, r24
  n += println();
    2b98:	ce 01       	movw	r24, r28
    2b9a:	e5 df       	rcall	.-54     	; 0x2b66 <_ZN5Print7printlnEv>
  return n;
}
    2b9c:	80 0f       	add	r24, r16
    2b9e:	91 1f       	adc	r25, r17
    2ba0:	df 91       	pop	r29
    2ba2:	cf 91       	pop	r28
    2ba4:	1f 91       	pop	r17
    2ba6:	0f 91       	pop	r16
    2ba8:	08 95       	ret

00002baa <__vector_23>:
	// we can't subtract any more than this or we'd overflow w/ small delays.
	us--;
#endif

	// busy wait
	__asm__ __volatile__ (
    2baa:	1f 92       	push	r1
    2bac:	0f 92       	push	r0
    2bae:	0f b6       	in	r0, 0x3f	; 63
    2bb0:	0f 92       	push	r0
    2bb2:	11 24       	eor	r1, r1
    2bb4:	2f 93       	push	r18
    2bb6:	3f 93       	push	r19
    2bb8:	8f 93       	push	r24
    2bba:	9f 93       	push	r25
    2bbc:	af 93       	push	r26
    2bbe:	bf 93       	push	r27
    2bc0:	80 91 f4 0e 	lds	r24, 0x0EF4
    2bc4:	90 91 f5 0e 	lds	r25, 0x0EF5
    2bc8:	a0 91 f6 0e 	lds	r26, 0x0EF6
    2bcc:	b0 91 f7 0e 	lds	r27, 0x0EF7
    2bd0:	30 91 f3 0e 	lds	r19, 0x0EF3
    2bd4:	23 e0       	ldi	r18, 0x03	; 3
    2bd6:	23 0f       	add	r18, r19
    2bd8:	2d 37       	cpi	r18, 0x7D	; 125
    2bda:	20 f4       	brcc	.+8      	; 0x2be4 <__vector_23+0x3a>
    2bdc:	01 96       	adiw	r24, 0x01	; 1
    2bde:	a1 1d       	adc	r26, r1
    2be0:	b1 1d       	adc	r27, r1
    2be2:	05 c0       	rjmp	.+10     	; 0x2bee <__vector_23+0x44>
    2be4:	26 e8       	ldi	r18, 0x86	; 134
    2be6:	23 0f       	add	r18, r19
    2be8:	02 96       	adiw	r24, 0x02	; 2
    2bea:	a1 1d       	adc	r26, r1
    2bec:	b1 1d       	adc	r27, r1
    2bee:	20 93 f3 0e 	sts	0x0EF3, r18
    2bf2:	80 93 f4 0e 	sts	0x0EF4, r24
    2bf6:	90 93 f5 0e 	sts	0x0EF5, r25
    2bfa:	a0 93 f6 0e 	sts	0x0EF6, r26
    2bfe:	b0 93 f7 0e 	sts	0x0EF7, r27
    2c02:	80 91 f8 0e 	lds	r24, 0x0EF8
    2c06:	90 91 f9 0e 	lds	r25, 0x0EF9
    2c0a:	a0 91 fa 0e 	lds	r26, 0x0EFA
    2c0e:	b0 91 fb 0e 	lds	r27, 0x0EFB
    2c12:	01 96       	adiw	r24, 0x01	; 1
    2c14:	a1 1d       	adc	r26, r1
    2c16:	b1 1d       	adc	r27, r1
    2c18:	80 93 f8 0e 	sts	0x0EF8, r24
    2c1c:	90 93 f9 0e 	sts	0x0EF9, r25
    2c20:	a0 93 fa 0e 	sts	0x0EFA, r26
    2c24:	b0 93 fb 0e 	sts	0x0EFB, r27
    2c28:	bf 91       	pop	r27
    2c2a:	af 91       	pop	r26
    2c2c:	9f 91       	pop	r25
    2c2e:	8f 91       	pop	r24
    2c30:	3f 91       	pop	r19
    2c32:	2f 91       	pop	r18
    2c34:	0f 90       	pop	r0
    2c36:	0f be       	out	0x3f, r0	; 63
    2c38:	0f 90       	pop	r0
    2c3a:	1f 90       	pop	r1
    2c3c:	18 95       	reti

00002c3e <micros>:
    2c3e:	3f b7       	in	r19, 0x3f	; 63
    2c40:	f8 94       	cli
    2c42:	80 91 f8 0e 	lds	r24, 0x0EF8
    2c46:	90 91 f9 0e 	lds	r25, 0x0EF9
    2c4a:	a0 91 fa 0e 	lds	r26, 0x0EFA
    2c4e:	b0 91 fb 0e 	lds	r27, 0x0EFB
    2c52:	26 b5       	in	r18, 0x26	; 38
    2c54:	a8 9b       	sbis	0x15, 0	; 21
    2c56:	05 c0       	rjmp	.+10     	; 0x2c62 <micros+0x24>
    2c58:	2f 3f       	cpi	r18, 0xFF	; 255
    2c5a:	19 f0       	breq	.+6      	; 0x2c62 <micros+0x24>
    2c5c:	01 96       	adiw	r24, 0x01	; 1
    2c5e:	a1 1d       	adc	r26, r1
    2c60:	b1 1d       	adc	r27, r1
    2c62:	3f bf       	out	0x3f, r19	; 63
    2c64:	ba 2f       	mov	r27, r26
    2c66:	a9 2f       	mov	r26, r25
    2c68:	98 2f       	mov	r25, r24
    2c6a:	88 27       	eor	r24, r24
    2c6c:	82 0f       	add	r24, r18
    2c6e:	91 1d       	adc	r25, r1
    2c70:	a1 1d       	adc	r26, r1
    2c72:	b1 1d       	adc	r27, r1
    2c74:	bc 01       	movw	r22, r24
    2c76:	cd 01       	movw	r24, r26
    2c78:	66 0f       	add	r22, r22
    2c7a:	77 1f       	adc	r23, r23
    2c7c:	88 1f       	adc	r24, r24
    2c7e:	99 1f       	adc	r25, r25
    2c80:	66 0f       	add	r22, r22
    2c82:	77 1f       	adc	r23, r23
    2c84:	88 1f       	adc	r24, r24
    2c86:	99 1f       	adc	r25, r25
    2c88:	08 95       	ret

00002c8a <delay>:
    2c8a:	cf 92       	push	r12
    2c8c:	df 92       	push	r13
    2c8e:	ef 92       	push	r14
    2c90:	ff 92       	push	r15
    2c92:	cf 93       	push	r28
    2c94:	df 93       	push	r29
    2c96:	6b 01       	movw	r12, r22
    2c98:	7c 01       	movw	r14, r24
    2c9a:	d1 df       	rcall	.-94     	; 0x2c3e <micros>
    2c9c:	eb 01       	movw	r28, r22
    2c9e:	c1 14       	cp	r12, r1
    2ca0:	d1 04       	cpc	r13, r1
    2ca2:	e1 04       	cpc	r14, r1
    2ca4:	f1 04       	cpc	r15, r1
    2ca6:	99 f0       	breq	.+38     	; 0x2cce <delay+0x44>
    2ca8:	78 d1       	rcall	.+752    	; 0x2f9a <yield>
    2caa:	c9 df       	rcall	.-110    	; 0x2c3e <micros>
    2cac:	6c 1b       	sub	r22, r28
    2cae:	7d 0b       	sbc	r23, r29
    2cb0:	68 3e       	cpi	r22, 0xE8	; 232
    2cb2:	73 40       	sbci	r23, 0x03	; 3
    2cb4:	38 f0       	brcs	.+14     	; 0x2cc4 <delay+0x3a>
    2cb6:	81 e0       	ldi	r24, 0x01	; 1
    2cb8:	c8 1a       	sub	r12, r24
    2cba:	d1 08       	sbc	r13, r1
    2cbc:	e1 08       	sbc	r14, r1
    2cbe:	f1 08       	sbc	r15, r1
    2cc0:	c8 51       	subi	r28, 0x18	; 24
    2cc2:	dc 4f       	sbci	r29, 0xFC	; 252
    2cc4:	c1 14       	cp	r12, r1
    2cc6:	d1 04       	cpc	r13, r1
    2cc8:	e1 04       	cpc	r14, r1
    2cca:	f1 04       	cpc	r15, r1
    2ccc:	69 f7       	brne	.-38     	; 0x2ca8 <delay+0x1e>
    2cce:	df 91       	pop	r29
    2cd0:	cf 91       	pop	r28
    2cd2:	ff 90       	pop	r15
    2cd4:	ef 90       	pop	r14
    2cd6:	df 90       	pop	r13
    2cd8:	cf 90       	pop	r12
    2cda:	08 95       	ret

00002cdc <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
    2cdc:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
    2cde:	84 b5       	in	r24, 0x24	; 36
    2ce0:	82 60       	ori	r24, 0x02	; 2
    2ce2:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
    2ce4:	84 b5       	in	r24, 0x24	; 36
    2ce6:	81 60       	ori	r24, 0x01	; 1
    2ce8:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
    2cea:	85 b5       	in	r24, 0x25	; 37
    2cec:	82 60       	ori	r24, 0x02	; 2
    2cee:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
    2cf0:	85 b5       	in	r24, 0x25	; 37
    2cf2:	81 60       	ori	r24, 0x01	; 1
    2cf4:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
    2cf6:	ee e6       	ldi	r30, 0x6E	; 110
    2cf8:	f0 e0       	ldi	r31, 0x00	; 0
    2cfa:	80 81       	ld	r24, Z
    2cfc:	81 60       	ori	r24, 0x01	; 1
    2cfe:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
    2d00:	e1 e8       	ldi	r30, 0x81	; 129
    2d02:	f0 e0       	ldi	r31, 0x00	; 0
    2d04:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
    2d06:	80 81       	ld	r24, Z
    2d08:	82 60       	ori	r24, 0x02	; 2
    2d0a:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
    2d0c:	80 81       	ld	r24, Z
    2d0e:	81 60       	ori	r24, 0x01	; 1
    2d10:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
    2d12:	e0 e8       	ldi	r30, 0x80	; 128
    2d14:	f0 e0       	ldi	r31, 0x00	; 0
    2d16:	80 81       	ld	r24, Z
    2d18:	81 60       	ori	r24, 0x01	; 1
    2d1a:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
    2d1c:	e1 eb       	ldi	r30, 0xB1	; 177
    2d1e:	f0 e0       	ldi	r31, 0x00	; 0
    2d20:	80 81       	ld	r24, Z
    2d22:	84 60       	ori	r24, 0x04	; 4
    2d24:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
    2d26:	e0 eb       	ldi	r30, 0xB0	; 176
    2d28:	f0 e0       	ldi	r31, 0x00	; 0
    2d2a:	80 81       	ld	r24, Z
    2d2c:	81 60       	ori	r24, 0x01	; 1
    2d2e:	80 83       	st	Z, r24
#else
	#warning Timer 2 not finished (may not be present on this CPU)
#endif

#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
    2d30:	e1 e9       	ldi	r30, 0x91	; 145
    2d32:	f0 e0       	ldi	r31, 0x00	; 0
    2d34:	80 81       	ld	r24, Z
    2d36:	82 60       	ori	r24, 0x02	; 2
    2d38:	80 83       	st	Z, r24
	sbi(TCCR3B, CS30);
    2d3a:	80 81       	ld	r24, Z
    2d3c:	81 60       	ori	r24, 0x01	; 1
    2d3e:	80 83       	st	Z, r24
	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
    2d40:	e0 e9       	ldi	r30, 0x90	; 144
    2d42:	f0 e0       	ldi	r31, 0x00	; 0
    2d44:	80 81       	ld	r24, Z
    2d46:	81 60       	ori	r24, 0x01	; 1
    2d48:	80 83       	st	Z, r24
	sbi(TCCR4D, WGM40);		// put timer 4 in phase- and frequency-correct PWM mode	
	sbi(TCCR4A, PWM4A);		// enable PWM mode for comparator OCR4A
	sbi(TCCR4C, PWM4D);		// enable PWM mode for comparator OCR4D
#else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */
#if defined(TCCR4B) && defined(CS41) && defined(WGM40)
	sbi(TCCR4B, CS41);		// set timer 4 prescale factor to 64
    2d4a:	e1 ea       	ldi	r30, 0xA1	; 161
    2d4c:	f0 e0       	ldi	r31, 0x00	; 0
    2d4e:	80 81       	ld	r24, Z
    2d50:	82 60       	ori	r24, 0x02	; 2
    2d52:	80 83       	st	Z, r24
	sbi(TCCR4B, CS40);
    2d54:	80 81       	ld	r24, Z
    2d56:	81 60       	ori	r24, 0x01	; 1
    2d58:	80 83       	st	Z, r24
	sbi(TCCR4A, WGM40);		// put timer 4 in 8-bit phase correct pwm mode
    2d5a:	e0 ea       	ldi	r30, 0xA0	; 160
    2d5c:	f0 e0       	ldi	r31, 0x00	; 0
    2d5e:	80 81       	ld	r24, Z
    2d60:	81 60       	ori	r24, 0x01	; 1
    2d62:	80 83       	st	Z, r24
#endif
#endif /* end timer4 block for ATMEGA1280/2560 and similar */	

#if defined(TCCR5B) && defined(CS51) && defined(WGM50)
	sbi(TCCR5B, CS51);		// set timer 5 prescale factor to 64
    2d64:	e1 e2       	ldi	r30, 0x21	; 33
    2d66:	f1 e0       	ldi	r31, 0x01	; 1
    2d68:	80 81       	ld	r24, Z
    2d6a:	82 60       	ori	r24, 0x02	; 2
    2d6c:	80 83       	st	Z, r24
	sbi(TCCR5B, CS50);
    2d6e:	80 81       	ld	r24, Z
    2d70:	81 60       	ori	r24, 0x01	; 1
    2d72:	80 83       	st	Z, r24
	sbi(TCCR5A, WGM50);		// put timer 5 in 8-bit phase correct pwm mode
    2d74:	e0 e2       	ldi	r30, 0x20	; 32
    2d76:	f1 e0       	ldi	r31, 0x01	; 1
    2d78:	80 81       	ld	r24, Z
    2d7a:	81 60       	ori	r24, 0x01	; 1
    2d7c:	80 83       	st	Z, r24
#if defined(ADCSRA)
	// set a2d prescale factor to 128
	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
	// XXX: this will not work properly for other clock speeds, and
	// this code should use F_CPU to determine the prescale factor.
	sbi(ADCSRA, ADPS2);
    2d7e:	ea e7       	ldi	r30, 0x7A	; 122
    2d80:	f0 e0       	ldi	r31, 0x00	; 0
    2d82:	80 81       	ld	r24, Z
    2d84:	84 60       	ori	r24, 0x04	; 4
    2d86:	80 83       	st	Z, r24
	sbi(ADCSRA, ADPS1);
    2d88:	80 81       	ld	r24, Z
    2d8a:	82 60       	ori	r24, 0x02	; 2
    2d8c:	80 83       	st	Z, r24
	sbi(ADCSRA, ADPS0);
    2d8e:	80 81       	ld	r24, Z
    2d90:	81 60       	ori	r24, 0x01	; 1
    2d92:	80 83       	st	Z, r24

	// enable a2d conversions
	sbi(ADCSRA, ADEN);
    2d94:	80 81       	ld	r24, Z
    2d96:	80 68       	ori	r24, 0x80	; 128
    2d98:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
    2d9a:	10 92 c1 00 	sts	0x00C1, r1
    2d9e:	08 95       	ret

00002da0 <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
    2da0:	90 e0       	ldi	r25, 0x00	; 0
    2da2:	fc 01       	movw	r30, r24
    2da4:	31 97       	sbiw	r30, 0x01	; 1
    2da6:	e2 31       	cpi	r30, 0x12	; 18
    2da8:	f1 05       	cpc	r31, r1
    2daa:	08 f0       	brcs	.+2      	; 0x2dae <turnOffPWM+0xe>
    2dac:	5e c0       	rjmp	.+188    	; 0x2e6a <turnOffPWM+0xca>
    2dae:	e4 58       	subi	r30, 0x84	; 132
    2db0:	fe 4f       	sbci	r31, 0xFE	; 254
    2db2:	16 c1       	rjmp	.+556    	; 0x2fe0 <__tablejump2__>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
    2db4:	e0 e8       	ldi	r30, 0x80	; 128
    2db6:	f0 e0       	ldi	r31, 0x00	; 0
    2db8:	80 81       	ld	r24, Z
    2dba:	8f 77       	andi	r24, 0x7F	; 127
    2dbc:	80 83       	st	Z, r24
    2dbe:	08 95       	ret
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    2dc0:	e0 e8       	ldi	r30, 0x80	; 128
    2dc2:	f0 e0       	ldi	r31, 0x00	; 0
    2dc4:	80 81       	ld	r24, Z
    2dc6:	8f 7d       	andi	r24, 0xDF	; 223
    2dc8:	80 83       	st	Z, r24
    2dca:	08 95       	ret
		#endif
		#if defined(TCCR1A) && defined(COM1C1)
		case TIMER1C:   cbi(TCCR1A, COM1C1);    break;
    2dcc:	e0 e8       	ldi	r30, 0x80	; 128
    2dce:	f0 e0       	ldi	r31, 0x00	; 0
    2dd0:	80 81       	ld	r24, Z
    2dd2:	87 7f       	andi	r24, 0xF7	; 247
    2dd4:	80 83       	st	Z, r24
    2dd6:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
    2dd8:	84 b5       	in	r24, 0x24	; 36
    2dda:	8f 77       	andi	r24, 0x7F	; 127
    2ddc:	84 bd       	out	0x24, r24	; 36
    2dde:	08 95       	ret
		#endif
		
		#if defined(TIMER0B) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
    2de0:	84 b5       	in	r24, 0x24	; 36
    2de2:	8f 7d       	andi	r24, 0xDF	; 223
    2de4:	84 bd       	out	0x24, r24	; 36
    2de6:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
    2de8:	e0 eb       	ldi	r30, 0xB0	; 176
    2dea:	f0 e0       	ldi	r31, 0x00	; 0
    2dec:	80 81       	ld	r24, Z
    2dee:	8f 77       	andi	r24, 0x7F	; 127
    2df0:	80 83       	st	Z, r24
    2df2:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
    2df4:	e0 eb       	ldi	r30, 0xB0	; 176
    2df6:	f0 e0       	ldi	r31, 0x00	; 0
    2df8:	80 81       	ld	r24, Z
    2dfa:	8f 7d       	andi	r24, 0xDF	; 223
    2dfc:	80 83       	st	Z, r24
    2dfe:	08 95       	ret
		#endif
		
		#if defined(TCCR3A) && defined(COM3A1)
		case  TIMER3A:  cbi(TCCR3A, COM3A1);    break;
    2e00:	e0 e9       	ldi	r30, 0x90	; 144
    2e02:	f0 e0       	ldi	r31, 0x00	; 0
    2e04:	80 81       	ld	r24, Z
    2e06:	8f 77       	andi	r24, 0x7F	; 127
    2e08:	80 83       	st	Z, r24
    2e0a:	08 95       	ret
		#endif
		#if defined(TCCR3A) && defined(COM3B1)
		case  TIMER3B:  cbi(TCCR3A, COM3B1);    break;
    2e0c:	e0 e9       	ldi	r30, 0x90	; 144
    2e0e:	f0 e0       	ldi	r31, 0x00	; 0
    2e10:	80 81       	ld	r24, Z
    2e12:	8f 7d       	andi	r24, 0xDF	; 223
    2e14:	80 83       	st	Z, r24
    2e16:	08 95       	ret
		#endif
		#if defined(TCCR3A) && defined(COM3C1)
		case  TIMER3C:  cbi(TCCR3A, COM3C1);    break;
    2e18:	e0 e9       	ldi	r30, 0x90	; 144
    2e1a:	f0 e0       	ldi	r31, 0x00	; 0
    2e1c:	80 81       	ld	r24, Z
    2e1e:	87 7f       	andi	r24, 0xF7	; 247
    2e20:	80 83       	st	Z, r24
    2e22:	08 95       	ret
		#endif

		#if defined(TCCR4A) && defined(COM4A1)
		case  TIMER4A:  cbi(TCCR4A, COM4A1);    break;
    2e24:	e0 ea       	ldi	r30, 0xA0	; 160
    2e26:	f0 e0       	ldi	r31, 0x00	; 0
    2e28:	80 81       	ld	r24, Z
    2e2a:	8f 77       	andi	r24, 0x7F	; 127
    2e2c:	80 83       	st	Z, r24
    2e2e:	08 95       	ret
		#endif					
		#if defined(TCCR4A) && defined(COM4B1)
		case  TIMER4B:  cbi(TCCR4A, COM4B1);    break;
    2e30:	e0 ea       	ldi	r30, 0xA0	; 160
    2e32:	f0 e0       	ldi	r31, 0x00	; 0
    2e34:	80 81       	ld	r24, Z
    2e36:	8f 7d       	andi	r24, 0xDF	; 223
    2e38:	80 83       	st	Z, r24
    2e3a:	08 95       	ret
		#endif
		#if defined(TCCR4A) && defined(COM4C1)
		case  TIMER4C:  cbi(TCCR4A, COM4C1);    break;
    2e3c:	e0 ea       	ldi	r30, 0xA0	; 160
    2e3e:	f0 e0       	ldi	r31, 0x00	; 0
    2e40:	80 81       	ld	r24, Z
    2e42:	87 7f       	andi	r24, 0xF7	; 247
    2e44:	80 83       	st	Z, r24
    2e46:	08 95       	ret
		#if defined(TCCR4C) && defined(COM4D1)
		case TIMER4D:	cbi(TCCR4C, COM4D1);	break;
		#endif			
			
		#if defined(TCCR5A)
		case  TIMER5A:  cbi(TCCR5A, COM5A1);    break;
    2e48:	e0 e2       	ldi	r30, 0x20	; 32
    2e4a:	f1 e0       	ldi	r31, 0x01	; 1
    2e4c:	80 81       	ld	r24, Z
    2e4e:	8f 77       	andi	r24, 0x7F	; 127
    2e50:	80 83       	st	Z, r24
    2e52:	08 95       	ret
		case  TIMER5B:  cbi(TCCR5A, COM5B1);    break;
    2e54:	e0 e2       	ldi	r30, 0x20	; 32
    2e56:	f1 e0       	ldi	r31, 0x01	; 1
    2e58:	80 81       	ld	r24, Z
    2e5a:	8f 7d       	andi	r24, 0xDF	; 223
    2e5c:	80 83       	st	Z, r24
    2e5e:	08 95       	ret
		case  TIMER5C:  cbi(TCCR5A, COM5C1);    break;
    2e60:	e0 e2       	ldi	r30, 0x20	; 32
    2e62:	f1 e0       	ldi	r31, 0x01	; 1
    2e64:	80 81       	ld	r24, Z
    2e66:	87 7f       	andi	r24, 0xF7	; 247
    2e68:	80 83       	st	Z, r24
    2e6a:	08 95       	ret

00002e6c <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
    2e6c:	cf 93       	push	r28
    2e6e:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
    2e70:	90 e0       	ldi	r25, 0x00	; 0
    2e72:	fc 01       	movw	r30, r24
    2e74:	ee 59       	subi	r30, 0x9E	; 158
    2e76:	fc 4f       	sbci	r31, 0xFC	; 252
    2e78:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
    2e7a:	fc 01       	movw	r30, r24
    2e7c:	e8 55       	subi	r30, 0x58	; 88
    2e7e:	fc 4f       	sbci	r31, 0xFC	; 252
    2e80:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
    2e82:	88 23       	and	r24, r24
    2e84:	71 f1       	breq	.+92     	; 0x2ee2 <pinMode+0x76>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
    2e86:	90 e0       	ldi	r25, 0x00	; 0
    2e88:	88 0f       	add	r24, r24
    2e8a:	99 1f       	adc	r25, r25
    2e8c:	fc 01       	movw	r30, r24
    2e8e:	ee 5d       	subi	r30, 0xDE	; 222
    2e90:	fb 4f       	sbci	r31, 0xFB	; 251
    2e92:	a5 91       	lpm	r26, Z+
    2e94:	b4 91       	lpm	r27, Z
	out = portOutputRegister(port);
    2e96:	88 5f       	subi	r24, 0xF8	; 248
    2e98:	9b 4f       	sbci	r25, 0xFB	; 251
    2e9a:	fc 01       	movw	r30, r24
    2e9c:	c5 91       	lpm	r28, Z+
    2e9e:	d4 91       	lpm	r29, Z

	if (mode == INPUT) { 
    2ea0:	61 11       	cpse	r22, r1
    2ea2:	0b c0       	rjmp	.+22     	; 0x2eba <pinMode+0x4e>
		uint8_t oldSREG = SREG;
    2ea4:	8f b7       	in	r24, 0x3f	; 63
                cli();
    2ea6:	f8 94       	cli
		*reg &= ~bit;
    2ea8:	9c 91       	ld	r25, X
    2eaa:	20 95       	com	r18
    2eac:	92 23       	and	r25, r18
    2eae:	9c 93       	st	X, r25
		*out &= ~bit;
    2eb0:	e8 81       	ld	r30, Y
    2eb2:	2e 23       	and	r18, r30
    2eb4:	28 83       	st	Y, r18
		SREG = oldSREG;
    2eb6:	8f bf       	out	0x3f, r24	; 63
    2eb8:	14 c0       	rjmp	.+40     	; 0x2ee2 <pinMode+0x76>
	} else if (mode == INPUT_PULLUP) {
    2eba:	62 30       	cpi	r22, 0x02	; 2
    2ebc:	61 f4       	brne	.+24     	; 0x2ed6 <pinMode+0x6a>
		uint8_t oldSREG = SREG;
    2ebe:	8f b7       	in	r24, 0x3f	; 63
                cli();
    2ec0:	f8 94       	cli
		*reg &= ~bit;
    2ec2:	3c 91       	ld	r19, X
    2ec4:	92 2f       	mov	r25, r18
    2ec6:	90 95       	com	r25
    2ec8:	93 23       	and	r25, r19
    2eca:	9c 93       	st	X, r25
		*out |= bit;
    2ecc:	e8 81       	ld	r30, Y
    2ece:	2e 2b       	or	r18, r30
    2ed0:	28 83       	st	Y, r18
		SREG = oldSREG;
    2ed2:	8f bf       	out	0x3f, r24	; 63
    2ed4:	06 c0       	rjmp	.+12     	; 0x2ee2 <pinMode+0x76>
	} else {
		uint8_t oldSREG = SREG;
    2ed6:	8f b7       	in	r24, 0x3f	; 63
                cli();
    2ed8:	f8 94       	cli
		*reg |= bit;
    2eda:	ec 91       	ld	r30, X
    2edc:	2e 2b       	or	r18, r30
    2ede:	2c 93       	st	X, r18
		SREG = oldSREG;
    2ee0:	8f bf       	out	0x3f, r24	; 63
	}
}
    2ee2:	df 91       	pop	r29
    2ee4:	cf 91       	pop	r28
    2ee6:	08 95       	ret

00002ee8 <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
    2ee8:	1f 93       	push	r17
    2eea:	cf 93       	push	r28
    2eec:	df 93       	push	r29
    2eee:	c6 2f       	mov	r28, r22
	uint8_t timer = digitalPinToTimer(pin);
    2ef0:	28 2f       	mov	r18, r24
    2ef2:	30 e0       	ldi	r19, 0x00	; 0
    2ef4:	f9 01       	movw	r30, r18
    2ef6:	e4 5e       	subi	r30, 0xE4	; 228
    2ef8:	fc 4f       	sbci	r31, 0xFC	; 252
    2efa:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
    2efc:	f9 01       	movw	r30, r18
    2efe:	ee 59       	subi	r30, 0x9E	; 158
    2f00:	fc 4f       	sbci	r31, 0xFC	; 252
    2f02:	14 91       	lpm	r17, Z
	uint8_t port = digitalPinToPort(pin);
    2f04:	f9 01       	movw	r30, r18
    2f06:	e8 55       	subi	r30, 0x58	; 88
    2f08:	fc 4f       	sbci	r31, 0xFC	; 252
    2f0a:	d4 91       	lpm	r29, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
    2f0c:	dd 23       	and	r29, r29
    2f0e:	c1 f0       	breq	.+48     	; 0x2f40 <digitalWrite+0x58>

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    2f10:	81 11       	cpse	r24, r1
    2f12:	46 df       	rcall	.-372    	; 0x2da0 <turnOffPWM>

	out = portOutputRegister(port);
    2f14:	2d 2f       	mov	r18, r29
    2f16:	30 e0       	ldi	r19, 0x00	; 0
    2f18:	f9 01       	movw	r30, r18
    2f1a:	ee 0f       	add	r30, r30
    2f1c:	ff 1f       	adc	r31, r31
    2f1e:	e8 5f       	subi	r30, 0xF8	; 248
    2f20:	fb 4f       	sbci	r31, 0xFB	; 251
    2f22:	a5 91       	lpm	r26, Z+
    2f24:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
    2f26:	8f b7       	in	r24, 0x3f	; 63
	cli();
    2f28:	f8 94       	cli

	if (val == LOW) {
    2f2a:	c1 11       	cpse	r28, r1
    2f2c:	05 c0       	rjmp	.+10     	; 0x2f38 <digitalWrite+0x50>
		*out &= ~bit;
    2f2e:	ec 91       	ld	r30, X
    2f30:	10 95       	com	r17
    2f32:	1e 23       	and	r17, r30
    2f34:	1c 93       	st	X, r17
    2f36:	03 c0       	rjmp	.+6      	; 0x2f3e <digitalWrite+0x56>
	} else {
		*out |= bit;
    2f38:	ec 91       	ld	r30, X
    2f3a:	1e 2b       	or	r17, r30
    2f3c:	1c 93       	st	X, r17
	}

	SREG = oldSREG;
    2f3e:	8f bf       	out	0x3f, r24	; 63
}
    2f40:	df 91       	pop	r29
    2f42:	cf 91       	pop	r28
    2f44:	1f 91       	pop	r17
    2f46:	08 95       	ret

00002f48 <digitalRead>:

int digitalRead(uint8_t pin)
{
    2f48:	cf 93       	push	r28
    2f4a:	df 93       	push	r29
	uint8_t timer = digitalPinToTimer(pin);
    2f4c:	28 2f       	mov	r18, r24
    2f4e:	30 e0       	ldi	r19, 0x00	; 0
    2f50:	f9 01       	movw	r30, r18
    2f52:	e4 5e       	subi	r30, 0xE4	; 228
    2f54:	fc 4f       	sbci	r31, 0xFC	; 252
    2f56:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
    2f58:	f9 01       	movw	r30, r18
    2f5a:	ee 59       	subi	r30, 0x9E	; 158
    2f5c:	fc 4f       	sbci	r31, 0xFC	; 252
    2f5e:	d4 91       	lpm	r29, Z
	uint8_t port = digitalPinToPort(pin);
    2f60:	f9 01       	movw	r30, r18
    2f62:	e8 55       	subi	r30, 0x58	; 88
    2f64:	fc 4f       	sbci	r31, 0xFC	; 252
    2f66:	c4 91       	lpm	r28, Z

	if (port == NOT_A_PIN) return LOW;
    2f68:	cc 23       	and	r28, r28
    2f6a:	91 f0       	breq	.+36     	; 0x2f90 <digitalRead+0x48>

	// If the pin that support PWM output, we need to turn it off
	// before getting a digital reading.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    2f6c:	81 11       	cpse	r24, r1
    2f6e:	18 df       	rcall	.-464    	; 0x2da0 <turnOffPWM>

	if (*portInputRegister(port) & bit) return HIGH;
    2f70:	2c 2f       	mov	r18, r28
    2f72:	30 e0       	ldi	r19, 0x00	; 0
    2f74:	f9 01       	movw	r30, r18
    2f76:	ee 0f       	add	r30, r30
    2f78:	ff 1f       	adc	r31, r31
    2f7a:	e2 51       	subi	r30, 0x12	; 18
    2f7c:	fc 4f       	sbci	r31, 0xFC	; 252
    2f7e:	a5 91       	lpm	r26, Z+
    2f80:	b4 91       	lpm	r27, Z
    2f82:	ec 91       	ld	r30, X
    2f84:	de 23       	and	r29, r30
    2f86:	81 e0       	ldi	r24, 0x01	; 1
    2f88:	90 e0       	ldi	r25, 0x00	; 0
    2f8a:	21 f4       	brne	.+8      	; 0x2f94 <digitalRead+0x4c>
    2f8c:	80 e0       	ldi	r24, 0x00	; 0
    2f8e:	02 c0       	rjmp	.+4      	; 0x2f94 <digitalRead+0x4c>
{
	uint8_t timer = digitalPinToTimer(pin);
	uint8_t bit = digitalPinToBitMask(pin);
	uint8_t port = digitalPinToPort(pin);

	if (port == NOT_A_PIN) return LOW;
    2f90:	80 e0       	ldi	r24, 0x00	; 0
    2f92:	90 e0       	ldi	r25, 0x00	; 0
	// before getting a digital reading.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	if (*portInputRegister(port) & bit) return HIGH;
	return LOW;
}
    2f94:	df 91       	pop	r29
    2f96:	cf 91       	pop	r28
    2f98:	08 95       	ret

00002f9a <yield>:
 * libraries or sketches that supports cooperative threads.
 *
 * Its defined as a weak symbol and it can be redefined to implement a
 * real cooperative scheduler.
 */
static void __empty() {
    2f9a:	08 95       	ret

00002f9c <__udivmodsi4>:
    2f9c:	a1 e2       	ldi	r26, 0x21	; 33
    2f9e:	1a 2e       	mov	r1, r26
    2fa0:	aa 1b       	sub	r26, r26
    2fa2:	bb 1b       	sub	r27, r27
    2fa4:	fd 01       	movw	r30, r26
    2fa6:	0d c0       	rjmp	.+26     	; 0x2fc2 <__udivmodsi4_ep>

00002fa8 <__udivmodsi4_loop>:
    2fa8:	aa 1f       	adc	r26, r26
    2faa:	bb 1f       	adc	r27, r27
    2fac:	ee 1f       	adc	r30, r30
    2fae:	ff 1f       	adc	r31, r31
    2fb0:	a2 17       	cp	r26, r18
    2fb2:	b3 07       	cpc	r27, r19
    2fb4:	e4 07       	cpc	r30, r20
    2fb6:	f5 07       	cpc	r31, r21
    2fb8:	20 f0       	brcs	.+8      	; 0x2fc2 <__udivmodsi4_ep>
    2fba:	a2 1b       	sub	r26, r18
    2fbc:	b3 0b       	sbc	r27, r19
    2fbe:	e4 0b       	sbc	r30, r20
    2fc0:	f5 0b       	sbc	r31, r21

00002fc2 <__udivmodsi4_ep>:
    2fc2:	66 1f       	adc	r22, r22
    2fc4:	77 1f       	adc	r23, r23
    2fc6:	88 1f       	adc	r24, r24
    2fc8:	99 1f       	adc	r25, r25
    2fca:	1a 94       	dec	r1
    2fcc:	69 f7       	brne	.-38     	; 0x2fa8 <__udivmodsi4_loop>
    2fce:	60 95       	com	r22
    2fd0:	70 95       	com	r23
    2fd2:	80 95       	com	r24
    2fd4:	90 95       	com	r25
    2fd6:	9b 01       	movw	r18, r22
    2fd8:	ac 01       	movw	r20, r24
    2fda:	bd 01       	movw	r22, r26
    2fdc:	cf 01       	movw	r24, r30
    2fde:	08 95       	ret

00002fe0 <__tablejump2__>:
    2fe0:	ee 0f       	add	r30, r30
    2fe2:	ff 1f       	adc	r31, r31

00002fe4 <__tablejump__>:
    2fe4:	05 90       	lpm	r0, Z+
    2fe6:	f4 91       	lpm	r31, Z
    2fe8:	e0 2d       	mov	r30, r0
    2fea:	19 94       	eijmp

00002fec <__tablejump_elpm__>:
    2fec:	07 90       	elpm	r0, Z+
    2fee:	f6 91       	elpm	r31, Z
    2ff0:	e0 2d       	mov	r30, r0
    2ff2:	19 94       	eijmp

00002ff4 <vsprintf>:
    2ff4:	0f 93       	push	r16
    2ff6:	1f 93       	push	r17
    2ff8:	cf 93       	push	r28
    2ffa:	df 93       	push	r29
    2ffc:	cd b7       	in	r28, 0x3d	; 61
    2ffe:	de b7       	in	r29, 0x3e	; 62
    3000:	2e 97       	sbiw	r28, 0x0e	; 14
    3002:	0f b6       	in	r0, 0x3f	; 63
    3004:	f8 94       	cli
    3006:	de bf       	out	0x3e, r29	; 62
    3008:	0f be       	out	0x3f, r0	; 63
    300a:	cd bf       	out	0x3d, r28	; 61
    300c:	8c 01       	movw	r16, r24
    300e:	86 e0       	ldi	r24, 0x06	; 6
    3010:	8c 83       	std	Y+4, r24	; 0x04
    3012:	1a 83       	std	Y+2, r17	; 0x02
    3014:	09 83       	std	Y+1, r16	; 0x01
    3016:	8f ef       	ldi	r24, 0xFF	; 255
    3018:	9f e7       	ldi	r25, 0x7F	; 127
    301a:	9e 83       	std	Y+6, r25	; 0x06
    301c:	8d 83       	std	Y+5, r24	; 0x05
    301e:	ce 01       	movw	r24, r28
    3020:	01 96       	adiw	r24, 0x01	; 1
    3022:	10 d0       	rcall	.+32     	; 0x3044 <vfprintf>
    3024:	ef 81       	ldd	r30, Y+7	; 0x07
    3026:	f8 85       	ldd	r31, Y+8	; 0x08
    3028:	e0 0f       	add	r30, r16
    302a:	f1 1f       	adc	r31, r17
    302c:	10 82       	st	Z, r1
    302e:	2e 96       	adiw	r28, 0x0e	; 14
    3030:	0f b6       	in	r0, 0x3f	; 63
    3032:	f8 94       	cli
    3034:	de bf       	out	0x3e, r29	; 62
    3036:	0f be       	out	0x3f, r0	; 63
    3038:	cd bf       	out	0x3d, r28	; 61
    303a:	df 91       	pop	r29
    303c:	cf 91       	pop	r28
    303e:	1f 91       	pop	r17
    3040:	0f 91       	pop	r16
    3042:	08 95       	ret

00003044 <vfprintf>:
    3044:	2f 92       	push	r2
    3046:	3f 92       	push	r3
    3048:	4f 92       	push	r4
    304a:	5f 92       	push	r5
    304c:	6f 92       	push	r6
    304e:	7f 92       	push	r7
    3050:	8f 92       	push	r8
    3052:	9f 92       	push	r9
    3054:	af 92       	push	r10
    3056:	bf 92       	push	r11
    3058:	cf 92       	push	r12
    305a:	df 92       	push	r13
    305c:	ef 92       	push	r14
    305e:	ff 92       	push	r15
    3060:	0f 93       	push	r16
    3062:	1f 93       	push	r17
    3064:	cf 93       	push	r28
    3066:	df 93       	push	r29
    3068:	cd b7       	in	r28, 0x3d	; 61
    306a:	de b7       	in	r29, 0x3e	; 62
    306c:	2c 97       	sbiw	r28, 0x0c	; 12
    306e:	0f b6       	in	r0, 0x3f	; 63
    3070:	f8 94       	cli
    3072:	de bf       	out	0x3e, r29	; 62
    3074:	0f be       	out	0x3f, r0	; 63
    3076:	cd bf       	out	0x3d, r28	; 61
    3078:	7c 01       	movw	r14, r24
    307a:	6b 01       	movw	r12, r22
    307c:	8a 01       	movw	r16, r20
    307e:	fc 01       	movw	r30, r24
    3080:	17 82       	std	Z+7, r1	; 0x07
    3082:	16 82       	std	Z+6, r1	; 0x06
    3084:	83 81       	ldd	r24, Z+3	; 0x03
    3086:	81 ff       	sbrs	r24, 1
    3088:	b0 c1       	rjmp	.+864    	; 0x33ea <vfprintf+0x3a6>
    308a:	ce 01       	movw	r24, r28
    308c:	01 96       	adiw	r24, 0x01	; 1
    308e:	4c 01       	movw	r8, r24
    3090:	f7 01       	movw	r30, r14
    3092:	93 81       	ldd	r25, Z+3	; 0x03
    3094:	f6 01       	movw	r30, r12
    3096:	93 fd       	sbrc	r25, 3
    3098:	85 91       	lpm	r24, Z+
    309a:	93 ff       	sbrs	r25, 3
    309c:	81 91       	ld	r24, Z+
    309e:	6f 01       	movw	r12, r30
    30a0:	88 23       	and	r24, r24
    30a2:	09 f4       	brne	.+2      	; 0x30a6 <vfprintf+0x62>
    30a4:	9e c1       	rjmp	.+828    	; 0x33e2 <vfprintf+0x39e>
    30a6:	85 32       	cpi	r24, 0x25	; 37
    30a8:	39 f4       	brne	.+14     	; 0x30b8 <vfprintf+0x74>
    30aa:	93 fd       	sbrc	r25, 3
    30ac:	85 91       	lpm	r24, Z+
    30ae:	93 ff       	sbrs	r25, 3
    30b0:	81 91       	ld	r24, Z+
    30b2:	6f 01       	movw	r12, r30
    30b4:	85 32       	cpi	r24, 0x25	; 37
    30b6:	21 f4       	brne	.+8      	; 0x30c0 <vfprintf+0x7c>
    30b8:	b7 01       	movw	r22, r14
    30ba:	90 e0       	ldi	r25, 0x00	; 0
    30bc:	c7 d1       	rcall	.+910    	; 0x344c <fputc>
    30be:	e8 cf       	rjmp	.-48     	; 0x3090 <vfprintf+0x4c>
    30c0:	51 2c       	mov	r5, r1
    30c2:	31 2c       	mov	r3, r1
    30c4:	20 e0       	ldi	r18, 0x00	; 0
    30c6:	20 32       	cpi	r18, 0x20	; 32
    30c8:	a0 f4       	brcc	.+40     	; 0x30f2 <vfprintf+0xae>
    30ca:	8b 32       	cpi	r24, 0x2B	; 43
    30cc:	69 f0       	breq	.+26     	; 0x30e8 <vfprintf+0xa4>
    30ce:	30 f4       	brcc	.+12     	; 0x30dc <vfprintf+0x98>
    30d0:	80 32       	cpi	r24, 0x20	; 32
    30d2:	59 f0       	breq	.+22     	; 0x30ea <vfprintf+0xa6>
    30d4:	83 32       	cpi	r24, 0x23	; 35
    30d6:	69 f4       	brne	.+26     	; 0x30f2 <vfprintf+0xae>
    30d8:	20 61       	ori	r18, 0x10	; 16
    30da:	2c c0       	rjmp	.+88     	; 0x3134 <vfprintf+0xf0>
    30dc:	8d 32       	cpi	r24, 0x2D	; 45
    30de:	39 f0       	breq	.+14     	; 0x30ee <vfprintf+0xaa>
    30e0:	80 33       	cpi	r24, 0x30	; 48
    30e2:	39 f4       	brne	.+14     	; 0x30f2 <vfprintf+0xae>
    30e4:	21 60       	ori	r18, 0x01	; 1
    30e6:	26 c0       	rjmp	.+76     	; 0x3134 <vfprintf+0xf0>
    30e8:	22 60       	ori	r18, 0x02	; 2
    30ea:	24 60       	ori	r18, 0x04	; 4
    30ec:	23 c0       	rjmp	.+70     	; 0x3134 <vfprintf+0xf0>
    30ee:	28 60       	ori	r18, 0x08	; 8
    30f0:	21 c0       	rjmp	.+66     	; 0x3134 <vfprintf+0xf0>
    30f2:	27 fd       	sbrc	r18, 7
    30f4:	27 c0       	rjmp	.+78     	; 0x3144 <vfprintf+0x100>
    30f6:	30 ed       	ldi	r19, 0xD0	; 208
    30f8:	38 0f       	add	r19, r24
    30fa:	3a 30       	cpi	r19, 0x0A	; 10
    30fc:	78 f4       	brcc	.+30     	; 0x311c <vfprintf+0xd8>
    30fe:	26 ff       	sbrs	r18, 6
    3100:	06 c0       	rjmp	.+12     	; 0x310e <vfprintf+0xca>
    3102:	fa e0       	ldi	r31, 0x0A	; 10
    3104:	5f 9e       	mul	r5, r31
    3106:	30 0d       	add	r19, r0
    3108:	11 24       	eor	r1, r1
    310a:	53 2e       	mov	r5, r19
    310c:	13 c0       	rjmp	.+38     	; 0x3134 <vfprintf+0xf0>
    310e:	8a e0       	ldi	r24, 0x0A	; 10
    3110:	38 9e       	mul	r3, r24
    3112:	30 0d       	add	r19, r0
    3114:	11 24       	eor	r1, r1
    3116:	33 2e       	mov	r3, r19
    3118:	20 62       	ori	r18, 0x20	; 32
    311a:	0c c0       	rjmp	.+24     	; 0x3134 <vfprintf+0xf0>
    311c:	8e 32       	cpi	r24, 0x2E	; 46
    311e:	21 f4       	brne	.+8      	; 0x3128 <vfprintf+0xe4>
    3120:	26 fd       	sbrc	r18, 6
    3122:	5f c1       	rjmp	.+702    	; 0x33e2 <vfprintf+0x39e>
    3124:	20 64       	ori	r18, 0x40	; 64
    3126:	06 c0       	rjmp	.+12     	; 0x3134 <vfprintf+0xf0>
    3128:	8c 36       	cpi	r24, 0x6C	; 108
    312a:	11 f4       	brne	.+4      	; 0x3130 <vfprintf+0xec>
    312c:	20 68       	ori	r18, 0x80	; 128
    312e:	02 c0       	rjmp	.+4      	; 0x3134 <vfprintf+0xf0>
    3130:	88 36       	cpi	r24, 0x68	; 104
    3132:	41 f4       	brne	.+16     	; 0x3144 <vfprintf+0x100>
    3134:	f6 01       	movw	r30, r12
    3136:	93 fd       	sbrc	r25, 3
    3138:	85 91       	lpm	r24, Z+
    313a:	93 ff       	sbrs	r25, 3
    313c:	81 91       	ld	r24, Z+
    313e:	6f 01       	movw	r12, r30
    3140:	81 11       	cpse	r24, r1
    3142:	c1 cf       	rjmp	.-126    	; 0x30c6 <vfprintf+0x82>
    3144:	98 2f       	mov	r25, r24
    3146:	9f 7d       	andi	r25, 0xDF	; 223
    3148:	95 54       	subi	r25, 0x45	; 69
    314a:	93 30       	cpi	r25, 0x03	; 3
    314c:	28 f4       	brcc	.+10     	; 0x3158 <vfprintf+0x114>
    314e:	0c 5f       	subi	r16, 0xFC	; 252
    3150:	1f 4f       	sbci	r17, 0xFF	; 255
    3152:	ff e3       	ldi	r31, 0x3F	; 63
    3154:	f9 83       	std	Y+1, r31	; 0x01
    3156:	0d c0       	rjmp	.+26     	; 0x3172 <vfprintf+0x12e>
    3158:	83 36       	cpi	r24, 0x63	; 99
    315a:	31 f0       	breq	.+12     	; 0x3168 <vfprintf+0x124>
    315c:	83 37       	cpi	r24, 0x73	; 115
    315e:	71 f0       	breq	.+28     	; 0x317c <vfprintf+0x138>
    3160:	83 35       	cpi	r24, 0x53	; 83
    3162:	09 f0       	breq	.+2      	; 0x3166 <vfprintf+0x122>
    3164:	57 c0       	rjmp	.+174    	; 0x3214 <vfprintf+0x1d0>
    3166:	21 c0       	rjmp	.+66     	; 0x31aa <vfprintf+0x166>
    3168:	f8 01       	movw	r30, r16
    316a:	80 81       	ld	r24, Z
    316c:	89 83       	std	Y+1, r24	; 0x01
    316e:	0e 5f       	subi	r16, 0xFE	; 254
    3170:	1f 4f       	sbci	r17, 0xFF	; 255
    3172:	44 24       	eor	r4, r4
    3174:	43 94       	inc	r4
    3176:	51 2c       	mov	r5, r1
    3178:	54 01       	movw	r10, r8
    317a:	14 c0       	rjmp	.+40     	; 0x31a4 <vfprintf+0x160>
    317c:	38 01       	movw	r6, r16
    317e:	f2 e0       	ldi	r31, 0x02	; 2
    3180:	6f 0e       	add	r6, r31
    3182:	71 1c       	adc	r7, r1
    3184:	f8 01       	movw	r30, r16
    3186:	a0 80       	ld	r10, Z
    3188:	b1 80       	ldd	r11, Z+1	; 0x01
    318a:	26 ff       	sbrs	r18, 6
    318c:	03 c0       	rjmp	.+6      	; 0x3194 <vfprintf+0x150>
    318e:	65 2d       	mov	r22, r5
    3190:	70 e0       	ldi	r23, 0x00	; 0
    3192:	02 c0       	rjmp	.+4      	; 0x3198 <vfprintf+0x154>
    3194:	6f ef       	ldi	r22, 0xFF	; 255
    3196:	7f ef       	ldi	r23, 0xFF	; 255
    3198:	c5 01       	movw	r24, r10
    319a:	2c 87       	std	Y+12, r18	; 0x0c
    319c:	4c d1       	rcall	.+664    	; 0x3436 <strnlen>
    319e:	2c 01       	movw	r4, r24
    31a0:	83 01       	movw	r16, r6
    31a2:	2c 85       	ldd	r18, Y+12	; 0x0c
    31a4:	2f 77       	andi	r18, 0x7F	; 127
    31a6:	22 2e       	mov	r2, r18
    31a8:	16 c0       	rjmp	.+44     	; 0x31d6 <vfprintf+0x192>
    31aa:	38 01       	movw	r6, r16
    31ac:	f2 e0       	ldi	r31, 0x02	; 2
    31ae:	6f 0e       	add	r6, r31
    31b0:	71 1c       	adc	r7, r1
    31b2:	f8 01       	movw	r30, r16
    31b4:	a0 80       	ld	r10, Z
    31b6:	b1 80       	ldd	r11, Z+1	; 0x01
    31b8:	26 ff       	sbrs	r18, 6
    31ba:	03 c0       	rjmp	.+6      	; 0x31c2 <vfprintf+0x17e>
    31bc:	65 2d       	mov	r22, r5
    31be:	70 e0       	ldi	r23, 0x00	; 0
    31c0:	02 c0       	rjmp	.+4      	; 0x31c6 <vfprintf+0x182>
    31c2:	6f ef       	ldi	r22, 0xFF	; 255
    31c4:	7f ef       	ldi	r23, 0xFF	; 255
    31c6:	c5 01       	movw	r24, r10
    31c8:	2c 87       	std	Y+12, r18	; 0x0c
    31ca:	2a d1       	rcall	.+596    	; 0x3420 <strnlen_P>
    31cc:	2c 01       	movw	r4, r24
    31ce:	2c 85       	ldd	r18, Y+12	; 0x0c
    31d0:	20 68       	ori	r18, 0x80	; 128
    31d2:	22 2e       	mov	r2, r18
    31d4:	83 01       	movw	r16, r6
    31d6:	23 fc       	sbrc	r2, 3
    31d8:	19 c0       	rjmp	.+50     	; 0x320c <vfprintf+0x1c8>
    31da:	83 2d       	mov	r24, r3
    31dc:	90 e0       	ldi	r25, 0x00	; 0
    31de:	48 16       	cp	r4, r24
    31e0:	59 06       	cpc	r5, r25
    31e2:	a0 f4       	brcc	.+40     	; 0x320c <vfprintf+0x1c8>
    31e4:	b7 01       	movw	r22, r14
    31e6:	80 e2       	ldi	r24, 0x20	; 32
    31e8:	90 e0       	ldi	r25, 0x00	; 0
    31ea:	30 d1       	rcall	.+608    	; 0x344c <fputc>
    31ec:	3a 94       	dec	r3
    31ee:	f5 cf       	rjmp	.-22     	; 0x31da <vfprintf+0x196>
    31f0:	f5 01       	movw	r30, r10
    31f2:	27 fc       	sbrc	r2, 7
    31f4:	85 91       	lpm	r24, Z+
    31f6:	27 fe       	sbrs	r2, 7
    31f8:	81 91       	ld	r24, Z+
    31fa:	5f 01       	movw	r10, r30
    31fc:	b7 01       	movw	r22, r14
    31fe:	90 e0       	ldi	r25, 0x00	; 0
    3200:	25 d1       	rcall	.+586    	; 0x344c <fputc>
    3202:	31 10       	cpse	r3, r1
    3204:	3a 94       	dec	r3
    3206:	f1 e0       	ldi	r31, 0x01	; 1
    3208:	4f 1a       	sub	r4, r31
    320a:	51 08       	sbc	r5, r1
    320c:	41 14       	cp	r4, r1
    320e:	51 04       	cpc	r5, r1
    3210:	79 f7       	brne	.-34     	; 0x31f0 <vfprintf+0x1ac>
    3212:	de c0       	rjmp	.+444    	; 0x33d0 <vfprintf+0x38c>
    3214:	84 36       	cpi	r24, 0x64	; 100
    3216:	11 f0       	breq	.+4      	; 0x321c <vfprintf+0x1d8>
    3218:	89 36       	cpi	r24, 0x69	; 105
    321a:	31 f5       	brne	.+76     	; 0x3268 <vfprintf+0x224>
    321c:	f8 01       	movw	r30, r16
    321e:	27 ff       	sbrs	r18, 7
    3220:	07 c0       	rjmp	.+14     	; 0x3230 <vfprintf+0x1ec>
    3222:	60 81       	ld	r22, Z
    3224:	71 81       	ldd	r23, Z+1	; 0x01
    3226:	82 81       	ldd	r24, Z+2	; 0x02
    3228:	93 81       	ldd	r25, Z+3	; 0x03
    322a:	0c 5f       	subi	r16, 0xFC	; 252
    322c:	1f 4f       	sbci	r17, 0xFF	; 255
    322e:	08 c0       	rjmp	.+16     	; 0x3240 <vfprintf+0x1fc>
    3230:	60 81       	ld	r22, Z
    3232:	71 81       	ldd	r23, Z+1	; 0x01
    3234:	88 27       	eor	r24, r24
    3236:	77 fd       	sbrc	r23, 7
    3238:	80 95       	com	r24
    323a:	98 2f       	mov	r25, r24
    323c:	0e 5f       	subi	r16, 0xFE	; 254
    323e:	1f 4f       	sbci	r17, 0xFF	; 255
    3240:	2f 76       	andi	r18, 0x6F	; 111
    3242:	b2 2e       	mov	r11, r18
    3244:	97 ff       	sbrs	r25, 7
    3246:	09 c0       	rjmp	.+18     	; 0x325a <vfprintf+0x216>
    3248:	90 95       	com	r25
    324a:	80 95       	com	r24
    324c:	70 95       	com	r23
    324e:	61 95       	neg	r22
    3250:	7f 4f       	sbci	r23, 0xFF	; 255
    3252:	8f 4f       	sbci	r24, 0xFF	; 255
    3254:	9f 4f       	sbci	r25, 0xFF	; 255
    3256:	20 68       	ori	r18, 0x80	; 128
    3258:	b2 2e       	mov	r11, r18
    325a:	2a e0       	ldi	r18, 0x0A	; 10
    325c:	30 e0       	ldi	r19, 0x00	; 0
    325e:	a4 01       	movw	r20, r8
    3260:	27 d1       	rcall	.+590    	; 0x34b0 <__ultoa_invert>
    3262:	a8 2e       	mov	r10, r24
    3264:	a8 18       	sub	r10, r8
    3266:	43 c0       	rjmp	.+134    	; 0x32ee <vfprintf+0x2aa>
    3268:	85 37       	cpi	r24, 0x75	; 117
    326a:	29 f4       	brne	.+10     	; 0x3276 <vfprintf+0x232>
    326c:	2f 7e       	andi	r18, 0xEF	; 239
    326e:	b2 2e       	mov	r11, r18
    3270:	2a e0       	ldi	r18, 0x0A	; 10
    3272:	30 e0       	ldi	r19, 0x00	; 0
    3274:	25 c0       	rjmp	.+74     	; 0x32c0 <vfprintf+0x27c>
    3276:	f2 2f       	mov	r31, r18
    3278:	f9 7f       	andi	r31, 0xF9	; 249
    327a:	bf 2e       	mov	r11, r31
    327c:	8f 36       	cpi	r24, 0x6F	; 111
    327e:	c1 f0       	breq	.+48     	; 0x32b0 <vfprintf+0x26c>
    3280:	18 f4       	brcc	.+6      	; 0x3288 <vfprintf+0x244>
    3282:	88 35       	cpi	r24, 0x58	; 88
    3284:	79 f0       	breq	.+30     	; 0x32a4 <vfprintf+0x260>
    3286:	ad c0       	rjmp	.+346    	; 0x33e2 <vfprintf+0x39e>
    3288:	80 37       	cpi	r24, 0x70	; 112
    328a:	19 f0       	breq	.+6      	; 0x3292 <vfprintf+0x24e>
    328c:	88 37       	cpi	r24, 0x78	; 120
    328e:	21 f0       	breq	.+8      	; 0x3298 <vfprintf+0x254>
    3290:	a8 c0       	rjmp	.+336    	; 0x33e2 <vfprintf+0x39e>
    3292:	2f 2f       	mov	r18, r31
    3294:	20 61       	ori	r18, 0x10	; 16
    3296:	b2 2e       	mov	r11, r18
    3298:	b4 fe       	sbrs	r11, 4
    329a:	0d c0       	rjmp	.+26     	; 0x32b6 <vfprintf+0x272>
    329c:	8b 2d       	mov	r24, r11
    329e:	84 60       	ori	r24, 0x04	; 4
    32a0:	b8 2e       	mov	r11, r24
    32a2:	09 c0       	rjmp	.+18     	; 0x32b6 <vfprintf+0x272>
    32a4:	24 ff       	sbrs	r18, 4
    32a6:	0a c0       	rjmp	.+20     	; 0x32bc <vfprintf+0x278>
    32a8:	9f 2f       	mov	r25, r31
    32aa:	96 60       	ori	r25, 0x06	; 6
    32ac:	b9 2e       	mov	r11, r25
    32ae:	06 c0       	rjmp	.+12     	; 0x32bc <vfprintf+0x278>
    32b0:	28 e0       	ldi	r18, 0x08	; 8
    32b2:	30 e0       	ldi	r19, 0x00	; 0
    32b4:	05 c0       	rjmp	.+10     	; 0x32c0 <vfprintf+0x27c>
    32b6:	20 e1       	ldi	r18, 0x10	; 16
    32b8:	30 e0       	ldi	r19, 0x00	; 0
    32ba:	02 c0       	rjmp	.+4      	; 0x32c0 <vfprintf+0x27c>
    32bc:	20 e1       	ldi	r18, 0x10	; 16
    32be:	32 e0       	ldi	r19, 0x02	; 2
    32c0:	f8 01       	movw	r30, r16
    32c2:	b7 fe       	sbrs	r11, 7
    32c4:	07 c0       	rjmp	.+14     	; 0x32d4 <vfprintf+0x290>
    32c6:	60 81       	ld	r22, Z
    32c8:	71 81       	ldd	r23, Z+1	; 0x01
    32ca:	82 81       	ldd	r24, Z+2	; 0x02
    32cc:	93 81       	ldd	r25, Z+3	; 0x03
    32ce:	0c 5f       	subi	r16, 0xFC	; 252
    32d0:	1f 4f       	sbci	r17, 0xFF	; 255
    32d2:	06 c0       	rjmp	.+12     	; 0x32e0 <vfprintf+0x29c>
    32d4:	60 81       	ld	r22, Z
    32d6:	71 81       	ldd	r23, Z+1	; 0x01
    32d8:	80 e0       	ldi	r24, 0x00	; 0
    32da:	90 e0       	ldi	r25, 0x00	; 0
    32dc:	0e 5f       	subi	r16, 0xFE	; 254
    32de:	1f 4f       	sbci	r17, 0xFF	; 255
    32e0:	a4 01       	movw	r20, r8
    32e2:	e6 d0       	rcall	.+460    	; 0x34b0 <__ultoa_invert>
    32e4:	a8 2e       	mov	r10, r24
    32e6:	a8 18       	sub	r10, r8
    32e8:	fb 2d       	mov	r31, r11
    32ea:	ff 77       	andi	r31, 0x7F	; 127
    32ec:	bf 2e       	mov	r11, r31
    32ee:	b6 fe       	sbrs	r11, 6
    32f0:	0b c0       	rjmp	.+22     	; 0x3308 <vfprintf+0x2c4>
    32f2:	2b 2d       	mov	r18, r11
    32f4:	2e 7f       	andi	r18, 0xFE	; 254
    32f6:	a5 14       	cp	r10, r5
    32f8:	50 f4       	brcc	.+20     	; 0x330e <vfprintf+0x2ca>
    32fa:	b4 fe       	sbrs	r11, 4
    32fc:	0a c0       	rjmp	.+20     	; 0x3312 <vfprintf+0x2ce>
    32fe:	b2 fc       	sbrc	r11, 2
    3300:	08 c0       	rjmp	.+16     	; 0x3312 <vfprintf+0x2ce>
    3302:	2b 2d       	mov	r18, r11
    3304:	2e 7e       	andi	r18, 0xEE	; 238
    3306:	05 c0       	rjmp	.+10     	; 0x3312 <vfprintf+0x2ce>
    3308:	7a 2c       	mov	r7, r10
    330a:	2b 2d       	mov	r18, r11
    330c:	03 c0       	rjmp	.+6      	; 0x3314 <vfprintf+0x2d0>
    330e:	7a 2c       	mov	r7, r10
    3310:	01 c0       	rjmp	.+2      	; 0x3314 <vfprintf+0x2d0>
    3312:	75 2c       	mov	r7, r5
    3314:	24 ff       	sbrs	r18, 4
    3316:	0d c0       	rjmp	.+26     	; 0x3332 <vfprintf+0x2ee>
    3318:	fe 01       	movw	r30, r28
    331a:	ea 0d       	add	r30, r10
    331c:	f1 1d       	adc	r31, r1
    331e:	80 81       	ld	r24, Z
    3320:	80 33       	cpi	r24, 0x30	; 48
    3322:	11 f4       	brne	.+4      	; 0x3328 <vfprintf+0x2e4>
    3324:	29 7e       	andi	r18, 0xE9	; 233
    3326:	09 c0       	rjmp	.+18     	; 0x333a <vfprintf+0x2f6>
    3328:	22 ff       	sbrs	r18, 2
    332a:	06 c0       	rjmp	.+12     	; 0x3338 <vfprintf+0x2f4>
    332c:	73 94       	inc	r7
    332e:	73 94       	inc	r7
    3330:	04 c0       	rjmp	.+8      	; 0x333a <vfprintf+0x2f6>
    3332:	82 2f       	mov	r24, r18
    3334:	86 78       	andi	r24, 0x86	; 134
    3336:	09 f0       	breq	.+2      	; 0x333a <vfprintf+0x2f6>
    3338:	73 94       	inc	r7
    333a:	23 fd       	sbrc	r18, 3
    333c:	12 c0       	rjmp	.+36     	; 0x3362 <vfprintf+0x31e>
    333e:	20 ff       	sbrs	r18, 0
    3340:	06 c0       	rjmp	.+12     	; 0x334e <vfprintf+0x30a>
    3342:	5a 2c       	mov	r5, r10
    3344:	73 14       	cp	r7, r3
    3346:	18 f4       	brcc	.+6      	; 0x334e <vfprintf+0x30a>
    3348:	53 0c       	add	r5, r3
    334a:	57 18       	sub	r5, r7
    334c:	73 2c       	mov	r7, r3
    334e:	73 14       	cp	r7, r3
    3350:	60 f4       	brcc	.+24     	; 0x336a <vfprintf+0x326>
    3352:	b7 01       	movw	r22, r14
    3354:	80 e2       	ldi	r24, 0x20	; 32
    3356:	90 e0       	ldi	r25, 0x00	; 0
    3358:	2c 87       	std	Y+12, r18	; 0x0c
    335a:	78 d0       	rcall	.+240    	; 0x344c <fputc>
    335c:	73 94       	inc	r7
    335e:	2c 85       	ldd	r18, Y+12	; 0x0c
    3360:	f6 cf       	rjmp	.-20     	; 0x334e <vfprintf+0x30a>
    3362:	73 14       	cp	r7, r3
    3364:	10 f4       	brcc	.+4      	; 0x336a <vfprintf+0x326>
    3366:	37 18       	sub	r3, r7
    3368:	01 c0       	rjmp	.+2      	; 0x336c <vfprintf+0x328>
    336a:	31 2c       	mov	r3, r1
    336c:	24 ff       	sbrs	r18, 4
    336e:	11 c0       	rjmp	.+34     	; 0x3392 <vfprintf+0x34e>
    3370:	b7 01       	movw	r22, r14
    3372:	80 e3       	ldi	r24, 0x30	; 48
    3374:	90 e0       	ldi	r25, 0x00	; 0
    3376:	2c 87       	std	Y+12, r18	; 0x0c
    3378:	69 d0       	rcall	.+210    	; 0x344c <fputc>
    337a:	2c 85       	ldd	r18, Y+12	; 0x0c
    337c:	22 ff       	sbrs	r18, 2
    337e:	16 c0       	rjmp	.+44     	; 0x33ac <vfprintf+0x368>
    3380:	21 ff       	sbrs	r18, 1
    3382:	03 c0       	rjmp	.+6      	; 0x338a <vfprintf+0x346>
    3384:	88 e5       	ldi	r24, 0x58	; 88
    3386:	90 e0       	ldi	r25, 0x00	; 0
    3388:	02 c0       	rjmp	.+4      	; 0x338e <vfprintf+0x34a>
    338a:	88 e7       	ldi	r24, 0x78	; 120
    338c:	90 e0       	ldi	r25, 0x00	; 0
    338e:	b7 01       	movw	r22, r14
    3390:	0c c0       	rjmp	.+24     	; 0x33aa <vfprintf+0x366>
    3392:	82 2f       	mov	r24, r18
    3394:	86 78       	andi	r24, 0x86	; 134
    3396:	51 f0       	breq	.+20     	; 0x33ac <vfprintf+0x368>
    3398:	21 fd       	sbrc	r18, 1
    339a:	02 c0       	rjmp	.+4      	; 0x33a0 <vfprintf+0x35c>
    339c:	80 e2       	ldi	r24, 0x20	; 32
    339e:	01 c0       	rjmp	.+2      	; 0x33a2 <vfprintf+0x35e>
    33a0:	8b e2       	ldi	r24, 0x2B	; 43
    33a2:	27 fd       	sbrc	r18, 7
    33a4:	8d e2       	ldi	r24, 0x2D	; 45
    33a6:	b7 01       	movw	r22, r14
    33a8:	90 e0       	ldi	r25, 0x00	; 0
    33aa:	50 d0       	rcall	.+160    	; 0x344c <fputc>
    33ac:	a5 14       	cp	r10, r5
    33ae:	30 f4       	brcc	.+12     	; 0x33bc <vfprintf+0x378>
    33b0:	b7 01       	movw	r22, r14
    33b2:	80 e3       	ldi	r24, 0x30	; 48
    33b4:	90 e0       	ldi	r25, 0x00	; 0
    33b6:	4a d0       	rcall	.+148    	; 0x344c <fputc>
    33b8:	5a 94       	dec	r5
    33ba:	f8 cf       	rjmp	.-16     	; 0x33ac <vfprintf+0x368>
    33bc:	aa 94       	dec	r10
    33be:	f4 01       	movw	r30, r8
    33c0:	ea 0d       	add	r30, r10
    33c2:	f1 1d       	adc	r31, r1
    33c4:	80 81       	ld	r24, Z
    33c6:	b7 01       	movw	r22, r14
    33c8:	90 e0       	ldi	r25, 0x00	; 0
    33ca:	40 d0       	rcall	.+128    	; 0x344c <fputc>
    33cc:	a1 10       	cpse	r10, r1
    33ce:	f6 cf       	rjmp	.-20     	; 0x33bc <vfprintf+0x378>
    33d0:	33 20       	and	r3, r3
    33d2:	09 f4       	brne	.+2      	; 0x33d6 <vfprintf+0x392>
    33d4:	5d ce       	rjmp	.-838    	; 0x3090 <vfprintf+0x4c>
    33d6:	b7 01       	movw	r22, r14
    33d8:	80 e2       	ldi	r24, 0x20	; 32
    33da:	90 e0       	ldi	r25, 0x00	; 0
    33dc:	37 d0       	rcall	.+110    	; 0x344c <fputc>
    33de:	3a 94       	dec	r3
    33e0:	f7 cf       	rjmp	.-18     	; 0x33d0 <vfprintf+0x38c>
    33e2:	f7 01       	movw	r30, r14
    33e4:	86 81       	ldd	r24, Z+6	; 0x06
    33e6:	97 81       	ldd	r25, Z+7	; 0x07
    33e8:	02 c0       	rjmp	.+4      	; 0x33ee <vfprintf+0x3aa>
    33ea:	8f ef       	ldi	r24, 0xFF	; 255
    33ec:	9f ef       	ldi	r25, 0xFF	; 255
    33ee:	2c 96       	adiw	r28, 0x0c	; 12
    33f0:	0f b6       	in	r0, 0x3f	; 63
    33f2:	f8 94       	cli
    33f4:	de bf       	out	0x3e, r29	; 62
    33f6:	0f be       	out	0x3f, r0	; 63
    33f8:	cd bf       	out	0x3d, r28	; 61
    33fa:	df 91       	pop	r29
    33fc:	cf 91       	pop	r28
    33fe:	1f 91       	pop	r17
    3400:	0f 91       	pop	r16
    3402:	ff 90       	pop	r15
    3404:	ef 90       	pop	r14
    3406:	df 90       	pop	r13
    3408:	cf 90       	pop	r12
    340a:	bf 90       	pop	r11
    340c:	af 90       	pop	r10
    340e:	9f 90       	pop	r9
    3410:	8f 90       	pop	r8
    3412:	7f 90       	pop	r7
    3414:	6f 90       	pop	r6
    3416:	5f 90       	pop	r5
    3418:	4f 90       	pop	r4
    341a:	3f 90       	pop	r3
    341c:	2f 90       	pop	r2
    341e:	08 95       	ret

00003420 <strnlen_P>:
    3420:	fc 01       	movw	r30, r24
    3422:	05 90       	lpm	r0, Z+
    3424:	61 50       	subi	r22, 0x01	; 1
    3426:	70 40       	sbci	r23, 0x00	; 0
    3428:	01 10       	cpse	r0, r1
    342a:	d8 f7       	brcc	.-10     	; 0x3422 <strnlen_P+0x2>
    342c:	80 95       	com	r24
    342e:	90 95       	com	r25
    3430:	8e 0f       	add	r24, r30
    3432:	9f 1f       	adc	r25, r31
    3434:	08 95       	ret

00003436 <strnlen>:
    3436:	fc 01       	movw	r30, r24
    3438:	61 50       	subi	r22, 0x01	; 1
    343a:	70 40       	sbci	r23, 0x00	; 0
    343c:	01 90       	ld	r0, Z+
    343e:	01 10       	cpse	r0, r1
    3440:	d8 f7       	brcc	.-10     	; 0x3438 <strnlen+0x2>
    3442:	80 95       	com	r24
    3444:	90 95       	com	r25
    3446:	8e 0f       	add	r24, r30
    3448:	9f 1f       	adc	r25, r31
    344a:	08 95       	ret

0000344c <fputc>:
    344c:	0f 93       	push	r16
    344e:	1f 93       	push	r17
    3450:	cf 93       	push	r28
    3452:	df 93       	push	r29
    3454:	18 2f       	mov	r17, r24
    3456:	09 2f       	mov	r16, r25
    3458:	eb 01       	movw	r28, r22
    345a:	8b 81       	ldd	r24, Y+3	; 0x03
    345c:	81 fd       	sbrc	r24, 1
    345e:	03 c0       	rjmp	.+6      	; 0x3466 <fputc+0x1a>
    3460:	8f ef       	ldi	r24, 0xFF	; 255
    3462:	9f ef       	ldi	r25, 0xFF	; 255
    3464:	20 c0       	rjmp	.+64     	; 0x34a6 <fputc+0x5a>
    3466:	82 ff       	sbrs	r24, 2
    3468:	10 c0       	rjmp	.+32     	; 0x348a <fputc+0x3e>
    346a:	4e 81       	ldd	r20, Y+6	; 0x06
    346c:	5f 81       	ldd	r21, Y+7	; 0x07
    346e:	2c 81       	ldd	r18, Y+4	; 0x04
    3470:	3d 81       	ldd	r19, Y+5	; 0x05
    3472:	42 17       	cp	r20, r18
    3474:	53 07       	cpc	r21, r19
    3476:	7c f4       	brge	.+30     	; 0x3496 <fputc+0x4a>
    3478:	e8 81       	ld	r30, Y
    347a:	f9 81       	ldd	r31, Y+1	; 0x01
    347c:	9f 01       	movw	r18, r30
    347e:	2f 5f       	subi	r18, 0xFF	; 255
    3480:	3f 4f       	sbci	r19, 0xFF	; 255
    3482:	39 83       	std	Y+1, r19	; 0x01
    3484:	28 83       	st	Y, r18
    3486:	10 83       	st	Z, r17
    3488:	06 c0       	rjmp	.+12     	; 0x3496 <fputc+0x4a>
    348a:	e8 85       	ldd	r30, Y+8	; 0x08
    348c:	f9 85       	ldd	r31, Y+9	; 0x09
    348e:	81 2f       	mov	r24, r17
    3490:	19 95       	eicall
    3492:	89 2b       	or	r24, r25
    3494:	29 f7       	brne	.-54     	; 0x3460 <fputc+0x14>
    3496:	2e 81       	ldd	r18, Y+6	; 0x06
    3498:	3f 81       	ldd	r19, Y+7	; 0x07
    349a:	2f 5f       	subi	r18, 0xFF	; 255
    349c:	3f 4f       	sbci	r19, 0xFF	; 255
    349e:	3f 83       	std	Y+7, r19	; 0x07
    34a0:	2e 83       	std	Y+6, r18	; 0x06
    34a2:	81 2f       	mov	r24, r17
    34a4:	90 2f       	mov	r25, r16
    34a6:	df 91       	pop	r29
    34a8:	cf 91       	pop	r28
    34aa:	1f 91       	pop	r17
    34ac:	0f 91       	pop	r16
    34ae:	08 95       	ret

000034b0 <__ultoa_invert>:
    34b0:	fa 01       	movw	r30, r20
    34b2:	aa 27       	eor	r26, r26
    34b4:	28 30       	cpi	r18, 0x08	; 8
    34b6:	51 f1       	breq	.+84     	; 0x350c <__ultoa_invert+0x5c>
    34b8:	20 31       	cpi	r18, 0x10	; 16
    34ba:	81 f1       	breq	.+96     	; 0x351c <__ultoa_invert+0x6c>
    34bc:	e8 94       	clt
    34be:	6f 93       	push	r22
    34c0:	6e 7f       	andi	r22, 0xFE	; 254
    34c2:	6e 5f       	subi	r22, 0xFE	; 254
    34c4:	7f 4f       	sbci	r23, 0xFF	; 255
    34c6:	8f 4f       	sbci	r24, 0xFF	; 255
    34c8:	9f 4f       	sbci	r25, 0xFF	; 255
    34ca:	af 4f       	sbci	r26, 0xFF	; 255
    34cc:	b1 e0       	ldi	r27, 0x01	; 1
    34ce:	3e d0       	rcall	.+124    	; 0x354c <__ultoa_invert+0x9c>
    34d0:	b4 e0       	ldi	r27, 0x04	; 4
    34d2:	3c d0       	rcall	.+120    	; 0x354c <__ultoa_invert+0x9c>
    34d4:	67 0f       	add	r22, r23
    34d6:	78 1f       	adc	r23, r24
    34d8:	89 1f       	adc	r24, r25
    34da:	9a 1f       	adc	r25, r26
    34dc:	a1 1d       	adc	r26, r1
    34de:	68 0f       	add	r22, r24
    34e0:	79 1f       	adc	r23, r25
    34e2:	8a 1f       	adc	r24, r26
    34e4:	91 1d       	adc	r25, r1
    34e6:	a1 1d       	adc	r26, r1
    34e8:	6a 0f       	add	r22, r26
    34ea:	71 1d       	adc	r23, r1
    34ec:	81 1d       	adc	r24, r1
    34ee:	91 1d       	adc	r25, r1
    34f0:	a1 1d       	adc	r26, r1
    34f2:	20 d0       	rcall	.+64     	; 0x3534 <__ultoa_invert+0x84>
    34f4:	09 f4       	brne	.+2      	; 0x34f8 <__ultoa_invert+0x48>
    34f6:	68 94       	set
    34f8:	3f 91       	pop	r19
    34fa:	2a e0       	ldi	r18, 0x0A	; 10
    34fc:	26 9f       	mul	r18, r22
    34fe:	11 24       	eor	r1, r1
    3500:	30 19       	sub	r19, r0
    3502:	30 5d       	subi	r19, 0xD0	; 208
    3504:	31 93       	st	Z+, r19
    3506:	de f6       	brtc	.-74     	; 0x34be <__ultoa_invert+0xe>
    3508:	cf 01       	movw	r24, r30
    350a:	08 95       	ret
    350c:	46 2f       	mov	r20, r22
    350e:	47 70       	andi	r20, 0x07	; 7
    3510:	40 5d       	subi	r20, 0xD0	; 208
    3512:	41 93       	st	Z+, r20
    3514:	b3 e0       	ldi	r27, 0x03	; 3
    3516:	0f d0       	rcall	.+30     	; 0x3536 <__ultoa_invert+0x86>
    3518:	c9 f7       	brne	.-14     	; 0x350c <__ultoa_invert+0x5c>
    351a:	f6 cf       	rjmp	.-20     	; 0x3508 <__ultoa_invert+0x58>
    351c:	46 2f       	mov	r20, r22
    351e:	4f 70       	andi	r20, 0x0F	; 15
    3520:	40 5d       	subi	r20, 0xD0	; 208
    3522:	4a 33       	cpi	r20, 0x3A	; 58
    3524:	18 f0       	brcs	.+6      	; 0x352c <__ultoa_invert+0x7c>
    3526:	49 5d       	subi	r20, 0xD9	; 217
    3528:	31 fd       	sbrc	r19, 1
    352a:	40 52       	subi	r20, 0x20	; 32
    352c:	41 93       	st	Z+, r20
    352e:	02 d0       	rcall	.+4      	; 0x3534 <__ultoa_invert+0x84>
    3530:	a9 f7       	brne	.-22     	; 0x351c <__ultoa_invert+0x6c>
    3532:	ea cf       	rjmp	.-44     	; 0x3508 <__ultoa_invert+0x58>
    3534:	b4 e0       	ldi	r27, 0x04	; 4
    3536:	a6 95       	lsr	r26
    3538:	97 95       	ror	r25
    353a:	87 95       	ror	r24
    353c:	77 95       	ror	r23
    353e:	67 95       	ror	r22
    3540:	ba 95       	dec	r27
    3542:	c9 f7       	brne	.-14     	; 0x3536 <__ultoa_invert+0x86>
    3544:	00 97       	sbiw	r24, 0x00	; 0
    3546:	61 05       	cpc	r22, r1
    3548:	71 05       	cpc	r23, r1
    354a:	08 95       	ret
    354c:	9b 01       	movw	r18, r22
    354e:	ac 01       	movw	r20, r24
    3550:	0a 2e       	mov	r0, r26
    3552:	06 94       	lsr	r0
    3554:	57 95       	ror	r21
    3556:	47 95       	ror	r20
    3558:	37 95       	ror	r19
    355a:	27 95       	ror	r18
    355c:	ba 95       	dec	r27
    355e:	c9 f7       	brne	.-14     	; 0x3552 <__ultoa_invert+0xa2>
    3560:	62 0f       	add	r22, r18
    3562:	73 1f       	adc	r23, r19
    3564:	84 1f       	adc	r24, r20
    3566:	95 1f       	adc	r25, r21
    3568:	a0 1d       	adc	r26, r0
    356a:	08 95       	ret

0000356c <_exit>:
    356c:	f8 94       	cli

0000356e <__stop_program>:
    356e:	ff cf       	rjmp	.-2      	; 0x356e <__stop_program>
