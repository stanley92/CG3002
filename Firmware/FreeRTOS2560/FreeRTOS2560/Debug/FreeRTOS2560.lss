
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00800200  0000108e  00001122  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000108e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000642  00800216  00800216  00001138  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001138  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000250  00000000  00000000  00001168  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00002809  00000000  00000000  000013b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000a86  00000000  00000000  00003bc1  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00001b45  00000000  00000000  00004647  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000005f0  00000000  00000000  0000618c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000d0f  00000000  00000000  0000677c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00001ed9  00000000  00000000  0000748b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000250  00000000  00000000  00009364  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	ab c0       	rjmp	.+342    	; 0x158 <__ctors_end>
       2:	00 00       	nop
       4:	c8 c0       	rjmp	.+400    	; 0x196 <__bad_interrupt>
       6:	00 00       	nop
       8:	c6 c0       	rjmp	.+396    	; 0x196 <__bad_interrupt>
       a:	00 00       	nop
       c:	c4 c0       	rjmp	.+392    	; 0x196 <__bad_interrupt>
       e:	00 00       	nop
      10:	c2 c0       	rjmp	.+388    	; 0x196 <__bad_interrupt>
      12:	00 00       	nop
      14:	c0 c0       	rjmp	.+384    	; 0x196 <__bad_interrupt>
      16:	00 00       	nop
      18:	be c0       	rjmp	.+380    	; 0x196 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	bc c0       	rjmp	.+376    	; 0x196 <__bad_interrupt>
      1e:	00 00       	nop
      20:	ba c0       	rjmp	.+372    	; 0x196 <__bad_interrupt>
      22:	00 00       	nop
      24:	b8 c0       	rjmp	.+368    	; 0x196 <__bad_interrupt>
      26:	00 00       	nop
      28:	b6 c0       	rjmp	.+364    	; 0x196 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	b4 c0       	rjmp	.+360    	; 0x196 <__bad_interrupt>
      2e:	00 00       	nop
      30:	b2 c0       	rjmp	.+356    	; 0x196 <__bad_interrupt>
      32:	00 00       	nop
      34:	b0 c0       	rjmp	.+352    	; 0x196 <__bad_interrupt>
      36:	00 00       	nop
      38:	ae c0       	rjmp	.+348    	; 0x196 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	ac c0       	rjmp	.+344    	; 0x196 <__bad_interrupt>
      3e:	00 00       	nop
      40:	aa c0       	rjmp	.+340    	; 0x196 <__bad_interrupt>
      42:	00 00       	nop
      44:	a8 c0       	rjmp	.+336    	; 0x196 <__bad_interrupt>
      46:	00 00       	nop
      48:	a6 c0       	rjmp	.+332    	; 0x196 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	a4 c0       	rjmp	.+328    	; 0x196 <__bad_interrupt>
      4e:	00 00       	nop
      50:	a2 c0       	rjmp	.+324    	; 0x196 <__bad_interrupt>
      52:	00 00       	nop
      54:	2d c3       	rjmp	.+1626   	; 0x6b0 <__vector_21>
      56:	00 00       	nop
      58:	9e c0       	rjmp	.+316    	; 0x196 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	90 c6       	rjmp	.+3360   	; 0xd7e <__vector_23>
      5e:	00 00       	nop
      60:	9a c0       	rjmp	.+308    	; 0x196 <__bad_interrupt>
      62:	00 00       	nop
      64:	98 c0       	rjmp	.+304    	; 0x196 <__bad_interrupt>
      66:	00 00       	nop
      68:	96 c0       	rjmp	.+300    	; 0x196 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	94 c0       	rjmp	.+296    	; 0x196 <__bad_interrupt>
      6e:	00 00       	nop
      70:	92 c0       	rjmp	.+292    	; 0x196 <__bad_interrupt>
      72:	00 00       	nop
      74:	90 c0       	rjmp	.+288    	; 0x196 <__bad_interrupt>
      76:	00 00       	nop
      78:	8e c0       	rjmp	.+284    	; 0x196 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	8c c0       	rjmp	.+280    	; 0x196 <__bad_interrupt>
      7e:	00 00       	nop
      80:	8a c0       	rjmp	.+276    	; 0x196 <__bad_interrupt>
      82:	00 00       	nop
      84:	88 c0       	rjmp	.+272    	; 0x196 <__bad_interrupt>
      86:	00 00       	nop
      88:	86 c0       	rjmp	.+268    	; 0x196 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	84 c0       	rjmp	.+264    	; 0x196 <__bad_interrupt>
      8e:	00 00       	nop
      90:	82 c0       	rjmp	.+260    	; 0x196 <__bad_interrupt>
      92:	00 00       	nop
      94:	80 c0       	rjmp	.+256    	; 0x196 <__bad_interrupt>
      96:	00 00       	nop
      98:	7e c0       	rjmp	.+252    	; 0x196 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	7c c0       	rjmp	.+248    	; 0x196 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	7a c0       	rjmp	.+244    	; 0x196 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	78 c0       	rjmp	.+240    	; 0x196 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	76 c0       	rjmp	.+236    	; 0x196 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	74 c0       	rjmp	.+232    	; 0x196 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	72 c0       	rjmp	.+228    	; 0x196 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	70 c0       	rjmp	.+224    	; 0x196 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	6e c0       	rjmp	.+220    	; 0x196 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	6c c0       	rjmp	.+216    	; 0x196 <__bad_interrupt>
      be:	00 00       	nop
      c0:	6a c0       	rjmp	.+212    	; 0x196 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	68 c0       	rjmp	.+208    	; 0x196 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	66 c0       	rjmp	.+204    	; 0x196 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	64 c0       	rjmp	.+200    	; 0x196 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	62 c0       	rjmp	.+196    	; 0x196 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	60 c0       	rjmp	.+192    	; 0x196 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	5e c0       	rjmp	.+188    	; 0x196 <__bad_interrupt>
      da:	00 00       	nop
      dc:	5c c0       	rjmp	.+184    	; 0x196 <__bad_interrupt>
      de:	00 00       	nop
      e0:	5a c0       	rjmp	.+180    	; 0x196 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	87 07       	cpc	r24, r23
      e6:	8b 07       	cpc	r24, r27
      e8:	75 07       	cpc	r23, r21
      ea:	7b 07       	cpc	r23, r27
      ec:	81 07       	cpc	r24, r17
      ee:	d0 07       	cpc	r29, r16
      f0:	8f 07       	cpc	r24, r31
      f2:	95 07       	cpc	r25, r21
      f4:	9b 07       	cpc	r25, r27
      f6:	a1 07       	cpc	r26, r17
      f8:	a7 07       	cpc	r26, r23
      fa:	ad 07       	cpc	r26, r29
      fc:	b3 07       	cpc	r27, r19
      fe:	b9 07       	cpc	r27, r25
     100:	d0 07       	cpc	r29, r16
     102:	bf 07       	cpc	r27, r31
     104:	c5 07       	cpc	r28, r21
     106:	cb 07       	cpc	r28, r27

00000108 <__trampolines_end>:
     108:	00 00       	nop
     10a:	00 08       	sbc	r0, r0
     10c:	00 02       	muls	r16, r16
     10e:	01 00       	.word	0x0001	; ????
     110:	00 03       	mulsu	r16, r16
     112:	04 07       	cpc	r16, r20
	...

0000011c <digital_pin_to_bit_mask_PGM>:
     11c:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 01 02     ..... @...... ..
     12c:	04 08 10 20                                         ... 

00000130 <digital_pin_to_port_PGM>:
     130:	04 04 04 04 04 04 04 04 02 02 02 02 02 02 03 03     ................
     140:	03 03 03 03                                         ....

00000144 <port_to_output_PGM>:
     144:	00 00 00 00 25 00 28 00 2b 00                       ....%.(.+.

0000014e <port_to_mode_PGM>:
     14e:	00 00 00 00 24 00 27 00 2a 00                       ....$.'.*.

00000158 <__ctors_end>:
     158:	11 24       	eor	r1, r1
     15a:	1f be       	out	0x3f, r1	; 63
     15c:	cf ef       	ldi	r28, 0xFF	; 255
     15e:	d1 e2       	ldi	r29, 0x21	; 33
     160:	de bf       	out	0x3e, r29	; 62
     162:	cd bf       	out	0x3d, r28	; 61
     164:	00 e0       	ldi	r16, 0x00	; 0
     166:	0c bf       	out	0x3c, r16	; 60

00000168 <__do_copy_data>:
     168:	12 e0       	ldi	r17, 0x02	; 2
     16a:	a0 e0       	ldi	r26, 0x00	; 0
     16c:	b2 e0       	ldi	r27, 0x02	; 2
     16e:	ee e8       	ldi	r30, 0x8E	; 142
     170:	f0 e1       	ldi	r31, 0x10	; 16
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0b bf       	out	0x3b, r16	; 59
     176:	02 c0       	rjmp	.+4      	; 0x17c <__do_copy_data+0x14>
     178:	07 90       	elpm	r0, Z+
     17a:	0d 92       	st	X+, r0
     17c:	a6 31       	cpi	r26, 0x16	; 22
     17e:	b1 07       	cpc	r27, r17
     180:	d9 f7       	brne	.-10     	; 0x178 <__do_copy_data+0x10>

00000182 <__do_clear_bss>:
     182:	28 e0       	ldi	r18, 0x08	; 8
     184:	a6 e1       	ldi	r26, 0x16	; 22
     186:	b2 e0       	ldi	r27, 0x02	; 2
     188:	01 c0       	rjmp	.+2      	; 0x18c <.do_clear_bss_start>

0000018a <.do_clear_bss_loop>:
     18a:	1d 92       	st	X+, r1

0000018c <.do_clear_bss_start>:
     18c:	a8 35       	cpi	r26, 0x58	; 88
     18e:	b2 07       	cpc	r27, r18
     190:	e1 f7       	brne	.-8      	; 0x18a <.do_clear_bss_loop>
     192:	1c d0       	rcall	.+56     	; 0x1cc <main>
     194:	7a c7       	rjmp	.+3828   	; 0x108a <_exit>

00000196 <__bad_interrupt>:
     196:	34 cf       	rjmp	.-408    	; 0x0 <__vectors>

00000198 <_Z5task1Pv>:
	}
}
#define STACK_DEPTH 64

void vApplicationIdleHook()
{
     198:	61 e0       	ldi	r22, 0x01	; 1
     19a:	8d e0       	ldi	r24, 0x0D	; 13
     19c:	40 d7       	rcall	.+3712   	; 0x101e <digitalWrite>
     19e:	88 eb       	ldi	r24, 0xB8	; 184
     1a0:	9b e0       	ldi	r25, 0x0B	; 11
     1a2:	3e d5       	rcall	.+2684   	; 0xc20 <vTaskDelay>
     1a4:	60 e0       	ldi	r22, 0x00	; 0
     1a6:	8d e0       	ldi	r24, 0x0D	; 13
     1a8:	3a d7       	rcall	.+3700   	; 0x101e <digitalWrite>
     1aa:	88 eb       	ldi	r24, 0xB8	; 184
     1ac:	9b e0       	ldi	r25, 0x0B	; 11
     1ae:	38 d5       	rcall	.+2672   	; 0xc20 <vTaskDelay>
     1b0:	f3 cf       	rjmp	.-26     	; 0x198 <_Z5task1Pv>

000001b2 <_Z5task2Pv>:
     1b2:	61 e0       	ldi	r22, 0x01	; 1
     1b4:	8c e0       	ldi	r24, 0x0C	; 12
     1b6:	33 d7       	rcall	.+3686   	; 0x101e <digitalWrite>
     1b8:	88 ee       	ldi	r24, 0xE8	; 232
     1ba:	93 e0       	ldi	r25, 0x03	; 3
     1bc:	31 d5       	rcall	.+2658   	; 0xc20 <vTaskDelay>
     1be:	60 e0       	ldi	r22, 0x00	; 0
     1c0:	8c e0       	ldi	r24, 0x0C	; 12
     1c2:	2d d7       	rcall	.+3674   	; 0x101e <digitalWrite>
     1c4:	88 ee       	ldi	r24, 0xE8	; 232
     1c6:	93 e0       	ldi	r25, 0x03	; 3
     1c8:	2b d5       	rcall	.+2646   	; 0xc20 <vTaskDelay>
     1ca:	f3 cf       	rjmp	.-26     	; 0x1b2 <_Z5task2Pv>

000001cc <main>:
	//Do nothing
}

int main(void)
{
     1cc:	af 92       	push	r10
     1ce:	bf 92       	push	r11
     1d0:	cf 92       	push	r12
     1d2:	df 92       	push	r13
     1d4:	ef 92       	push	r14
     1d6:	ff 92       	push	r15
     1d8:	0f 93       	push	r16
     1da:	cf 93       	push	r28
     1dc:	df 93       	push	r29
     1de:	00 d0       	rcall	.+0      	; 0x1e0 <main+0x14>
     1e0:	1f 92       	push	r1
     1e2:	cd b7       	in	r28, 0x3d	; 61
     1e4:	de b7       	in	r29, 0x3e	; 62
	init();
     1e6:	15 d6       	rcall	.+3114   	; 0xe12 <init>
	pinMode(12,OUTPUT);
     1e8:	61 e0       	ldi	r22, 0x01	; 1
     1ea:	8c e0       	ldi	r24, 0x0C	; 12
     1ec:	da d6       	rcall	.+3508   	; 0xfa2 <pinMode>
	pinMode(13,OUTPUT);
     1ee:	61 e0       	ldi	r22, 0x01	; 1
     1f0:	8d e0       	ldi	r24, 0x0D	; 13
     1f2:	d7 d6       	rcall	.+3502   	; 0xfa2 <pinMode>
	TaskHandle_t t1,t2;
	
	//Create tasks
	xTaskCreate(task1, "Task 1", STACK_DEPTH, NULL, 6, &t1);
     1f4:	a1 2c       	mov	r10, r1
     1f6:	b1 2c       	mov	r11, r1
     1f8:	c1 2c       	mov	r12, r1
     1fa:	d1 2c       	mov	r13, r1
     1fc:	ce 01       	movw	r24, r28
     1fe:	03 96       	adiw	r24, 0x03	; 3
     200:	7c 01       	movw	r14, r24
     202:	06 e0       	ldi	r16, 0x06	; 6
     204:	20 e0       	ldi	r18, 0x00	; 0
     206:	30 e0       	ldi	r19, 0x00	; 0
     208:	40 e4       	ldi	r20, 0x40	; 64
     20a:	50 e0       	ldi	r21, 0x00	; 0
     20c:	62 e0       	ldi	r22, 0x02	; 2
     20e:	72 e0       	ldi	r23, 0x02	; 2
     210:	8c ec       	ldi	r24, 0xCC	; 204
     212:	90 e0       	ldi	r25, 0x00	; 0
     214:	a3 d2       	rcall	.+1350   	; 0x75c <xTaskGenericCreate>
	xTaskCreate(task2, "Task 2", STACK_DEPTH, NULL, 5, &t2);
     216:	ce 01       	movw	r24, r28
     218:	01 96       	adiw	r24, 0x01	; 1
     21a:	7c 01       	movw	r14, r24
     21c:	05 e0       	ldi	r16, 0x05	; 5
     21e:	20 e0       	ldi	r18, 0x00	; 0
     220:	30 e0       	ldi	r19, 0x00	; 0
     222:	40 e4       	ldi	r20, 0x40	; 64
     224:	50 e0       	ldi	r21, 0x00	; 0
     226:	69 e0       	ldi	r22, 0x09	; 9
     228:	72 e0       	ldi	r23, 0x02	; 2
     22a:	89 ed       	ldi	r24, 0xD9	; 217
     22c:	90 e0       	ldi	r25, 0x00	; 0
     22e:	96 d2       	rcall	.+1324   	; 0x75c <xTaskGenericCreate>
	
	vTaskStartScheduler();
     230:	8f d3       	rcall	.+1822   	; 0x950 <vTaskStartScheduler>
     232:	80 e0       	ldi	r24, 0x00	; 0
     234:	90 e0       	ldi	r25, 0x00	; 0
     236:	0f 90       	pop	r0
     238:	0f 90       	pop	r0
     23a:	0f 90       	pop	r0
     23c:	0f 90       	pop	r0
     23e:	df 91       	pop	r29
     240:	cf 91       	pop	r28
     242:	0f 91       	pop	r16
     244:	ff 90       	pop	r15
     246:	ef 90       	pop	r14
     248:	df 90       	pop	r13
     24a:	cf 90       	pop	r12
     24c:	bf 90       	pop	r11
     24e:	af 90       	pop	r10
     250:	08 95       	ret

00000252 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     252:	cf 93       	push	r28
     254:	df 93       	push	r29
     256:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     258:	a4 d3       	rcall	.+1864   	; 0x9a2 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     25a:	80 91 16 02 	lds	r24, 0x0216
     25e:	90 91 17 02 	lds	r25, 0x0217
     262:	89 2b       	or	r24, r25
     264:	31 f4       	brne	.+12     	; 0x272 <pvPortMalloc+0x20>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     266:	8b e1       	ldi	r24, 0x1B	; 27
     268:	92 e0       	ldi	r25, 0x02	; 2
     26a:	90 93 17 02 	sts	0x0217, r25
     26e:	80 93 16 02 	sts	0x0216, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     272:	40 91 18 02 	lds	r20, 0x0218
     276:	50 91 19 02 	lds	r21, 0x0219
     27a:	9e 01       	movw	r18, r28
     27c:	24 0f       	add	r18, r20
     27e:	35 1f       	adc	r19, r21
     280:	2b 3d       	cpi	r18, 0xDB	; 219
     282:	85 e0       	ldi	r24, 0x05	; 5
     284:	38 07       	cpc	r19, r24
     286:	70 f4       	brcc	.+28     	; 0x2a4 <pvPortMalloc+0x52>
     288:	42 17       	cp	r20, r18
     28a:	53 07       	cpc	r21, r19
     28c:	70 f4       	brcc	.+28     	; 0x2aa <pvPortMalloc+0x58>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     28e:	c0 91 16 02 	lds	r28, 0x0216
     292:	d0 91 17 02 	lds	r29, 0x0217
     296:	c4 0f       	add	r28, r20
     298:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     29a:	30 93 19 02 	sts	0x0219, r19
     29e:	20 93 18 02 	sts	0x0218, r18
     2a2:	05 c0       	rjmp	.+10     	; 0x2ae <pvPortMalloc+0x5c>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     2a4:	c0 e0       	ldi	r28, 0x00	; 0
     2a6:	d0 e0       	ldi	r29, 0x00	; 0
     2a8:	02 c0       	rjmp	.+4      	; 0x2ae <pvPortMalloc+0x5c>
     2aa:	c0 e0       	ldi	r28, 0x00	; 0
     2ac:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     2ae:	3a d4       	rcall	.+2164   	; 0xb24 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     2b0:	ce 01       	movw	r24, r28
     2b2:	df 91       	pop	r29
     2b4:	cf 91       	pop	r28
     2b6:	08 95       	ret

000002b8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     2b8:	08 95       	ret

000002ba <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     2ba:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2bc:	03 96       	adiw	r24, 0x03	; 3
     2be:	92 83       	std	Z+2, r25	; 0x02
     2c0:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     2c2:	2f ef       	ldi	r18, 0xFF	; 255
     2c4:	3f ef       	ldi	r19, 0xFF	; 255
     2c6:	34 83       	std	Z+4, r19	; 0x04
     2c8:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2ca:	96 83       	std	Z+6, r25	; 0x06
     2cc:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2ce:	90 87       	std	Z+8, r25	; 0x08
     2d0:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     2d2:	10 82       	st	Z, r1
     2d4:	08 95       	ret

000002d6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     2d6:	fc 01       	movw	r30, r24
     2d8:	11 86       	std	Z+9, r1	; 0x09
     2da:	10 86       	std	Z+8, r1	; 0x08
     2dc:	08 95       	ret

000002de <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     2de:	cf 93       	push	r28
     2e0:	df 93       	push	r29
     2e2:	9c 01       	movw	r18, r24
     2e4:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     2e6:	dc 01       	movw	r26, r24
     2e8:	11 96       	adiw	r26, 0x01	; 1
     2ea:	cd 91       	ld	r28, X+
     2ec:	dc 91       	ld	r29, X
     2ee:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     2f0:	d3 83       	std	Z+3, r29	; 0x03
     2f2:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     2f4:	8c 81       	ldd	r24, Y+4	; 0x04
     2f6:	9d 81       	ldd	r25, Y+5	; 0x05
     2f8:	95 83       	std	Z+5, r25	; 0x05
     2fa:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     2fc:	8c 81       	ldd	r24, Y+4	; 0x04
     2fe:	9d 81       	ldd	r25, Y+5	; 0x05
     300:	dc 01       	movw	r26, r24
     302:	13 96       	adiw	r26, 0x03	; 3
     304:	7c 93       	st	X, r23
     306:	6e 93       	st	-X, r22
     308:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     30a:	7d 83       	std	Y+5, r23	; 0x05
     30c:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     30e:	31 87       	std	Z+9, r19	; 0x09
     310:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     312:	f9 01       	movw	r30, r18
     314:	80 81       	ld	r24, Z
     316:	8f 5f       	subi	r24, 0xFF	; 255
     318:	80 83       	st	Z, r24
}
     31a:	df 91       	pop	r29
     31c:	cf 91       	pop	r28
     31e:	08 95       	ret

00000320 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     320:	cf 93       	push	r28
     322:	df 93       	push	r29
     324:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     326:	48 81       	ld	r20, Y
     328:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     32a:	4f 3f       	cpi	r20, 0xFF	; 255
     32c:	2f ef       	ldi	r18, 0xFF	; 255
     32e:	52 07       	cpc	r21, r18
     330:	21 f4       	brne	.+8      	; 0x33a <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     332:	fc 01       	movw	r30, r24
     334:	a7 81       	ldd	r26, Z+7	; 0x07
     336:	b0 85       	ldd	r27, Z+8	; 0x08
     338:	0d c0       	rjmp	.+26     	; 0x354 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     33a:	dc 01       	movw	r26, r24
     33c:	13 96       	adiw	r26, 0x03	; 3
     33e:	12 96       	adiw	r26, 0x02	; 2
     340:	ed 91       	ld	r30, X+
     342:	fc 91       	ld	r31, X
     344:	13 97       	sbiw	r26, 0x03	; 3
     346:	20 81       	ld	r18, Z
     348:	31 81       	ldd	r19, Z+1	; 0x01
     34a:	42 17       	cp	r20, r18
     34c:	53 07       	cpc	r21, r19
     34e:	10 f0       	brcs	.+4      	; 0x354 <vListInsert+0x34>
     350:	df 01       	movw	r26, r30
     352:	f5 cf       	rjmp	.-22     	; 0x33e <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     354:	12 96       	adiw	r26, 0x02	; 2
     356:	ed 91       	ld	r30, X+
     358:	fc 91       	ld	r31, X
     35a:	13 97       	sbiw	r26, 0x03	; 3
     35c:	fb 83       	std	Y+3, r31	; 0x03
     35e:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     360:	d5 83       	std	Z+5, r29	; 0x05
     362:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     364:	bd 83       	std	Y+5, r27	; 0x05
     366:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     368:	13 96       	adiw	r26, 0x03	; 3
     36a:	dc 93       	st	X, r29
     36c:	ce 93       	st	-X, r28
     36e:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     370:	99 87       	std	Y+9, r25	; 0x09
     372:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     374:	fc 01       	movw	r30, r24
     376:	20 81       	ld	r18, Z
     378:	2f 5f       	subi	r18, 0xFF	; 255
     37a:	20 83       	st	Z, r18
}
     37c:	df 91       	pop	r29
     37e:	cf 91       	pop	r28
     380:	08 95       	ret

00000382 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     382:	cf 93       	push	r28
     384:	df 93       	push	r29
     386:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     388:	a0 85       	ldd	r26, Z+8	; 0x08
     38a:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     38c:	c2 81       	ldd	r28, Z+2	; 0x02
     38e:	d3 81       	ldd	r29, Z+3	; 0x03
     390:	84 81       	ldd	r24, Z+4	; 0x04
     392:	95 81       	ldd	r25, Z+5	; 0x05
     394:	9d 83       	std	Y+5, r25	; 0x05
     396:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     398:	c4 81       	ldd	r28, Z+4	; 0x04
     39a:	d5 81       	ldd	r29, Z+5	; 0x05
     39c:	82 81       	ldd	r24, Z+2	; 0x02
     39e:	93 81       	ldd	r25, Z+3	; 0x03
     3a0:	9b 83       	std	Y+3, r25	; 0x03
     3a2:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     3a4:	11 96       	adiw	r26, 0x01	; 1
     3a6:	cd 91       	ld	r28, X+
     3a8:	dc 91       	ld	r29, X
     3aa:	12 97       	sbiw	r26, 0x02	; 2
     3ac:	ce 17       	cp	r28, r30
     3ae:	df 07       	cpc	r29, r31
     3b0:	31 f4       	brne	.+12     	; 0x3be <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     3b2:	8c 81       	ldd	r24, Y+4	; 0x04
     3b4:	9d 81       	ldd	r25, Y+5	; 0x05
     3b6:	12 96       	adiw	r26, 0x02	; 2
     3b8:	9c 93       	st	X, r25
     3ba:	8e 93       	st	-X, r24
     3bc:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     3be:	11 86       	std	Z+9, r1	; 0x09
     3c0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     3c2:	8c 91       	ld	r24, X
     3c4:	81 50       	subi	r24, 0x01	; 1
     3c6:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     3c8:	df 91       	pop	r29
     3ca:	cf 91       	pop	r28
     3cc:	08 95       	ret

000003ce <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     3ce:	31 e1       	ldi	r19, 0x11	; 17
     3d0:	fc 01       	movw	r30, r24
     3d2:	30 83       	st	Z, r19
     3d4:	31 97       	sbiw	r30, 0x01	; 1
     3d6:	22 e2       	ldi	r18, 0x22	; 34
     3d8:	20 83       	st	Z, r18
     3da:	31 97       	sbiw	r30, 0x01	; 1
     3dc:	a3 e3       	ldi	r26, 0x33	; 51
     3de:	a0 83       	st	Z, r26
     3e0:	31 97       	sbiw	r30, 0x01	; 1
     3e2:	60 83       	st	Z, r22
     3e4:	31 97       	sbiw	r30, 0x01	; 1
     3e6:	70 83       	st	Z, r23
     3e8:	31 97       	sbiw	r30, 0x01	; 1
     3ea:	10 82       	st	Z, r1
     3ec:	31 97       	sbiw	r30, 0x01	; 1
     3ee:	10 82       	st	Z, r1
     3f0:	31 97       	sbiw	r30, 0x01	; 1
     3f2:	60 e8       	ldi	r22, 0x80	; 128
     3f4:	60 83       	st	Z, r22
     3f6:	31 97       	sbiw	r30, 0x01	; 1
     3f8:	10 82       	st	Z, r1
     3fa:	31 97       	sbiw	r30, 0x01	; 1
     3fc:	10 82       	st	Z, r1
     3fe:	31 97       	sbiw	r30, 0x01	; 1
     400:	10 82       	st	Z, r1
     402:	31 97       	sbiw	r30, 0x01	; 1
     404:	62 e0       	ldi	r22, 0x02	; 2
     406:	60 83       	st	Z, r22
     408:	31 97       	sbiw	r30, 0x01	; 1
     40a:	63 e0       	ldi	r22, 0x03	; 3
     40c:	60 83       	st	Z, r22
     40e:	31 97       	sbiw	r30, 0x01	; 1
     410:	64 e0       	ldi	r22, 0x04	; 4
     412:	60 83       	st	Z, r22
     414:	31 97       	sbiw	r30, 0x01	; 1
     416:	65 e0       	ldi	r22, 0x05	; 5
     418:	60 83       	st	Z, r22
     41a:	31 97       	sbiw	r30, 0x01	; 1
     41c:	66 e0       	ldi	r22, 0x06	; 6
     41e:	60 83       	st	Z, r22
     420:	31 97       	sbiw	r30, 0x01	; 1
     422:	67 e0       	ldi	r22, 0x07	; 7
     424:	60 83       	st	Z, r22
     426:	31 97       	sbiw	r30, 0x01	; 1
     428:	68 e0       	ldi	r22, 0x08	; 8
     42a:	60 83       	st	Z, r22
     42c:	31 97       	sbiw	r30, 0x01	; 1
     42e:	69 e0       	ldi	r22, 0x09	; 9
     430:	60 83       	st	Z, r22
     432:	31 97       	sbiw	r30, 0x01	; 1
     434:	60 e1       	ldi	r22, 0x10	; 16
     436:	60 83       	st	Z, r22
     438:	31 97       	sbiw	r30, 0x01	; 1
     43a:	30 83       	st	Z, r19
     43c:	31 97       	sbiw	r30, 0x01	; 1
     43e:	32 e1       	ldi	r19, 0x12	; 18
     440:	30 83       	st	Z, r19
     442:	31 97       	sbiw	r30, 0x01	; 1
     444:	33 e1       	ldi	r19, 0x13	; 19
     446:	30 83       	st	Z, r19
     448:	31 97       	sbiw	r30, 0x01	; 1
     44a:	34 e1       	ldi	r19, 0x14	; 20
     44c:	30 83       	st	Z, r19
     44e:	31 97       	sbiw	r30, 0x01	; 1
     450:	35 e1       	ldi	r19, 0x15	; 21
     452:	30 83       	st	Z, r19
     454:	31 97       	sbiw	r30, 0x01	; 1
     456:	36 e1       	ldi	r19, 0x16	; 22
     458:	30 83       	st	Z, r19
     45a:	31 97       	sbiw	r30, 0x01	; 1
     45c:	37 e1       	ldi	r19, 0x17	; 23
     45e:	30 83       	st	Z, r19
     460:	31 97       	sbiw	r30, 0x01	; 1
     462:	38 e1       	ldi	r19, 0x18	; 24
     464:	30 83       	st	Z, r19
     466:	31 97       	sbiw	r30, 0x01	; 1
     468:	39 e1       	ldi	r19, 0x19	; 25
     46a:	30 83       	st	Z, r19
     46c:	31 97       	sbiw	r30, 0x01	; 1
     46e:	30 e2       	ldi	r19, 0x20	; 32
     470:	30 83       	st	Z, r19
     472:	31 97       	sbiw	r30, 0x01	; 1
     474:	31 e2       	ldi	r19, 0x21	; 33
     476:	30 83       	st	Z, r19
     478:	31 97       	sbiw	r30, 0x01	; 1
     47a:	20 83       	st	Z, r18
     47c:	31 97       	sbiw	r30, 0x01	; 1
     47e:	23 e2       	ldi	r18, 0x23	; 35
     480:	20 83       	st	Z, r18
     482:	31 97       	sbiw	r30, 0x01	; 1
     484:	40 83       	st	Z, r20
     486:	31 97       	sbiw	r30, 0x01	; 1
     488:	50 83       	st	Z, r21
     48a:	31 97       	sbiw	r30, 0x01	; 1
     48c:	26 e2       	ldi	r18, 0x26	; 38
     48e:	20 83       	st	Z, r18
     490:	31 97       	sbiw	r30, 0x01	; 1
     492:	27 e2       	ldi	r18, 0x27	; 39
     494:	20 83       	st	Z, r18
     496:	31 97       	sbiw	r30, 0x01	; 1
     498:	28 e2       	ldi	r18, 0x28	; 40
     49a:	20 83       	st	Z, r18
     49c:	31 97       	sbiw	r30, 0x01	; 1
     49e:	29 e2       	ldi	r18, 0x29	; 41
     4a0:	20 83       	st	Z, r18
     4a2:	31 97       	sbiw	r30, 0x01	; 1
     4a4:	20 e3       	ldi	r18, 0x30	; 48
     4a6:	20 83       	st	Z, r18
     4a8:	31 97       	sbiw	r30, 0x01	; 1
     4aa:	21 e3       	ldi	r18, 0x31	; 49
     4ac:	20 83       	st	Z, r18
     4ae:	89 97       	sbiw	r24, 0x29	; 41
     4b0:	08 95       	ret

000004b2 <xPortStartScheduler>:
     4b2:	82 e0       	ldi	r24, 0x02	; 2
     4b4:	84 bd       	out	0x24, r24	; 36
     4b6:	16 bc       	out	0x26, r1	; 38
     4b8:	80 e3       	ldi	r24, 0x30	; 48
     4ba:	87 bd       	out	0x27, r24	; 39
     4bc:	ee e6       	ldi	r30, 0x6E	; 110
     4be:	f0 e0       	ldi	r31, 0x00	; 0
     4c0:	80 81       	ld	r24, Z
     4c2:	82 60       	ori	r24, 0x02	; 2
     4c4:	80 83       	st	Z, r24
     4c6:	83 e0       	ldi	r24, 0x03	; 3
     4c8:	85 bd       	out	0x25, r24	; 37
     4ca:	a0 91 4d 08 	lds	r26, 0x084D
     4ce:	b0 91 4e 08 	lds	r27, 0x084E
     4d2:	cd 91       	ld	r28, X+
     4d4:	cd bf       	out	0x3d, r28	; 61
     4d6:	dd 91       	ld	r29, X+
     4d8:	de bf       	out	0x3e, r29	; 62
     4da:	ff 91       	pop	r31
     4dc:	ef 91       	pop	r30
     4de:	df 91       	pop	r29
     4e0:	cf 91       	pop	r28
     4e2:	bf 91       	pop	r27
     4e4:	af 91       	pop	r26
     4e6:	9f 91       	pop	r25
     4e8:	8f 91       	pop	r24
     4ea:	7f 91       	pop	r23
     4ec:	6f 91       	pop	r22
     4ee:	5f 91       	pop	r21
     4f0:	4f 91       	pop	r20
     4f2:	3f 91       	pop	r19
     4f4:	2f 91       	pop	r18
     4f6:	1f 91       	pop	r17
     4f8:	0f 91       	pop	r16
     4fa:	ff 90       	pop	r15
     4fc:	ef 90       	pop	r14
     4fe:	df 90       	pop	r13
     500:	cf 90       	pop	r12
     502:	bf 90       	pop	r11
     504:	af 90       	pop	r10
     506:	9f 90       	pop	r9
     508:	8f 90       	pop	r8
     50a:	7f 90       	pop	r7
     50c:	6f 90       	pop	r6
     50e:	5f 90       	pop	r5
     510:	4f 90       	pop	r4
     512:	3f 90       	pop	r3
     514:	2f 90       	pop	r2
     516:	1f 90       	pop	r1
     518:	0f 90       	pop	r0
     51a:	0c be       	out	0x3c, r0	; 60
     51c:	0f 90       	pop	r0
     51e:	0b be       	out	0x3b, r0	; 59
     520:	0f 90       	pop	r0
     522:	0f be       	out	0x3f, r0	; 63
     524:	0f 90       	pop	r0
     526:	08 95       	ret
     528:	81 e0       	ldi	r24, 0x01	; 1
     52a:	08 95       	ret

0000052c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     52c:	0f 92       	push	r0
     52e:	0f b6       	in	r0, 0x3f	; 63
     530:	f8 94       	cli
     532:	0f 92       	push	r0
     534:	0b b6       	in	r0, 0x3b	; 59
     536:	0f 92       	push	r0
     538:	0c b6       	in	r0, 0x3c	; 60
     53a:	0f 92       	push	r0
     53c:	1f 92       	push	r1
     53e:	11 24       	eor	r1, r1
     540:	2f 92       	push	r2
     542:	3f 92       	push	r3
     544:	4f 92       	push	r4
     546:	5f 92       	push	r5
     548:	6f 92       	push	r6
     54a:	7f 92       	push	r7
     54c:	8f 92       	push	r8
     54e:	9f 92       	push	r9
     550:	af 92       	push	r10
     552:	bf 92       	push	r11
     554:	cf 92       	push	r12
     556:	df 92       	push	r13
     558:	ef 92       	push	r14
     55a:	ff 92       	push	r15
     55c:	0f 93       	push	r16
     55e:	1f 93       	push	r17
     560:	2f 93       	push	r18
     562:	3f 93       	push	r19
     564:	4f 93       	push	r20
     566:	5f 93       	push	r21
     568:	6f 93       	push	r22
     56a:	7f 93       	push	r23
     56c:	8f 93       	push	r24
     56e:	9f 93       	push	r25
     570:	af 93       	push	r26
     572:	bf 93       	push	r27
     574:	cf 93       	push	r28
     576:	df 93       	push	r29
     578:	ef 93       	push	r30
     57a:	ff 93       	push	r31
     57c:	a0 91 4d 08 	lds	r26, 0x084D
     580:	b0 91 4e 08 	lds	r27, 0x084E
     584:	0d b6       	in	r0, 0x3d	; 61
     586:	0d 92       	st	X+, r0
     588:	0e b6       	in	r0, 0x3e	; 62
     58a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     58c:	9a d3       	rcall	.+1844   	; 0xcc2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     58e:	a0 91 4d 08 	lds	r26, 0x084D
     592:	b0 91 4e 08 	lds	r27, 0x084E
     596:	cd 91       	ld	r28, X+
     598:	cd bf       	out	0x3d, r28	; 61
     59a:	dd 91       	ld	r29, X+
     59c:	de bf       	out	0x3e, r29	; 62
     59e:	ff 91       	pop	r31
     5a0:	ef 91       	pop	r30
     5a2:	df 91       	pop	r29
     5a4:	cf 91       	pop	r28
     5a6:	bf 91       	pop	r27
     5a8:	af 91       	pop	r26
     5aa:	9f 91       	pop	r25
     5ac:	8f 91       	pop	r24
     5ae:	7f 91       	pop	r23
     5b0:	6f 91       	pop	r22
     5b2:	5f 91       	pop	r21
     5b4:	4f 91       	pop	r20
     5b6:	3f 91       	pop	r19
     5b8:	2f 91       	pop	r18
     5ba:	1f 91       	pop	r17
     5bc:	0f 91       	pop	r16
     5be:	ff 90       	pop	r15
     5c0:	ef 90       	pop	r14
     5c2:	df 90       	pop	r13
     5c4:	cf 90       	pop	r12
     5c6:	bf 90       	pop	r11
     5c8:	af 90       	pop	r10
     5ca:	9f 90       	pop	r9
     5cc:	8f 90       	pop	r8
     5ce:	7f 90       	pop	r7
     5d0:	6f 90       	pop	r6
     5d2:	5f 90       	pop	r5
     5d4:	4f 90       	pop	r4
     5d6:	3f 90       	pop	r3
     5d8:	2f 90       	pop	r2
     5da:	1f 90       	pop	r1
     5dc:	0f 90       	pop	r0
     5de:	0c be       	out	0x3c, r0	; 60
     5e0:	0f 90       	pop	r0
     5e2:	0b be       	out	0x3b, r0	; 59
     5e4:	0f 90       	pop	r0
     5e6:	0f be       	out	0x3f, r0	; 63
     5e8:	0f 90       	pop	r0

	asm volatile ( "ret" );
     5ea:	08 95       	ret

000005ec <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     5ec:	0f 92       	push	r0
     5ee:	0f b6       	in	r0, 0x3f	; 63
     5f0:	f8 94       	cli
     5f2:	0f 92       	push	r0
     5f4:	0b b6       	in	r0, 0x3b	; 59
     5f6:	0f 92       	push	r0
     5f8:	0c b6       	in	r0, 0x3c	; 60
     5fa:	0f 92       	push	r0
     5fc:	1f 92       	push	r1
     5fe:	11 24       	eor	r1, r1
     600:	2f 92       	push	r2
     602:	3f 92       	push	r3
     604:	4f 92       	push	r4
     606:	5f 92       	push	r5
     608:	6f 92       	push	r6
     60a:	7f 92       	push	r7
     60c:	8f 92       	push	r8
     60e:	9f 92       	push	r9
     610:	af 92       	push	r10
     612:	bf 92       	push	r11
     614:	cf 92       	push	r12
     616:	df 92       	push	r13
     618:	ef 92       	push	r14
     61a:	ff 92       	push	r15
     61c:	0f 93       	push	r16
     61e:	1f 93       	push	r17
     620:	2f 93       	push	r18
     622:	3f 93       	push	r19
     624:	4f 93       	push	r20
     626:	5f 93       	push	r21
     628:	6f 93       	push	r22
     62a:	7f 93       	push	r23
     62c:	8f 93       	push	r24
     62e:	9f 93       	push	r25
     630:	af 93       	push	r26
     632:	bf 93       	push	r27
     634:	cf 93       	push	r28
     636:	df 93       	push	r29
     638:	ef 93       	push	r30
     63a:	ff 93       	push	r31
     63c:	a0 91 4d 08 	lds	r26, 0x084D
     640:	b0 91 4e 08 	lds	r27, 0x084E
     644:	0d b6       	in	r0, 0x3d	; 61
     646:	0d 92       	st	X+, r0
     648:	0e b6       	in	r0, 0x3e	; 62
     64a:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     64c:	b0 d1       	rcall	.+864    	; 0x9ae <xTaskIncrementTick>
     64e:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     650:	38 d3       	rcall	.+1648   	; 0xcc2 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     652:	a0 91 4d 08 	lds	r26, 0x084D
     656:	b0 91 4e 08 	lds	r27, 0x084E
     65a:	cd 91       	ld	r28, X+
     65c:	cd bf       	out	0x3d, r28	; 61
     65e:	dd 91       	ld	r29, X+
     660:	de bf       	out	0x3e, r29	; 62
     662:	ff 91       	pop	r31
     664:	ef 91       	pop	r30
     666:	df 91       	pop	r29
     668:	cf 91       	pop	r28
     66a:	bf 91       	pop	r27
     66c:	af 91       	pop	r26
     66e:	9f 91       	pop	r25
     670:	8f 91       	pop	r24
     672:	7f 91       	pop	r23
     674:	6f 91       	pop	r22
     676:	5f 91       	pop	r21
     678:	4f 91       	pop	r20
     67a:	3f 91       	pop	r19
     67c:	2f 91       	pop	r18
     67e:	1f 91       	pop	r17
     680:	0f 91       	pop	r16
     682:	ff 90       	pop	r15
     684:	ef 90       	pop	r14
     686:	df 90       	pop	r13
     688:	cf 90       	pop	r12
     68a:	bf 90       	pop	r11
     68c:	af 90       	pop	r10
     68e:	9f 90       	pop	r9
     690:	8f 90       	pop	r8
     692:	7f 90       	pop	r7
     694:	6f 90       	pop	r6
     696:	5f 90       	pop	r5
     698:	4f 90       	pop	r4
     69a:	3f 90       	pop	r3
     69c:	2f 90       	pop	r2
     69e:	1f 90       	pop	r1
     6a0:	0f 90       	pop	r0
     6a2:	0c be       	out	0x3c, r0	; 60
     6a4:	0f 90       	pop	r0
     6a6:	0b be       	out	0x3b, r0	; 59
     6a8:	0f 90       	pop	r0
     6aa:	0f be       	out	0x3f, r0	; 63
     6ac:	0f 90       	pop	r0

	asm volatile ( "ret" );
     6ae:	08 95       	ret

000006b0 <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	ISR(TIMER0_COMPA_vect, ISR_NAKED)
	{
		vPortYieldFromTick();
     6b0:	9d df       	rcall	.-198    	; 0x5ec <vPortYieldFromTick>
		asm volatile ("reti");
     6b2:	18 95       	reti

000006b4 <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     6b4:	e0 91 15 08 	lds	r30, 0x0815
     6b8:	f0 91 16 08 	lds	r31, 0x0816
     6bc:	80 81       	ld	r24, Z
     6be:	81 11       	cpse	r24, r1
     6c0:	07 c0       	rjmp	.+14     	; 0x6d0 <prvResetNextTaskUnblockTime+0x1c>
     6c2:	8f ef       	ldi	r24, 0xFF	; 255
     6c4:	9f ef       	ldi	r25, 0xFF	; 255
     6c6:	90 93 01 02 	sts	0x0201, r25
     6ca:	80 93 00 02 	sts	0x0200, r24
     6ce:	08 95       	ret
     6d0:	e0 91 15 08 	lds	r30, 0x0815
     6d4:	f0 91 16 08 	lds	r31, 0x0816
     6d8:	05 80       	ldd	r0, Z+5	; 0x05
     6da:	f6 81       	ldd	r31, Z+6	; 0x06
     6dc:	e0 2d       	mov	r30, r0
     6de:	06 80       	ldd	r0, Z+6	; 0x06
     6e0:	f7 81       	ldd	r31, Z+7	; 0x07
     6e2:	e0 2d       	mov	r30, r0
     6e4:	82 81       	ldd	r24, Z+2	; 0x02
     6e6:	93 81       	ldd	r25, Z+3	; 0x03
     6e8:	90 93 01 02 	sts	0x0201, r25
     6ec:	80 93 00 02 	sts	0x0200, r24
     6f0:	08 95       	ret

000006f2 <prvAddCurrentTaskToDelayedList>:
     6f2:	cf 93       	push	r28
     6f4:	df 93       	push	r29
     6f6:	ec 01       	movw	r28, r24
     6f8:	e0 91 4d 08 	lds	r30, 0x084D
     6fc:	f0 91 4e 08 	lds	r31, 0x084E
     700:	93 83       	std	Z+3, r25	; 0x03
     702:	82 83       	std	Z+2, r24	; 0x02
     704:	80 91 fd 07 	lds	r24, 0x07FD
     708:	90 91 fe 07 	lds	r25, 0x07FE
     70c:	c8 17       	cp	r28, r24
     70e:	d9 07       	cpc	r29, r25
     710:	60 f4       	brcc	.+24     	; 0x72a <prvAddCurrentTaskToDelayedList+0x38>
     712:	60 91 4d 08 	lds	r22, 0x084D
     716:	70 91 4e 08 	lds	r23, 0x084E
     71a:	80 91 13 08 	lds	r24, 0x0813
     71e:	90 91 14 08 	lds	r25, 0x0814
     722:	6e 5f       	subi	r22, 0xFE	; 254
     724:	7f 4f       	sbci	r23, 0xFF	; 255
     726:	fc dd       	rcall	.-1032   	; 0x320 <vListInsert>
     728:	16 c0       	rjmp	.+44     	; 0x756 <prvAddCurrentTaskToDelayedList+0x64>
     72a:	60 91 4d 08 	lds	r22, 0x084D
     72e:	70 91 4e 08 	lds	r23, 0x084E
     732:	80 91 15 08 	lds	r24, 0x0815
     736:	90 91 16 08 	lds	r25, 0x0816
     73a:	6e 5f       	subi	r22, 0xFE	; 254
     73c:	7f 4f       	sbci	r23, 0xFF	; 255
     73e:	f0 dd       	rcall	.-1056   	; 0x320 <vListInsert>
     740:	80 91 00 02 	lds	r24, 0x0200
     744:	90 91 01 02 	lds	r25, 0x0201
     748:	c8 17       	cp	r28, r24
     74a:	d9 07       	cpc	r29, r25
     74c:	20 f4       	brcc	.+8      	; 0x756 <prvAddCurrentTaskToDelayedList+0x64>
     74e:	d0 93 01 02 	sts	0x0201, r29
     752:	c0 93 00 02 	sts	0x0200, r28
     756:	df 91       	pop	r29
     758:	cf 91       	pop	r28
     75a:	08 95       	ret

0000075c <xTaskGenericCreate>:
     75c:	4f 92       	push	r4
     75e:	5f 92       	push	r5
     760:	6f 92       	push	r6
     762:	7f 92       	push	r7
     764:	8f 92       	push	r8
     766:	9f 92       	push	r9
     768:	af 92       	push	r10
     76a:	bf 92       	push	r11
     76c:	cf 92       	push	r12
     76e:	df 92       	push	r13
     770:	ef 92       	push	r14
     772:	ff 92       	push	r15
     774:	0f 93       	push	r16
     776:	1f 93       	push	r17
     778:	cf 93       	push	r28
     77a:	df 93       	push	r29
     77c:	4c 01       	movw	r8, r24
     77e:	5b 01       	movw	r10, r22
     780:	2a 01       	movw	r4, r20
     782:	39 01       	movw	r6, r18
     784:	81 e2       	ldi	r24, 0x21	; 33
     786:	90 e0       	ldi	r25, 0x00	; 0
     788:	64 dd       	rcall	.-1336   	; 0x252 <pvPortMalloc>
     78a:	ec 01       	movw	r28, r24
     78c:	00 97       	sbiw	r24, 0x00	; 0
     78e:	09 f4       	brne	.+2      	; 0x792 <xTaskGenericCreate+0x36>
     790:	cd c0       	rjmp	.+410    	; 0x92c <xTaskGenericCreate+0x1d0>
     792:	c1 14       	cp	r12, r1
     794:	d1 04       	cpc	r13, r1
     796:	09 f0       	breq	.+2      	; 0x79a <xTaskGenericCreate+0x3e>
     798:	b2 c0       	rjmp	.+356    	; 0x8fe <xTaskGenericCreate+0x1a2>
     79a:	c2 01       	movw	r24, r4
     79c:	5a dd       	rcall	.-1356   	; 0x252 <pvPortMalloc>
     79e:	98 8f       	std	Y+24, r25	; 0x18
     7a0:	8f 8b       	std	Y+23, r24	; 0x17
     7a2:	89 2b       	or	r24, r25
     7a4:	09 f0       	breq	.+2      	; 0x7a8 <xTaskGenericCreate+0x4c>
     7a6:	ad c0       	rjmp	.+346    	; 0x902 <xTaskGenericCreate+0x1a6>
     7a8:	ce 01       	movw	r24, r28
     7aa:	86 dd       	rcall	.-1268   	; 0x2b8 <vPortFree>
     7ac:	bf c0       	rjmp	.+382    	; 0x92c <xTaskGenericCreate+0x1d0>
     7ae:	cf 01       	movw	r24, r30
     7b0:	31 91       	ld	r19, Z+
     7b2:	da 01       	movw	r26, r20
     7b4:	3d 93       	st	X+, r19
     7b6:	ad 01       	movw	r20, r26
     7b8:	dc 01       	movw	r26, r24
     7ba:	8c 91       	ld	r24, X
     7bc:	88 23       	and	r24, r24
     7be:	11 f0       	breq	.+4      	; 0x7c4 <xTaskGenericCreate+0x68>
     7c0:	21 50       	subi	r18, 0x01	; 1
     7c2:	a9 f7       	brne	.-22     	; 0x7ae <xTaskGenericCreate+0x52>
     7c4:	18 a2       	std	Y+32, r1	; 0x20
     7c6:	10 2f       	mov	r17, r16
     7c8:	04 30       	cpi	r16, 0x04	; 4
     7ca:	08 f0       	brcs	.+2      	; 0x7ce <xTaskGenericCreate+0x72>
     7cc:	13 e0       	ldi	r17, 0x03	; 3
     7ce:	1e 8b       	std	Y+22, r17	; 0x16
     7d0:	5e 01       	movw	r10, r28
     7d2:	b2 e0       	ldi	r27, 0x02	; 2
     7d4:	ab 0e       	add	r10, r27
     7d6:	b1 1c       	adc	r11, r1
     7d8:	c5 01       	movw	r24, r10
     7da:	7d dd       	rcall	.-1286   	; 0x2d6 <vListInitialiseItem>
     7dc:	ce 01       	movw	r24, r28
     7de:	0c 96       	adiw	r24, 0x0c	; 12
     7e0:	7a dd       	rcall	.-1292   	; 0x2d6 <vListInitialiseItem>
     7e2:	d9 87       	std	Y+9, r29	; 0x09
     7e4:	c8 87       	std	Y+8, r28	; 0x08
     7e6:	84 e0       	ldi	r24, 0x04	; 4
     7e8:	90 e0       	ldi	r25, 0x00	; 0
     7ea:	81 1b       	sub	r24, r17
     7ec:	91 09       	sbc	r25, r1
     7ee:	9d 87       	std	Y+13, r25	; 0x0d
     7f0:	8c 87       	std	Y+12, r24	; 0x0c
     7f2:	db 8b       	std	Y+19, r29	; 0x13
     7f4:	ca 8b       	std	Y+18, r28	; 0x12
     7f6:	a3 01       	movw	r20, r6
     7f8:	b4 01       	movw	r22, r8
     7fa:	c6 01       	movw	r24, r12
     7fc:	e8 dd       	rcall	.-1072   	; 0x3ce <pxPortInitialiseStack>
     7fe:	99 83       	std	Y+1, r25	; 0x01
     800:	88 83       	st	Y, r24
     802:	e1 14       	cp	r14, r1
     804:	f1 04       	cpc	r15, r1
     806:	19 f0       	breq	.+6      	; 0x80e <xTaskGenericCreate+0xb2>
     808:	f7 01       	movw	r30, r14
     80a:	d1 83       	std	Z+1, r29	; 0x01
     80c:	c0 83       	st	Z, r28
     80e:	0f b6       	in	r0, 0x3f	; 63
     810:	f8 94       	cli
     812:	0f 92       	push	r0
     814:	80 91 ff 07 	lds	r24, 0x07FF
     818:	8f 5f       	subi	r24, 0xFF	; 255
     81a:	80 93 ff 07 	sts	0x07FF, r24
     81e:	80 91 4d 08 	lds	r24, 0x084D
     822:	90 91 4e 08 	lds	r25, 0x084E
     826:	89 2b       	or	r24, r25
     828:	69 f5       	brne	.+90     	; 0x884 <xTaskGenericCreate+0x128>
     82a:	d0 93 4e 08 	sts	0x084E, r29
     82e:	c0 93 4d 08 	sts	0x084D, r28
     832:	80 91 ff 07 	lds	r24, 0x07FF
     836:	81 30       	cpi	r24, 0x01	; 1
     838:	a1 f5       	brne	.+104    	; 0x8a2 <xTaskGenericCreate+0x146>
     83a:	89 e2       	ldi	r24, 0x29	; 41
     83c:	98 e0       	ldi	r25, 0x08	; 8
     83e:	3d dd       	rcall	.-1414   	; 0x2ba <vListInitialise>
     840:	82 e3       	ldi	r24, 0x32	; 50
     842:	98 e0       	ldi	r25, 0x08	; 8
     844:	3a dd       	rcall	.-1420   	; 0x2ba <vListInitialise>
     846:	8b e3       	ldi	r24, 0x3B	; 59
     848:	98 e0       	ldi	r25, 0x08	; 8
     84a:	37 dd       	rcall	.-1426   	; 0x2ba <vListInitialise>
     84c:	84 e4       	ldi	r24, 0x44	; 68
     84e:	98 e0       	ldi	r25, 0x08	; 8
     850:	34 dd       	rcall	.-1432   	; 0x2ba <vListInitialise>
     852:	80 e2       	ldi	r24, 0x20	; 32
     854:	98 e0       	ldi	r25, 0x08	; 8
     856:	31 dd       	rcall	.-1438   	; 0x2ba <vListInitialise>
     858:	87 e1       	ldi	r24, 0x17	; 23
     85a:	98 e0       	ldi	r25, 0x08	; 8
     85c:	2e dd       	rcall	.-1444   	; 0x2ba <vListInitialise>
     85e:	8a e0       	ldi	r24, 0x0A	; 10
     860:	98 e0       	ldi	r25, 0x08	; 8
     862:	2b dd       	rcall	.-1450   	; 0x2ba <vListInitialise>
     864:	81 e0       	ldi	r24, 0x01	; 1
     866:	98 e0       	ldi	r25, 0x08	; 8
     868:	28 dd       	rcall	.-1456   	; 0x2ba <vListInitialise>
     86a:	80 e2       	ldi	r24, 0x20	; 32
     86c:	98 e0       	ldi	r25, 0x08	; 8
     86e:	90 93 16 08 	sts	0x0816, r25
     872:	80 93 15 08 	sts	0x0815, r24
     876:	87 e1       	ldi	r24, 0x17	; 23
     878:	98 e0       	ldi	r25, 0x08	; 8
     87a:	90 93 14 08 	sts	0x0814, r25
     87e:	80 93 13 08 	sts	0x0813, r24
     882:	0f c0       	rjmp	.+30     	; 0x8a2 <xTaskGenericCreate+0x146>
     884:	80 91 fb 07 	lds	r24, 0x07FB
     888:	81 11       	cpse	r24, r1
     88a:	0b c0       	rjmp	.+22     	; 0x8a2 <xTaskGenericCreate+0x146>
     88c:	e0 91 4d 08 	lds	r30, 0x084D
     890:	f0 91 4e 08 	lds	r31, 0x084E
     894:	86 89       	ldd	r24, Z+22	; 0x16
     896:	08 17       	cp	r16, r24
     898:	20 f0       	brcs	.+8      	; 0x8a2 <xTaskGenericCreate+0x146>
     89a:	d0 93 4e 08 	sts	0x084E, r29
     89e:	c0 93 4d 08 	sts	0x084D, r28
     8a2:	80 91 f7 07 	lds	r24, 0x07F7
     8a6:	8f 5f       	subi	r24, 0xFF	; 255
     8a8:	80 93 f7 07 	sts	0x07F7, r24
     8ac:	8e 89       	ldd	r24, Y+22	; 0x16
     8ae:	90 91 fc 07 	lds	r25, 0x07FC
     8b2:	98 17       	cp	r25, r24
     8b4:	10 f4       	brcc	.+4      	; 0x8ba <xTaskGenericCreate+0x15e>
     8b6:	80 93 fc 07 	sts	0x07FC, r24
     8ba:	90 e0       	ldi	r25, 0x00	; 0
     8bc:	9c 01       	movw	r18, r24
     8be:	22 0f       	add	r18, r18
     8c0:	33 1f       	adc	r19, r19
     8c2:	22 0f       	add	r18, r18
     8c4:	33 1f       	adc	r19, r19
     8c6:	22 0f       	add	r18, r18
     8c8:	33 1f       	adc	r19, r19
     8ca:	82 0f       	add	r24, r18
     8cc:	93 1f       	adc	r25, r19
     8ce:	b5 01       	movw	r22, r10
     8d0:	87 5d       	subi	r24, 0xD7	; 215
     8d2:	97 4f       	sbci	r25, 0xF7	; 247
     8d4:	04 dd       	rcall	.-1528   	; 0x2de <vListInsertEnd>
     8d6:	0f 90       	pop	r0
     8d8:	0f be       	out	0x3f, r0	; 63
     8da:	80 91 fb 07 	lds	r24, 0x07FB
     8de:	88 23       	and	r24, r24
     8e0:	51 f0       	breq	.+20     	; 0x8f6 <xTaskGenericCreate+0x19a>
     8e2:	e0 91 4d 08 	lds	r30, 0x084D
     8e6:	f0 91 4e 08 	lds	r31, 0x084E
     8ea:	86 89       	ldd	r24, Z+22	; 0x16
     8ec:	80 17       	cp	r24, r16
     8ee:	28 f4       	brcc	.+10     	; 0x8fa <xTaskGenericCreate+0x19e>
     8f0:	1d de       	rcall	.-966    	; 0x52c <vPortYield>
     8f2:	81 e0       	ldi	r24, 0x01	; 1
     8f4:	1c c0       	rjmp	.+56     	; 0x92e <xTaskGenericCreate+0x1d2>
     8f6:	81 e0       	ldi	r24, 0x01	; 1
     8f8:	1a c0       	rjmp	.+52     	; 0x92e <xTaskGenericCreate+0x1d2>
     8fa:	81 e0       	ldi	r24, 0x01	; 1
     8fc:	18 c0       	rjmp	.+48     	; 0x92e <xTaskGenericCreate+0x1d2>
     8fe:	d8 8e       	std	Y+24, r13	; 0x18
     900:	cf 8a       	std	Y+23, r12	; 0x17
     902:	f1 e0       	ldi	r31, 0x01	; 1
     904:	4f 1a       	sub	r4, r31
     906:	51 08       	sbc	r5, r1
     908:	cf 88       	ldd	r12, Y+23	; 0x17
     90a:	d8 8c       	ldd	r13, Y+24	; 0x18
     90c:	c4 0c       	add	r12, r4
     90e:	d5 1c       	adc	r13, r5
     910:	d5 01       	movw	r26, r10
     912:	8c 91       	ld	r24, X
     914:	89 8f       	std	Y+25, r24	; 0x19
     916:	8c 91       	ld	r24, X
     918:	88 23       	and	r24, r24
     91a:	09 f4       	brne	.+2      	; 0x91e <xTaskGenericCreate+0x1c2>
     91c:	53 cf       	rjmp	.-346    	; 0x7c4 <xTaskGenericCreate+0x68>
     91e:	ae 01       	movw	r20, r28
     920:	46 5e       	subi	r20, 0xE6	; 230
     922:	5f 4f       	sbci	r21, 0xFF	; 255
     924:	f5 01       	movw	r30, r10
     926:	31 96       	adiw	r30, 0x01	; 1
     928:	27 e0       	ldi	r18, 0x07	; 7
     92a:	41 cf       	rjmp	.-382    	; 0x7ae <xTaskGenericCreate+0x52>
     92c:	8f ef       	ldi	r24, 0xFF	; 255
     92e:	df 91       	pop	r29
     930:	cf 91       	pop	r28
     932:	1f 91       	pop	r17
     934:	0f 91       	pop	r16
     936:	ff 90       	pop	r15
     938:	ef 90       	pop	r14
     93a:	df 90       	pop	r13
     93c:	cf 90       	pop	r12
     93e:	bf 90       	pop	r11
     940:	af 90       	pop	r10
     942:	9f 90       	pop	r9
     944:	8f 90       	pop	r8
     946:	7f 90       	pop	r7
     948:	6f 90       	pop	r6
     94a:	5f 90       	pop	r5
     94c:	4f 90       	pop	r4
     94e:	08 95       	ret

00000950 <vTaskStartScheduler>:
     950:	af 92       	push	r10
     952:	bf 92       	push	r11
     954:	cf 92       	push	r12
     956:	df 92       	push	r13
     958:	ef 92       	push	r14
     95a:	ff 92       	push	r15
     95c:	0f 93       	push	r16
     95e:	a1 2c       	mov	r10, r1
     960:	b1 2c       	mov	r11, r1
     962:	c1 2c       	mov	r12, r1
     964:	d1 2c       	mov	r13, r1
     966:	e1 2c       	mov	r14, r1
     968:	f1 2c       	mov	r15, r1
     96a:	00 e0       	ldi	r16, 0x00	; 0
     96c:	20 e0       	ldi	r18, 0x00	; 0
     96e:	30 e0       	ldi	r19, 0x00	; 0
     970:	45 e5       	ldi	r20, 0x55	; 85
     972:	50 e0       	ldi	r21, 0x00	; 0
     974:	60 e1       	ldi	r22, 0x10	; 16
     976:	72 e0       	ldi	r23, 0x02	; 2
     978:	8b e2       	ldi	r24, 0x2B	; 43
     97a:	96 e0       	ldi	r25, 0x06	; 6
     97c:	ef de       	rcall	.-546    	; 0x75c <xTaskGenericCreate>
     97e:	81 30       	cpi	r24, 0x01	; 1
     980:	41 f4       	brne	.+16     	; 0x992 <vTaskStartScheduler+0x42>
     982:	f8 94       	cli
     984:	80 93 fb 07 	sts	0x07FB, r24
     988:	10 92 fe 07 	sts	0x07FE, r1
     98c:	10 92 fd 07 	sts	0x07FD, r1
     990:	90 dd       	rcall	.-1248   	; 0x4b2 <xPortStartScheduler>
     992:	0f 91       	pop	r16
     994:	ff 90       	pop	r15
     996:	ef 90       	pop	r14
     998:	df 90       	pop	r13
     99a:	cf 90       	pop	r12
     99c:	bf 90       	pop	r11
     99e:	af 90       	pop	r10
     9a0:	08 95       	ret

000009a2 <vTaskSuspendAll>:
     9a2:	80 91 f6 07 	lds	r24, 0x07F6
     9a6:	8f 5f       	subi	r24, 0xFF	; 255
     9a8:	80 93 f6 07 	sts	0x07F6, r24
     9ac:	08 95       	ret

000009ae <xTaskIncrementTick>:
     9ae:	cf 92       	push	r12
     9b0:	df 92       	push	r13
     9b2:	ef 92       	push	r14
     9b4:	ff 92       	push	r15
     9b6:	0f 93       	push	r16
     9b8:	1f 93       	push	r17
     9ba:	cf 93       	push	r28
     9bc:	df 93       	push	r29
     9be:	80 91 f6 07 	lds	r24, 0x07F6
     9c2:	81 11       	cpse	r24, r1
     9c4:	96 c0       	rjmp	.+300    	; 0xaf2 <xTaskIncrementTick+0x144>
     9c6:	80 91 fd 07 	lds	r24, 0x07FD
     9ca:	90 91 fe 07 	lds	r25, 0x07FE
     9ce:	01 96       	adiw	r24, 0x01	; 1
     9d0:	90 93 fe 07 	sts	0x07FE, r25
     9d4:	80 93 fd 07 	sts	0x07FD, r24
     9d8:	e0 90 fd 07 	lds	r14, 0x07FD
     9dc:	f0 90 fe 07 	lds	r15, 0x07FE
     9e0:	e1 14       	cp	r14, r1
     9e2:	f1 04       	cpc	r15, r1
     9e4:	b1 f4       	brne	.+44     	; 0xa12 <xTaskIncrementTick+0x64>
     9e6:	80 91 15 08 	lds	r24, 0x0815
     9ea:	90 91 16 08 	lds	r25, 0x0816
     9ee:	20 91 13 08 	lds	r18, 0x0813
     9f2:	30 91 14 08 	lds	r19, 0x0814
     9f6:	30 93 16 08 	sts	0x0816, r19
     9fa:	20 93 15 08 	sts	0x0815, r18
     9fe:	90 93 14 08 	sts	0x0814, r25
     a02:	80 93 13 08 	sts	0x0813, r24
     a06:	80 91 f8 07 	lds	r24, 0x07F8
     a0a:	8f 5f       	subi	r24, 0xFF	; 255
     a0c:	80 93 f8 07 	sts	0x07F8, r24
     a10:	51 de       	rcall	.-862    	; 0x6b4 <prvResetNextTaskUnblockTime>
     a12:	80 91 00 02 	lds	r24, 0x0200
     a16:	90 91 01 02 	lds	r25, 0x0201
     a1a:	e8 16       	cp	r14, r24
     a1c:	f9 06       	cpc	r15, r25
     a1e:	08 f4       	brcc	.+2      	; 0xa22 <xTaskIncrementTick+0x74>
     a20:	51 c0       	rjmp	.+162    	; 0xac4 <xTaskIncrementTick+0x116>
     a22:	d1 2c       	mov	r13, r1
     a24:	cc 24       	eor	r12, r12
     a26:	c3 94       	inc	r12
     a28:	01 c0       	rjmp	.+2      	; 0xa2c <xTaskIncrementTick+0x7e>
     a2a:	dc 2c       	mov	r13, r12
     a2c:	e0 91 15 08 	lds	r30, 0x0815
     a30:	f0 91 16 08 	lds	r31, 0x0816
     a34:	80 81       	ld	r24, Z
     a36:	81 11       	cpse	r24, r1
     a38:	07 c0       	rjmp	.+14     	; 0xa48 <xTaskIncrementTick+0x9a>
     a3a:	8f ef       	ldi	r24, 0xFF	; 255
     a3c:	9f ef       	ldi	r25, 0xFF	; 255
     a3e:	90 93 01 02 	sts	0x0201, r25
     a42:	80 93 00 02 	sts	0x0200, r24
     a46:	3f c0       	rjmp	.+126    	; 0xac6 <xTaskIncrementTick+0x118>
     a48:	e0 91 15 08 	lds	r30, 0x0815
     a4c:	f0 91 16 08 	lds	r31, 0x0816
     a50:	05 80       	ldd	r0, Z+5	; 0x05
     a52:	f6 81       	ldd	r31, Z+6	; 0x06
     a54:	e0 2d       	mov	r30, r0
     a56:	c6 81       	ldd	r28, Z+6	; 0x06
     a58:	d7 81       	ldd	r29, Z+7	; 0x07
     a5a:	2a 81       	ldd	r18, Y+2	; 0x02
     a5c:	3b 81       	ldd	r19, Y+3	; 0x03
     a5e:	e2 16       	cp	r14, r18
     a60:	f3 06       	cpc	r15, r19
     a62:	28 f4       	brcc	.+10     	; 0xa6e <xTaskIncrementTick+0xc0>
     a64:	30 93 01 02 	sts	0x0201, r19
     a68:	20 93 00 02 	sts	0x0200, r18
     a6c:	2c c0       	rjmp	.+88     	; 0xac6 <xTaskIncrementTick+0x118>
     a6e:	8e 01       	movw	r16, r28
     a70:	0e 5f       	subi	r16, 0xFE	; 254
     a72:	1f 4f       	sbci	r17, 0xFF	; 255
     a74:	c8 01       	movw	r24, r16
     a76:	85 dc       	rcall	.-1782   	; 0x382 <uxListRemove>
     a78:	8c 89       	ldd	r24, Y+20	; 0x14
     a7a:	9d 89       	ldd	r25, Y+21	; 0x15
     a7c:	89 2b       	or	r24, r25
     a7e:	19 f0       	breq	.+6      	; 0xa86 <xTaskIncrementTick+0xd8>
     a80:	ce 01       	movw	r24, r28
     a82:	0c 96       	adiw	r24, 0x0c	; 12
     a84:	7e dc       	rcall	.-1796   	; 0x382 <uxListRemove>
     a86:	2e 89       	ldd	r18, Y+22	; 0x16
     a88:	80 91 fc 07 	lds	r24, 0x07FC
     a8c:	82 17       	cp	r24, r18
     a8e:	10 f4       	brcc	.+4      	; 0xa94 <xTaskIncrementTick+0xe6>
     a90:	20 93 fc 07 	sts	0x07FC, r18
     a94:	30 e0       	ldi	r19, 0x00	; 0
     a96:	c9 01       	movw	r24, r18
     a98:	88 0f       	add	r24, r24
     a9a:	99 1f       	adc	r25, r25
     a9c:	88 0f       	add	r24, r24
     a9e:	99 1f       	adc	r25, r25
     aa0:	88 0f       	add	r24, r24
     aa2:	99 1f       	adc	r25, r25
     aa4:	82 0f       	add	r24, r18
     aa6:	93 1f       	adc	r25, r19
     aa8:	b8 01       	movw	r22, r16
     aaa:	87 5d       	subi	r24, 0xD7	; 215
     aac:	97 4f       	sbci	r25, 0xF7	; 247
     aae:	17 dc       	rcall	.-2002   	; 0x2de <vListInsertEnd>
     ab0:	e0 91 4d 08 	lds	r30, 0x084D
     ab4:	f0 91 4e 08 	lds	r31, 0x084E
     ab8:	9e 89       	ldd	r25, Y+22	; 0x16
     aba:	86 89       	ldd	r24, Z+22	; 0x16
     abc:	98 17       	cp	r25, r24
     abe:	08 f0       	brcs	.+2      	; 0xac2 <xTaskIncrementTick+0x114>
     ac0:	b4 cf       	rjmp	.-152    	; 0xa2a <xTaskIncrementTick+0x7c>
     ac2:	b4 cf       	rjmp	.-152    	; 0xa2c <xTaskIncrementTick+0x7e>
     ac4:	d1 2c       	mov	r13, r1
     ac6:	e0 91 4d 08 	lds	r30, 0x084D
     aca:	f0 91 4e 08 	lds	r31, 0x084E
     ace:	86 89       	ldd	r24, Z+22	; 0x16
     ad0:	90 e0       	ldi	r25, 0x00	; 0
     ad2:	fc 01       	movw	r30, r24
     ad4:	ee 0f       	add	r30, r30
     ad6:	ff 1f       	adc	r31, r31
     ad8:	ee 0f       	add	r30, r30
     ada:	ff 1f       	adc	r31, r31
     adc:	ee 0f       	add	r30, r30
     ade:	ff 1f       	adc	r31, r31
     ae0:	8e 0f       	add	r24, r30
     ae2:	9f 1f       	adc	r25, r31
     ae4:	fc 01       	movw	r30, r24
     ae6:	e7 5d       	subi	r30, 0xD7	; 215
     ae8:	f7 4f       	sbci	r31, 0xF7	; 247
     aea:	80 81       	ld	r24, Z
     aec:	82 30       	cpi	r24, 0x02	; 2
     aee:	40 f4       	brcc	.+16     	; 0xb00 <xTaskIncrementTick+0x152>
     af0:	09 c0       	rjmp	.+18     	; 0xb04 <xTaskIncrementTick+0x156>
     af2:	80 91 fa 07 	lds	r24, 0x07FA
     af6:	8f 5f       	subi	r24, 0xFF	; 255
     af8:	80 93 fa 07 	sts	0x07FA, r24
     afc:	d1 2c       	mov	r13, r1
     afe:	02 c0       	rjmp	.+4      	; 0xb04 <xTaskIncrementTick+0x156>
     b00:	dd 24       	eor	r13, r13
     b02:	d3 94       	inc	r13
     b04:	80 91 f9 07 	lds	r24, 0x07F9
     b08:	88 23       	and	r24, r24
     b0a:	11 f0       	breq	.+4      	; 0xb10 <xTaskIncrementTick+0x162>
     b0c:	dd 24       	eor	r13, r13
     b0e:	d3 94       	inc	r13
     b10:	8d 2d       	mov	r24, r13
     b12:	df 91       	pop	r29
     b14:	cf 91       	pop	r28
     b16:	1f 91       	pop	r17
     b18:	0f 91       	pop	r16
     b1a:	ff 90       	pop	r15
     b1c:	ef 90       	pop	r14
     b1e:	df 90       	pop	r13
     b20:	cf 90       	pop	r12
     b22:	08 95       	ret

00000b24 <xTaskResumeAll>:
     b24:	df 92       	push	r13
     b26:	ef 92       	push	r14
     b28:	ff 92       	push	r15
     b2a:	0f 93       	push	r16
     b2c:	1f 93       	push	r17
     b2e:	cf 93       	push	r28
     b30:	df 93       	push	r29
     b32:	0f b6       	in	r0, 0x3f	; 63
     b34:	f8 94       	cli
     b36:	0f 92       	push	r0
     b38:	80 91 f6 07 	lds	r24, 0x07F6
     b3c:	81 50       	subi	r24, 0x01	; 1
     b3e:	80 93 f6 07 	sts	0x07F6, r24
     b42:	80 91 f6 07 	lds	r24, 0x07F6
     b46:	81 11       	cpse	r24, r1
     b48:	5c c0       	rjmp	.+184    	; 0xc02 <xTaskResumeAll+0xde>
     b4a:	80 91 ff 07 	lds	r24, 0x07FF
     b4e:	88 23       	and	r24, r24
     b50:	09 f4       	brne	.+2      	; 0xb54 <xTaskResumeAll+0x30>
     b52:	59 c0       	rjmp	.+178    	; 0xc06 <xTaskResumeAll+0xe2>
     b54:	0f 2e       	mov	r0, r31
     b56:	fa e0       	ldi	r31, 0x0A	; 10
     b58:	ef 2e       	mov	r14, r31
     b5a:	f8 e0       	ldi	r31, 0x08	; 8
     b5c:	ff 2e       	mov	r15, r31
     b5e:	f0 2d       	mov	r31, r0
     b60:	dd 24       	eor	r13, r13
     b62:	d3 94       	inc	r13
     b64:	2d c0       	rjmp	.+90     	; 0xbc0 <xTaskResumeAll+0x9c>
     b66:	e0 91 0f 08 	lds	r30, 0x080F
     b6a:	f0 91 10 08 	lds	r31, 0x0810
     b6e:	c6 81       	ldd	r28, Z+6	; 0x06
     b70:	d7 81       	ldd	r29, Z+7	; 0x07
     b72:	ce 01       	movw	r24, r28
     b74:	0c 96       	adiw	r24, 0x0c	; 12
     b76:	05 dc       	rcall	.-2038   	; 0x382 <uxListRemove>
     b78:	8e 01       	movw	r16, r28
     b7a:	0e 5f       	subi	r16, 0xFE	; 254
     b7c:	1f 4f       	sbci	r17, 0xFF	; 255
     b7e:	c8 01       	movw	r24, r16
     b80:	00 dc       	rcall	.-2048   	; 0x382 <uxListRemove>
     b82:	8e 89       	ldd	r24, Y+22	; 0x16
     b84:	90 91 fc 07 	lds	r25, 0x07FC
     b88:	98 17       	cp	r25, r24
     b8a:	10 f4       	brcc	.+4      	; 0xb90 <xTaskResumeAll+0x6c>
     b8c:	80 93 fc 07 	sts	0x07FC, r24
     b90:	90 e0       	ldi	r25, 0x00	; 0
     b92:	9c 01       	movw	r18, r24
     b94:	22 0f       	add	r18, r18
     b96:	33 1f       	adc	r19, r19
     b98:	22 0f       	add	r18, r18
     b9a:	33 1f       	adc	r19, r19
     b9c:	22 0f       	add	r18, r18
     b9e:	33 1f       	adc	r19, r19
     ba0:	82 0f       	add	r24, r18
     ba2:	93 1f       	adc	r25, r19
     ba4:	b8 01       	movw	r22, r16
     ba6:	87 5d       	subi	r24, 0xD7	; 215
     ba8:	97 4f       	sbci	r25, 0xF7	; 247
     baa:	99 db       	rcall	.-2254   	; 0x2de <vListInsertEnd>
     bac:	e0 91 4d 08 	lds	r30, 0x084D
     bb0:	f0 91 4e 08 	lds	r31, 0x084E
     bb4:	9e 89       	ldd	r25, Y+22	; 0x16
     bb6:	86 89       	ldd	r24, Z+22	; 0x16
     bb8:	98 17       	cp	r25, r24
     bba:	10 f0       	brcs	.+4      	; 0xbc0 <xTaskResumeAll+0x9c>
     bbc:	d0 92 f9 07 	sts	0x07F9, r13
     bc0:	f7 01       	movw	r30, r14
     bc2:	80 81       	ld	r24, Z
     bc4:	81 11       	cpse	r24, r1
     bc6:	cf cf       	rjmp	.-98     	; 0xb66 <xTaskResumeAll+0x42>
     bc8:	80 91 fa 07 	lds	r24, 0x07FA
     bcc:	88 23       	and	r24, r24
     bce:	91 f0       	breq	.+36     	; 0xbf4 <xTaskResumeAll+0xd0>
     bd0:	80 91 fa 07 	lds	r24, 0x07FA
     bd4:	88 23       	and	r24, r24
     bd6:	71 f0       	breq	.+28     	; 0xbf4 <xTaskResumeAll+0xd0>
     bd8:	c1 e0       	ldi	r28, 0x01	; 1
     bda:	e9 de       	rcall	.-558    	; 0x9ae <xTaskIncrementTick>
     bdc:	81 11       	cpse	r24, r1
     bde:	c0 93 f9 07 	sts	0x07F9, r28
     be2:	80 91 fa 07 	lds	r24, 0x07FA
     be6:	81 50       	subi	r24, 0x01	; 1
     be8:	80 93 fa 07 	sts	0x07FA, r24
     bec:	80 91 fa 07 	lds	r24, 0x07FA
     bf0:	81 11       	cpse	r24, r1
     bf2:	f3 cf       	rjmp	.-26     	; 0xbda <xTaskResumeAll+0xb6>
     bf4:	80 91 f9 07 	lds	r24, 0x07F9
     bf8:	81 30       	cpi	r24, 0x01	; 1
     bfa:	39 f4       	brne	.+14     	; 0xc0a <xTaskResumeAll+0xe6>
     bfc:	97 dc       	rcall	.-1746   	; 0x52c <vPortYield>
     bfe:	81 e0       	ldi	r24, 0x01	; 1
     c00:	05 c0       	rjmp	.+10     	; 0xc0c <xTaskResumeAll+0xe8>
     c02:	80 e0       	ldi	r24, 0x00	; 0
     c04:	03 c0       	rjmp	.+6      	; 0xc0c <xTaskResumeAll+0xe8>
     c06:	80 e0       	ldi	r24, 0x00	; 0
     c08:	01 c0       	rjmp	.+2      	; 0xc0c <xTaskResumeAll+0xe8>
     c0a:	80 e0       	ldi	r24, 0x00	; 0
     c0c:	0f 90       	pop	r0
     c0e:	0f be       	out	0x3f, r0	; 63
     c10:	df 91       	pop	r29
     c12:	cf 91       	pop	r28
     c14:	1f 91       	pop	r17
     c16:	0f 91       	pop	r16
     c18:	ff 90       	pop	r15
     c1a:	ef 90       	pop	r14
     c1c:	df 90       	pop	r13
     c1e:	08 95       	ret

00000c20 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     c20:	cf 93       	push	r28
     c22:	df 93       	push	r29
     c24:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     c26:	00 97       	sbiw	r24, 0x00	; 0
     c28:	91 f0       	breq	.+36     	; 0xc4e <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     c2a:	bb de       	rcall	.-650    	; 0x9a2 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
     c2c:	80 91 fd 07 	lds	r24, 0x07FD
     c30:	90 91 fe 07 	lds	r25, 0x07FE
     c34:	c8 0f       	add	r28, r24
     c36:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
     c38:	80 91 4d 08 	lds	r24, 0x084D
     c3c:	90 91 4e 08 	lds	r25, 0x084E
     c40:	02 96       	adiw	r24, 0x02	; 2
     c42:	9f db       	rcall	.-2242   	; 0x382 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
     c44:	ce 01       	movw	r24, r28
     c46:	55 dd       	rcall	.-1366   	; 0x6f2 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     c48:	6d df       	rcall	.-294    	; 0xb24 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     c4a:	81 11       	cpse	r24, r1
     c4c:	01 c0       	rjmp	.+2      	; 0xc50 <vTaskDelay+0x30>
		{
			portYIELD_WITHIN_API();
     c4e:	6e dc       	rcall	.-1828   	; 0x52c <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     c50:	df 91       	pop	r29
     c52:	cf 91       	pop	r28
     c54:	08 95       	ret

00000c56 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     c56:	0f 2e       	mov	r0, r31
     c58:	f9 e2       	ldi	r31, 0x29	; 41
     c5a:	ef 2e       	mov	r14, r31
     c5c:	f8 e0       	ldi	r31, 0x08	; 8
     c5e:	ff 2e       	mov	r15, r31
     c60:	f0 2d       	mov	r31, r0
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
     c62:	c1 e0       	ldi	r28, 0x01	; 1
     c64:	d8 e0       	ldi	r29, 0x08	; 8
     c66:	23 c0       	rjmp	.+70     	; 0xcae <prvIdleTask+0x58>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
     c68:	9c de       	rcall	.-712    	; 0x9a2 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
     c6a:	18 81       	ld	r17, Y
			}
			( void ) xTaskResumeAll();
     c6c:	5b df       	rcall	.-330    	; 0xb24 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
     c6e:	11 23       	and	r17, r17
     c70:	f1 f0       	breq	.+60     	; 0xcae <prvIdleTask+0x58>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
     c72:	0f b6       	in	r0, 0x3f	; 63
     c74:	f8 94       	cli
     c76:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
     c78:	e0 91 06 08 	lds	r30, 0x0806
     c7c:	f0 91 07 08 	lds	r31, 0x0807
     c80:	06 81       	ldd	r16, Z+6	; 0x06
     c82:	17 81       	ldd	r17, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     c84:	c8 01       	movw	r24, r16
     c86:	02 96       	adiw	r24, 0x02	; 2
     c88:	7c db       	rcall	.-2312   	; 0x382 <uxListRemove>
					--uxCurrentNumberOfTasks;
     c8a:	80 91 ff 07 	lds	r24, 0x07FF
     c8e:	81 50       	subi	r24, 0x01	; 1
     c90:	80 93 ff 07 	sts	0x07FF, r24
					--uxTasksDeleted;
     c94:	80 91 00 08 	lds	r24, 0x0800
     c98:	81 50       	subi	r24, 0x01	; 1
     c9a:	80 93 00 08 	sts	0x0800, r24
				}
				taskEXIT_CRITICAL();
     c9e:	0f 90       	pop	r0
     ca0:	0f be       	out	0x3f, r0	; 63
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
		vPortFreeAligned( pxTCB->pxStack );
     ca2:	f8 01       	movw	r30, r16
     ca4:	87 89       	ldd	r24, Z+23	; 0x17
     ca6:	90 8d       	ldd	r25, Z+24	; 0x18
     ca8:	07 db       	rcall	.-2546   	; 0x2b8 <vPortFree>
		vPortFree( pxTCB );
     caa:	c8 01       	movw	r24, r16
     cac:	05 db       	rcall	.-2550   	; 0x2b8 <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
     cae:	80 91 00 08 	lds	r24, 0x0800
     cb2:	81 11       	cpse	r24, r1
     cb4:	d9 cf       	rjmp	.-78     	; 0xc68 <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     cb6:	f7 01       	movw	r30, r14
     cb8:	80 81       	ld	r24, Z
     cba:	82 30       	cpi	r24, 0x02	; 2
     cbc:	c0 f3       	brcs	.-16     	; 0xcae <prvIdleTask+0x58>
			{
				taskYIELD();
     cbe:	36 dc       	rcall	.-1940   	; 0x52c <vPortYield>
     cc0:	f6 cf       	rjmp	.-20     	; 0xcae <prvIdleTask+0x58>

00000cc2 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     cc2:	80 91 f6 07 	lds	r24, 0x07F6
     cc6:	88 23       	and	r24, r24
     cc8:	21 f0       	breq	.+8      	; 0xcd2 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     cca:	81 e0       	ldi	r24, 0x01	; 1
     ccc:	80 93 f9 07 	sts	0x07F9, r24
     cd0:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     cd2:	10 92 f9 07 	sts	0x07F9, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     cd6:	80 91 fc 07 	lds	r24, 0x07FC
     cda:	90 e0       	ldi	r25, 0x00	; 0
     cdc:	fc 01       	movw	r30, r24
     cde:	ee 0f       	add	r30, r30
     ce0:	ff 1f       	adc	r31, r31
     ce2:	ee 0f       	add	r30, r30
     ce4:	ff 1f       	adc	r31, r31
     ce6:	ee 0f       	add	r30, r30
     ce8:	ff 1f       	adc	r31, r31
     cea:	8e 0f       	add	r24, r30
     cec:	9f 1f       	adc	r25, r31
     cee:	fc 01       	movw	r30, r24
     cf0:	e7 5d       	subi	r30, 0xD7	; 215
     cf2:	f7 4f       	sbci	r31, 0xF7	; 247
     cf4:	80 81       	ld	r24, Z
     cf6:	81 11       	cpse	r24, r1
     cf8:	17 c0       	rjmp	.+46     	; 0xd28 <vTaskSwitchContext+0x66>
     cfa:	80 91 fc 07 	lds	r24, 0x07FC
     cfe:	81 50       	subi	r24, 0x01	; 1
     d00:	80 93 fc 07 	sts	0x07FC, r24
     d04:	80 91 fc 07 	lds	r24, 0x07FC
     d08:	90 e0       	ldi	r25, 0x00	; 0
     d0a:	fc 01       	movw	r30, r24
     d0c:	ee 0f       	add	r30, r30
     d0e:	ff 1f       	adc	r31, r31
     d10:	ee 0f       	add	r30, r30
     d12:	ff 1f       	adc	r31, r31
     d14:	ee 0f       	add	r30, r30
     d16:	ff 1f       	adc	r31, r31
     d18:	8e 0f       	add	r24, r30
     d1a:	9f 1f       	adc	r25, r31
     d1c:	fc 01       	movw	r30, r24
     d1e:	e7 5d       	subi	r30, 0xD7	; 215
     d20:	f7 4f       	sbci	r31, 0xF7	; 247
     d22:	80 81       	ld	r24, Z
     d24:	88 23       	and	r24, r24
     d26:	49 f3       	breq	.-46     	; 0xcfa <vTaskSwitchContext+0x38>
     d28:	e0 91 fc 07 	lds	r30, 0x07FC
     d2c:	f0 e0       	ldi	r31, 0x00	; 0
     d2e:	cf 01       	movw	r24, r30
     d30:	88 0f       	add	r24, r24
     d32:	99 1f       	adc	r25, r25
     d34:	88 0f       	add	r24, r24
     d36:	99 1f       	adc	r25, r25
     d38:	88 0f       	add	r24, r24
     d3a:	99 1f       	adc	r25, r25
     d3c:	e8 0f       	add	r30, r24
     d3e:	f9 1f       	adc	r31, r25
     d40:	e7 5d       	subi	r30, 0xD7	; 215
     d42:	f7 4f       	sbci	r31, 0xF7	; 247
     d44:	a1 81       	ldd	r26, Z+1	; 0x01
     d46:	b2 81       	ldd	r27, Z+2	; 0x02
     d48:	12 96       	adiw	r26, 0x02	; 2
     d4a:	0d 90       	ld	r0, X+
     d4c:	bc 91       	ld	r27, X
     d4e:	a0 2d       	mov	r26, r0
     d50:	b2 83       	std	Z+2, r27	; 0x02
     d52:	a1 83       	std	Z+1, r26	; 0x01
     d54:	cf 01       	movw	r24, r30
     d56:	03 96       	adiw	r24, 0x03	; 3
     d58:	a8 17       	cp	r26, r24
     d5a:	b9 07       	cpc	r27, r25
     d5c:	31 f4       	brne	.+12     	; 0xd6a <vTaskSwitchContext+0xa8>
     d5e:	12 96       	adiw	r26, 0x02	; 2
     d60:	8d 91       	ld	r24, X+
     d62:	9c 91       	ld	r25, X
     d64:	13 97       	sbiw	r26, 0x03	; 3
     d66:	92 83       	std	Z+2, r25	; 0x02
     d68:	81 83       	std	Z+1, r24	; 0x01
     d6a:	01 80       	ldd	r0, Z+1	; 0x01
     d6c:	f2 81       	ldd	r31, Z+2	; 0x02
     d6e:	e0 2d       	mov	r30, r0
     d70:	86 81       	ldd	r24, Z+6	; 0x06
     d72:	97 81       	ldd	r25, Z+7	; 0x07
     d74:	90 93 4e 08 	sts	0x084E, r25
     d78:	80 93 4d 08 	sts	0x084D, r24
     d7c:	08 95       	ret

00000d7e <__vector_23>:
	// we can't subtract any more than this or we'd overflow w/ small delays.
	us--;
#endif

	// busy wait
	__asm__ __volatile__ (
     d7e:	1f 92       	push	r1
     d80:	0f 92       	push	r0
     d82:	0f b6       	in	r0, 0x3f	; 63
     d84:	0f 92       	push	r0
     d86:	11 24       	eor	r1, r1
     d88:	2f 93       	push	r18
     d8a:	3f 93       	push	r19
     d8c:	8f 93       	push	r24
     d8e:	9f 93       	push	r25
     d90:	af 93       	push	r26
     d92:	bf 93       	push	r27
     d94:	80 91 50 08 	lds	r24, 0x0850
     d98:	90 91 51 08 	lds	r25, 0x0851
     d9c:	a0 91 52 08 	lds	r26, 0x0852
     da0:	b0 91 53 08 	lds	r27, 0x0853
     da4:	30 91 4f 08 	lds	r19, 0x084F
     da8:	23 e0       	ldi	r18, 0x03	; 3
     daa:	23 0f       	add	r18, r19
     dac:	2d 37       	cpi	r18, 0x7D	; 125
     dae:	20 f4       	brcc	.+8      	; 0xdb8 <__vector_23+0x3a>
     db0:	01 96       	adiw	r24, 0x01	; 1
     db2:	a1 1d       	adc	r26, r1
     db4:	b1 1d       	adc	r27, r1
     db6:	05 c0       	rjmp	.+10     	; 0xdc2 <__vector_23+0x44>
     db8:	26 e8       	ldi	r18, 0x86	; 134
     dba:	23 0f       	add	r18, r19
     dbc:	02 96       	adiw	r24, 0x02	; 2
     dbe:	a1 1d       	adc	r26, r1
     dc0:	b1 1d       	adc	r27, r1
     dc2:	20 93 4f 08 	sts	0x084F, r18
     dc6:	80 93 50 08 	sts	0x0850, r24
     dca:	90 93 51 08 	sts	0x0851, r25
     dce:	a0 93 52 08 	sts	0x0852, r26
     dd2:	b0 93 53 08 	sts	0x0853, r27
     dd6:	80 91 54 08 	lds	r24, 0x0854
     dda:	90 91 55 08 	lds	r25, 0x0855
     dde:	a0 91 56 08 	lds	r26, 0x0856
     de2:	b0 91 57 08 	lds	r27, 0x0857
     de6:	01 96       	adiw	r24, 0x01	; 1
     de8:	a1 1d       	adc	r26, r1
     dea:	b1 1d       	adc	r27, r1
     dec:	80 93 54 08 	sts	0x0854, r24
     df0:	90 93 55 08 	sts	0x0855, r25
     df4:	a0 93 56 08 	sts	0x0856, r26
     df8:	b0 93 57 08 	sts	0x0857, r27
     dfc:	bf 91       	pop	r27
     dfe:	af 91       	pop	r26
     e00:	9f 91       	pop	r25
     e02:	8f 91       	pop	r24
     e04:	3f 91       	pop	r19
     e06:	2f 91       	pop	r18
     e08:	0f 90       	pop	r0
     e0a:	0f be       	out	0x3f, r0	; 63
     e0c:	0f 90       	pop	r0
     e0e:	1f 90       	pop	r1
     e10:	18 95       	reti

00000e12 <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
     e12:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
     e14:	84 b5       	in	r24, 0x24	; 36
     e16:	82 60       	ori	r24, 0x02	; 2
     e18:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
     e1a:	84 b5       	in	r24, 0x24	; 36
     e1c:	81 60       	ori	r24, 0x01	; 1
     e1e:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
     e20:	85 b5       	in	r24, 0x25	; 37
     e22:	82 60       	ori	r24, 0x02	; 2
     e24:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
     e26:	85 b5       	in	r24, 0x25	; 37
     e28:	81 60       	ori	r24, 0x01	; 1
     e2a:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
     e2c:	ee e6       	ldi	r30, 0x6E	; 110
     e2e:	f0 e0       	ldi	r31, 0x00	; 0
     e30:	80 81       	ld	r24, Z
     e32:	81 60       	ori	r24, 0x01	; 1
     e34:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
     e36:	e1 e8       	ldi	r30, 0x81	; 129
     e38:	f0 e0       	ldi	r31, 0x00	; 0
     e3a:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
     e3c:	80 81       	ld	r24, Z
     e3e:	82 60       	ori	r24, 0x02	; 2
     e40:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
     e42:	80 81       	ld	r24, Z
     e44:	81 60       	ori	r24, 0x01	; 1
     e46:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
     e48:	e0 e8       	ldi	r30, 0x80	; 128
     e4a:	f0 e0       	ldi	r31, 0x00	; 0
     e4c:	80 81       	ld	r24, Z
     e4e:	81 60       	ori	r24, 0x01	; 1
     e50:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
     e52:	e1 eb       	ldi	r30, 0xB1	; 177
     e54:	f0 e0       	ldi	r31, 0x00	; 0
     e56:	80 81       	ld	r24, Z
     e58:	84 60       	ori	r24, 0x04	; 4
     e5a:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
     e5c:	e0 eb       	ldi	r30, 0xB0	; 176
     e5e:	f0 e0       	ldi	r31, 0x00	; 0
     e60:	80 81       	ld	r24, Z
     e62:	81 60       	ori	r24, 0x01	; 1
     e64:	80 83       	st	Z, r24
#else
	#warning Timer 2 not finished (may not be present on this CPU)
#endif

#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
     e66:	e1 e9       	ldi	r30, 0x91	; 145
     e68:	f0 e0       	ldi	r31, 0x00	; 0
     e6a:	80 81       	ld	r24, Z
     e6c:	82 60       	ori	r24, 0x02	; 2
     e6e:	80 83       	st	Z, r24
	sbi(TCCR3B, CS30);
     e70:	80 81       	ld	r24, Z
     e72:	81 60       	ori	r24, 0x01	; 1
     e74:	80 83       	st	Z, r24
	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
     e76:	e0 e9       	ldi	r30, 0x90	; 144
     e78:	f0 e0       	ldi	r31, 0x00	; 0
     e7a:	80 81       	ld	r24, Z
     e7c:	81 60       	ori	r24, 0x01	; 1
     e7e:	80 83       	st	Z, r24
	sbi(TCCR4D, WGM40);		// put timer 4 in phase- and frequency-correct PWM mode	
	sbi(TCCR4A, PWM4A);		// enable PWM mode for comparator OCR4A
	sbi(TCCR4C, PWM4D);		// enable PWM mode for comparator OCR4D
#else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */
#if defined(TCCR4B) && defined(CS41) && defined(WGM40)
	sbi(TCCR4B, CS41);		// set timer 4 prescale factor to 64
     e80:	e1 ea       	ldi	r30, 0xA1	; 161
     e82:	f0 e0       	ldi	r31, 0x00	; 0
     e84:	80 81       	ld	r24, Z
     e86:	82 60       	ori	r24, 0x02	; 2
     e88:	80 83       	st	Z, r24
	sbi(TCCR4B, CS40);
     e8a:	80 81       	ld	r24, Z
     e8c:	81 60       	ori	r24, 0x01	; 1
     e8e:	80 83       	st	Z, r24
	sbi(TCCR4A, WGM40);		// put timer 4 in 8-bit phase correct pwm mode
     e90:	e0 ea       	ldi	r30, 0xA0	; 160
     e92:	f0 e0       	ldi	r31, 0x00	; 0
     e94:	80 81       	ld	r24, Z
     e96:	81 60       	ori	r24, 0x01	; 1
     e98:	80 83       	st	Z, r24
#endif
#endif /* end timer4 block for ATMEGA1280/2560 and similar */	

#if defined(TCCR5B) && defined(CS51) && defined(WGM50)
	sbi(TCCR5B, CS51);		// set timer 5 prescale factor to 64
     e9a:	e1 e2       	ldi	r30, 0x21	; 33
     e9c:	f1 e0       	ldi	r31, 0x01	; 1
     e9e:	80 81       	ld	r24, Z
     ea0:	82 60       	ori	r24, 0x02	; 2
     ea2:	80 83       	st	Z, r24
	sbi(TCCR5B, CS50);
     ea4:	80 81       	ld	r24, Z
     ea6:	81 60       	ori	r24, 0x01	; 1
     ea8:	80 83       	st	Z, r24
	sbi(TCCR5A, WGM50);		// put timer 5 in 8-bit phase correct pwm mode
     eaa:	e0 e2       	ldi	r30, 0x20	; 32
     eac:	f1 e0       	ldi	r31, 0x01	; 1
     eae:	80 81       	ld	r24, Z
     eb0:	81 60       	ori	r24, 0x01	; 1
     eb2:	80 83       	st	Z, r24
#if defined(ADCSRA)
	// set a2d prescale factor to 128
	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
	// XXX: this will not work properly for other clock speeds, and
	// this code should use F_CPU to determine the prescale factor.
	sbi(ADCSRA, ADPS2);
     eb4:	ea e7       	ldi	r30, 0x7A	; 122
     eb6:	f0 e0       	ldi	r31, 0x00	; 0
     eb8:	80 81       	ld	r24, Z
     eba:	84 60       	ori	r24, 0x04	; 4
     ebc:	80 83       	st	Z, r24
	sbi(ADCSRA, ADPS1);
     ebe:	80 81       	ld	r24, Z
     ec0:	82 60       	ori	r24, 0x02	; 2
     ec2:	80 83       	st	Z, r24
	sbi(ADCSRA, ADPS0);
     ec4:	80 81       	ld	r24, Z
     ec6:	81 60       	ori	r24, 0x01	; 1
     ec8:	80 83       	st	Z, r24

	// enable a2d conversions
	sbi(ADCSRA, ADEN);
     eca:	80 81       	ld	r24, Z
     ecc:	80 68       	ori	r24, 0x80	; 128
     ece:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
     ed0:	10 92 c1 00 	sts	0x00C1, r1
     ed4:	08 95       	ret

00000ed6 <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
     ed6:	90 e0       	ldi	r25, 0x00	; 0
     ed8:	fc 01       	movw	r30, r24
     eda:	31 97       	sbiw	r30, 0x01	; 1
     edc:	e2 31       	cpi	r30, 0x12	; 18
     ede:	f1 05       	cpc	r31, r1
     ee0:	08 f0       	brcs	.+2      	; 0xee4 <turnOffPWM+0xe>
     ee2:	5e c0       	rjmp	.+188    	; 0xfa0 <turnOffPWM+0xca>
     ee4:	ee 58       	subi	r30, 0x8E	; 142
     ee6:	ff 4f       	sbci	r31, 0xFF	; 255
     ee8:	ca c0       	rjmp	.+404    	; 0x107e <__tablejump2__>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
     eea:	e0 e8       	ldi	r30, 0x80	; 128
     eec:	f0 e0       	ldi	r31, 0x00	; 0
     eee:	80 81       	ld	r24, Z
     ef0:	8f 77       	andi	r24, 0x7F	; 127
     ef2:	80 83       	st	Z, r24
     ef4:	08 95       	ret
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
     ef6:	e0 e8       	ldi	r30, 0x80	; 128
     ef8:	f0 e0       	ldi	r31, 0x00	; 0
     efa:	80 81       	ld	r24, Z
     efc:	8f 7d       	andi	r24, 0xDF	; 223
     efe:	80 83       	st	Z, r24
     f00:	08 95       	ret
		#endif
		#if defined(TCCR1A) && defined(COM1C1)
		case TIMER1C:   cbi(TCCR1A, COM1C1);    break;
     f02:	e0 e8       	ldi	r30, 0x80	; 128
     f04:	f0 e0       	ldi	r31, 0x00	; 0
     f06:	80 81       	ld	r24, Z
     f08:	87 7f       	andi	r24, 0xF7	; 247
     f0a:	80 83       	st	Z, r24
     f0c:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
     f0e:	84 b5       	in	r24, 0x24	; 36
     f10:	8f 77       	andi	r24, 0x7F	; 127
     f12:	84 bd       	out	0x24, r24	; 36
     f14:	08 95       	ret
		#endif
		
		#if defined(TIMER0B) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
     f16:	84 b5       	in	r24, 0x24	; 36
     f18:	8f 7d       	andi	r24, 0xDF	; 223
     f1a:	84 bd       	out	0x24, r24	; 36
     f1c:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
     f1e:	e0 eb       	ldi	r30, 0xB0	; 176
     f20:	f0 e0       	ldi	r31, 0x00	; 0
     f22:	80 81       	ld	r24, Z
     f24:	8f 77       	andi	r24, 0x7F	; 127
     f26:	80 83       	st	Z, r24
     f28:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
     f2a:	e0 eb       	ldi	r30, 0xB0	; 176
     f2c:	f0 e0       	ldi	r31, 0x00	; 0
     f2e:	80 81       	ld	r24, Z
     f30:	8f 7d       	andi	r24, 0xDF	; 223
     f32:	80 83       	st	Z, r24
     f34:	08 95       	ret
		#endif
		
		#if defined(TCCR3A) && defined(COM3A1)
		case  TIMER3A:  cbi(TCCR3A, COM3A1);    break;
     f36:	e0 e9       	ldi	r30, 0x90	; 144
     f38:	f0 e0       	ldi	r31, 0x00	; 0
     f3a:	80 81       	ld	r24, Z
     f3c:	8f 77       	andi	r24, 0x7F	; 127
     f3e:	80 83       	st	Z, r24
     f40:	08 95       	ret
		#endif
		#if defined(TCCR3A) && defined(COM3B1)
		case  TIMER3B:  cbi(TCCR3A, COM3B1);    break;
     f42:	e0 e9       	ldi	r30, 0x90	; 144
     f44:	f0 e0       	ldi	r31, 0x00	; 0
     f46:	80 81       	ld	r24, Z
     f48:	8f 7d       	andi	r24, 0xDF	; 223
     f4a:	80 83       	st	Z, r24
     f4c:	08 95       	ret
		#endif
		#if defined(TCCR3A) && defined(COM3C1)
		case  TIMER3C:  cbi(TCCR3A, COM3C1);    break;
     f4e:	e0 e9       	ldi	r30, 0x90	; 144
     f50:	f0 e0       	ldi	r31, 0x00	; 0
     f52:	80 81       	ld	r24, Z
     f54:	87 7f       	andi	r24, 0xF7	; 247
     f56:	80 83       	st	Z, r24
     f58:	08 95       	ret
		#endif

		#if defined(TCCR4A) && defined(COM4A1)
		case  TIMER4A:  cbi(TCCR4A, COM4A1);    break;
     f5a:	e0 ea       	ldi	r30, 0xA0	; 160
     f5c:	f0 e0       	ldi	r31, 0x00	; 0
     f5e:	80 81       	ld	r24, Z
     f60:	8f 77       	andi	r24, 0x7F	; 127
     f62:	80 83       	st	Z, r24
     f64:	08 95       	ret
		#endif					
		#if defined(TCCR4A) && defined(COM4B1)
		case  TIMER4B:  cbi(TCCR4A, COM4B1);    break;
     f66:	e0 ea       	ldi	r30, 0xA0	; 160
     f68:	f0 e0       	ldi	r31, 0x00	; 0
     f6a:	80 81       	ld	r24, Z
     f6c:	8f 7d       	andi	r24, 0xDF	; 223
     f6e:	80 83       	st	Z, r24
     f70:	08 95       	ret
		#endif
		#if defined(TCCR4A) && defined(COM4C1)
		case  TIMER4C:  cbi(TCCR4A, COM4C1);    break;
     f72:	e0 ea       	ldi	r30, 0xA0	; 160
     f74:	f0 e0       	ldi	r31, 0x00	; 0
     f76:	80 81       	ld	r24, Z
     f78:	87 7f       	andi	r24, 0xF7	; 247
     f7a:	80 83       	st	Z, r24
     f7c:	08 95       	ret
		#if defined(TCCR4C) && defined(COM4D1)
		case TIMER4D:	cbi(TCCR4C, COM4D1);	break;
		#endif			
			
		#if defined(TCCR5A)
		case  TIMER5A:  cbi(TCCR5A, COM5A1);    break;
     f7e:	e0 e2       	ldi	r30, 0x20	; 32
     f80:	f1 e0       	ldi	r31, 0x01	; 1
     f82:	80 81       	ld	r24, Z
     f84:	8f 77       	andi	r24, 0x7F	; 127
     f86:	80 83       	st	Z, r24
     f88:	08 95       	ret
		case  TIMER5B:  cbi(TCCR5A, COM5B1);    break;
     f8a:	e0 e2       	ldi	r30, 0x20	; 32
     f8c:	f1 e0       	ldi	r31, 0x01	; 1
     f8e:	80 81       	ld	r24, Z
     f90:	8f 7d       	andi	r24, 0xDF	; 223
     f92:	80 83       	st	Z, r24
     f94:	08 95       	ret
		case  TIMER5C:  cbi(TCCR5A, COM5C1);    break;
     f96:	e0 e2       	ldi	r30, 0x20	; 32
     f98:	f1 e0       	ldi	r31, 0x01	; 1
     f9a:	80 81       	ld	r24, Z
     f9c:	87 7f       	andi	r24, 0xF7	; 247
     f9e:	80 83       	st	Z, r24
     fa0:	08 95       	ret

00000fa2 <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
     fa2:	cf 93       	push	r28
     fa4:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
     fa6:	90 e0       	ldi	r25, 0x00	; 0
     fa8:	fc 01       	movw	r30, r24
     faa:	e4 5e       	subi	r30, 0xE4	; 228
     fac:	fe 4f       	sbci	r31, 0xFE	; 254
     fae:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
     fb0:	fc 01       	movw	r30, r24
     fb2:	e0 5d       	subi	r30, 0xD0	; 208
     fb4:	fe 4f       	sbci	r31, 0xFE	; 254
     fb6:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
     fb8:	88 23       	and	r24, r24
     fba:	71 f1       	breq	.+92     	; 0x1018 <pinMode+0x76>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
     fbc:	90 e0       	ldi	r25, 0x00	; 0
     fbe:	88 0f       	add	r24, r24
     fc0:	99 1f       	adc	r25, r25
     fc2:	fc 01       	movw	r30, r24
     fc4:	e2 5b       	subi	r30, 0xB2	; 178
     fc6:	fe 4f       	sbci	r31, 0xFE	; 254
     fc8:	a5 91       	lpm	r26, Z+
     fca:	b4 91       	lpm	r27, Z
	out = portOutputRegister(port);
     fcc:	8c 5b       	subi	r24, 0xBC	; 188
     fce:	9e 4f       	sbci	r25, 0xFE	; 254
     fd0:	fc 01       	movw	r30, r24
     fd2:	c5 91       	lpm	r28, Z+
     fd4:	d4 91       	lpm	r29, Z

	if (mode == INPUT) { 
     fd6:	61 11       	cpse	r22, r1
     fd8:	0b c0       	rjmp	.+22     	; 0xff0 <pinMode+0x4e>
		uint8_t oldSREG = SREG;
     fda:	8f b7       	in	r24, 0x3f	; 63
                cli();
     fdc:	f8 94       	cli
		*reg &= ~bit;
     fde:	9c 91       	ld	r25, X
     fe0:	20 95       	com	r18
     fe2:	92 23       	and	r25, r18
     fe4:	9c 93       	st	X, r25
		*out &= ~bit;
     fe6:	e8 81       	ld	r30, Y
     fe8:	2e 23       	and	r18, r30
     fea:	28 83       	st	Y, r18
		SREG = oldSREG;
     fec:	8f bf       	out	0x3f, r24	; 63
     fee:	14 c0       	rjmp	.+40     	; 0x1018 <pinMode+0x76>
	} else if (mode == INPUT_PULLUP) {
     ff0:	62 30       	cpi	r22, 0x02	; 2
     ff2:	61 f4       	brne	.+24     	; 0x100c <pinMode+0x6a>
		uint8_t oldSREG = SREG;
     ff4:	8f b7       	in	r24, 0x3f	; 63
                cli();
     ff6:	f8 94       	cli
		*reg &= ~bit;
     ff8:	3c 91       	ld	r19, X
     ffa:	92 2f       	mov	r25, r18
     ffc:	90 95       	com	r25
     ffe:	93 23       	and	r25, r19
    1000:	9c 93       	st	X, r25
		*out |= bit;
    1002:	e8 81       	ld	r30, Y
    1004:	2e 2b       	or	r18, r30
    1006:	28 83       	st	Y, r18
		SREG = oldSREG;
    1008:	8f bf       	out	0x3f, r24	; 63
    100a:	06 c0       	rjmp	.+12     	; 0x1018 <pinMode+0x76>
	} else {
		uint8_t oldSREG = SREG;
    100c:	8f b7       	in	r24, 0x3f	; 63
                cli();
    100e:	f8 94       	cli
		*reg |= bit;
    1010:	ec 91       	ld	r30, X
    1012:	2e 2b       	or	r18, r30
    1014:	2c 93       	st	X, r18
		SREG = oldSREG;
    1016:	8f bf       	out	0x3f, r24	; 63
	}
}
    1018:	df 91       	pop	r29
    101a:	cf 91       	pop	r28
    101c:	08 95       	ret

0000101e <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
    101e:	1f 93       	push	r17
    1020:	cf 93       	push	r28
    1022:	df 93       	push	r29
    1024:	c6 2f       	mov	r28, r22
	uint8_t timer = digitalPinToTimer(pin);
    1026:	28 2f       	mov	r18, r24
    1028:	30 e0       	ldi	r19, 0x00	; 0
    102a:	f9 01       	movw	r30, r18
    102c:	e8 5f       	subi	r30, 0xF8	; 248
    102e:	fe 4f       	sbci	r31, 0xFE	; 254
    1030:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
    1032:	f9 01       	movw	r30, r18
    1034:	e4 5e       	subi	r30, 0xE4	; 228
    1036:	fe 4f       	sbci	r31, 0xFE	; 254
    1038:	14 91       	lpm	r17, Z
	uint8_t port = digitalPinToPort(pin);
    103a:	f9 01       	movw	r30, r18
    103c:	e0 5d       	subi	r30, 0xD0	; 208
    103e:	fe 4f       	sbci	r31, 0xFE	; 254
    1040:	d4 91       	lpm	r29, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
    1042:	dd 23       	and	r29, r29
    1044:	c1 f0       	breq	.+48     	; 0x1076 <digitalWrite+0x58>

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    1046:	81 11       	cpse	r24, r1
    1048:	46 df       	rcall	.-372    	; 0xed6 <turnOffPWM>

	out = portOutputRegister(port);
    104a:	2d 2f       	mov	r18, r29
    104c:	30 e0       	ldi	r19, 0x00	; 0
    104e:	f9 01       	movw	r30, r18
    1050:	ee 0f       	add	r30, r30
    1052:	ff 1f       	adc	r31, r31
    1054:	ec 5b       	subi	r30, 0xBC	; 188
    1056:	fe 4f       	sbci	r31, 0xFE	; 254
    1058:	a5 91       	lpm	r26, Z+
    105a:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
    105c:	8f b7       	in	r24, 0x3f	; 63
	cli();
    105e:	f8 94       	cli

	if (val == LOW) {
    1060:	c1 11       	cpse	r28, r1
    1062:	05 c0       	rjmp	.+10     	; 0x106e <digitalWrite+0x50>
		*out &= ~bit;
    1064:	ec 91       	ld	r30, X
    1066:	10 95       	com	r17
    1068:	1e 23       	and	r17, r30
    106a:	1c 93       	st	X, r17
    106c:	03 c0       	rjmp	.+6      	; 0x1074 <digitalWrite+0x56>
	} else {
		*out |= bit;
    106e:	ec 91       	ld	r30, X
    1070:	1e 2b       	or	r17, r30
    1072:	1c 93       	st	X, r17
	}

	SREG = oldSREG;
    1074:	8f bf       	out	0x3f, r24	; 63
}
    1076:	df 91       	pop	r29
    1078:	cf 91       	pop	r28
    107a:	1f 91       	pop	r17
    107c:	08 95       	ret

0000107e <__tablejump2__>:
    107e:	ee 0f       	add	r30, r30
    1080:	ff 1f       	adc	r31, r31

00001082 <__tablejump__>:
    1082:	05 90       	lpm	r0, Z+
    1084:	f4 91       	lpm	r31, Z
    1086:	e0 2d       	mov	r30, r0
    1088:	19 94       	eijmp

0000108a <_exit>:
    108a:	f8 94       	cli

0000108c <__stop_program>:
    108c:	ff cf       	rjmp	.-2      	; 0x108c <__stop_program>
