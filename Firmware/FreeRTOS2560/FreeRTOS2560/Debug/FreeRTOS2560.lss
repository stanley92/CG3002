
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000006a  00800200  000027d2  00002866  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000027d2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000860  0080026a  0080026a  000028d0  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000028d0  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000008c0  00000000  00000000  00002900  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00011fcc  00000000  00000000  000031c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00003524  00000000  00000000  0001518c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00005e8b  00000000  00000000  000186b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00001b14  00000000  00000000  0001e53c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000041f0  00000000  00000000  00020050  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00008e0a  00000000  00000000  00024240  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000928  00000000  00000000  0002d04a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	df c1       	rjmp	.+958    	; 0x3c0 <__ctors_end>
       2:	00 00       	nop
       4:	0d c2       	rjmp	.+1050   	; 0x420 <__bad_interrupt>
       6:	00 00       	nop
       8:	0b c2       	rjmp	.+1046   	; 0x420 <__bad_interrupt>
       a:	00 00       	nop
       c:	09 c2       	rjmp	.+1042   	; 0x420 <__bad_interrupt>
       e:	00 00       	nop
      10:	07 c2       	rjmp	.+1038   	; 0x420 <__bad_interrupt>
      12:	00 00       	nop
      14:	05 c2       	rjmp	.+1034   	; 0x420 <__bad_interrupt>
      16:	00 00       	nop
      18:	03 c2       	rjmp	.+1030   	; 0x420 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	01 c2       	rjmp	.+1026   	; 0x420 <__bad_interrupt>
      1e:	00 00       	nop
      20:	ff c1       	rjmp	.+1022   	; 0x420 <__bad_interrupt>
      22:	00 00       	nop
      24:	fd c1       	rjmp	.+1018   	; 0x420 <__bad_interrupt>
      26:	00 00       	nop
      28:	fb c1       	rjmp	.+1014   	; 0x420 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	f9 c1       	rjmp	.+1010   	; 0x420 <__bad_interrupt>
      2e:	00 00       	nop
      30:	f7 c1       	rjmp	.+1006   	; 0x420 <__bad_interrupt>
      32:	00 00       	nop
      34:	0c 94 ed 08 	jmp	0x11da	; 0x11da <__vector_13>
      38:	f3 c1       	rjmp	.+998    	; 0x420 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	f1 c1       	rjmp	.+994    	; 0x420 <__bad_interrupt>
      3e:	00 00       	nop
      40:	ef c1       	rjmp	.+990    	; 0x420 <__bad_interrupt>
      42:	00 00       	nop
      44:	ed c1       	rjmp	.+986    	; 0x420 <__bad_interrupt>
      46:	00 00       	nop
      48:	eb c1       	rjmp	.+982    	; 0x420 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	e9 c1       	rjmp	.+978    	; 0x420 <__bad_interrupt>
      4e:	00 00       	nop
      50:	e7 c1       	rjmp	.+974    	; 0x420 <__bad_interrupt>
      52:	00 00       	nop
      54:	e5 c1       	rjmp	.+970    	; 0x420 <__bad_interrupt>
      56:	00 00       	nop
      58:	e3 c1       	rjmp	.+966    	; 0x420 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	0c 94 12 12 	jmp	0x2424	; 0x2424 <__vector_23>
      60:	df c1       	rjmp	.+958    	; 0x420 <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 57 10 	jmp	0x20ae	; 0x20ae <__vector_25>
      68:	0c 94 96 10 	jmp	0x212c	; 0x212c <__vector_26>
      6c:	d9 c1       	rjmp	.+946    	; 0x420 <__bad_interrupt>
      6e:	00 00       	nop
      70:	d7 c1       	rjmp	.+942    	; 0x420 <__bad_interrupt>
      72:	00 00       	nop
      74:	d5 c1       	rjmp	.+938    	; 0x420 <__bad_interrupt>
      76:	00 00       	nop
      78:	d3 c1       	rjmp	.+934    	; 0x420 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	d1 c1       	rjmp	.+930    	; 0x420 <__bad_interrupt>
      7e:	00 00       	nop
      80:	cf c1       	rjmp	.+926    	; 0x420 <__bad_interrupt>
      82:	00 00       	nop
      84:	cd c1       	rjmp	.+922    	; 0x420 <__bad_interrupt>
      86:	00 00       	nop
      88:	cb c1       	rjmp	.+918    	; 0x420 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	c9 c1       	rjmp	.+914    	; 0x420 <__bad_interrupt>
      8e:	00 00       	nop
      90:	c7 c1       	rjmp	.+910    	; 0x420 <__bad_interrupt>
      92:	00 00       	nop
      94:	c5 c1       	rjmp	.+906    	; 0x420 <__bad_interrupt>
      96:	00 00       	nop
      98:	c3 c1       	rjmp	.+902    	; 0x420 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	0c 94 4d 0d 	jmp	0x1a9a	; 0x1a9a <__vector_39>
      a0:	bf c1       	rjmp	.+894    	; 0x420 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	bd c1       	rjmp	.+890    	; 0x420 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	bb c1       	rjmp	.+886    	; 0x420 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	b9 c1       	rjmp	.+882    	; 0x420 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	b7 c1       	rjmp	.+878    	; 0x420 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	f0 c6       	rjmp	.+3552   	; 0xe96 <__vector_45>
      b6:	00 00       	nop
      b8:	b3 c1       	rjmp	.+870    	; 0x420 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	b1 c1       	rjmp	.+866    	; 0x420 <__bad_interrupt>
      be:	00 00       	nop
      c0:	af c1       	rjmp	.+862    	; 0x420 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	ad c1       	rjmp	.+858    	; 0x420 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	ab c1       	rjmp	.+854    	; 0x420 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	a9 c1       	rjmp	.+850    	; 0x420 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	a7 c1       	rjmp	.+846    	; 0x420 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	a5 c1       	rjmp	.+842    	; 0x420 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	a3 c1       	rjmp	.+838    	; 0x420 <__bad_interrupt>
      da:	00 00       	nop
      dc:	a1 c1       	rjmp	.+834    	; 0x420 <__bad_interrupt>
      de:	00 00       	nop
      e0:	9f c1       	rjmp	.+830    	; 0x420 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	52 0e       	add	r5, r18
      e6:	55 0e       	add	r5, r21
      e8:	55 0e       	add	r5, r21
      ea:	55 0e       	add	r5, r21
      ec:	55 0e       	add	r5, r21
      ee:	55 0e       	add	r5, r21
      f0:	55 0e       	add	r5, r21
      f2:	55 0e       	add	r5, r21
      f4:	6c 0d       	add	r22, r12
      f6:	55 0e       	add	r5, r21
      f8:	55 0e       	add	r5, r21
      fa:	55 0e       	add	r5, r21
      fc:	55 0e       	add	r5, r21
      fe:	55 0e       	add	r5, r21
     100:	55 0e       	add	r5, r21
     102:	55 0e       	add	r5, r21
     104:	6c 0d       	add	r22, r12
     106:	55 0e       	add	r5, r21
     108:	55 0e       	add	r5, r21
     10a:	55 0e       	add	r5, r21
     10c:	55 0e       	add	r5, r21
     10e:	55 0e       	add	r5, r21
     110:	55 0e       	add	r5, r21
     112:	55 0e       	add	r5, r21
     114:	74 0d       	add	r23, r4
     116:	55 0e       	add	r5, r21
     118:	55 0e       	add	r5, r21
     11a:	55 0e       	add	r5, r21
     11c:	55 0e       	add	r5, r21
     11e:	55 0e       	add	r5, r21
     120:	55 0e       	add	r5, r21
     122:	55 0e       	add	r5, r21
     124:	99 0d       	add	r25, r9
     126:	55 0e       	add	r5, r21
     128:	55 0e       	add	r5, r21
     12a:	55 0e       	add	r5, r21
     12c:	55 0e       	add	r5, r21
     12e:	55 0e       	add	r5, r21
     130:	55 0e       	add	r5, r21
     132:	55 0e       	add	r5, r21
     134:	74 0d       	add	r23, r4
     136:	55 0e       	add	r5, r21
     138:	55 0e       	add	r5, r21
     13a:	55 0e       	add	r5, r21
     13c:	55 0e       	add	r5, r21
     13e:	55 0e       	add	r5, r21
     140:	55 0e       	add	r5, r21
     142:	55 0e       	add	r5, r21
     144:	9e 0d       	add	r25, r14
     146:	55 0e       	add	r5, r21
     148:	55 0e       	add	r5, r21
     14a:	55 0e       	add	r5, r21
     14c:	55 0e       	add	r5, r21
     14e:	55 0e       	add	r5, r21
     150:	55 0e       	add	r5, r21
     152:	55 0e       	add	r5, r21
     154:	a3 0d       	add	r26, r3
     156:	55 0e       	add	r5, r21
     158:	55 0e       	add	r5, r21
     15a:	55 0e       	add	r5, r21
     15c:	55 0e       	add	r5, r21
     15e:	55 0e       	add	r5, r21
     160:	55 0e       	add	r5, r21
     162:	55 0e       	add	r5, r21
     164:	b4 0d       	add	r27, r4
     166:	55 0e       	add	r5, r21
     168:	55 0e       	add	r5, r21
     16a:	55 0e       	add	r5, r21
     16c:	55 0e       	add	r5, r21
     16e:	55 0e       	add	r5, r21
     170:	55 0e       	add	r5, r21
     172:	55 0e       	add	r5, r21
     174:	dd 0d       	add	r29, r13
     176:	55 0e       	add	r5, r21
     178:	55 0e       	add	r5, r21
     17a:	55 0e       	add	r5, r21
     17c:	55 0e       	add	r5, r21
     17e:	55 0e       	add	r5, r21
     180:	55 0e       	add	r5, r21
     182:	55 0e       	add	r5, r21
     184:	a8 0d       	add	r26, r8
     186:	55 0e       	add	r5, r21
     188:	55 0e       	add	r5, r21
     18a:	55 0e       	add	r5, r21
     18c:	55 0e       	add	r5, r21
     18e:	55 0e       	add	r5, r21
     190:	55 0e       	add	r5, r21
     192:	55 0e       	add	r5, r21
     194:	c2 0d       	add	r28, r2
     196:	55 0e       	add	r5, r21
     198:	55 0e       	add	r5, r21
     19a:	55 0e       	add	r5, r21
     19c:	55 0e       	add	r5, r21
     19e:	55 0e       	add	r5, r21
     1a0:	55 0e       	add	r5, r21
     1a2:	55 0e       	add	r5, r21
     1a4:	df 0d       	add	r29, r15
     1a6:	55 0e       	add	r5, r21
     1a8:	55 0e       	add	r5, r21
     1aa:	55 0e       	add	r5, r21
     1ac:	55 0e       	add	r5, r21
     1ae:	55 0e       	add	r5, r21
     1b0:	55 0e       	add	r5, r21
     1b2:	55 0e       	add	r5, r21
     1b4:	df 0d       	add	r29, r15
     1b6:	55 0e       	add	r5, r21
     1b8:	55 0e       	add	r5, r21
     1ba:	55 0e       	add	r5, r21
     1bc:	55 0e       	add	r5, r21
     1be:	55 0e       	add	r5, r21
     1c0:	55 0e       	add	r5, r21
     1c2:	55 0e       	add	r5, r21
     1c4:	df 0d       	add	r29, r15
     1c6:	55 0e       	add	r5, r21
     1c8:	55 0e       	add	r5, r21
     1ca:	55 0e       	add	r5, r21
     1cc:	55 0e       	add	r5, r21
     1ce:	55 0e       	add	r5, r21
     1d0:	55 0e       	add	r5, r21
     1d2:	55 0e       	add	r5, r21
     1d4:	df 0d       	add	r29, r15
     1d6:	55 0e       	add	r5, r21
     1d8:	55 0e       	add	r5, r21
     1da:	55 0e       	add	r5, r21
     1dc:	55 0e       	add	r5, r21
     1de:	55 0e       	add	r5, r21
     1e0:	55 0e       	add	r5, r21
     1e2:	55 0e       	add	r5, r21
     1e4:	e8 0d       	add	r30, r8
     1e6:	55 0e       	add	r5, r21
     1e8:	55 0e       	add	r5, r21
     1ea:	55 0e       	add	r5, r21
     1ec:	55 0e       	add	r5, r21
     1ee:	55 0e       	add	r5, r21
     1f0:	55 0e       	add	r5, r21
     1f2:	55 0e       	add	r5, r21
     1f4:	19 0e       	add	r1, r25
     1f6:	55 0e       	add	r5, r21
     1f8:	55 0e       	add	r5, r21
     1fa:	55 0e       	add	r5, r21
     1fc:	55 0e       	add	r5, r21
     1fe:	55 0e       	add	r5, r21
     200:	55 0e       	add	r5, r21
     202:	55 0e       	add	r5, r21
     204:	e8 0d       	add	r30, r8
     206:	55 0e       	add	r5, r21
     208:	55 0e       	add	r5, r21
     20a:	55 0e       	add	r5, r21
     20c:	55 0e       	add	r5, r21
     20e:	55 0e       	add	r5, r21
     210:	55 0e       	add	r5, r21
     212:	55 0e       	add	r5, r21
     214:	19 0e       	add	r1, r25
     216:	55 0e       	add	r5, r21
     218:	55 0e       	add	r5, r21
     21a:	55 0e       	add	r5, r21
     21c:	55 0e       	add	r5, r21
     21e:	55 0e       	add	r5, r21
     220:	55 0e       	add	r5, r21
     222:	55 0e       	add	r5, r21
     224:	00 0e       	add	r0, r16
     226:	55 0e       	add	r5, r21
     228:	55 0e       	add	r5, r21
     22a:	55 0e       	add	r5, r21
     22c:	55 0e       	add	r5, r21
     22e:	55 0e       	add	r5, r21
     230:	55 0e       	add	r5, r21
     232:	55 0e       	add	r5, r21
     234:	1d 0e       	add	r1, r29
     236:	55 0e       	add	r5, r21
     238:	55 0e       	add	r5, r21
     23a:	55 0e       	add	r5, r21
     23c:	55 0e       	add	r5, r21
     23e:	55 0e       	add	r5, r21
     240:	55 0e       	add	r5, r21
     242:	55 0e       	add	r5, r21
     244:	1d 0e       	add	r1, r29
     246:	55 0e       	add	r5, r21
     248:	55 0e       	add	r5, r21
     24a:	55 0e       	add	r5, r21
     24c:	55 0e       	add	r5, r21
     24e:	55 0e       	add	r5, r21
     250:	55 0e       	add	r5, r21
     252:	55 0e       	add	r5, r21
     254:	32 0e       	add	r3, r18
     256:	55 0e       	add	r5, r21
     258:	55 0e       	add	r5, r21
     25a:	55 0e       	add	r5, r21
     25c:	55 0e       	add	r5, r21
     25e:	55 0e       	add	r5, r21
     260:	55 0e       	add	r5, r21
     262:	55 0e       	add	r5, r21
     264:	4c 0e       	add	r4, r28
     266:	55 0e       	add	r5, r21
     268:	55 0e       	add	r5, r21
     26a:	55 0e       	add	r5, r21
     26c:	55 0e       	add	r5, r21
     26e:	55 0e       	add	r5, r21
     270:	55 0e       	add	r5, r21
     272:	55 0e       	add	r5, r21
     274:	4c 0e       	add	r4, r28
     276:	da 12       	cpse	r13, r26
     278:	de 12       	cpse	r13, r30
     27a:	c8 12       	cpse	r12, r24
     27c:	ce 12       	cpse	r12, r30
     27e:	d4 12       	cpse	r13, r20
     280:	23 13       	cpse	r18, r19
     282:	e2 12       	cpse	r14, r18
     284:	e8 12       	cpse	r14, r24
     286:	ee 12       	cpse	r14, r30
     288:	f4 12       	cpse	r15, r20
     28a:	fa 12       	cpse	r15, r26
     28c:	00 13       	cpse	r16, r16
     28e:	06 13       	cpse	r16, r22
     290:	0c 13       	cpse	r16, r28
     292:	23 13       	cpse	r18, r19
     294:	12 13       	cpse	r17, r18
     296:	18 13       	cpse	r17, r24
     298:	1e 13       	cpse	r17, r30

0000029a <__trampolines_end>:
     29a:	00 00       	nop
     29c:	0a 0b       	sbc	r16, r26
     29e:	02 09       	sbc	r16, r2
     2a0:	0c 0d       	add	r16, r12
     2a2:	0e 08       	sbc	r0, r14
     2a4:	07 03       	mulsu	r16, r23
     2a6:	04 01       	movw	r0, r8
	...
     2c4:	00 00       	nop
     2c6:	12 11       	cpse	r17, r2
     2c8:	10 00       	.word	0x0010	; ????
	...

000002e0 <digital_pin_to_bit_mask_PGM>:
     2e0:	01 02 10 20 20 08 08 10 20 40 10 20 40 80 02 01     ...  ... @. @...
     2f0:	02 01 08 04 02 01 01 02 04 08 10 20 40 80 80 40     ........... @..@
     300:	20 10 08 04 02 01 80 04 02 01 80 40 20 10 08 04      ..........@ ...
     310:	02 01 08 04 02 01 01 02 04 08 10 20 40 80 01 02     ........... @...
     320:	04 08 10 20 40 80                                   ... @.

00000326 <digital_pin_to_port_PGM>:
     326:	05 05 05 05 07 05 08 08 08 08 02 02 02 02 0a 0a     ................
     336:	08 08 04 04 04 04 01 01 01 01 01 01 01 01 03 03     ................
     346:	03 03 03 03 03 03 04 07 07 07 0c 0c 0c 0c 0c 0c     ................
     356:	0c 0c 02 02 02 02 06 06 06 06 06 06 06 06 0b 0b     ................
     366:	0b 0b 0b 0b 0b 0b                                   ......

0000036c <port_to_input_PGM>:
     36c:	00 00 20 00 23 00 26 00 29 00 2c 00 2f 00 32 00     .. .#.&.).,./.2.
     37c:	00 01 00 00 03 01 06 01 09 01                       ..........

00000386 <port_to_output_PGM>:
     386:	00 00 22 00 25 00 28 00 2b 00 2e 00 31 00 34 00     ..".%.(.+...1.4.
     396:	02 01 00 00 05 01 08 01 0b 01                       ..........

000003a0 <port_to_mode_PGM>:
     3a0:	00 00 21 00 24 00 27 00 2a 00 2d 00 30 00 33 00     ..!.$.'.*.-.0.3.
     3b0:	01 01 00 00 04 01 07 01 0a 01                       ..........

000003ba <__ctors_start>:
     3ba:	8c 02       	muls	r24, r28
     3bc:	3a 0f       	add	r19, r26
     3be:	bf 10       	cpse	r11, r15

000003c0 <__ctors_end>:
     3c0:	11 24       	eor	r1, r1
     3c2:	1f be       	out	0x3f, r1	; 63
     3c4:	cf ef       	ldi	r28, 0xFF	; 255
     3c6:	d1 e2       	ldi	r29, 0x21	; 33
     3c8:	de bf       	out	0x3e, r29	; 62
     3ca:	cd bf       	out	0x3d, r28	; 61
     3cc:	00 e0       	ldi	r16, 0x00	; 0
     3ce:	0c bf       	out	0x3c, r16	; 60

000003d0 <__do_copy_data>:
     3d0:	12 e0       	ldi	r17, 0x02	; 2
     3d2:	a0 e0       	ldi	r26, 0x00	; 0
     3d4:	b2 e0       	ldi	r27, 0x02	; 2
     3d6:	e2 ed       	ldi	r30, 0xD2	; 210
     3d8:	f7 e2       	ldi	r31, 0x27	; 39
     3da:	00 e0       	ldi	r16, 0x00	; 0
     3dc:	0b bf       	out	0x3b, r16	; 59
     3de:	02 c0       	rjmp	.+4      	; 0x3e4 <__do_copy_data+0x14>
     3e0:	07 90       	elpm	r0, Z+
     3e2:	0d 92       	st	X+, r0
     3e4:	aa 36       	cpi	r26, 0x6A	; 106
     3e6:	b1 07       	cpc	r27, r17
     3e8:	d9 f7       	brne	.-10     	; 0x3e0 <__do_copy_data+0x10>

000003ea <__do_clear_bss>:
     3ea:	2a e0       	ldi	r18, 0x0A	; 10
     3ec:	aa e6       	ldi	r26, 0x6A	; 106
     3ee:	b2 e0       	ldi	r27, 0x02	; 2
     3f0:	01 c0       	rjmp	.+2      	; 0x3f4 <.do_clear_bss_start>

000003f2 <.do_clear_bss_loop>:
     3f2:	1d 92       	st	X+, r1

000003f4 <.do_clear_bss_start>:
     3f4:	aa 3c       	cpi	r26, 0xCA	; 202
     3f6:	b2 07       	cpc	r27, r18
     3f8:	e1 f7       	brne	.-8      	; 0x3f2 <.do_clear_bss_loop>

000003fa <__do_global_ctors>:
     3fa:	13 e0       	ldi	r17, 0x03	; 3
     3fc:	c0 ec       	ldi	r28, 0xC0	; 192
     3fe:	d3 e0       	ldi	r29, 0x03	; 3
     400:	00 e0       	ldi	r16, 0x00	; 0
     402:	06 c0       	rjmp	.+12     	; 0x410 <__do_global_ctors+0x16>
     404:	22 97       	sbiw	r28, 0x02	; 2
     406:	01 09       	sbc	r16, r1
     408:	fe 01       	movw	r30, r28
     40a:	0b bf       	out	0x3b, r16	; 59
     40c:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <__tablejump_elpm__>
     410:	ca 3b       	cpi	r28, 0xBA	; 186
     412:	d1 07       	cpc	r29, r17
     414:	80 e0       	ldi	r24, 0x00	; 0
     416:	08 07       	cpc	r16, r24
     418:	a9 f7       	brne	.-22     	; 0x404 <__do_global_ctors+0xa>
     41a:	46 d0       	rcall	.+140    	; 0x4a8 <main>
     41c:	0c 94 e7 13 	jmp	0x27ce	; 0x27ce <_exit>

00000420 <__bad_interrupt>:
     420:	ef cd       	rjmp	.-1058   	; 0x0 <__vectors>

00000422 <_Z7freeRAMv>:
	{
		dprintf("%d",1);
		digitalWrite(13,HIGH);
		vTaskDelay(500);
		digitalWrite(13,LOW);
		vTaskDelay(500);
     422:	cf 93       	push	r28
     424:	df 93       	push	r29
     426:	1f 92       	push	r1
     428:	1f 92       	push	r1
     42a:	cd b7       	in	r28, 0x3d	; 61
     42c:	de b7       	in	r29, 0x3e	; 62
     42e:	20 91 c6 0a 	lds	r18, 0x0AC6
     432:	30 91 c7 0a 	lds	r19, 0x0AC7
     436:	21 15       	cp	r18, r1
     438:	31 05       	cpc	r19, r1
     43a:	21 f4       	brne	.+8      	; 0x444 <_Z7freeRAMv+0x22>
     43c:	ce 01       	movw	r24, r28
     43e:	89 5c       	subi	r24, 0xC9	; 201
     440:	9a 40       	sbci	r25, 0x0A	; 10
     442:	04 c0       	rjmp	.+8      	; 0x44c <_Z7freeRAMv+0x2a>
     444:	ce 01       	movw	r24, r28
     446:	01 96       	adiw	r24, 0x01	; 1
     448:	82 1b       	sub	r24, r18
     44a:	93 0b       	sbc	r25, r19
     44c:	0f 90       	pop	r0
     44e:	0f 90       	pop	r0
     450:	df 91       	pop	r29
     452:	cf 91       	pop	r28
     454:	08 95       	ret

00000456 <setup>:
     456:	26 e0       	ldi	r18, 0x06	; 6
     458:	40 e0       	ldi	r20, 0x00	; 0
     45a:	52 ec       	ldi	r21, 0xC2	; 194
     45c:	61 e0       	ldi	r22, 0x01	; 1
     45e:	70 e0       	ldi	r23, 0x00	; 0
     460:	80 e2       	ldi	r24, 0x20	; 32
     462:	9a e0       	ldi	r25, 0x0A	; 10
     464:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <_ZN14HardwareSerial5beginEmh>
     468:	8e ec       	ldi	r24, 0xCE	; 206
     46a:	99 e0       	ldi	r25, 0x09	; 9
     46c:	0e 94 02 0f 	call	0x1e04	; 0x1e04 <_ZN7TwoWire5beginEv>
     470:	42 e0       	ldi	r20, 0x02	; 2
     472:	63 e0       	ldi	r22, 0x03	; 3
     474:	87 e9       	ldi	r24, 0x97	; 151
     476:	92 e0       	ldi	r25, 0x02	; 2
     478:	a6 d1       	rcall	.+844    	; 0x7c6 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE>
     47a:	87 e9       	ldi	r24, 0x97	; 151
     47c:	92 e0       	ldi	r25, 0x02	; 2
     47e:	62 d1       	rcall	.+708    	; 0x744 <_ZN3L3G13enableDefaultEv>
     480:	80 e9       	ldi	r24, 0x90	; 144
     482:	92 e0       	ldi	r25, 0x02	; 2
     484:	f4 d2       	rcall	.+1512   	; 0xa6e <_ZN3LPS13enableDefaultEv>
     486:	42 e0       	ldi	r20, 0x02	; 2
     488:	64 e0       	ldi	r22, 0x04	; 4
     48a:	8a e6       	ldi	r24, 0x6A	; 106
     48c:	92 e0       	ldi	r25, 0x02	; 2
     48e:	cf d3       	rcall	.+1950   	; 0xc2e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE>
     490:	8a e6       	ldi	r24, 0x6A	; 106
     492:	92 e0       	ldi	r25, 0x02	; 2
     494:	63 d3       	rcall	.+1734   	; 0xb5c <_ZN6LSM30313enableDefaultEv>
     496:	61 e0       	ldi	r22, 0x01	; 1
     498:	86 e1       	ldi	r24, 0x16	; 22
     49a:	0e 94 24 13 	call	0x2648	; 0x2648 <pinMode>
     49e:	60 e0       	ldi	r22, 0x00	; 0
     4a0:	88 e1       	ldi	r24, 0x18	; 24
     4a2:	0c 94 24 13 	jmp	0x2648	; 0x2648 <pinMode>
     4a6:	08 95       	ret

000004a8 <main>:
     4a8:	af 92       	push	r10
     4aa:	bf 92       	push	r11
     4ac:	cf 92       	push	r12
     4ae:	df 92       	push	r13
     4b0:	ef 92       	push	r14
     4b2:	ff 92       	push	r15
     4b4:	0f 93       	push	r16
     4b6:	cf 93       	push	r28
     4b8:	df 93       	push	r29
     4ba:	1f 92       	push	r1
     4bc:	1f 92       	push	r1
     4be:	cd b7       	in	r28, 0x3d	; 61
     4c0:	de b7       	in	r29, 0x3e	; 62
     4c2:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <init>
     4c6:	c7 df       	rcall	.-114    	; 0x456 <setup>
     4c8:	61 e0       	ldi	r22, 0x01	; 1
     4ca:	8c e0       	ldi	r24, 0x0C	; 12
     4cc:	0e 94 24 13 	call	0x2648	; 0x2648 <pinMode>
     4d0:	61 e0       	ldi	r22, 0x01	; 1
     4d2:	8d e0       	ldi	r24, 0x0D	; 13
     4d4:	0e 94 24 13 	call	0x2648	; 0x2648 <pinMode>
     4d8:	a1 2c       	mov	r10, r1
     4da:	b1 2c       	mov	r11, r1
     4dc:	c1 2c       	mov	r12, r1
     4de:	d1 2c       	mov	r13, r1
     4e0:	ce 01       	movw	r24, r28
     4e2:	01 96       	adiw	r24, 0x01	; 1
     4e4:	7c 01       	movw	r14, r24
     4e6:	00 e0       	ldi	r16, 0x00	; 0
     4e8:	20 e0       	ldi	r18, 0x00	; 0
     4ea:	30 e0       	ldi	r19, 0x00	; 0
     4ec:	40 e4       	ldi	r20, 0x40	; 64
     4ee:	50 e0       	ldi	r21, 0x00	; 0
     4f0:	63 e2       	ldi	r22, 0x23	; 35
     4f2:	72 e0       	ldi	r23, 0x02	; 2
     4f4:	8f ea       	ldi	r24, 0xAF	; 175
     4f6:	92 e0       	ldi	r25, 0x02	; 2
     4f8:	c6 d6       	rcall	.+3468   	; 0x1286 <xTaskGenericCreate>
     4fa:	bf d7       	rcall	.+3966   	; 0x147a <vTaskStartScheduler>
     4fc:	80 e0       	ldi	r24, 0x00	; 0
     4fe:	90 e0       	ldi	r25, 0x00	; 0
     500:	0f 90       	pop	r0
     502:	0f 90       	pop	r0
     504:	df 91       	pop	r29
     506:	cf 91       	pop	r28
     508:	0f 91       	pop	r16
     50a:	ff 90       	pop	r15
     50c:	ef 90       	pop	r14
     50e:	df 90       	pop	r13
     510:	cf 90       	pop	r12
     512:	bf 90       	pop	r11
     514:	af 90       	pop	r10
     516:	08 95       	ret

00000518 <_GLOBAL__sub_I_sonar>:
     518:	ef 92       	push	r14
     51a:	0f 93       	push	r16
     51c:	28 ec       	ldi	r18, 0xC8	; 200
     51e:	30 e0       	ldi	r19, 0x00	; 0
     520:	48 e1       	ldi	r20, 0x18	; 24
     522:	66 e1       	ldi	r22, 0x16	; 22
     524:	83 e1       	ldi	r24, 0x13	; 19
     526:	93 e0       	ldi	r25, 0x03	; 3
     528:	5e d4       	rcall	.+2236   	; 0xde6 <_ZN7NewPingC1Ehhi>
     52a:	0f 2e       	mov	r0, r31
     52c:	f3 e0       	ldi	r31, 0x03	; 3
     52e:	ef 2e       	mov	r14, r31
     530:	f0 2d       	mov	r31, r0
     532:	04 e0       	ldi	r16, 0x04	; 4
     534:	20 e0       	ldi	r18, 0x00	; 0
     536:	32 e0       	ldi	r19, 0x02	; 2
     538:	43 e0       	ldi	r20, 0x03	; 3
     53a:	52 e0       	ldi	r21, 0x02	; 2
     53c:	67 e0       	ldi	r22, 0x07	; 7
     53e:	72 e0       	ldi	r23, 0x02	; 2
     540:	8f ea       	ldi	r24, 0xAF	; 175
     542:	92 e0       	ldi	r25, 0x02	; 2
     544:	7d d0       	rcall	.+250    	; 0x640 <_ZN6KeypadC1EPcPhS1_hh>
     546:	87 e9       	ldi	r24, 0x97	; 151
     548:	92 e0       	ldi	r25, 0x02	; 2
     54a:	d5 d0       	rcall	.+426    	; 0x6f6 <_ZN3L3GC1Ev>
     54c:	80 e9       	ldi	r24, 0x90	; 144
     54e:	92 e0       	ldi	r25, 0x02	; 2
     550:	5c d2       	rcall	.+1208   	; 0xa0a <_ZN3LPSC1Ev>
     552:	8a e6       	ldi	r24, 0x6A	; 106
     554:	92 e0       	ldi	r25, 0x02	; 2
     556:	9b d2       	rcall	.+1334   	; 0xa8e <_ZN6LSM303C1Ev>
     558:	0f 91       	pop	r16
     55a:	ef 90       	pop	r14
     55c:	08 95       	ret

0000055e <_Z10printArrayPv>:
	//return ((int) &v) – ((__brkval == 0 ? (int) &__heap_start : (int) __brkval));
}

void printArray(void* p){
	int i;
	data [1] = 123;
     55e:	8b e7       	ldi	r24, 0x7B	; 123
     560:	80 93 a4 02 	sts	0x02A4, r24
	char canRead = '0';
	while(1){
		if(Serial.available()){
     564:	80 e2       	ldi	r24, 0x20	; 32
     566:	9a e0       	ldi	r25, 0x0A	; 10
     568:	0e 94 3e 0f 	call	0x1e7c	; 0x1e7c <_ZN14HardwareSerial9availableEv>
     56c:	89 2b       	or	r24, r25
     56e:	d9 f0       	breq	.+54     	; 0x5a6 <_Z10printArrayPv+0x48>
			canRead = Serial.read();
     570:	80 e2       	ldi	r24, 0x20	; 32
     572:	9a e0       	ldi	r25, 0x0A	; 10
     574:	0e 94 57 0f 	call	0x1eae	; 0x1eae <_ZN14HardwareSerial4readEv>
		}
		if(canRead -'0'){
     578:	80 33       	cpi	r24, 0x30	; 48
     57a:	a9 f0       	breq	.+42     	; 0x5a6 <_Z10printArrayPv+0x48>
			//for(i = 1;i<10;i++){
				Serial.println(/*data[1]*/213);
     57c:	4a e0       	ldi	r20, 0x0A	; 10
     57e:	50 e0       	ldi	r21, 0x00	; 0
     580:	65 ed       	ldi	r22, 0xD5	; 213
     582:	70 e0       	ldi	r23, 0x00	; 0
     584:	80 e2       	ldi	r24, 0x20	; 32
     586:	9a e0       	ldi	r25, 0x0A	; 10
     588:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <_ZN5Print7printlnEii>
				Serial.print('\r');
     58c:	6d e0       	ldi	r22, 0x0D	; 13
     58e:	80 e2       	ldi	r24, 0x20	; 32
     590:	9a e0       	ldi	r25, 0x0A	; 10
     592:	0e 94 30 11 	call	0x2260	; 0x2260 <_ZN5Print5printEc>
		//	}
			Serial.println(freeRAM());
     596:	45 df       	rcall	.-374    	; 0x422 <_Z7freeRAMv>
     598:	4a e0       	ldi	r20, 0x0A	; 10
     59a:	50 e0       	ldi	r21, 0x00	; 0
     59c:	bc 01       	movw	r22, r24
     59e:	80 e2       	ldi	r24, 0x20	; 32
     5a0:	9a e0       	ldi	r25, 0x0A	; 10
     5a2:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <_ZN5Print7printlnEii>
			canRead = '0';
		}
		vTaskDelay(500);
     5a6:	84 ef       	ldi	r24, 0xF4	; 244
     5a8:	91 e0       	ldi	r25, 0x01	; 1
     5aa:	0e 94 a5 0b 	call	0x174a	; 0x174a <vTaskDelay>
	}
     5ae:	da cf       	rjmp	.-76     	; 0x564 <_Z10printArrayPv+0x6>

000005b0 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     5b0:	cf 93       	push	r28
     5b2:	df 93       	push	r29
     5b4:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     5b6:	8a d7       	rcall	.+3860   	; 0x14cc <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     5b8:	80 91 25 03 	lds	r24, 0x0325
     5bc:	90 91 26 03 	lds	r25, 0x0326
     5c0:	89 2b       	or	r24, r25
     5c2:	31 f4       	brne	.+12     	; 0x5d0 <pvPortMalloc+0x20>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     5c4:	8a e2       	ldi	r24, 0x2A	; 42
     5c6:	93 e0       	ldi	r25, 0x03	; 3
     5c8:	90 93 26 03 	sts	0x0326, r25
     5cc:	80 93 25 03 	sts	0x0325, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     5d0:	40 91 27 03 	lds	r20, 0x0327
     5d4:	50 91 28 03 	lds	r21, 0x0328
     5d8:	9e 01       	movw	r18, r28
     5da:	24 0f       	add	r18, r20
     5dc:	35 1f       	adc	r19, r21
     5de:	2b 3d       	cpi	r18, 0xDB	; 219
     5e0:	85 e0       	ldi	r24, 0x05	; 5
     5e2:	38 07       	cpc	r19, r24
     5e4:	70 f4       	brcc	.+28     	; 0x602 <pvPortMalloc+0x52>
     5e6:	42 17       	cp	r20, r18
     5e8:	53 07       	cpc	r21, r19
     5ea:	70 f4       	brcc	.+28     	; 0x608 <pvPortMalloc+0x58>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     5ec:	c0 91 25 03 	lds	r28, 0x0325
     5f0:	d0 91 26 03 	lds	r29, 0x0326
     5f4:	c4 0f       	add	r28, r20
     5f6:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     5f8:	30 93 28 03 	sts	0x0328, r19
     5fc:	20 93 27 03 	sts	0x0327, r18
     600:	05 c0       	rjmp	.+10     	; 0x60c <pvPortMalloc+0x5c>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     602:	c0 e0       	ldi	r28, 0x00	; 0
     604:	d0 e0       	ldi	r29, 0x00	; 0
     606:	02 c0       	rjmp	.+4      	; 0x60c <pvPortMalloc+0x5c>
     608:	c0 e0       	ldi	r28, 0x00	; 0
     60a:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     60c:	0e 94 27 0b 	call	0x164e	; 0x164e <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     610:	ce 01       	movw	r24, r28
     612:	df 91       	pop	r29
     614:	cf 91       	pop	r28
     616:	08 95       	ret

00000618 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     618:	08 95       	ret

0000061a <_ZN3KeyC1Ev>:
*/
#include <Key.h>


// default constructor
Key::Key() {
     61a:	fc 01       	movw	r30, r24
	kchar = NO_KEY;
     61c:	10 82       	st	Z, r1
	kstate = IDLE;
     61e:	13 82       	std	Z+3, r1	; 0x03
	stateChanged = false;
     620:	14 82       	std	Z+4, r1	; 0x04
     622:	08 95       	ret

00000624 <_ZN6Keypad8pin_modeEhh>:
class Keypad : public Key {
public:

	Keypad(char *userKeymap, unsigned char *row, unsigned char *col, unsigned char numRows, unsigned char numCols);

	virtual void pin_mode(unsigned char pinNum, unsigned char mode) { pinMode(pinNum, mode); }
     624:	86 2f       	mov	r24, r22
     626:	64 2f       	mov	r22, r20
     628:	0c 94 24 13 	jmp	0x2648	; 0x2648 <pinMode>
     62c:	08 95       	ret

0000062e <_ZN6Keypad9pin_writeEhb>:
	virtual void pin_write(unsigned char pinNum, bool level) { digitalWrite(pinNum, level); }
     62e:	86 2f       	mov	r24, r22
     630:	64 2f       	mov	r22, r20
     632:	0c 94 62 13 	jmp	0x26c4	; 0x26c4 <digitalWrite>
     636:	08 95       	ret

00000638 <_ZN6Keypad8pin_readEh>:
	virtual int  pin_read(unsigned char pinNum) { return digitalRead(pinNum); }
     638:	86 2f       	mov	r24, r22
     63a:	0c 94 92 13 	jmp	0x2724	; 0x2724 <digitalRead>
     63e:	08 95       	ret

00000640 <_ZN6KeypadC1EPcPhS1_hh>:
#include <Arduino.h>
#include <avr/io.h>
#include <Key.h>

// <<constructor>> Allows custom keymap, pin configuration, and keypad sizes.
Keypad::Keypad(char *userKeymap, unsigned char *row, unsigned char *col, unsigned char numRows, unsigned char numCols) {
     640:	4f 92       	push	r4
     642:	5f 92       	push	r5
     644:	6f 92       	push	r6
     646:	7f 92       	push	r7
     648:	8f 92       	push	r8
     64a:	9f 92       	push	r9
     64c:	af 92       	push	r10
     64e:	bf 92       	push	r11
     650:	cf 92       	push	r12
     652:	df 92       	push	r13
     654:	ef 92       	push	r14
     656:	0f 93       	push	r16
     658:	cf 93       	push	r28
     65a:	df 93       	push	r29
     65c:	ec 01       	movw	r28, r24
     65e:	4b 01       	movw	r8, r22
     660:	3a 01       	movw	r6, r20
     662:	59 01       	movw	r10, r18
     664:	02 96       	adiw	r24, 0x02	; 2
     666:	d9 df       	rcall	.-78     	; 0x61a <_ZN3KeyC1Ev>
     668:	8e e3       	ldi	r24, 0x3E	; 62
     66a:	92 e0       	ldi	r25, 0x02	; 2
     66c:	99 83       	std	Y+1, r25	; 0x01
     66e:	88 83       	st	Y, r24
     670:	2e 01       	movw	r4, r28
     672:	8b e1       	ldi	r24, 0x1B	; 27
     674:	48 0e       	add	r4, r24
     676:	51 1c       	adc	r5, r1
     678:	62 01       	movw	r12, r4
     67a:	82 e3       	ldi	r24, 0x32	; 50
     67c:	c8 0e       	add	r12, r24
     67e:	d1 1c       	adc	r13, r1
     680:	c2 01       	movw	r24, r4
     682:	cb df       	rcall	.-106    	; 0x61a <_ZN3KeyC1Ev>
     684:	85 e0       	ldi	r24, 0x05	; 5
     686:	48 0e       	add	r4, r24
     688:	51 1c       	adc	r5, r1
     68a:	4c 14       	cp	r4, r12
     68c:	5d 04       	cpc	r5, r13
     68e:	c1 f7       	brne	.-16     	; 0x680 <_ZN6KeypadC1EPcPhS1_hh+0x40>
	rowPins = row;
     690:	fe 01       	movw	r30, r28
     692:	e9 5a       	subi	r30, 0xA9	; 169
     694:	ff 4f       	sbci	r31, 0xFF	; 255
     696:	71 82       	std	Z+1, r7	; 0x01
     698:	60 82       	st	Z, r6
	columnPins = col;
     69a:	32 96       	adiw	r30, 0x02	; 2
     69c:	b1 82       	std	Z+1, r11	; 0x01
     69e:	a0 82       	st	Z, r10
	sizeKpd.rows = numRows;
     6a0:	32 96       	adiw	r30, 0x02	; 2
     6a2:	00 83       	st	Z, r16
	sizeKpd.columns = numCols;
     6a4:	31 96       	adiw	r30, 0x01	; 1
     6a6:	e0 82       	st	Z, r14
	single_key = false;
}

// Let the user define a keymap - assume the same row/column count as defined in constructor
void Keypad::begin(char *userKeymap) {
    keymap = userKeymap;
     6a8:	37 97       	sbiw	r30, 0x07	; 7
     6aa:	91 82       	std	Z+1, r9	; 0x01
     6ac:	80 82       	st	Z, r8
	return sizeof(key)/sizeof(Key);
}

// Minimum debounceTime is 1 mS. Any lower *will* slow down the loop().
void Keypad::setDebounceTime(uint debounce) {
	debounce<1 ? debounceTime=1 : debounceTime=debounce;
     6ae:	38 96       	adiw	r30, 0x08	; 8
     6b0:	8a e0       	ldi	r24, 0x0A	; 10
     6b2:	90 e0       	ldi	r25, 0x00	; 0
     6b4:	91 83       	std	Z+1, r25	; 0x01
     6b6:	80 83       	st	Z, r24
}

void Keypad::setHoldTime(uint hold) {
    holdTime = hold;
     6b8:	32 96       	adiw	r30, 0x02	; 2
     6ba:	84 ef       	ldi	r24, 0xF4	; 244
     6bc:	91 e0       	ldi	r25, 0x01	; 1
     6be:	91 83       	std	Z+1, r25	; 0x01
     6c0:	80 83       	st	Z, r24

	begin(userKeymap);

	setDebounceTime(10);
	setHoldTime(500);
	keypadEventListener = 0;
     6c2:	33 96       	adiw	r30, 0x03	; 3
     6c4:	11 82       	std	Z+1, r1	; 0x01
     6c6:	10 82       	st	Z, r1

	startTime = 0;
     6c8:	71 97       	sbiw	r30, 0x11	; 17
     6ca:	10 82       	st	Z, r1
     6cc:	11 82       	std	Z+1, r1	; 0x01
     6ce:	12 82       	std	Z+2, r1	; 0x02
     6d0:	13 82       	std	Z+3, r1	; 0x03
	single_key = false;
     6d2:	cf 59       	subi	r28, 0x9F	; 159
     6d4:	df 4f       	sbci	r29, 0xFF	; 255
     6d6:	18 82       	st	Y, r1
}
     6d8:	df 91       	pop	r29
     6da:	cf 91       	pop	r28
     6dc:	0f 91       	pop	r16
     6de:	ef 90       	pop	r14
     6e0:	df 90       	pop	r13
     6e2:	cf 90       	pop	r12
     6e4:	bf 90       	pop	r11
     6e6:	af 90       	pop	r10
     6e8:	9f 90       	pop	r9
     6ea:	8f 90       	pop	r8
     6ec:	7f 90       	pop	r7
     6ee:	6f 90       	pop	r6
     6f0:	5f 90       	pop	r5
     6f2:	4f 90       	pop	r4
     6f4:	08 95       	ret

000006f6 <_ZN3L3GC1Ev>:

  // combine high and low bytes
  g.x = (int16_t)(xhg << 8 | xlg);
  g.y = (int16_t)(yhg << 8 | ylg);
  g.z = (int16_t)(zhg << 8 | zlg);
}
     6f6:	fc 01       	movw	r30, r24
     6f8:	83 e0       	ldi	r24, 0x03	; 3
     6fa:	87 83       	std	Z+7, r24	; 0x07
     6fc:	12 86       	std	Z+10, r1	; 0x0a
     6fe:	11 86       	std	Z+9, r1	; 0x09
     700:	13 86       	std	Z+11, r1	; 0x0b
     702:	08 95       	ret

00000704 <_ZN3L3G8writeRegEhh>:
     704:	0f 93       	push	r16
     706:	1f 93       	push	r17
     708:	cf 93       	push	r28
     70a:	df 93       	push	r29
     70c:	ec 01       	movw	r28, r24
     70e:	06 2f       	mov	r16, r22
     710:	14 2f       	mov	r17, r20
     712:	68 85       	ldd	r22, Y+8	; 0x08
     714:	8e ec       	ldi	r24, 0xCE	; 206
     716:	99 e0       	ldi	r25, 0x09	; 9
     718:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <_ZN7TwoWire17beginTransmissionEh>
     71c:	60 2f       	mov	r22, r16
     71e:	8e ec       	ldi	r24, 0xCE	; 206
     720:	99 e0       	ldi	r25, 0x09	; 9
     722:	0e 94 c2 0e 	call	0x1d84	; 0x1d84 <_ZN7TwoWire5writeEh>
     726:	61 2f       	mov	r22, r17
     728:	8e ec       	ldi	r24, 0xCE	; 206
     72a:	99 e0       	ldi	r25, 0x09	; 9
     72c:	0e 94 c2 0e 	call	0x1d84	; 0x1d84 <_ZN7TwoWire5writeEh>
     730:	8e ec       	ldi	r24, 0xCE	; 206
     732:	99 e0       	ldi	r25, 0x09	; 9
     734:	0e 94 37 0f 	call	0x1e6e	; 0x1e6e <_ZN7TwoWire15endTransmissionEv>
     738:	8e 83       	std	Y+6, r24	; 0x06
     73a:	df 91       	pop	r29
     73c:	cf 91       	pop	r28
     73e:	1f 91       	pop	r17
     740:	0f 91       	pop	r16
     742:	08 95       	ret

00000744 <_ZN3L3G13enableDefaultEv>:
     744:	cf 93       	push	r28
     746:	df 93       	push	r29
     748:	ec 01       	movw	r28, r24
     74a:	8f 81       	ldd	r24, Y+7	; 0x07
     74c:	82 30       	cpi	r24, 0x02	; 2
     74e:	21 f4       	brne	.+8      	; 0x758 <_ZN3L3G13enableDefaultEv+0x14>
     750:	40 e0       	ldi	r20, 0x00	; 0
     752:	69 e3       	ldi	r22, 0x39	; 57
     754:	ce 01       	movw	r24, r28
     756:	d6 df       	rcall	.-84     	; 0x704 <_ZN3L3G8writeRegEhh>
     758:	40 e0       	ldi	r20, 0x00	; 0
     75a:	63 e2       	ldi	r22, 0x23	; 35
     75c:	ce 01       	movw	r24, r28
     75e:	d2 df       	rcall	.-92     	; 0x704 <_ZN3L3G8writeRegEhh>
     760:	4f e6       	ldi	r20, 0x6F	; 111
     762:	60 e2       	ldi	r22, 0x20	; 32
     764:	ce 01       	movw	r24, r28
     766:	ce df       	rcall	.-100    	; 0x704 <_ZN3L3G8writeRegEhh>
     768:	df 91       	pop	r29
     76a:	cf 91       	pop	r28
     76c:	08 95       	ret

0000076e <_ZN3L3G7testRegEhNS_7regAddrE>:
}

// Private Methods //////////////////////////////////////////////////////////////

int L3G::testReg(byte address, regAddr reg)
{
     76e:	cf 93       	push	r28
     770:	df 93       	push	r29
     772:	c6 2f       	mov	r28, r22
     774:	d4 2f       	mov	r29, r20
  Wire.beginTransmission(address);
     776:	8e ec       	ldi	r24, 0xCE	; 206
     778:	99 e0       	ldi	r25, 0x09	; 9
     77a:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <_ZN7TwoWire17beginTransmissionEh>
  Wire.write((byte)reg);
     77e:	6d 2f       	mov	r22, r29
     780:	8e ec       	ldi	r24, 0xCE	; 206
     782:	99 e0       	ldi	r25, 0x09	; 9
     784:	0e 94 c2 0e 	call	0x1d84	; 0x1d84 <_ZN7TwoWire5writeEh>
  if (Wire.endTransmission() != 0)
     788:	8e ec       	ldi	r24, 0xCE	; 206
     78a:	99 e0       	ldi	r25, 0x09	; 9
     78c:	0e 94 37 0f 	call	0x1e6e	; 0x1e6e <_ZN7TwoWire15endTransmissionEv>
     790:	81 11       	cpse	r24, r1
     792:	11 c0       	rjmp	.+34     	; 0x7b6 <_ZN3L3G7testRegEhNS_7regAddrE+0x48>
  {
    return TEST_REG_ERROR;
  }

  Wire.requestFrom(address, (byte)1);
     794:	41 e0       	ldi	r20, 0x01	; 1
     796:	6c 2f       	mov	r22, r28
     798:	8e ec       	ldi	r24, 0xCE	; 206
     79a:	99 e0       	ldi	r25, 0x09	; 9
     79c:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <_ZN7TwoWire11requestFromEhh>
  if (Wire.available())
     7a0:	8e ec       	ldi	r24, 0xCE	; 206
     7a2:	99 e0       	ldi	r25, 0x09	; 9
     7a4:	0e 94 68 0e 	call	0x1cd0	; 0x1cd0 <_ZN7TwoWire9availableEv>
     7a8:	89 2b       	or	r24, r25
     7aa:	41 f0       	breq	.+16     	; 0x7bc <_ZN3L3G7testRegEhNS_7regAddrE+0x4e>
  {
    return Wire.read();
     7ac:	8e ec       	ldi	r24, 0xCE	; 206
     7ae:	99 e0       	ldi	r25, 0x09	; 9
     7b0:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <_ZN7TwoWire4readEv>
     7b4:	05 c0       	rjmp	.+10     	; 0x7c0 <_ZN3L3G7testRegEhNS_7regAddrE+0x52>
{
  Wire.beginTransmission(address);
  Wire.write((byte)reg);
  if (Wire.endTransmission() != 0)
  {
    return TEST_REG_ERROR;
     7b6:	8f ef       	ldi	r24, 0xFF	; 255
     7b8:	9f ef       	ldi	r25, 0xFF	; 255
     7ba:	02 c0       	rjmp	.+4      	; 0x7c0 <_ZN3L3G7testRegEhNS_7regAddrE+0x52>
  {
    return Wire.read();
  }
  else
  {
    return TEST_REG_ERROR;
     7bc:	8f ef       	ldi	r24, 0xFF	; 255
     7be:	9f ef       	ldi	r25, 0xFF	; 255
  }
}
     7c0:	df 91       	pop	r29
     7c2:	cf 91       	pop	r28
     7c4:	08 95       	ret

000007c6 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE>:
{
  return io_timeout;
}

bool L3G::init(deviceType device, sa0State sa0)
{
     7c6:	0f 93       	push	r16
     7c8:	1f 93       	push	r17
     7ca:	cf 93       	push	r28
     7cc:	df 93       	push	r29
     7ce:	ec 01       	movw	r28, r24
     7d0:	16 2f       	mov	r17, r22
     7d2:	04 2f       	mov	r16, r20
  int id;
  
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
     7d4:	63 30       	cpi	r22, 0x03	; 3
     7d6:	09 f4       	brne	.+2      	; 0x7da <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x14>
     7d8:	56 c0       	rjmp	.+172    	; 0x886 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xc0>
     7da:	42 30       	cpi	r20, 0x02	; 2
     7dc:	c9 f5       	brne	.+114    	; 0x850 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x8a>
     7de:	56 c0       	rjmp	.+172    	; 0x88c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xc6>
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
        if (device == device_auto)
     7e0:	13 30       	cpi	r17, 0x03	; 3
     7e2:	09 f0       	breq	.+2      	; 0x7e6 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x20>
     7e4:	58 c0       	rjmp	.+176    	; 0x896 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xd0>
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     7e6:	87 3d       	cpi	r24, 0xD7	; 215
     7e8:	91 05       	cpc	r25, r1
     7ea:	09 f4       	brne	.+2      	; 0x7ee <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x28>
     7ec:	58 c0       	rjmp	.+176    	; 0x89e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xd8>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
     7ee:	01 e0       	ldi	r16, 0x01	; 1
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     7f0:	11 e0       	ldi	r17, 0x01	; 1
     7f2:	2c c0       	rjmp	.+88     	; 0x84c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
        }
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     7f4:	01 30       	cpi	r16, 0x01	; 1
     7f6:	91 f0       	breq	.+36     	; 0x81c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x56>
     7f8:	4f e0       	ldi	r20, 0x0F	; 15
     7fa:	6a e6       	ldi	r22, 0x6A	; 106
     7fc:	ce 01       	movw	r24, r28
     7fe:	b7 df       	rcall	.-146    	; 0x76e <_ZN3L3G7testRegEhNS_7regAddrE>
     800:	8f 3f       	cpi	r24, 0xFF	; 255
     802:	2f ef       	ldi	r18, 0xFF	; 255
     804:	92 07       	cpc	r25, r18
     806:	51 f0       	breq	.+20     	; 0x81c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x56>
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
        if (device == device_auto)
     808:	13 30       	cpi	r17, 0x03	; 3
     80a:	09 f0       	breq	.+2      	; 0x80e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x48>
     80c:	46 c0       	rjmp	.+140    	; 0x89a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xd4>
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     80e:	87 3d       	cpi	r24, 0xD7	; 215
     810:	91 05       	cpc	r25, r1
     812:	09 f0       	breq	.+2      	; 0x816 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x50>
     814:	47 c0       	rjmp	.+142    	; 0x8a4 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xde>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
     816:	00 e0       	ldi	r16, 0x00	; 0
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     818:	12 e0       	ldi	r17, 0x02	; 2
     81a:	18 c0       	rjmp	.+48     	; 0x84c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
        }
      }
    }
    
    // check for L3G4200D if device is still unidentified or was specified to be this type
    if (device == device_auto || device == device_4200D)
     81c:	13 30       	cpi	r17, 0x03	; 3
     81e:	11 f0       	breq	.+4      	; 0x824 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5e>
     820:	11 11       	cpse	r17, r1
     822:	14 c0       	rjmp	.+40     	; 0x84c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
    {
      if (sa0 != sa0_low && testReg(L3G4200D_SA0_HIGH_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
     824:	00 23       	and	r16, r16
     826:	49 f0       	breq	.+18     	; 0x83a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x74>
     828:	4f e0       	ldi	r20, 0x0F	; 15
     82a:	69 e6       	ldi	r22, 0x69	; 105
     82c:	ce 01       	movw	r24, r28
     82e:	9f df       	rcall	.-194    	; 0x76e <_ZN3L3G7testRegEhNS_7regAddrE>
     830:	83 3d       	cpi	r24, 0xD3	; 211
     832:	91 05       	cpc	r25, r1
     834:	d1 f1       	breq	.+116    	; 0x8aa <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xe4>
      {
        // device responds to address 1101001; it's a 4200D with SA0 high
        device = device_4200D;
        sa0 = sa0_high;
      }
      else if (sa0 != sa0_high && testReg(L3G4200D_SA0_LOW_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
     836:	01 30       	cpi	r16, 0x01	; 1
     838:	39 f0       	breq	.+14     	; 0x848 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x82>
     83a:	4f e0       	ldi	r20, 0x0F	; 15
     83c:	68 e6       	ldi	r22, 0x68	; 104
     83e:	ce 01       	movw	r24, r28
     840:	96 df       	rcall	.-212    	; 0x76e <_ZN3L3G7testRegEhNS_7regAddrE>
     842:	83 3d       	cpi	r24, 0xD3	; 211
     844:	91 05       	cpc	r25, r1
     846:	99 f1       	breq	.+102    	; 0x8ae <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xe8>
        sa0 = sa0_low;
      }
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
     848:	13 30       	cpi	r17, 0x03	; 3
     84a:	b9 f0       	breq	.+46     	; 0x87a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xb4>
     84c:	02 30       	cpi	r16, 0x02	; 2
     84e:	b9 f0       	breq	.+46     	; 0x87e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xb8>
    {
      return false;
    }
  }
  
  _device = device;
     850:	1f 83       	std	Y+7, r17	; 0x07

  // set device address
  switch (device)
     852:	11 23       	and	r17, r17
     854:	51 f0       	breq	.+20     	; 0x86a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xa4>
     856:	13 30       	cpi	r17, 0x03	; 3
     858:	a0 f4       	brcc	.+40     	; 0x882 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xbc>
  {
    case device_D20H:
    case device_D20:
      address = (sa0 == sa0_high) ? D20_SA0_HIGH_ADDRESS : D20_SA0_LOW_ADDRESS;
     85a:	01 30       	cpi	r16, 0x01	; 1
     85c:	11 f4       	brne	.+4      	; 0x862 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x9c>
     85e:	8b e6       	ldi	r24, 0x6B	; 107
     860:	01 c0       	rjmp	.+2      	; 0x864 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x9e>
     862:	8a e6       	ldi	r24, 0x6A	; 106
     864:	88 87       	std	Y+8, r24	; 0x08
    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
  }
  
  return true;
     866:	81 e0       	ldi	r24, 0x01	; 1
  switch (device)
  {
    case device_D20H:
    case device_D20:
      address = (sa0 == sa0_high) ? D20_SA0_HIGH_ADDRESS : D20_SA0_LOW_ADDRESS;
      break;
     868:	41 c0       	rjmp	.+130    	; 0x8ec <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>

    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
     86a:	01 30       	cpi	r16, 0x01	; 1
     86c:	11 f4       	brne	.+4      	; 0x872 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xac>
     86e:	89 e6       	ldi	r24, 0x69	; 105
     870:	01 c0       	rjmp	.+2      	; 0x874 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xae>
     872:	88 e6       	ldi	r24, 0x68	; 104
     874:	88 87       	std	Y+8, r24	; 0x08
      break;
  }
  
  return true;
     876:	81 e0       	ldi	r24, 0x01	; 1
      address = (sa0 == sa0_high) ? D20_SA0_HIGH_ADDRESS : D20_SA0_LOW_ADDRESS;
      break;

    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
     878:	39 c0       	rjmp	.+114    	; 0x8ec <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
    {
      return false;
     87a:	80 e0       	ldi	r24, 0x00	; 0
     87c:	37 c0       	rjmp	.+110    	; 0x8ec <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
     87e:	80 e0       	ldi	r24, 0x00	; 0
     880:	35 c0       	rjmp	.+106    	; 0x8ec <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
    case device_4200D:
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
  }
  
  return true;
     882:	81 e0       	ldi	r24, 0x01	; 1
     884:	33 c0       	rjmp	.+102    	; 0x8ec <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x126>
  {
    // check for L3GD20H, D20 if device is unidentified or was specified to be one of these types
    if (device == device_auto || device == device_D20H || device == device_D20)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     886:	44 23       	and	r20, r20
     888:	41 f1       	breq	.+80     	; 0x8da <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x114>
     88a:	1e c0       	rjmp	.+60     	; 0x8c8 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x102>
  
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
  {
    // check for L3GD20H, D20 if device is unidentified or was specified to be one of these types
    if (device == device_auto || device == device_D20H || device == device_D20)
     88c:	8f ef       	ldi	r24, 0xFF	; 255
     88e:	86 0f       	add	r24, r22
     890:	83 30       	cpi	r24, 0x03	; 3
     892:	30 f6       	brcc	.-116    	; 0x820 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5a>
     894:	0f c0       	rjmp	.+30     	; 0x8b4 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xee>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
     896:	01 e0       	ldi	r16, 0x01	; 1
     898:	c3 cf       	rjmp	.-122    	; 0x820 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5a>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
     89a:	00 e0       	ldi	r16, 0x00	; 0
     89c:	c1 cf       	rjmp	.-126    	; 0x820 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x5a>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101011; it's a D20H or D20 with SA0 high     
        sa0 = sa0_high;
     89e:	01 e0       	ldi	r16, 0x01	; 1
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     8a0:	12 e0       	ldi	r17, 0x02	; 2
     8a2:	d4 cf       	rjmp	.-88     	; 0x84c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
      {
        // device responds to address 1101010; it's a D20H or D20 with SA0 low      
        sa0 = sa0_low;
     8a4:	00 e0       	ldi	r16, 0x00	; 0
        if (device == device_auto)
        {
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
     8a6:	11 e0       	ldi	r17, 0x01	; 1
     8a8:	d1 cf       	rjmp	.-94     	; 0x84c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x86>
    {
      if (sa0 != sa0_low && testReg(L3G4200D_SA0_HIGH_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
      {
        // device responds to address 1101001; it's a 4200D with SA0 high
        device = device_4200D;
        sa0 = sa0_high;
     8aa:	01 e0       	ldi	r16, 0x01	; 1
     8ac:	01 c0       	rjmp	.+2      	; 0x8b0 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xea>
      }
      else if (sa0 != sa0_high && testReg(L3G4200D_SA0_LOW_ADDRESS, WHO_AM_I) == L3G4200D_WHO_ID)
      {
        // device responds to address 1101000; it's a 4200D with SA0 low
        device = device_4200D;
        sa0 = sa0_low;
     8ae:	00 e0       	ldi	r16, 0x00	; 0
    {
      return false;
    }
  }
  
  _device = device;
     8b0:	1f 82       	std	Y+7, r1	; 0x07
     8b2:	db cf       	rjmp	.-74     	; 0x86a <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0xa4>
  {
    // check for L3GD20H, D20 if device is unidentified or was specified to be one of these types
    if (device == device_auto || device == device_D20H || device == device_D20)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && (id = testReg(D20_SA0_HIGH_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     8b4:	4f e0       	ldi	r20, 0x0F	; 15
     8b6:	6b e6       	ldi	r22, 0x6B	; 107
     8b8:	ce 01       	movw	r24, r28
     8ba:	59 df       	rcall	.-334    	; 0x76e <_ZN3L3G7testRegEhNS_7regAddrE>
     8bc:	8f 3f       	cpi	r24, 0xFF	; 255
     8be:	2f ef       	ldi	r18, 0xFF	; 255
     8c0:	92 07       	cpc	r25, r18
     8c2:	09 f0       	breq	.+2      	; 0x8c6 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x100>
     8c4:	8d cf       	rjmp	.-230    	; 0x7e0 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x1a>
     8c6:	98 cf       	rjmp	.-208    	; 0x7f8 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x32>
     8c8:	4f e0       	ldi	r20, 0x0F	; 15
     8ca:	6b e6       	ldi	r22, 0x6B	; 107
     8cc:	50 df       	rcall	.-352    	; 0x76e <_ZN3L3G7testRegEhNS_7regAddrE>
     8ce:	8f 3f       	cpi	r24, 0xFF	; 255
     8d0:	2f ef       	ldi	r18, 0xFF	; 255
     8d2:	92 07       	cpc	r25, r18
     8d4:	09 f0       	breq	.+2      	; 0x8d8 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x112>
     8d6:	87 cf       	rjmp	.-242    	; 0x7e6 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x20>
     8d8:	8d cf       	rjmp	.-230    	; 0x7f4 <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x2e>
          // use ID from WHO_AM_I register to determine device type
          device = (id == D20H_WHO_ID) ? device_D20H : device_D20;
        }
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && (id = testReg(D20_SA0_LOW_ADDRESS, WHO_AM_I)) != TEST_REG_ERROR)
     8da:	4f e0       	ldi	r20, 0x0F	; 15
     8dc:	6a e6       	ldi	r22, 0x6A	; 106
     8de:	47 df       	rcall	.-370    	; 0x76e <_ZN3L3G7testRegEhNS_7regAddrE>
     8e0:	8f 3f       	cpi	r24, 0xFF	; 255
     8e2:	2f ef       	ldi	r18, 0xFF	; 255
     8e4:	92 07       	cpc	r25, r18
     8e6:	09 f0       	breq	.+2      	; 0x8ea <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x124>
     8e8:	92 cf       	rjmp	.-220    	; 0x80e <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x48>
     8ea:	98 cf       	rjmp	.-208    	; 0x81c <_ZN3L3G4initENS_10deviceTypeENS_8sa0StateE+0x56>
      address = (sa0 == sa0_high) ? L3G4200D_SA0_HIGH_ADDRESS : L3G4200D_SA0_LOW_ADDRESS;
      break;
  }
  
  return true;
}
     8ec:	df 91       	pop	r29
     8ee:	cf 91       	pop	r28
     8f0:	1f 91       	pop	r17
     8f2:	0f 91       	pop	r16
     8f4:	08 95       	ret

000008f6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     8f6:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8f8:	03 96       	adiw	r24, 0x03	; 3
     8fa:	92 83       	std	Z+2, r25	; 0x02
     8fc:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     8fe:	2f ef       	ldi	r18, 0xFF	; 255
     900:	3f ef       	ldi	r19, 0xFF	; 255
     902:	34 83       	std	Z+4, r19	; 0x04
     904:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     906:	96 83       	std	Z+6, r25	; 0x06
     908:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     90a:	90 87       	std	Z+8, r25	; 0x08
     90c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     90e:	10 82       	st	Z, r1
     910:	08 95       	ret

00000912 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     912:	fc 01       	movw	r30, r24
     914:	11 86       	std	Z+9, r1	; 0x09
     916:	10 86       	std	Z+8, r1	; 0x08
     918:	08 95       	ret

0000091a <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     91a:	cf 93       	push	r28
     91c:	df 93       	push	r29
     91e:	9c 01       	movw	r18, r24
     920:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     922:	dc 01       	movw	r26, r24
     924:	11 96       	adiw	r26, 0x01	; 1
     926:	cd 91       	ld	r28, X+
     928:	dc 91       	ld	r29, X
     92a:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     92c:	d3 83       	std	Z+3, r29	; 0x03
     92e:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     930:	8c 81       	ldd	r24, Y+4	; 0x04
     932:	9d 81       	ldd	r25, Y+5	; 0x05
     934:	95 83       	std	Z+5, r25	; 0x05
     936:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     938:	8c 81       	ldd	r24, Y+4	; 0x04
     93a:	9d 81       	ldd	r25, Y+5	; 0x05
     93c:	dc 01       	movw	r26, r24
     93e:	13 96       	adiw	r26, 0x03	; 3
     940:	7c 93       	st	X, r23
     942:	6e 93       	st	-X, r22
     944:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     946:	7d 83       	std	Y+5, r23	; 0x05
     948:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     94a:	31 87       	std	Z+9, r19	; 0x09
     94c:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     94e:	f9 01       	movw	r30, r18
     950:	80 81       	ld	r24, Z
     952:	8f 5f       	subi	r24, 0xFF	; 255
     954:	80 83       	st	Z, r24
}
     956:	df 91       	pop	r29
     958:	cf 91       	pop	r28
     95a:	08 95       	ret

0000095c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     95c:	cf 93       	push	r28
     95e:	df 93       	push	r29
     960:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     962:	48 81       	ld	r20, Y
     964:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     966:	4f 3f       	cpi	r20, 0xFF	; 255
     968:	2f ef       	ldi	r18, 0xFF	; 255
     96a:	52 07       	cpc	r21, r18
     96c:	21 f4       	brne	.+8      	; 0x976 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     96e:	fc 01       	movw	r30, r24
     970:	a7 81       	ldd	r26, Z+7	; 0x07
     972:	b0 85       	ldd	r27, Z+8	; 0x08
     974:	0d c0       	rjmp	.+26     	; 0x990 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     976:	dc 01       	movw	r26, r24
     978:	13 96       	adiw	r26, 0x03	; 3
     97a:	12 96       	adiw	r26, 0x02	; 2
     97c:	ed 91       	ld	r30, X+
     97e:	fc 91       	ld	r31, X
     980:	13 97       	sbiw	r26, 0x03	; 3
     982:	20 81       	ld	r18, Z
     984:	31 81       	ldd	r19, Z+1	; 0x01
     986:	42 17       	cp	r20, r18
     988:	53 07       	cpc	r21, r19
     98a:	10 f0       	brcs	.+4      	; 0x990 <vListInsert+0x34>
     98c:	df 01       	movw	r26, r30
     98e:	f5 cf       	rjmp	.-22     	; 0x97a <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     990:	12 96       	adiw	r26, 0x02	; 2
     992:	ed 91       	ld	r30, X+
     994:	fc 91       	ld	r31, X
     996:	13 97       	sbiw	r26, 0x03	; 3
     998:	fb 83       	std	Y+3, r31	; 0x03
     99a:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     99c:	d5 83       	std	Z+5, r29	; 0x05
     99e:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     9a0:	bd 83       	std	Y+5, r27	; 0x05
     9a2:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     9a4:	13 96       	adiw	r26, 0x03	; 3
     9a6:	dc 93       	st	X, r29
     9a8:	ce 93       	st	-X, r28
     9aa:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     9ac:	99 87       	std	Y+9, r25	; 0x09
     9ae:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     9b0:	fc 01       	movw	r30, r24
     9b2:	20 81       	ld	r18, Z
     9b4:	2f 5f       	subi	r18, 0xFF	; 255
     9b6:	20 83       	st	Z, r18
}
     9b8:	df 91       	pop	r29
     9ba:	cf 91       	pop	r28
     9bc:	08 95       	ret

000009be <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     9be:	cf 93       	push	r28
     9c0:	df 93       	push	r29
     9c2:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     9c4:	a0 85       	ldd	r26, Z+8	; 0x08
     9c6:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     9c8:	c2 81       	ldd	r28, Z+2	; 0x02
     9ca:	d3 81       	ldd	r29, Z+3	; 0x03
     9cc:	84 81       	ldd	r24, Z+4	; 0x04
     9ce:	95 81       	ldd	r25, Z+5	; 0x05
     9d0:	9d 83       	std	Y+5, r25	; 0x05
     9d2:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     9d4:	c4 81       	ldd	r28, Z+4	; 0x04
     9d6:	d5 81       	ldd	r29, Z+5	; 0x05
     9d8:	82 81       	ldd	r24, Z+2	; 0x02
     9da:	93 81       	ldd	r25, Z+3	; 0x03
     9dc:	9b 83       	std	Y+3, r25	; 0x03
     9de:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     9e0:	11 96       	adiw	r26, 0x01	; 1
     9e2:	cd 91       	ld	r28, X+
     9e4:	dc 91       	ld	r29, X
     9e6:	12 97       	sbiw	r26, 0x02	; 2
     9e8:	ce 17       	cp	r28, r30
     9ea:	df 07       	cpc	r29, r31
     9ec:	31 f4       	brne	.+12     	; 0x9fa <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     9ee:	8c 81       	ldd	r24, Y+4	; 0x04
     9f0:	9d 81       	ldd	r25, Y+5	; 0x05
     9f2:	12 96       	adiw	r26, 0x02	; 2
     9f4:	9c 93       	st	X, r25
     9f6:	8e 93       	st	-X, r24
     9f8:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     9fa:	11 86       	std	Z+9, r1	; 0x09
     9fc:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     9fe:	8c 91       	ld	r24, X
     a00:	81 50       	subi	r24, 0x01	; 1
     a02:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     a04:	df 91       	pop	r29
     a06:	cf 91       	pop	r28
     a08:	08 95       	ret

00000a0a <_ZN3LPSC1Ev>:

// converts pressure in inHg to altitude in feet; see notes above
float LPS::pressureToAltitudeFeet(float pressure_inHg, float altimeter_setting_inHg)
{
  return (1 - pow(pressure_inHg / altimeter_setting_inHg, 0.190263)) * 145442;
}
     a0a:	22 e0       	ldi	r18, 0x02	; 2
     a0c:	fc 01       	movw	r30, r24
     a0e:	20 83       	st	Z, r18
     a10:	2d e5       	ldi	r18, 0x5D	; 93
     a12:	21 83       	std	Z+1, r18	; 0x01
     a14:	08 95       	ret

00000a16 <_ZN3LPS8writeRegEih>:
  }
}

// writes register
void LPS::writeReg(int reg, byte value)
{
     a16:	1f 93       	push	r17
     a18:	cf 93       	push	r28
     a1a:	df 93       	push	r29
     a1c:	eb 01       	movw	r28, r22
     a1e:	14 2f       	mov	r17, r20
  // if dummy register address, look up actual translated address (based on device type)
  if (reg < 0)
     a20:	dd 23       	and	r29, r29
     a22:	3c f4       	brge	.+14     	; 0xa32 <_ZN3LPS8writeRegEih+0x1c>
  {
    reg = translated_regs[-reg];
     a24:	fc 01       	movw	r30, r24
     a26:	e6 1b       	sub	r30, r22
     a28:	f7 0b       	sbc	r31, r23
     a2a:	c2 81       	ldd	r28, Z+2	; 0x02
     a2c:	dd 27       	eor	r29, r29
     a2e:	c7 fd       	sbrc	r28, 7
     a30:	d0 95       	com	r29
  }

  Wire.beginTransmission(address);
     a32:	fc 01       	movw	r30, r24
     a34:	61 81       	ldd	r22, Z+1	; 0x01
     a36:	8e ec       	ldi	r24, 0xCE	; 206
     a38:	99 e0       	ldi	r25, 0x09	; 9
     a3a:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <_ZN7TwoWire17beginTransmissionEh>
    void onRequest( void (*)(void) );

    inline size_t write(unsigned long n) { return write((uint8_t)n); }
    inline size_t write(long n) { return write((uint8_t)n); }
    inline size_t write(unsigned int n) { return write((uint8_t)n); }
    inline size_t write(int n) { return write((uint8_t)n); }
     a3e:	e0 91 ce 09 	lds	r30, 0x09CE
     a42:	f0 91 cf 09 	lds	r31, 0x09CF
     a46:	01 90       	ld	r0, Z+
     a48:	f0 81       	ld	r31, Z
     a4a:	e0 2d       	mov	r30, r0
     a4c:	6c 2f       	mov	r22, r28
     a4e:	8e ec       	ldi	r24, 0xCE	; 206
     a50:	99 e0       	ldi	r25, 0x09	; 9
     a52:	19 95       	eicall
  Wire.write(reg);
  Wire.write(value);
     a54:	61 2f       	mov	r22, r17
     a56:	8e ec       	ldi	r24, 0xCE	; 206
     a58:	99 e0       	ldi	r25, 0x09	; 9
     a5a:	0e 94 c2 0e 	call	0x1d84	; 0x1d84 <_ZN7TwoWire5writeEh>
  Wire.endTransmission();
     a5e:	8e ec       	ldi	r24, 0xCE	; 206
     a60:	99 e0       	ldi	r25, 0x09	; 9
     a62:	0e 94 37 0f 	call	0x1e6e	; 0x1e6e <_ZN7TwoWire15endTransmissionEv>
}
     a66:	df 91       	pop	r29
     a68:	cf 91       	pop	r28
     a6a:	1f 91       	pop	r17
     a6c:	08 95       	ret

00000a6e <_ZN3LPS13enableDefaultEv>:
}

// turns on sensor and enables continuous output
void LPS::enableDefault(void)
{
  if (_device == device_25H)
     a6e:	fc 01       	movw	r30, r24
     a70:	20 81       	ld	r18, Z
     a72:	21 30       	cpi	r18, 0x01	; 1
     a74:	29 f4       	brne	.+10     	; 0xa80 <_ZN3LPS13enableDefaultEv+0x12>
  {
    // 0xB0 = 0b10110000
    // PD = 1 (active mode);  ODR = 011 (12.5 Hz pressure & temperature output data rate)
    writeReg(CTRL_REG1, 0xB0);
     a76:	40 eb       	ldi	r20, 0xB0	; 176
     a78:	60 e2       	ldi	r22, 0x20	; 32
     a7a:	70 e0       	ldi	r23, 0x00	; 0
     a7c:	cc cf       	rjmp	.-104    	; 0xa16 <_ZN3LPS8writeRegEih>
     a7e:	08 95       	ret
  }
  else if (_device == device_331AP)
     a80:	21 11       	cpse	r18, r1
     a82:	04 c0       	rjmp	.+8      	; 0xa8c <_ZN3LPS13enableDefaultEv+0x1e>
  {
    // 0xE0 = 0b11100000
    // PD = 1 (active mode);  ODR = 110 (12.5 Hz pressure & temperature output data rate)
    writeReg(CTRL_REG1, 0xE0);
     a84:	40 ee       	ldi	r20, 0xE0	; 224
     a86:	60 e2       	ldi	r22, 0x20	; 32
     a88:	70 e0       	ldi	r23, 0x00	; 0
     a8a:	c5 cf       	rjmp	.-118    	; 0xa16 <_ZN3LPS8writeRegEih>
     a8c:	08 95       	ret

00000a8e <_ZN6LSM303C1Ev>:
// Reads all 6 channels of the LSM303 and stores them in the object variables
void LSM303::read(void)
{
  readAcc();
  readMag();
}
     a8e:	cf 93       	push	r28
     a90:	df 93       	push	r29
     a92:	ec 01       	movw	r28, r24
     a94:	86 e0       	ldi	r24, 0x06	; 6
     a96:	e5 e1       	ldi	r30, 0x15	; 21
     a98:	f2 e0       	ldi	r31, 0x02	; 2
     a9a:	de 01       	movw	r26, r28
     a9c:	52 96       	adiw	r26, 0x12	; 18
     a9e:	01 90       	ld	r0, Z+
     aa0:	0d 92       	st	X+, r0
     aa2:	8a 95       	dec	r24
     aa4:	e1 f7       	brne	.-8      	; 0xa9e <_ZN6LSM303C1Ev+0x10>
     aa6:	86 e0       	ldi	r24, 0x06	; 6
     aa8:	eb e1       	ldi	r30, 0x1B	; 27
     aaa:	f2 e0       	ldi	r31, 0x02	; 2
     aac:	de 01       	movw	r26, r28
     aae:	1c 96       	adiw	r26, 0x0c	; 12
     ab0:	01 90       	ld	r0, Z+
     ab2:	0d 92       	st	X+, r0
     ab4:	8a 95       	dec	r24
     ab6:	e1 f7       	brne	.-8      	; 0xab0 <_ZN6LSM303C1Ev+0x22>
     ab8:	84 e0       	ldi	r24, 0x04	; 4
     aba:	89 8f       	std	Y+25, r24	; 0x19
     abc:	1c a2       	std	Y+36, r1	; 0x24
     abe:	1b a2       	std	Y+35, r1	; 0x23
     ac0:	1d a2       	std	Y+37, r1	; 0x25
     ac2:	df 91       	pop	r29
     ac4:	cf 91       	pop	r28
     ac6:	08 95       	ret

00000ac8 <_ZN6LSM30311writeAccRegEhh>:
     ac8:	0f 93       	push	r16
     aca:	1f 93       	push	r17
     acc:	cf 93       	push	r28
     ace:	df 93       	push	r29
     ad0:	ec 01       	movw	r28, r24
     ad2:	06 2f       	mov	r16, r22
     ad4:	14 2f       	mov	r17, r20
     ad6:	6a 8d       	ldd	r22, Y+26	; 0x1a
     ad8:	8e ec       	ldi	r24, 0xCE	; 206
     ada:	99 e0       	ldi	r25, 0x09	; 9
     adc:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <_ZN7TwoWire17beginTransmissionEh>
     ae0:	60 2f       	mov	r22, r16
     ae2:	8e ec       	ldi	r24, 0xCE	; 206
     ae4:	99 e0       	ldi	r25, 0x09	; 9
     ae6:	0e 94 c2 0e 	call	0x1d84	; 0x1d84 <_ZN7TwoWire5writeEh>
     aea:	61 2f       	mov	r22, r17
     aec:	8e ec       	ldi	r24, 0xCE	; 206
     aee:	99 e0       	ldi	r25, 0x09	; 9
     af0:	0e 94 c2 0e 	call	0x1d84	; 0x1d84 <_ZN7TwoWire5writeEh>
     af4:	8e ec       	ldi	r24, 0xCE	; 206
     af6:	99 e0       	ldi	r25, 0x09	; 9
     af8:	0e 94 37 0f 	call	0x1e6e	; 0x1e6e <_ZN7TwoWire15endTransmissionEv>
     afc:	88 8f       	std	Y+24, r24	; 0x18
     afe:	df 91       	pop	r29
     b00:	cf 91       	pop	r28
     b02:	1f 91       	pop	r17
     b04:	0f 91       	pop	r16
     b06:	08 95       	ret

00000b08 <_ZN6LSM30311writeMagRegEhh>:
     b08:	0f 93       	push	r16
     b0a:	1f 93       	push	r17
     b0c:	cf 93       	push	r28
     b0e:	df 93       	push	r29
     b10:	ec 01       	movw	r28, r24
     b12:	06 2f       	mov	r16, r22
     b14:	14 2f       	mov	r17, r20
     b16:	6b 8d       	ldd	r22, Y+27	; 0x1b
     b18:	8e ec       	ldi	r24, 0xCE	; 206
     b1a:	99 e0       	ldi	r25, 0x09	; 9
     b1c:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <_ZN7TwoWire17beginTransmissionEh>
     b20:	60 2f       	mov	r22, r16
     b22:	8e ec       	ldi	r24, 0xCE	; 206
     b24:	99 e0       	ldi	r25, 0x09	; 9
     b26:	0e 94 c2 0e 	call	0x1d84	; 0x1d84 <_ZN7TwoWire5writeEh>
     b2a:	61 2f       	mov	r22, r17
     b2c:	8e ec       	ldi	r24, 0xCE	; 206
     b2e:	99 e0       	ldi	r25, 0x09	; 9
     b30:	0e 94 c2 0e 	call	0x1d84	; 0x1d84 <_ZN7TwoWire5writeEh>
     b34:	8e ec       	ldi	r24, 0xCE	; 206
     b36:	99 e0       	ldi	r25, 0x09	; 9
     b38:	0e 94 37 0f 	call	0x1e6e	; 0x1e6e <_ZN7TwoWire15endTransmissionEv>
     b3c:	88 8f       	std	Y+24, r24	; 0x18
     b3e:	df 91       	pop	r29
     b40:	cf 91       	pop	r28
     b42:	1f 91       	pop	r17
     b44:	0f 91       	pop	r16
     b46:	08 95       	ret

00000b48 <_ZN6LSM3038writeRegEhh>:
     b48:	fc 01       	movw	r30, r24
     b4a:	21 8d       	ldd	r18, Z+25	; 0x19
     b4c:	23 30       	cpi	r18, 0x03	; 3
     b4e:	11 f0       	breq	.+4      	; 0xb54 <_ZN6LSM3038writeRegEhh+0xc>
     b50:	60 32       	cpi	r22, 0x20	; 32
     b52:	10 f4       	brcc	.+4      	; 0xb58 <_ZN6LSM3038writeRegEhh+0x10>
     b54:	d9 cf       	rjmp	.-78     	; 0xb08 <_ZN6LSM30311writeMagRegEhh>
     b56:	08 95       	ret
     b58:	b7 cf       	rjmp	.-146    	; 0xac8 <_ZN6LSM30311writeAccRegEhh>
     b5a:	08 95       	ret

00000b5c <_ZN6LSM30313enableDefaultEv>:
     b5c:	cf 93       	push	r28
     b5e:	df 93       	push	r29
     b60:	ec 01       	movw	r28, r24
     b62:	89 8d       	ldd	r24, Y+25	; 0x19
     b64:	83 30       	cpi	r24, 0x03	; 3
     b66:	a9 f4       	brne	.+42     	; 0xb92 <_ZN6LSM30313enableDefaultEv+0x36>
     b68:	40 e0       	ldi	r20, 0x00	; 0
     b6a:	61 e2       	ldi	r22, 0x21	; 33
     b6c:	ce 01       	movw	r24, r28
     b6e:	ec df       	rcall	.-40     	; 0xb48 <_ZN6LSM3038writeRegEhh>
     b70:	47 e5       	ldi	r20, 0x57	; 87
     b72:	60 e2       	ldi	r22, 0x20	; 32
     b74:	ce 01       	movw	r24, r28
     b76:	e8 df       	rcall	.-48     	; 0xb48 <_ZN6LSM3038writeRegEhh>
     b78:	44 e6       	ldi	r20, 0x64	; 100
     b7a:	64 e2       	ldi	r22, 0x24	; 36
     b7c:	ce 01       	movw	r24, r28
     b7e:	e4 df       	rcall	.-56     	; 0xb48 <_ZN6LSM3038writeRegEhh>
     b80:	40 e2       	ldi	r20, 0x20	; 32
     b82:	65 e2       	ldi	r22, 0x25	; 37
     b84:	ce 01       	movw	r24, r28
     b86:	e0 df       	rcall	.-64     	; 0xb48 <_ZN6LSM3038writeRegEhh>
     b88:	40 e0       	ldi	r20, 0x00	; 0
     b8a:	66 e2       	ldi	r22, 0x26	; 38
     b8c:	ce 01       	movw	r24, r28
     b8e:	dc df       	rcall	.-72     	; 0xb48 <_ZN6LSM3038writeRegEhh>
     b90:	1f c0       	rjmp	.+62     	; 0xbd0 <_ZN6LSM30313enableDefaultEv+0x74>
     b92:	82 30       	cpi	r24, 0x02	; 2
     b94:	49 f4       	brne	.+18     	; 0xba8 <_ZN6LSM30313enableDefaultEv+0x4c>
     b96:	48 e0       	ldi	r20, 0x08	; 8
     b98:	63 e2       	ldi	r22, 0x23	; 35
     b9a:	ce 01       	movw	r24, r28
     b9c:	95 df       	rcall	.-214    	; 0xac8 <_ZN6LSM30311writeAccRegEhh>
     b9e:	47 e4       	ldi	r20, 0x47	; 71
     ba0:	60 e2       	ldi	r22, 0x20	; 32
     ba2:	ce 01       	movw	r24, r28
     ba4:	91 df       	rcall	.-222    	; 0xac8 <_ZN6LSM30311writeAccRegEhh>
     ba6:	08 c0       	rjmp	.+16     	; 0xbb8 <_ZN6LSM30313enableDefaultEv+0x5c>
     ba8:	40 e0       	ldi	r20, 0x00	; 0
     baa:	63 e2       	ldi	r22, 0x23	; 35
     bac:	ce 01       	movw	r24, r28
     bae:	8c df       	rcall	.-232    	; 0xac8 <_ZN6LSM30311writeAccRegEhh>
     bb0:	47 e2       	ldi	r20, 0x27	; 39
     bb2:	60 e2       	ldi	r22, 0x20	; 32
     bb4:	ce 01       	movw	r24, r28
     bb6:	88 df       	rcall	.-240    	; 0xac8 <_ZN6LSM30311writeAccRegEhh>
     bb8:	4c e0       	ldi	r20, 0x0C	; 12
     bba:	60 e0       	ldi	r22, 0x00	; 0
     bbc:	ce 01       	movw	r24, r28
     bbe:	a4 df       	rcall	.-184    	; 0xb08 <_ZN6LSM30311writeMagRegEhh>
     bc0:	40 e2       	ldi	r20, 0x20	; 32
     bc2:	61 e0       	ldi	r22, 0x01	; 1
     bc4:	ce 01       	movw	r24, r28
     bc6:	a0 df       	rcall	.-192    	; 0xb08 <_ZN6LSM30311writeMagRegEhh>
     bc8:	40 e0       	ldi	r20, 0x00	; 0
     bca:	62 e0       	ldi	r22, 0x02	; 2
     bcc:	ce 01       	movw	r24, r28
     bce:	9c df       	rcall	.-200    	; 0xb08 <_ZN6LSM30311writeMagRegEhh>
     bd0:	df 91       	pop	r29
     bd2:	cf 91       	pop	r28
     bd4:	08 95       	ret

00000bd6 <_ZN6LSM3037testRegEhNS_7regAddrE>:
}

// Private Methods //////////////////////////////////////////////////////////////

int LSM303::testReg(byte address, regAddr reg)
{
     bd6:	cf 93       	push	r28
     bd8:	df 93       	push	r29
     bda:	c6 2f       	mov	r28, r22
     bdc:	d4 2f       	mov	r29, r20
  Wire.beginTransmission(address);
     bde:	8e ec       	ldi	r24, 0xCE	; 206
     be0:	99 e0       	ldi	r25, 0x09	; 9
     be2:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <_ZN7TwoWire17beginTransmissionEh>
  Wire.write((byte)reg);
     be6:	6d 2f       	mov	r22, r29
     be8:	8e ec       	ldi	r24, 0xCE	; 206
     bea:	99 e0       	ldi	r25, 0x09	; 9
     bec:	0e 94 c2 0e 	call	0x1d84	; 0x1d84 <_ZN7TwoWire5writeEh>
  if (Wire.endTransmission() != 0)
     bf0:	8e ec       	ldi	r24, 0xCE	; 206
     bf2:	99 e0       	ldi	r25, 0x09	; 9
     bf4:	0e 94 37 0f 	call	0x1e6e	; 0x1e6e <_ZN7TwoWire15endTransmissionEv>
     bf8:	81 11       	cpse	r24, r1
     bfa:	11 c0       	rjmp	.+34     	; 0xc1e <_ZN6LSM3037testRegEhNS_7regAddrE+0x48>
  {
    return TEST_REG_ERROR;
  }

  Wire.requestFrom(address, (byte)1);
     bfc:	41 e0       	ldi	r20, 0x01	; 1
     bfe:	6c 2f       	mov	r22, r28
     c00:	8e ec       	ldi	r24, 0xCE	; 206
     c02:	99 e0       	ldi	r25, 0x09	; 9
     c04:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <_ZN7TwoWire11requestFromEhh>
  if (Wire.available())
     c08:	8e ec       	ldi	r24, 0xCE	; 206
     c0a:	99 e0       	ldi	r25, 0x09	; 9
     c0c:	0e 94 68 0e 	call	0x1cd0	; 0x1cd0 <_ZN7TwoWire9availableEv>
     c10:	89 2b       	or	r24, r25
     c12:	41 f0       	breq	.+16     	; 0xc24 <_ZN6LSM3037testRegEhNS_7regAddrE+0x4e>
  {
    return Wire.read();
     c14:	8e ec       	ldi	r24, 0xCE	; 206
     c16:	99 e0       	ldi	r25, 0x09	; 9
     c18:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <_ZN7TwoWire4readEv>
     c1c:	05 c0       	rjmp	.+10     	; 0xc28 <_ZN6LSM3037testRegEhNS_7regAddrE+0x52>
{
  Wire.beginTransmission(address);
  Wire.write((byte)reg);
  if (Wire.endTransmission() != 0)
  {
    return TEST_REG_ERROR;
     c1e:	8f ef       	ldi	r24, 0xFF	; 255
     c20:	9f ef       	ldi	r25, 0xFF	; 255
     c22:	02 c0       	rjmp	.+4      	; 0xc28 <_ZN6LSM3037testRegEhNS_7regAddrE+0x52>
  {
    return Wire.read();
  }
  else
  {
    return TEST_REG_ERROR;
     c24:	8f ef       	ldi	r24, 0xFF	; 255
     c26:	9f ef       	ldi	r25, 0xFF	; 255
  }
     c28:	df 91       	pop	r29
     c2a:	cf 91       	pop	r28
     c2c:	08 95       	ret

00000c2e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE>:
{
  return io_timeout;
}

bool LSM303::init(deviceType device, sa0State sa0)
{
     c2e:	0f 93       	push	r16
     c30:	1f 93       	push	r17
     c32:	cf 93       	push	r28
     c34:	df 93       	push	r29
     c36:	ec 01       	movw	r28, r24
     c38:	16 2f       	mov	r17, r22
     c3a:	04 2f       	mov	r16, r20
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
     c3c:	64 30       	cpi	r22, 0x04	; 4
     c3e:	09 f4       	brne	.+2      	; 0xc42 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x14>
     c40:	ad c0       	rjmp	.+346    	; 0xd9c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x16e>
     c42:	42 30       	cpi	r20, 0x02	; 2
     c44:	09 f0       	breq	.+2      	; 0xc48 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1a>
     c46:	47 c0       	rjmp	.+142    	; 0xcd6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
     c48:	ad c0       	rjmp	.+346    	; 0xda4 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x176>
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
     c4a:	4f e0       	ldi	r20, 0x0F	; 15
     c4c:	6d e1       	ldi	r22, 0x1D	; 29
     c4e:	ce 01       	movw	r24, r28
     c50:	c2 df       	rcall	.-124    	; 0xbd6 <_ZN6LSM3037testRegEhNS_7regAddrE>
     c52:	89 34       	cpi	r24, 0x49	; 73
     c54:	91 05       	cpc	r25, r1
     c56:	09 f4       	brne	.+2      	; 0xc5a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x2c>
     c58:	ab c0       	rjmp	.+342    	; 0xdb0 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x182>
        // device responds to address 0011101 with D ID; it's a D with SA0 high
        device = device_D;
        sa0 = sa0_high;
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(D_SA0_LOW_ADDRESS, WHO_AM_I) == D_WHO_ID)
     c5a:	01 30       	cpi	r16, 0x01	; 1
     c5c:	41 f0       	breq	.+16     	; 0xc6e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x40>
     c5e:	4f e0       	ldi	r20, 0x0F	; 15
     c60:	6e e1       	ldi	r22, 0x1E	; 30
     c62:	ce 01       	movw	r24, r28
     c64:	b8 df       	rcall	.-144    	; 0xbd6 <_ZN6LSM3037testRegEhNS_7regAddrE>
     c66:	89 34       	cpi	r24, 0x49	; 73
     c68:	91 05       	cpc	r25, r1
     c6a:	09 f4       	brne	.+2      	; 0xc6e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x40>
     c6c:	a3 c0       	rjmp	.+326    	; 0xdb4 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x186>
        sa0 = sa0_low;
      }
    }
    
    // check for LSM303DLHC, DLM, DLH if device is still unidentified or was specified to be one of these types
    if (device == device_auto || device == device_DLHC || device == device_DLM || device == device_DLH)
     c6e:	14 30       	cpi	r17, 0x04	; 4
     c70:	11 f0       	breq	.+4      	; 0xc76 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x48>
     c72:	13 30       	cpi	r17, 0x03	; 3
     c74:	68 f5       	brcc	.+90     	; 0xcd0 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa2>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
     c76:	00 23       	and	r16, r16
     c78:	a9 f0       	breq	.+42     	; 0xca4 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x76>
     c7a:	40 e2       	ldi	r20, 0x20	; 32
     c7c:	69 e1       	ldi	r22, 0x19	; 25
     c7e:	ce 01       	movw	r24, r28
     c80:	aa df       	rcall	.-172    	; 0xbd6 <_ZN6LSM3037testRegEhNS_7regAddrE>
     c82:	01 96       	adiw	r24, 0x01	; 1
     c84:	69 f0       	breq	.+26     	; 0xca0 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x72>
      {
        // device responds to address 0011001; it's a DLHC, DLM with SA0 high, or DLH with SA0 high
        sa0 = sa0_high;
        if (device == device_auto)
     c86:	14 30       	cpi	r17, 0x04	; 4
     c88:	09 f0       	breq	.+2      	; 0xc8c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x5e>
     c8a:	99 c0       	rjmp	.+306    	; 0xdbe <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x190>
          // DLHC seems to respond to WHO_AM_I request the same way as DLM, even though this
          // register isn't documented in its datasheet. Since the DLHC accelerometer address is the
          // same as the DLM with SA0 high, but Pololu DLM boards pull SA0 low by default, we'll
          // guess that a device whose accelerometer responds to the SA0 high address and whose
          // magnetometer gives the DLM ID is actually a DLHC.
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLHC : device_DLH;
     c8c:	4f e0       	ldi	r20, 0x0F	; 15
     c8e:	6e e1       	ldi	r22, 0x1E	; 30
     c90:	ce 01       	movw	r24, r28
     c92:	a1 df       	rcall	.-190    	; 0xbd6 <_ZN6LSM3037testRegEhNS_7regAddrE>
     c94:	cc 97       	sbiw	r24, 0x3c	; 60
     c96:	09 f0       	breq	.+2      	; 0xc9a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x6c>
     c98:	94 c0       	rjmp	.+296    	; 0xdc2 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x194>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011001; it's a DLHC, DLM with SA0 high, or DLH with SA0 high
        sa0 = sa0_high;
     c9a:	01 e0       	ldi	r16, 0x01	; 1
          // DLHC seems to respond to WHO_AM_I request the same way as DLM, even though this
          // register isn't documented in its datasheet. Since the DLHC accelerometer address is the
          // same as the DLM with SA0 high, but Pololu DLM boards pull SA0 low by default, we'll
          // guess that a device whose accelerometer responds to the SA0 high address and whose
          // magnetometer gives the DLM ID is actually a DLHC.
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLHC : device_DLH;
     c9c:	12 e0       	ldi	r17, 0x02	; 2
     c9e:	1b c0       	rjmp	.+54     	; 0xcd6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
        }
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(DLM_DLH_ACC_SA0_LOW_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
     ca0:	01 30       	cpi	r16, 0x01	; 1
     ca2:	99 f0       	breq	.+38     	; 0xcca <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x9c>
     ca4:	40 e2       	ldi	r20, 0x20	; 32
     ca6:	68 e1       	ldi	r22, 0x18	; 24
     ca8:	ce 01       	movw	r24, r28
     caa:	95 df       	rcall	.-214    	; 0xbd6 <_ZN6LSM3037testRegEhNS_7regAddrE>
     cac:	01 96       	adiw	r24, 0x01	; 1
     cae:	69 f0       	breq	.+26     	; 0xcca <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x9c>
      {
        // device responds to address 0011000; it's a DLM with SA0 low or DLH with SA0 low
        sa0 = sa0_low;
        if (device == device_auto)
     cb0:	14 30       	cpi	r17, 0x04	; 4
     cb2:	09 f0       	breq	.+2      	; 0xcb6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x88>
     cb4:	89 c0       	rjmp	.+274    	; 0xdc8 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x19a>
        {
          // use magnetometer WHO_AM_I register to determine device type
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLM : device_DLH;
     cb6:	4f e0       	ldi	r20, 0x0F	; 15
     cb8:	6e e1       	ldi	r22, 0x1E	; 30
     cba:	ce 01       	movw	r24, r28
     cbc:	8c df       	rcall	.-232    	; 0xbd6 <_ZN6LSM3037testRegEhNS_7regAddrE>
     cbe:	11 e0       	ldi	r17, 0x01	; 1
     cc0:	cc 97       	sbiw	r24, 0x3c	; 60
     cc2:	09 f0       	breq	.+2      	; 0xcc6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x98>
     cc4:	10 e0       	ldi	r17, 0x00	; 0
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(DLM_DLH_ACC_SA0_LOW_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011000; it's a DLM with SA0 low or DLH with SA0 low
        sa0 = sa0_low;
     cc6:	00 e0       	ldi	r16, 0x00	; 0
     cc8:	06 c0       	rjmp	.+12     	; 0xcd6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
        }
      }
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
     cca:	14 30       	cpi	r17, 0x04	; 4
     ccc:	09 f4       	brne	.+2      	; 0xcd0 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa2>
     cce:	60 c0       	rjmp	.+192    	; 0xd90 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x162>
     cd0:	02 30       	cpi	r16, 0x02	; 2
     cd2:	09 f4       	brne	.+2      	; 0xcd6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
     cd4:	5f c0       	rjmp	.+190    	; 0xd94 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x166>
    {
      return false;
    }
  }
  
  _device = device;
     cd6:	19 8f       	std	Y+25, r17	; 0x19
  
  // set device addresses and translated register addresses
  switch (device)
     cd8:	11 30       	cpi	r17, 0x01	; 1
     cda:	71 f1       	breq	.+92     	; 0xd38 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x10a>
     cdc:	08 f4       	brcc	.+2      	; 0xce0 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xb2>
     cde:	42 c0       	rjmp	.+132    	; 0xd64 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x136>
     ce0:	12 30       	cpi	r17, 0x02	; 2
     ce2:	c1 f0       	breq	.+48     	; 0xd14 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xe6>
     ce4:	13 30       	cpi	r17, 0x03	; 3
     ce6:	09 f0       	breq	.+2      	; 0xcea <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xbc>
     ce8:	57 c0       	rjmp	.+174    	; 0xd98 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x16a>
  {
    case device_D:
      acc_address = mag_address = (sa0 == sa0_high) ? D_SA0_HIGH_ADDRESS : D_SA0_LOW_ADDRESS;
     cea:	01 30       	cpi	r16, 0x01	; 1
     cec:	11 f4       	brne	.+4      	; 0xcf2 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xc4>
     cee:	8d e1       	ldi	r24, 0x1D	; 29
     cf0:	01 c0       	rjmp	.+2      	; 0xcf4 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xc6>
     cf2:	8e e1       	ldi	r24, 0x1E	; 30
     cf4:	8b 8f       	std	Y+27, r24	; 0x1b
     cf6:	8a 8f       	std	Y+26, r24	; 0x1a
      translated_regs[-OUT_X_L_M] = D_OUT_X_L_M;
     cf8:	88 e0       	ldi	r24, 0x08	; 8
     cfa:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_X_H_M] = D_OUT_X_H_M;
     cfc:	89 e0       	ldi	r24, 0x09	; 9
     cfe:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_Y_L_M] = D_OUT_Y_L_M;
     d00:	8a e0       	ldi	r24, 0x0A	; 10
     d02:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Y_H_M] = D_OUT_Y_H_M;
     d04:	8b e0       	ldi	r24, 0x0B	; 11
     d06:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Z_L_M] = D_OUT_Z_L_M;
     d08:	8c e0       	ldi	r24, 0x0C	; 12
     d0a:	8a a3       	std	Y+34, r24	; 0x22
      translated_regs[-OUT_Z_H_M] = D_OUT_Z_H_M;
     d0c:	8d e0       	ldi	r24, 0x0D	; 13
     d0e:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
     d10:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_H_M] = D_OUT_X_H_M;
      translated_regs[-OUT_Y_L_M] = D_OUT_Y_L_M;
      translated_regs[-OUT_Y_H_M] = D_OUT_Y_H_M;
      translated_regs[-OUT_Z_L_M] = D_OUT_Z_L_M;
      translated_regs[-OUT_Z_H_M] = D_OUT_Z_H_M;
      break;
     d12:	64 c0       	rjmp	.+200    	; 0xddc <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>

    case device_DLHC:
      acc_address = DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS; // DLHC doesn't have configurable SA0 but uses same acc address as DLM/DLH with SA0 high
     d14:	89 e1       	ldi	r24, 0x19	; 25
     d16:	8a 8f       	std	Y+26, r24	; 0x1a
      mag_address = DLHC_DLM_DLH_MAG_ADDRESS;
     d18:	8e e1       	ldi	r24, 0x1E	; 30
     d1a:	8b 8f       	std	Y+27, r24	; 0x1b
      translated_regs[-OUT_X_H_M] = DLHC_OUT_X_H_M;
     d1c:	83 e0       	ldi	r24, 0x03	; 3
     d1e:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_X_L_M] = DLHC_OUT_X_L_M;
     d20:	84 e0       	ldi	r24, 0x04	; 4
     d22:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_Y_H_M] = DLHC_OUT_Y_H_M;
     d24:	87 e0       	ldi	r24, 0x07	; 7
     d26:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Y_L_M] = DLHC_OUT_Y_L_M;
     d28:	88 e0       	ldi	r24, 0x08	; 8
     d2a:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Z_H_M] = DLHC_OUT_Z_H_M;
     d2c:	85 e0       	ldi	r24, 0x05	; 5
     d2e:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_L_M] = DLHC_OUT_Z_L_M;
     d30:	86 e0       	ldi	r24, 0x06	; 6
     d32:	8a a3       	std	Y+34, r24	; 0x22
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
     d34:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_L_M] = DLHC_OUT_X_L_M;
      translated_regs[-OUT_Y_H_M] = DLHC_OUT_Y_H_M;
      translated_regs[-OUT_Y_L_M] = DLHC_OUT_Y_L_M;
      translated_regs[-OUT_Z_H_M] = DLHC_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLHC_OUT_Z_L_M;
      break;
     d36:	52 c0       	rjmp	.+164    	; 0xddc <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>

    case device_DLM:
      acc_address = (sa0 == sa0_high) ? DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS : DLM_DLH_ACC_SA0_LOW_ADDRESS;
     d38:	01 30       	cpi	r16, 0x01	; 1
     d3a:	11 f4       	brne	.+4      	; 0xd40 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x112>
     d3c:	89 e1       	ldi	r24, 0x19	; 25
     d3e:	01 c0       	rjmp	.+2      	; 0xd42 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x114>
     d40:	88 e1       	ldi	r24, 0x18	; 24
     d42:	8a 8f       	std	Y+26, r24	; 0x1a
      mag_address = DLHC_DLM_DLH_MAG_ADDRESS;
     d44:	8e e1       	ldi	r24, 0x1E	; 30
     d46:	8b 8f       	std	Y+27, r24	; 0x1b
      translated_regs[-OUT_X_H_M] = DLM_OUT_X_H_M;
     d48:	83 e0       	ldi	r24, 0x03	; 3
     d4a:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_X_L_M] = DLM_OUT_X_L_M;
     d4c:	84 e0       	ldi	r24, 0x04	; 4
     d4e:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_Y_H_M] = DLM_OUT_Y_H_M;
     d50:	87 e0       	ldi	r24, 0x07	; 7
     d52:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Y_L_M] = DLM_OUT_Y_L_M;
     d54:	88 e0       	ldi	r24, 0x08	; 8
     d56:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Z_H_M] = DLM_OUT_Z_H_M;
     d58:	85 e0       	ldi	r24, 0x05	; 5
     d5a:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_L_M] = DLM_OUT_Z_L_M;
     d5c:	86 e0       	ldi	r24, 0x06	; 6
     d5e:	8a a3       	std	Y+34, r24	; 0x22
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
     d60:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_L_M] = DLM_OUT_X_L_M;
      translated_regs[-OUT_Y_H_M] = DLM_OUT_Y_H_M;
      translated_regs[-OUT_Y_L_M] = DLM_OUT_Y_L_M;
      translated_regs[-OUT_Z_H_M] = DLM_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLM_OUT_Z_L_M;
      break;
     d62:	3c c0       	rjmp	.+120    	; 0xddc <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>

    case device_DLH:
      acc_address = (sa0 == sa0_high) ? DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS : DLM_DLH_ACC_SA0_LOW_ADDRESS;
     d64:	01 30       	cpi	r16, 0x01	; 1
     d66:	11 f4       	brne	.+4      	; 0xd6c <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x13e>
     d68:	89 e1       	ldi	r24, 0x19	; 25
     d6a:	01 c0       	rjmp	.+2      	; 0xd6e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x140>
     d6c:	88 e1       	ldi	r24, 0x18	; 24
     d6e:	8a 8f       	std	Y+26, r24	; 0x1a
      mag_address = DLHC_DLM_DLH_MAG_ADDRESS;
     d70:	8e e1       	ldi	r24, 0x1E	; 30
     d72:	8b 8f       	std	Y+27, r24	; 0x1b
      translated_regs[-OUT_X_H_M] = DLH_OUT_X_H_M;
     d74:	83 e0       	ldi	r24, 0x03	; 3
     d76:	8d 8f       	std	Y+29, r24	; 0x1d
      translated_regs[-OUT_X_L_M] = DLH_OUT_X_L_M;
     d78:	84 e0       	ldi	r24, 0x04	; 4
     d7a:	8e 8f       	std	Y+30, r24	; 0x1e
      translated_regs[-OUT_Y_H_M] = DLH_OUT_Y_H_M;
     d7c:	85 e0       	ldi	r24, 0x05	; 5
     d7e:	8f 8f       	std	Y+31, r24	; 0x1f
      translated_regs[-OUT_Y_L_M] = DLH_OUT_Y_L_M;
     d80:	86 e0       	ldi	r24, 0x06	; 6
     d82:	88 a3       	std	Y+32, r24	; 0x20
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
     d84:	87 e0       	ldi	r24, 0x07	; 7
     d86:	89 a3       	std	Y+33, r24	; 0x21
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
     d88:	88 e0       	ldi	r24, 0x08	; 8
     d8a:	8a a3       	std	Y+34, r24	; 0x22
      break;
  }
  
  return true;
     d8c:	81 e0       	ldi	r24, 0x01	; 1
      translated_regs[-OUT_X_L_M] = DLH_OUT_X_L_M;
      translated_regs[-OUT_Y_H_M] = DLH_OUT_Y_H_M;
      translated_regs[-OUT_Y_L_M] = DLH_OUT_Y_L_M;
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
     d8e:	26 c0       	rjmp	.+76     	; 0xddc <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
    }
    
    // make sure device and SA0 were successfully detected; otherwise, indicate failure
    if (device == device_auto || sa0 == sa0_auto)
    {
      return false;
     d90:	80 e0       	ldi	r24, 0x00	; 0
     d92:	24 c0       	rjmp	.+72     	; 0xddc <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
     d94:	80 e0       	ldi	r24, 0x00	; 0
     d96:	22 c0       	rjmp	.+68     	; 0xddc <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
      translated_regs[-OUT_Z_H_M] = DLH_OUT_Z_H_M;
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
     d98:	81 e0       	ldi	r24, 0x01	; 1
     d9a:	20 c0       	rjmp	.+64     	; 0xddc <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1ae>
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
     d9c:	44 23       	and	r20, r20
     d9e:	09 f4       	brne	.+2      	; 0xda2 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x174>
     da0:	5e cf       	rjmp	.-324    	; 0xc5e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x30>
     da2:	53 cf       	rjmp	.-346    	; 0xc4a <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x1c>
{
  // perform auto-detection unless device type and SA0 state were both specified
  if (device == device_auto || sa0 == sa0_auto)
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
     da4:	8d ef       	ldi	r24, 0xFD	; 253
     da6:	86 0f       	add	r24, r22
     da8:	82 30       	cpi	r24, 0x02	; 2
     daa:	08 f0       	brcs	.+2      	; 0xdae <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x180>
     dac:	62 cf       	rjmp	.-316    	; 0xc72 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x44>
     dae:	0e c0       	rjmp	.+28     	; 0xdcc <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x19e>
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
      {
        // device responds to address 0011101 with D ID; it's a D with SA0 high
        device = device_D;
        sa0 = sa0_high;
     db0:	01 e0       	ldi	r16, 0x01	; 1
     db2:	03 c0       	rjmp	.+6      	; 0xdba <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x18c>
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(D_SA0_LOW_ADDRESS, WHO_AM_I) == D_WHO_ID)
      {
        // device responds to address 0011110 with D ID; it's a D with SA0 low
        device = device_D;
        sa0 = sa0_low;
     db4:	00 e0       	ldi	r16, 0x00	; 0
     db6:	01 c0       	rjmp	.+2      	; 0xdba <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x18c>
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
      {
        // device responds to address 0011101 with D ID; it's a D with SA0 high
        device = device_D;
        sa0 = sa0_high;
     db8:	01 e0       	ldi	r16, 0x01	; 1
     dba:	13 e0       	ldi	r17, 0x03	; 3
     dbc:	89 cf       	rjmp	.-238    	; 0xcd0 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa2>
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(DLHC_DLM_DLH_ACC_SA0_HIGH_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011001; it's a DLHC, DLM with SA0 high, or DLH with SA0 high
        sa0 = sa0_high;
     dbe:	01 e0       	ldi	r16, 0x01	; 1
     dc0:	8a cf       	rjmp	.-236    	; 0xcd6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
     dc2:	01 e0       	ldi	r16, 0x01	; 1
          // DLHC seems to respond to WHO_AM_I request the same way as DLM, even though this
          // register isn't documented in its datasheet. Since the DLHC accelerometer address is the
          // same as the DLM with SA0 high, but Pololu DLM boards pull SA0 low by default, we'll
          // guess that a device whose accelerometer responds to the SA0 high address and whose
          // magnetometer gives the DLM ID is actually a DLHC.
          device = (testReg(DLHC_DLM_DLH_MAG_ADDRESS, WHO_AM_I_M) == DLM_WHO_ID) ? device_DLHC : device_DLH;
     dc4:	10 e0       	ldi	r17, 0x00	; 0
     dc6:	87 cf       	rjmp	.-242    	; 0xcd6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
      }
      // check SA0 low address unless SA0 was specified to be high
      else if (sa0 != sa0_high && testReg(DLM_DLH_ACC_SA0_LOW_ADDRESS, CTRL_REG1_A) != TEST_REG_ERROR)
      {
        // device responds to address 0011000; it's a DLM with SA0 low or DLH with SA0 low
        sa0 = sa0_low;
     dc8:	00 e0       	ldi	r16, 0x00	; 0
     dca:	85 cf       	rjmp	.-246    	; 0xcd6 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0xa8>
  {
    // check for LSM303D if device is unidentified or was specified to be this type
    if (device == device_auto || device == device_D)
    {
      // check SA0 high address unless SA0 was specified to be low
      if (sa0 != sa0_low && testReg(D_SA0_HIGH_ADDRESS, WHO_AM_I) == D_WHO_ID)
     dcc:	4f e0       	ldi	r20, 0x0F	; 15
     dce:	6d e1       	ldi	r22, 0x1D	; 29
     dd0:	ce 01       	movw	r24, r28
     dd2:	01 df       	rcall	.-510    	; 0xbd6 <_ZN6LSM3037testRegEhNS_7regAddrE>
     dd4:	89 34       	cpi	r24, 0x49	; 73
     dd6:	91 05       	cpc	r25, r1
     dd8:	79 f3       	breq	.-34     	; 0xdb8 <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x18a>
     dda:	41 cf       	rjmp	.-382    	; 0xc5e <_ZN6LSM3034initENS_10deviceTypeENS_8sa0StateE+0x30>
      translated_regs[-OUT_Z_L_M] = DLH_OUT_Z_L_M;
      break;
  }
  
  return true;
}
     ddc:	df 91       	pop	r29
     dde:	cf 91       	pop	r28
     de0:	1f 91       	pop	r17
     de2:	0f 91       	pop	r16
     de4:	08 95       	ret

00000de6 <_ZN7NewPingC1Ehhi>:
	TIMSK4 = (1<<TOIE4); // Enable Timer4 interrupt.
//#else
	//OCR2A = 249;           // Every count is 4uS, so 1ms = 250 counts - 1.
	//TIMSK2 |= (1<<OCIE2A); // Enable Timer2 interrupt.
//#endif
}
     de6:	cf 93       	push	r28
     de8:	df 93       	push	r29
     dea:	dc 01       	movw	r26, r24
     dec:	70 e0       	ldi	r23, 0x00	; 0
     dee:	fb 01       	movw	r30, r22
     df0:	e0 52       	subi	r30, 0x20	; 32
     df2:	fd 4f       	sbci	r31, 0xFD	; 253
     df4:	e4 91       	lpm	r30, Z
     df6:	14 96       	adiw	r26, 0x04	; 4
     df8:	ec 93       	st	X, r30
     dfa:	14 97       	sbiw	r26, 0x04	; 4
     dfc:	50 e0       	ldi	r21, 0x00	; 0
     dfe:	fa 01       	movw	r30, r20
     e00:	e0 52       	subi	r30, 0x20	; 32
     e02:	fd 4f       	sbci	r31, 0xFD	; 253
     e04:	e4 91       	lpm	r30, Z
     e06:	15 96       	adiw	r26, 0x05	; 5
     e08:	ec 93       	st	X, r30
     e0a:	15 97       	sbiw	r26, 0x05	; 5
     e0c:	6a 5d       	subi	r22, 0xDA	; 218
     e0e:	7c 4f       	sbci	r23, 0xFC	; 252
     e10:	fb 01       	movw	r30, r22
     e12:	84 91       	lpm	r24, Z
     e14:	90 e0       	ldi	r25, 0x00	; 0
     e16:	88 0f       	add	r24, r24
     e18:	99 1f       	adc	r25, r25
     e1a:	8a 57       	subi	r24, 0x7A	; 122
     e1c:	9c 4f       	sbci	r25, 0xFC	; 252
     e1e:	fc 01       	movw	r30, r24
     e20:	c5 91       	lpm	r28, Z+
     e22:	d4 91       	lpm	r29, Z
     e24:	17 96       	adiw	r26, 0x07	; 7
     e26:	dc 93       	st	X, r29
     e28:	ce 93       	st	-X, r28
     e2a:	16 97       	sbiw	r26, 0x06	; 6
     e2c:	fa 01       	movw	r30, r20
     e2e:	ea 5d       	subi	r30, 0xDA	; 218
     e30:	fc 4f       	sbci	r31, 0xFC	; 252
     e32:	84 91       	lpm	r24, Z
     e34:	90 e0       	ldi	r25, 0x00	; 0
     e36:	88 0f       	add	r24, r24
     e38:	99 1f       	adc	r25, r25
     e3a:	84 59       	subi	r24, 0x94	; 148
     e3c:	9c 4f       	sbci	r25, 0xFC	; 252
     e3e:	fc 01       	movw	r30, r24
     e40:	45 91       	lpm	r20, Z+
     e42:	54 91       	lpm	r21, Z
     e44:	1b 96       	adiw	r26, 0x0b	; 11
     e46:	5c 93       	st	X, r21
     e48:	4e 93       	st	-X, r20
     e4a:	1a 97       	sbiw	r26, 0x0a	; 10
     e4c:	fb 01       	movw	r30, r22
     e4e:	64 91       	lpm	r22, Z
     e50:	e6 2f       	mov	r30, r22
     e52:	f0 e0       	ldi	r31, 0x00	; 0
     e54:	ee 0f       	add	r30, r30
     e56:	ff 1f       	adc	r31, r31
     e58:	e0 56       	subi	r30, 0x60	; 96
     e5a:	fc 4f       	sbci	r31, 0xFC	; 252
     e5c:	85 91       	lpm	r24, Z+
     e5e:	94 91       	lpm	r25, Z
     e60:	19 96       	adiw	r26, 0x09	; 9
     e62:	9c 93       	st	X, r25
     e64:	8e 93       	st	-X, r24
     e66:	18 97       	sbiw	r26, 0x08	; 8
     e68:	82 2f       	mov	r24, r18
     e6a:	93 2f       	mov	r25, r19
     e6c:	85 3f       	cpi	r24, 0xF5	; 245
     e6e:	f1 e0       	ldi	r31, 0x01	; 1
     e70:	9f 07       	cpc	r25, r31
     e72:	14 f0       	brlt	.+4      	; 0xe78 <_ZN7NewPingC1Ehhi+0x92>
     e74:	84 ef       	ldi	r24, 0xF4	; 244
     e76:	91 e0       	ldi	r25, 0x01	; 1
     e78:	49 e3       	ldi	r20, 0x39	; 57
     e7a:	48 9f       	mul	r20, r24
     e7c:	90 01       	movw	r18, r0
     e7e:	49 9f       	mul	r20, r25
     e80:	30 0d       	add	r19, r0
     e82:	11 24       	eor	r1, r1
     e84:	c9 01       	movw	r24, r18
     e86:	4c 96       	adiw	r24, 0x1c	; 28
     e88:	1d 96       	adiw	r26, 0x0d	; 13
     e8a:	9c 93       	st	X, r25
     e8c:	8e 93       	st	-X, r24
     e8e:	1c 97       	sbiw	r26, 0x0c	; 12
     e90:	df 91       	pop	r29
     e92:	cf 91       	pop	r28
     e94:	08 95       	ret

00000e96 <__vector_45>:
	}
}


//#if defined (__AVR_ATmega32U4__) // Use Timer4 for ATmega32U4 (Teensy/Leonardo).
ISR(TIMER4_OVF_vect) {
     e96:	1f 92       	push	r1
     e98:	0f 92       	push	r0
     e9a:	0f b6       	in	r0, 0x3f	; 63
     e9c:	0f 92       	push	r0
     e9e:	11 24       	eor	r1, r1
     ea0:	0b b6       	in	r0, 0x3b	; 59
     ea2:	0f 92       	push	r0
     ea4:	2f 93       	push	r18
     ea6:	3f 93       	push	r19
     ea8:	4f 93       	push	r20
     eaa:	5f 93       	push	r21
     eac:	6f 93       	push	r22
     eae:	7f 93       	push	r23
     eb0:	8f 93       	push	r24
     eb2:	9f 93       	push	r25
     eb4:	af 93       	push	r26
     eb6:	bf 93       	push	r27
     eb8:	ef 93       	push	r30
     eba:	ff 93       	push	r31
//#else
//ISR(TIMER2_COMPA_vect) {
//#endif
	if(intFunc) intFunc(); // If wrapped function is set, call it.
     ebc:	e0 91 05 09 	lds	r30, 0x0905
     ec0:	f0 91 06 09 	lds	r31, 0x0906
     ec4:	30 97       	sbiw	r30, 0x00	; 0
     ec6:	09 f0       	breq	.+2      	; 0xeca <__vector_45+0x34>
     ec8:	19 95       	eicall
}
     eca:	ff 91       	pop	r31
     ecc:	ef 91       	pop	r30
     ece:	bf 91       	pop	r27
     ed0:	af 91       	pop	r26
     ed2:	9f 91       	pop	r25
     ed4:	8f 91       	pop	r24
     ed6:	7f 91       	pop	r23
     ed8:	6f 91       	pop	r22
     eda:	5f 91       	pop	r21
     edc:	4f 91       	pop	r20
     ede:	3f 91       	pop	r19
     ee0:	2f 91       	pop	r18
     ee2:	0f 90       	pop	r0
     ee4:	0b be       	out	0x3b, r0	; 59
     ee6:	0f 90       	pop	r0
     ee8:	0f be       	out	0x3f, r0	; 63
     eea:	0f 90       	pop	r0
     eec:	1f 90       	pop	r1
     eee:	18 95       	reti

00000ef0 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     ef0:	31 e1       	ldi	r19, 0x11	; 17
     ef2:	fc 01       	movw	r30, r24
     ef4:	30 83       	st	Z, r19
     ef6:	31 97       	sbiw	r30, 0x01	; 1
     ef8:	22 e2       	ldi	r18, 0x22	; 34
     efa:	20 83       	st	Z, r18
     efc:	31 97       	sbiw	r30, 0x01	; 1
     efe:	a3 e3       	ldi	r26, 0x33	; 51
     f00:	a0 83       	st	Z, r26
     f02:	31 97       	sbiw	r30, 0x01	; 1
     f04:	60 83       	st	Z, r22
     f06:	31 97       	sbiw	r30, 0x01	; 1
     f08:	70 83       	st	Z, r23
     f0a:	31 97       	sbiw	r30, 0x01	; 1
     f0c:	10 82       	st	Z, r1
     f0e:	31 97       	sbiw	r30, 0x01	; 1
     f10:	10 82       	st	Z, r1
     f12:	31 97       	sbiw	r30, 0x01	; 1
     f14:	60 e8       	ldi	r22, 0x80	; 128
     f16:	60 83       	st	Z, r22
     f18:	31 97       	sbiw	r30, 0x01	; 1
     f1a:	10 82       	st	Z, r1
     f1c:	31 97       	sbiw	r30, 0x01	; 1
     f1e:	10 82       	st	Z, r1
     f20:	31 97       	sbiw	r30, 0x01	; 1
     f22:	10 82       	st	Z, r1
     f24:	31 97       	sbiw	r30, 0x01	; 1
     f26:	62 e0       	ldi	r22, 0x02	; 2
     f28:	60 83       	st	Z, r22
     f2a:	31 97       	sbiw	r30, 0x01	; 1
     f2c:	63 e0       	ldi	r22, 0x03	; 3
     f2e:	60 83       	st	Z, r22
     f30:	31 97       	sbiw	r30, 0x01	; 1
     f32:	64 e0       	ldi	r22, 0x04	; 4
     f34:	60 83       	st	Z, r22
     f36:	31 97       	sbiw	r30, 0x01	; 1
     f38:	65 e0       	ldi	r22, 0x05	; 5
     f3a:	60 83       	st	Z, r22
     f3c:	31 97       	sbiw	r30, 0x01	; 1
     f3e:	66 e0       	ldi	r22, 0x06	; 6
     f40:	60 83       	st	Z, r22
     f42:	31 97       	sbiw	r30, 0x01	; 1
     f44:	67 e0       	ldi	r22, 0x07	; 7
     f46:	60 83       	st	Z, r22
     f48:	31 97       	sbiw	r30, 0x01	; 1
     f4a:	68 e0       	ldi	r22, 0x08	; 8
     f4c:	60 83       	st	Z, r22
     f4e:	31 97       	sbiw	r30, 0x01	; 1
     f50:	69 e0       	ldi	r22, 0x09	; 9
     f52:	60 83       	st	Z, r22
     f54:	31 97       	sbiw	r30, 0x01	; 1
     f56:	60 e1       	ldi	r22, 0x10	; 16
     f58:	60 83       	st	Z, r22
     f5a:	31 97       	sbiw	r30, 0x01	; 1
     f5c:	30 83       	st	Z, r19
     f5e:	31 97       	sbiw	r30, 0x01	; 1
     f60:	32 e1       	ldi	r19, 0x12	; 18
     f62:	30 83       	st	Z, r19
     f64:	31 97       	sbiw	r30, 0x01	; 1
     f66:	33 e1       	ldi	r19, 0x13	; 19
     f68:	30 83       	st	Z, r19
     f6a:	31 97       	sbiw	r30, 0x01	; 1
     f6c:	34 e1       	ldi	r19, 0x14	; 20
     f6e:	30 83       	st	Z, r19
     f70:	31 97       	sbiw	r30, 0x01	; 1
     f72:	35 e1       	ldi	r19, 0x15	; 21
     f74:	30 83       	st	Z, r19
     f76:	31 97       	sbiw	r30, 0x01	; 1
     f78:	36 e1       	ldi	r19, 0x16	; 22
     f7a:	30 83       	st	Z, r19
     f7c:	31 97       	sbiw	r30, 0x01	; 1
     f7e:	37 e1       	ldi	r19, 0x17	; 23
     f80:	30 83       	st	Z, r19
     f82:	31 97       	sbiw	r30, 0x01	; 1
     f84:	38 e1       	ldi	r19, 0x18	; 24
     f86:	30 83       	st	Z, r19
     f88:	31 97       	sbiw	r30, 0x01	; 1
     f8a:	39 e1       	ldi	r19, 0x19	; 25
     f8c:	30 83       	st	Z, r19
     f8e:	31 97       	sbiw	r30, 0x01	; 1
     f90:	30 e2       	ldi	r19, 0x20	; 32
     f92:	30 83       	st	Z, r19
     f94:	31 97       	sbiw	r30, 0x01	; 1
     f96:	31 e2       	ldi	r19, 0x21	; 33
     f98:	30 83       	st	Z, r19
     f9a:	31 97       	sbiw	r30, 0x01	; 1
     f9c:	20 83       	st	Z, r18
     f9e:	31 97       	sbiw	r30, 0x01	; 1
     fa0:	23 e2       	ldi	r18, 0x23	; 35
     fa2:	20 83       	st	Z, r18
     fa4:	31 97       	sbiw	r30, 0x01	; 1
     fa6:	40 83       	st	Z, r20
     fa8:	31 97       	sbiw	r30, 0x01	; 1
     faa:	50 83       	st	Z, r21
     fac:	31 97       	sbiw	r30, 0x01	; 1
     fae:	26 e2       	ldi	r18, 0x26	; 38
     fb0:	20 83       	st	Z, r18
     fb2:	31 97       	sbiw	r30, 0x01	; 1
     fb4:	27 e2       	ldi	r18, 0x27	; 39
     fb6:	20 83       	st	Z, r18
     fb8:	31 97       	sbiw	r30, 0x01	; 1
     fba:	28 e2       	ldi	r18, 0x28	; 40
     fbc:	20 83       	st	Z, r18
     fbe:	31 97       	sbiw	r30, 0x01	; 1
     fc0:	29 e2       	ldi	r18, 0x29	; 41
     fc2:	20 83       	st	Z, r18
     fc4:	31 97       	sbiw	r30, 0x01	; 1
     fc6:	20 e3       	ldi	r18, 0x30	; 48
     fc8:	20 83       	st	Z, r18
     fca:	31 97       	sbiw	r30, 0x01	; 1
     fcc:	21 e3       	ldi	r18, 0x31	; 49
     fce:	20 83       	st	Z, r18
     fd0:	89 97       	sbiw	r24, 0x29	; 41
     fd2:	08 95       	ret

00000fd4 <xPortStartScheduler>:
     fd4:	82 e0       	ldi	r24, 0x02	; 2
     fd6:	80 93 b0 00 	sts	0x00B0, r24
     fda:	10 92 b2 00 	sts	0x00B2, r1
     fde:	80 e3       	ldi	r24, 0x30	; 48
     fe0:	80 93 b3 00 	sts	0x00B3, r24
     fe4:	e0 e7       	ldi	r30, 0x70	; 112
     fe6:	f0 e0       	ldi	r31, 0x00	; 0
     fe8:	80 81       	ld	r24, Z
     fea:	82 60       	ori	r24, 0x02	; 2
     fec:	80 83       	st	Z, r24
     fee:	83 e0       	ldi	r24, 0x03	; 3
     ff0:	80 93 b1 00 	sts	0x00B1, r24
     ff4:	a0 91 5e 09 	lds	r26, 0x095E
     ff8:	b0 91 5f 09 	lds	r27, 0x095F
     ffc:	cd 91       	ld	r28, X+
     ffe:	cd bf       	out	0x3d, r28	; 61
    1000:	dd 91       	ld	r29, X+
    1002:	de bf       	out	0x3e, r29	; 62
    1004:	ff 91       	pop	r31
    1006:	ef 91       	pop	r30
    1008:	df 91       	pop	r29
    100a:	cf 91       	pop	r28
    100c:	bf 91       	pop	r27
    100e:	af 91       	pop	r26
    1010:	9f 91       	pop	r25
    1012:	8f 91       	pop	r24
    1014:	7f 91       	pop	r23
    1016:	6f 91       	pop	r22
    1018:	5f 91       	pop	r21
    101a:	4f 91       	pop	r20
    101c:	3f 91       	pop	r19
    101e:	2f 91       	pop	r18
    1020:	1f 91       	pop	r17
    1022:	0f 91       	pop	r16
    1024:	ff 90       	pop	r15
    1026:	ef 90       	pop	r14
    1028:	df 90       	pop	r13
    102a:	cf 90       	pop	r12
    102c:	bf 90       	pop	r11
    102e:	af 90       	pop	r10
    1030:	9f 90       	pop	r9
    1032:	8f 90       	pop	r8
    1034:	7f 90       	pop	r7
    1036:	6f 90       	pop	r6
    1038:	5f 90       	pop	r5
    103a:	4f 90       	pop	r4
    103c:	3f 90       	pop	r3
    103e:	2f 90       	pop	r2
    1040:	1f 90       	pop	r1
    1042:	0f 90       	pop	r0
    1044:	0c be       	out	0x3c, r0	; 60
    1046:	0f 90       	pop	r0
    1048:	0b be       	out	0x3b, r0	; 59
    104a:	0f 90       	pop	r0
    104c:	0f be       	out	0x3f, r0	; 63
    104e:	0f 90       	pop	r0
    1050:	08 95       	ret
    1052:	81 e0       	ldi	r24, 0x01	; 1
    1054:	08 95       	ret

00001056 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1056:	0f 92       	push	r0
    1058:	0f b6       	in	r0, 0x3f	; 63
    105a:	f8 94       	cli
    105c:	0f 92       	push	r0
    105e:	0b b6       	in	r0, 0x3b	; 59
    1060:	0f 92       	push	r0
    1062:	0c b6       	in	r0, 0x3c	; 60
    1064:	0f 92       	push	r0
    1066:	1f 92       	push	r1
    1068:	11 24       	eor	r1, r1
    106a:	2f 92       	push	r2
    106c:	3f 92       	push	r3
    106e:	4f 92       	push	r4
    1070:	5f 92       	push	r5
    1072:	6f 92       	push	r6
    1074:	7f 92       	push	r7
    1076:	8f 92       	push	r8
    1078:	9f 92       	push	r9
    107a:	af 92       	push	r10
    107c:	bf 92       	push	r11
    107e:	cf 92       	push	r12
    1080:	df 92       	push	r13
    1082:	ef 92       	push	r14
    1084:	ff 92       	push	r15
    1086:	0f 93       	push	r16
    1088:	1f 93       	push	r17
    108a:	2f 93       	push	r18
    108c:	3f 93       	push	r19
    108e:	4f 93       	push	r20
    1090:	5f 93       	push	r21
    1092:	6f 93       	push	r22
    1094:	7f 93       	push	r23
    1096:	8f 93       	push	r24
    1098:	9f 93       	push	r25
    109a:	af 93       	push	r26
    109c:	bf 93       	push	r27
    109e:	cf 93       	push	r28
    10a0:	df 93       	push	r29
    10a2:	ef 93       	push	r30
    10a4:	ff 93       	push	r31
    10a6:	a0 91 5e 09 	lds	r26, 0x095E
    10aa:	b0 91 5f 09 	lds	r27, 0x095F
    10ae:	0d b6       	in	r0, 0x3d	; 61
    10b0:	0d 92       	st	X+, r0
    10b2:	0e b6       	in	r0, 0x3e	; 62
    10b4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    10b6:	9c d3       	rcall	.+1848   	; 0x17f0 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    10b8:	a0 91 5e 09 	lds	r26, 0x095E
    10bc:	b0 91 5f 09 	lds	r27, 0x095F
    10c0:	cd 91       	ld	r28, X+
    10c2:	cd bf       	out	0x3d, r28	; 61
    10c4:	dd 91       	ld	r29, X+
    10c6:	de bf       	out	0x3e, r29	; 62
    10c8:	ff 91       	pop	r31
    10ca:	ef 91       	pop	r30
    10cc:	df 91       	pop	r29
    10ce:	cf 91       	pop	r28
    10d0:	bf 91       	pop	r27
    10d2:	af 91       	pop	r26
    10d4:	9f 91       	pop	r25
    10d6:	8f 91       	pop	r24
    10d8:	7f 91       	pop	r23
    10da:	6f 91       	pop	r22
    10dc:	5f 91       	pop	r21
    10de:	4f 91       	pop	r20
    10e0:	3f 91       	pop	r19
    10e2:	2f 91       	pop	r18
    10e4:	1f 91       	pop	r17
    10e6:	0f 91       	pop	r16
    10e8:	ff 90       	pop	r15
    10ea:	ef 90       	pop	r14
    10ec:	df 90       	pop	r13
    10ee:	cf 90       	pop	r12
    10f0:	bf 90       	pop	r11
    10f2:	af 90       	pop	r10
    10f4:	9f 90       	pop	r9
    10f6:	8f 90       	pop	r8
    10f8:	7f 90       	pop	r7
    10fa:	6f 90       	pop	r6
    10fc:	5f 90       	pop	r5
    10fe:	4f 90       	pop	r4
    1100:	3f 90       	pop	r3
    1102:	2f 90       	pop	r2
    1104:	1f 90       	pop	r1
    1106:	0f 90       	pop	r0
    1108:	0c be       	out	0x3c, r0	; 60
    110a:	0f 90       	pop	r0
    110c:	0b be       	out	0x3b, r0	; 59
    110e:	0f 90       	pop	r0
    1110:	0f be       	out	0x3f, r0	; 63
    1112:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1114:	08 95       	ret

00001116 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1116:	0f 92       	push	r0
    1118:	0f b6       	in	r0, 0x3f	; 63
    111a:	f8 94       	cli
    111c:	0f 92       	push	r0
    111e:	0b b6       	in	r0, 0x3b	; 59
    1120:	0f 92       	push	r0
    1122:	0c b6       	in	r0, 0x3c	; 60
    1124:	0f 92       	push	r0
    1126:	1f 92       	push	r1
    1128:	11 24       	eor	r1, r1
    112a:	2f 92       	push	r2
    112c:	3f 92       	push	r3
    112e:	4f 92       	push	r4
    1130:	5f 92       	push	r5
    1132:	6f 92       	push	r6
    1134:	7f 92       	push	r7
    1136:	8f 92       	push	r8
    1138:	9f 92       	push	r9
    113a:	af 92       	push	r10
    113c:	bf 92       	push	r11
    113e:	cf 92       	push	r12
    1140:	df 92       	push	r13
    1142:	ef 92       	push	r14
    1144:	ff 92       	push	r15
    1146:	0f 93       	push	r16
    1148:	1f 93       	push	r17
    114a:	2f 93       	push	r18
    114c:	3f 93       	push	r19
    114e:	4f 93       	push	r20
    1150:	5f 93       	push	r21
    1152:	6f 93       	push	r22
    1154:	7f 93       	push	r23
    1156:	8f 93       	push	r24
    1158:	9f 93       	push	r25
    115a:	af 93       	push	r26
    115c:	bf 93       	push	r27
    115e:	cf 93       	push	r28
    1160:	df 93       	push	r29
    1162:	ef 93       	push	r30
    1164:	ff 93       	push	r31
    1166:	a0 91 5e 09 	lds	r26, 0x095E
    116a:	b0 91 5f 09 	lds	r27, 0x095F
    116e:	0d b6       	in	r0, 0x3d	; 61
    1170:	0d 92       	st	X+, r0
    1172:	0e b6       	in	r0, 0x3e	; 62
    1174:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1176:	b0 d1       	rcall	.+864    	; 0x14d8 <xTaskIncrementTick>
    1178:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    117a:	3a d3       	rcall	.+1652   	; 0x17f0 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    117c:	a0 91 5e 09 	lds	r26, 0x095E
    1180:	b0 91 5f 09 	lds	r27, 0x095F
    1184:	cd 91       	ld	r28, X+
    1186:	cd bf       	out	0x3d, r28	; 61
    1188:	dd 91       	ld	r29, X+
    118a:	de bf       	out	0x3e, r29	; 62
    118c:	ff 91       	pop	r31
    118e:	ef 91       	pop	r30
    1190:	df 91       	pop	r29
    1192:	cf 91       	pop	r28
    1194:	bf 91       	pop	r27
    1196:	af 91       	pop	r26
    1198:	9f 91       	pop	r25
    119a:	8f 91       	pop	r24
    119c:	7f 91       	pop	r23
    119e:	6f 91       	pop	r22
    11a0:	5f 91       	pop	r21
    11a2:	4f 91       	pop	r20
    11a4:	3f 91       	pop	r19
    11a6:	2f 91       	pop	r18
    11a8:	1f 91       	pop	r17
    11aa:	0f 91       	pop	r16
    11ac:	ff 90       	pop	r15
    11ae:	ef 90       	pop	r14
    11b0:	df 90       	pop	r13
    11b2:	cf 90       	pop	r12
    11b4:	bf 90       	pop	r11
    11b6:	af 90       	pop	r10
    11b8:	9f 90       	pop	r9
    11ba:	8f 90       	pop	r8
    11bc:	7f 90       	pop	r7
    11be:	6f 90       	pop	r6
    11c0:	5f 90       	pop	r5
    11c2:	4f 90       	pop	r4
    11c4:	3f 90       	pop	r3
    11c6:	2f 90       	pop	r2
    11c8:	1f 90       	pop	r1
    11ca:	0f 90       	pop	r0
    11cc:	0c be       	out	0x3c, r0	; 60
    11ce:	0f 90       	pop	r0
    11d0:	0b be       	out	0x3b, r0	; 59
    11d2:	0f 90       	pop	r0
    11d4:	0f be       	out	0x3f, r0	; 63
    11d6:	0f 90       	pop	r0

	asm volatile ( "ret" );
    11d8:	08 95       	ret

000011da <__vector_13>:
	 */
	
	//ISR(TIMER0_COMPA_vect,ISR_NAKED) //comeback timer2
	ISR(TIMER2_COMPA_vect,ISR_NAKED)
	{
		vPortYieldFromTick();
    11da:	9d df       	rcall	.-198    	; 0x1116 <vPortYieldFromTick>
		asm volatile ( "reti" );
    11dc:	18 95       	reti

000011de <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    11de:	e0 91 26 09 	lds	r30, 0x0926
    11e2:	f0 91 27 09 	lds	r31, 0x0927
    11e6:	80 81       	ld	r24, Z
    11e8:	81 11       	cpse	r24, r1
    11ea:	07 c0       	rjmp	.+14     	; 0x11fa <prvResetNextTaskUnblockTime+0x1c>
    11ec:	8f ef       	ldi	r24, 0xFF	; 255
    11ee:	9f ef       	ldi	r25, 0xFF	; 255
    11f0:	90 93 14 02 	sts	0x0214, r25
    11f4:	80 93 13 02 	sts	0x0213, r24
    11f8:	08 95       	ret
    11fa:	e0 91 26 09 	lds	r30, 0x0926
    11fe:	f0 91 27 09 	lds	r31, 0x0927
    1202:	05 80       	ldd	r0, Z+5	; 0x05
    1204:	f6 81       	ldd	r31, Z+6	; 0x06
    1206:	e0 2d       	mov	r30, r0
    1208:	06 80       	ldd	r0, Z+6	; 0x06
    120a:	f7 81       	ldd	r31, Z+7	; 0x07
    120c:	e0 2d       	mov	r30, r0
    120e:	82 81       	ldd	r24, Z+2	; 0x02
    1210:	93 81       	ldd	r25, Z+3	; 0x03
    1212:	90 93 14 02 	sts	0x0214, r25
    1216:	80 93 13 02 	sts	0x0213, r24
    121a:	08 95       	ret

0000121c <prvAddCurrentTaskToDelayedList>:
    121c:	cf 93       	push	r28
    121e:	df 93       	push	r29
    1220:	ec 01       	movw	r28, r24
    1222:	e0 91 5e 09 	lds	r30, 0x095E
    1226:	f0 91 5f 09 	lds	r31, 0x095F
    122a:	93 83       	std	Z+3, r25	; 0x03
    122c:	82 83       	std	Z+2, r24	; 0x02
    122e:	80 91 0e 09 	lds	r24, 0x090E
    1232:	90 91 0f 09 	lds	r25, 0x090F
    1236:	c8 17       	cp	r28, r24
    1238:	d9 07       	cpc	r29, r25
    123a:	60 f4       	brcc	.+24     	; 0x1254 <prvAddCurrentTaskToDelayedList+0x38>
    123c:	60 91 5e 09 	lds	r22, 0x095E
    1240:	70 91 5f 09 	lds	r23, 0x095F
    1244:	80 91 24 09 	lds	r24, 0x0924
    1248:	90 91 25 09 	lds	r25, 0x0925
    124c:	6e 5f       	subi	r22, 0xFE	; 254
    124e:	7f 4f       	sbci	r23, 0xFF	; 255
    1250:	85 db       	rcall	.-2294   	; 0x95c <vListInsert>
    1252:	16 c0       	rjmp	.+44     	; 0x1280 <prvAddCurrentTaskToDelayedList+0x64>
    1254:	60 91 5e 09 	lds	r22, 0x095E
    1258:	70 91 5f 09 	lds	r23, 0x095F
    125c:	80 91 26 09 	lds	r24, 0x0926
    1260:	90 91 27 09 	lds	r25, 0x0927
    1264:	6e 5f       	subi	r22, 0xFE	; 254
    1266:	7f 4f       	sbci	r23, 0xFF	; 255
    1268:	79 db       	rcall	.-2318   	; 0x95c <vListInsert>
    126a:	80 91 13 02 	lds	r24, 0x0213
    126e:	90 91 14 02 	lds	r25, 0x0214
    1272:	c8 17       	cp	r28, r24
    1274:	d9 07       	cpc	r29, r25
    1276:	20 f4       	brcc	.+8      	; 0x1280 <prvAddCurrentTaskToDelayedList+0x64>
    1278:	d0 93 14 02 	sts	0x0214, r29
    127c:	c0 93 13 02 	sts	0x0213, r28
    1280:	df 91       	pop	r29
    1282:	cf 91       	pop	r28
    1284:	08 95       	ret

00001286 <xTaskGenericCreate>:
    1286:	4f 92       	push	r4
    1288:	5f 92       	push	r5
    128a:	6f 92       	push	r6
    128c:	7f 92       	push	r7
    128e:	8f 92       	push	r8
    1290:	9f 92       	push	r9
    1292:	af 92       	push	r10
    1294:	bf 92       	push	r11
    1296:	cf 92       	push	r12
    1298:	df 92       	push	r13
    129a:	ef 92       	push	r14
    129c:	ff 92       	push	r15
    129e:	0f 93       	push	r16
    12a0:	1f 93       	push	r17
    12a2:	cf 93       	push	r28
    12a4:	df 93       	push	r29
    12a6:	4c 01       	movw	r8, r24
    12a8:	5b 01       	movw	r10, r22
    12aa:	2a 01       	movw	r4, r20
    12ac:	39 01       	movw	r6, r18
    12ae:	81 e2       	ldi	r24, 0x21	; 33
    12b0:	90 e0       	ldi	r25, 0x00	; 0
    12b2:	7e d9       	rcall	.-3332   	; 0x5b0 <pvPortMalloc>
    12b4:	ec 01       	movw	r28, r24
    12b6:	00 97       	sbiw	r24, 0x00	; 0
    12b8:	09 f4       	brne	.+2      	; 0x12bc <xTaskGenericCreate+0x36>
    12ba:	cd c0       	rjmp	.+410    	; 0x1456 <xTaskGenericCreate+0x1d0>
    12bc:	c1 14       	cp	r12, r1
    12be:	d1 04       	cpc	r13, r1
    12c0:	09 f0       	breq	.+2      	; 0x12c4 <xTaskGenericCreate+0x3e>
    12c2:	b2 c0       	rjmp	.+356    	; 0x1428 <xTaskGenericCreate+0x1a2>
    12c4:	c2 01       	movw	r24, r4
    12c6:	74 d9       	rcall	.-3352   	; 0x5b0 <pvPortMalloc>
    12c8:	98 8f       	std	Y+24, r25	; 0x18
    12ca:	8f 8b       	std	Y+23, r24	; 0x17
    12cc:	89 2b       	or	r24, r25
    12ce:	09 f0       	breq	.+2      	; 0x12d2 <xTaskGenericCreate+0x4c>
    12d0:	ad c0       	rjmp	.+346    	; 0x142c <xTaskGenericCreate+0x1a6>
    12d2:	ce 01       	movw	r24, r28
    12d4:	a1 d9       	rcall	.-3262   	; 0x618 <vPortFree>
    12d6:	bf c0       	rjmp	.+382    	; 0x1456 <xTaskGenericCreate+0x1d0>
    12d8:	cf 01       	movw	r24, r30
    12da:	31 91       	ld	r19, Z+
    12dc:	da 01       	movw	r26, r20
    12de:	3d 93       	st	X+, r19
    12e0:	ad 01       	movw	r20, r26
    12e2:	dc 01       	movw	r26, r24
    12e4:	8c 91       	ld	r24, X
    12e6:	88 23       	and	r24, r24
    12e8:	11 f0       	breq	.+4      	; 0x12ee <xTaskGenericCreate+0x68>
    12ea:	21 50       	subi	r18, 0x01	; 1
    12ec:	a9 f7       	brne	.-22     	; 0x12d8 <xTaskGenericCreate+0x52>
    12ee:	18 a2       	std	Y+32, r1	; 0x20
    12f0:	10 2f       	mov	r17, r16
    12f2:	04 30       	cpi	r16, 0x04	; 4
    12f4:	08 f0       	brcs	.+2      	; 0x12f8 <xTaskGenericCreate+0x72>
    12f6:	13 e0       	ldi	r17, 0x03	; 3
    12f8:	1e 8b       	std	Y+22, r17	; 0x16
    12fa:	5e 01       	movw	r10, r28
    12fc:	b2 e0       	ldi	r27, 0x02	; 2
    12fe:	ab 0e       	add	r10, r27
    1300:	b1 1c       	adc	r11, r1
    1302:	c5 01       	movw	r24, r10
    1304:	06 db       	rcall	.-2548   	; 0x912 <vListInitialiseItem>
    1306:	ce 01       	movw	r24, r28
    1308:	0c 96       	adiw	r24, 0x0c	; 12
    130a:	03 db       	rcall	.-2554   	; 0x912 <vListInitialiseItem>
    130c:	d9 87       	std	Y+9, r29	; 0x09
    130e:	c8 87       	std	Y+8, r28	; 0x08
    1310:	84 e0       	ldi	r24, 0x04	; 4
    1312:	90 e0       	ldi	r25, 0x00	; 0
    1314:	81 1b       	sub	r24, r17
    1316:	91 09       	sbc	r25, r1
    1318:	9d 87       	std	Y+13, r25	; 0x0d
    131a:	8c 87       	std	Y+12, r24	; 0x0c
    131c:	db 8b       	std	Y+19, r29	; 0x13
    131e:	ca 8b       	std	Y+18, r28	; 0x12
    1320:	a3 01       	movw	r20, r6
    1322:	b4 01       	movw	r22, r8
    1324:	c6 01       	movw	r24, r12
    1326:	e4 dd       	rcall	.-1080   	; 0xef0 <pxPortInitialiseStack>
    1328:	99 83       	std	Y+1, r25	; 0x01
    132a:	88 83       	st	Y, r24
    132c:	e1 14       	cp	r14, r1
    132e:	f1 04       	cpc	r15, r1
    1330:	19 f0       	breq	.+6      	; 0x1338 <xTaskGenericCreate+0xb2>
    1332:	f7 01       	movw	r30, r14
    1334:	d1 83       	std	Z+1, r29	; 0x01
    1336:	c0 83       	st	Z, r28
    1338:	0f b6       	in	r0, 0x3f	; 63
    133a:	f8 94       	cli
    133c:	0f 92       	push	r0
    133e:	80 91 10 09 	lds	r24, 0x0910
    1342:	8f 5f       	subi	r24, 0xFF	; 255
    1344:	80 93 10 09 	sts	0x0910, r24
    1348:	80 91 5e 09 	lds	r24, 0x095E
    134c:	90 91 5f 09 	lds	r25, 0x095F
    1350:	89 2b       	or	r24, r25
    1352:	69 f5       	brne	.+90     	; 0x13ae <xTaskGenericCreate+0x128>
    1354:	d0 93 5f 09 	sts	0x095F, r29
    1358:	c0 93 5e 09 	sts	0x095E, r28
    135c:	80 91 10 09 	lds	r24, 0x0910
    1360:	81 30       	cpi	r24, 0x01	; 1
    1362:	a1 f5       	brne	.+104    	; 0x13cc <xTaskGenericCreate+0x146>
    1364:	8a e3       	ldi	r24, 0x3A	; 58
    1366:	99 e0       	ldi	r25, 0x09	; 9
    1368:	c6 da       	rcall	.-2676   	; 0x8f6 <vListInitialise>
    136a:	83 e4       	ldi	r24, 0x43	; 67
    136c:	99 e0       	ldi	r25, 0x09	; 9
    136e:	c3 da       	rcall	.-2682   	; 0x8f6 <vListInitialise>
    1370:	8c e4       	ldi	r24, 0x4C	; 76
    1372:	99 e0       	ldi	r25, 0x09	; 9
    1374:	c0 da       	rcall	.-2688   	; 0x8f6 <vListInitialise>
    1376:	85 e5       	ldi	r24, 0x55	; 85
    1378:	99 e0       	ldi	r25, 0x09	; 9
    137a:	bd da       	rcall	.-2694   	; 0x8f6 <vListInitialise>
    137c:	81 e3       	ldi	r24, 0x31	; 49
    137e:	99 e0       	ldi	r25, 0x09	; 9
    1380:	ba da       	rcall	.-2700   	; 0x8f6 <vListInitialise>
    1382:	88 e2       	ldi	r24, 0x28	; 40
    1384:	99 e0       	ldi	r25, 0x09	; 9
    1386:	b7 da       	rcall	.-2706   	; 0x8f6 <vListInitialise>
    1388:	8b e1       	ldi	r24, 0x1B	; 27
    138a:	99 e0       	ldi	r25, 0x09	; 9
    138c:	b4 da       	rcall	.-2712   	; 0x8f6 <vListInitialise>
    138e:	82 e1       	ldi	r24, 0x12	; 18
    1390:	99 e0       	ldi	r25, 0x09	; 9
    1392:	b1 da       	rcall	.-2718   	; 0x8f6 <vListInitialise>
    1394:	81 e3       	ldi	r24, 0x31	; 49
    1396:	99 e0       	ldi	r25, 0x09	; 9
    1398:	90 93 27 09 	sts	0x0927, r25
    139c:	80 93 26 09 	sts	0x0926, r24
    13a0:	88 e2       	ldi	r24, 0x28	; 40
    13a2:	99 e0       	ldi	r25, 0x09	; 9
    13a4:	90 93 25 09 	sts	0x0925, r25
    13a8:	80 93 24 09 	sts	0x0924, r24
    13ac:	0f c0       	rjmp	.+30     	; 0x13cc <xTaskGenericCreate+0x146>
    13ae:	80 91 0c 09 	lds	r24, 0x090C
    13b2:	81 11       	cpse	r24, r1
    13b4:	0b c0       	rjmp	.+22     	; 0x13cc <xTaskGenericCreate+0x146>
    13b6:	e0 91 5e 09 	lds	r30, 0x095E
    13ba:	f0 91 5f 09 	lds	r31, 0x095F
    13be:	86 89       	ldd	r24, Z+22	; 0x16
    13c0:	08 17       	cp	r16, r24
    13c2:	20 f0       	brcs	.+8      	; 0x13cc <xTaskGenericCreate+0x146>
    13c4:	d0 93 5f 09 	sts	0x095F, r29
    13c8:	c0 93 5e 09 	sts	0x095E, r28
    13cc:	80 91 08 09 	lds	r24, 0x0908
    13d0:	8f 5f       	subi	r24, 0xFF	; 255
    13d2:	80 93 08 09 	sts	0x0908, r24
    13d6:	8e 89       	ldd	r24, Y+22	; 0x16
    13d8:	90 91 0d 09 	lds	r25, 0x090D
    13dc:	98 17       	cp	r25, r24
    13de:	10 f4       	brcc	.+4      	; 0x13e4 <xTaskGenericCreate+0x15e>
    13e0:	80 93 0d 09 	sts	0x090D, r24
    13e4:	90 e0       	ldi	r25, 0x00	; 0
    13e6:	9c 01       	movw	r18, r24
    13e8:	22 0f       	add	r18, r18
    13ea:	33 1f       	adc	r19, r19
    13ec:	22 0f       	add	r18, r18
    13ee:	33 1f       	adc	r19, r19
    13f0:	22 0f       	add	r18, r18
    13f2:	33 1f       	adc	r19, r19
    13f4:	82 0f       	add	r24, r18
    13f6:	93 1f       	adc	r25, r19
    13f8:	b5 01       	movw	r22, r10
    13fa:	86 5c       	subi	r24, 0xC6	; 198
    13fc:	96 4f       	sbci	r25, 0xF6	; 246
    13fe:	8d da       	rcall	.-2790   	; 0x91a <vListInsertEnd>
    1400:	0f 90       	pop	r0
    1402:	0f be       	out	0x3f, r0	; 63
    1404:	80 91 0c 09 	lds	r24, 0x090C
    1408:	88 23       	and	r24, r24
    140a:	51 f0       	breq	.+20     	; 0x1420 <xTaskGenericCreate+0x19a>
    140c:	e0 91 5e 09 	lds	r30, 0x095E
    1410:	f0 91 5f 09 	lds	r31, 0x095F
    1414:	86 89       	ldd	r24, Z+22	; 0x16
    1416:	80 17       	cp	r24, r16
    1418:	28 f4       	brcc	.+10     	; 0x1424 <xTaskGenericCreate+0x19e>
    141a:	1d de       	rcall	.-966    	; 0x1056 <vPortYield>
    141c:	81 e0       	ldi	r24, 0x01	; 1
    141e:	1c c0       	rjmp	.+56     	; 0x1458 <xTaskGenericCreate+0x1d2>
    1420:	81 e0       	ldi	r24, 0x01	; 1
    1422:	1a c0       	rjmp	.+52     	; 0x1458 <xTaskGenericCreate+0x1d2>
    1424:	81 e0       	ldi	r24, 0x01	; 1
    1426:	18 c0       	rjmp	.+48     	; 0x1458 <xTaskGenericCreate+0x1d2>
    1428:	d8 8e       	std	Y+24, r13	; 0x18
    142a:	cf 8a       	std	Y+23, r12	; 0x17
    142c:	f1 e0       	ldi	r31, 0x01	; 1
    142e:	4f 1a       	sub	r4, r31
    1430:	51 08       	sbc	r5, r1
    1432:	cf 88       	ldd	r12, Y+23	; 0x17
    1434:	d8 8c       	ldd	r13, Y+24	; 0x18
    1436:	c4 0c       	add	r12, r4
    1438:	d5 1c       	adc	r13, r5
    143a:	d5 01       	movw	r26, r10
    143c:	8c 91       	ld	r24, X
    143e:	89 8f       	std	Y+25, r24	; 0x19
    1440:	8c 91       	ld	r24, X
    1442:	88 23       	and	r24, r24
    1444:	09 f4       	brne	.+2      	; 0x1448 <xTaskGenericCreate+0x1c2>
    1446:	53 cf       	rjmp	.-346    	; 0x12ee <xTaskGenericCreate+0x68>
    1448:	ae 01       	movw	r20, r28
    144a:	46 5e       	subi	r20, 0xE6	; 230
    144c:	5f 4f       	sbci	r21, 0xFF	; 255
    144e:	f5 01       	movw	r30, r10
    1450:	31 96       	adiw	r30, 0x01	; 1
    1452:	27 e0       	ldi	r18, 0x07	; 7
    1454:	41 cf       	rjmp	.-382    	; 0x12d8 <xTaskGenericCreate+0x52>
    1456:	8f ef       	ldi	r24, 0xFF	; 255
    1458:	df 91       	pop	r29
    145a:	cf 91       	pop	r28
    145c:	1f 91       	pop	r17
    145e:	0f 91       	pop	r16
    1460:	ff 90       	pop	r15
    1462:	ef 90       	pop	r14
    1464:	df 90       	pop	r13
    1466:	cf 90       	pop	r12
    1468:	bf 90       	pop	r11
    146a:	af 90       	pop	r10
    146c:	9f 90       	pop	r9
    146e:	8f 90       	pop	r8
    1470:	7f 90       	pop	r7
    1472:	6f 90       	pop	r6
    1474:	5f 90       	pop	r5
    1476:	4f 90       	pop	r4
    1478:	08 95       	ret

0000147a <vTaskStartScheduler>:
    147a:	af 92       	push	r10
    147c:	bf 92       	push	r11
    147e:	cf 92       	push	r12
    1480:	df 92       	push	r13
    1482:	ef 92       	push	r14
    1484:	ff 92       	push	r15
    1486:	0f 93       	push	r16
    1488:	a1 2c       	mov	r10, r1
    148a:	b1 2c       	mov	r11, r1
    148c:	c1 2c       	mov	r12, r1
    148e:	d1 2c       	mov	r13, r1
    1490:	e1 2c       	mov	r14, r1
    1492:	f1 2c       	mov	r15, r1
    1494:	00 e0       	ldi	r16, 0x00	; 0
    1496:	20 e0       	ldi	r18, 0x00	; 0
    1498:	30 e0       	ldi	r19, 0x00	; 0
    149a:	45 e5       	ldi	r20, 0x55	; 85
    149c:	50 e0       	ldi	r21, 0x00	; 0
    149e:	64 e4       	ldi	r22, 0x44	; 68
    14a0:	72 e0       	ldi	r23, 0x02	; 2
    14a2:	80 ec       	ldi	r24, 0xC0	; 192
    14a4:	9b e0       	ldi	r25, 0x0B	; 11
    14a6:	ef de       	rcall	.-546    	; 0x1286 <xTaskGenericCreate>
    14a8:	81 30       	cpi	r24, 0x01	; 1
    14aa:	41 f4       	brne	.+16     	; 0x14bc <vTaskStartScheduler+0x42>
    14ac:	f8 94       	cli
    14ae:	80 93 0c 09 	sts	0x090C, r24
    14b2:	10 92 0f 09 	sts	0x090F, r1
    14b6:	10 92 0e 09 	sts	0x090E, r1
    14ba:	8c dd       	rcall	.-1256   	; 0xfd4 <xPortStartScheduler>
    14bc:	0f 91       	pop	r16
    14be:	ff 90       	pop	r15
    14c0:	ef 90       	pop	r14
    14c2:	df 90       	pop	r13
    14c4:	cf 90       	pop	r12
    14c6:	bf 90       	pop	r11
    14c8:	af 90       	pop	r10
    14ca:	08 95       	ret

000014cc <vTaskSuspendAll>:
    14cc:	80 91 07 09 	lds	r24, 0x0907
    14d0:	8f 5f       	subi	r24, 0xFF	; 255
    14d2:	80 93 07 09 	sts	0x0907, r24
    14d6:	08 95       	ret

000014d8 <xTaskIncrementTick>:
    14d8:	cf 92       	push	r12
    14da:	df 92       	push	r13
    14dc:	ef 92       	push	r14
    14de:	ff 92       	push	r15
    14e0:	0f 93       	push	r16
    14e2:	1f 93       	push	r17
    14e4:	cf 93       	push	r28
    14e6:	df 93       	push	r29
    14e8:	80 91 07 09 	lds	r24, 0x0907
    14ec:	81 11       	cpse	r24, r1
    14ee:	96 c0       	rjmp	.+300    	; 0x161c <xTaskIncrementTick+0x144>
    14f0:	80 91 0e 09 	lds	r24, 0x090E
    14f4:	90 91 0f 09 	lds	r25, 0x090F
    14f8:	01 96       	adiw	r24, 0x01	; 1
    14fa:	90 93 0f 09 	sts	0x090F, r25
    14fe:	80 93 0e 09 	sts	0x090E, r24
    1502:	e0 90 0e 09 	lds	r14, 0x090E
    1506:	f0 90 0f 09 	lds	r15, 0x090F
    150a:	e1 14       	cp	r14, r1
    150c:	f1 04       	cpc	r15, r1
    150e:	b1 f4       	brne	.+44     	; 0x153c <xTaskIncrementTick+0x64>
    1510:	80 91 26 09 	lds	r24, 0x0926
    1514:	90 91 27 09 	lds	r25, 0x0927
    1518:	20 91 24 09 	lds	r18, 0x0924
    151c:	30 91 25 09 	lds	r19, 0x0925
    1520:	30 93 27 09 	sts	0x0927, r19
    1524:	20 93 26 09 	sts	0x0926, r18
    1528:	90 93 25 09 	sts	0x0925, r25
    152c:	80 93 24 09 	sts	0x0924, r24
    1530:	80 91 09 09 	lds	r24, 0x0909
    1534:	8f 5f       	subi	r24, 0xFF	; 255
    1536:	80 93 09 09 	sts	0x0909, r24
    153a:	51 de       	rcall	.-862    	; 0x11de <prvResetNextTaskUnblockTime>
    153c:	80 91 13 02 	lds	r24, 0x0213
    1540:	90 91 14 02 	lds	r25, 0x0214
    1544:	e8 16       	cp	r14, r24
    1546:	f9 06       	cpc	r15, r25
    1548:	08 f4       	brcc	.+2      	; 0x154c <xTaskIncrementTick+0x74>
    154a:	51 c0       	rjmp	.+162    	; 0x15ee <xTaskIncrementTick+0x116>
    154c:	d1 2c       	mov	r13, r1
    154e:	cc 24       	eor	r12, r12
    1550:	c3 94       	inc	r12
    1552:	01 c0       	rjmp	.+2      	; 0x1556 <xTaskIncrementTick+0x7e>
    1554:	dc 2c       	mov	r13, r12
    1556:	e0 91 26 09 	lds	r30, 0x0926
    155a:	f0 91 27 09 	lds	r31, 0x0927
    155e:	80 81       	ld	r24, Z
    1560:	81 11       	cpse	r24, r1
    1562:	07 c0       	rjmp	.+14     	; 0x1572 <xTaskIncrementTick+0x9a>
    1564:	8f ef       	ldi	r24, 0xFF	; 255
    1566:	9f ef       	ldi	r25, 0xFF	; 255
    1568:	90 93 14 02 	sts	0x0214, r25
    156c:	80 93 13 02 	sts	0x0213, r24
    1570:	3f c0       	rjmp	.+126    	; 0x15f0 <xTaskIncrementTick+0x118>
    1572:	e0 91 26 09 	lds	r30, 0x0926
    1576:	f0 91 27 09 	lds	r31, 0x0927
    157a:	05 80       	ldd	r0, Z+5	; 0x05
    157c:	f6 81       	ldd	r31, Z+6	; 0x06
    157e:	e0 2d       	mov	r30, r0
    1580:	c6 81       	ldd	r28, Z+6	; 0x06
    1582:	d7 81       	ldd	r29, Z+7	; 0x07
    1584:	2a 81       	ldd	r18, Y+2	; 0x02
    1586:	3b 81       	ldd	r19, Y+3	; 0x03
    1588:	e2 16       	cp	r14, r18
    158a:	f3 06       	cpc	r15, r19
    158c:	28 f4       	brcc	.+10     	; 0x1598 <xTaskIncrementTick+0xc0>
    158e:	30 93 14 02 	sts	0x0214, r19
    1592:	20 93 13 02 	sts	0x0213, r18
    1596:	2c c0       	rjmp	.+88     	; 0x15f0 <xTaskIncrementTick+0x118>
    1598:	8e 01       	movw	r16, r28
    159a:	0e 5f       	subi	r16, 0xFE	; 254
    159c:	1f 4f       	sbci	r17, 0xFF	; 255
    159e:	c8 01       	movw	r24, r16
    15a0:	0e da       	rcall	.-3044   	; 0x9be <uxListRemove>
    15a2:	8c 89       	ldd	r24, Y+20	; 0x14
    15a4:	9d 89       	ldd	r25, Y+21	; 0x15
    15a6:	89 2b       	or	r24, r25
    15a8:	19 f0       	breq	.+6      	; 0x15b0 <xTaskIncrementTick+0xd8>
    15aa:	ce 01       	movw	r24, r28
    15ac:	0c 96       	adiw	r24, 0x0c	; 12
    15ae:	07 da       	rcall	.-3058   	; 0x9be <uxListRemove>
    15b0:	2e 89       	ldd	r18, Y+22	; 0x16
    15b2:	80 91 0d 09 	lds	r24, 0x090D
    15b6:	82 17       	cp	r24, r18
    15b8:	10 f4       	brcc	.+4      	; 0x15be <xTaskIncrementTick+0xe6>
    15ba:	20 93 0d 09 	sts	0x090D, r18
    15be:	30 e0       	ldi	r19, 0x00	; 0
    15c0:	c9 01       	movw	r24, r18
    15c2:	88 0f       	add	r24, r24
    15c4:	99 1f       	adc	r25, r25
    15c6:	88 0f       	add	r24, r24
    15c8:	99 1f       	adc	r25, r25
    15ca:	88 0f       	add	r24, r24
    15cc:	99 1f       	adc	r25, r25
    15ce:	82 0f       	add	r24, r18
    15d0:	93 1f       	adc	r25, r19
    15d2:	b8 01       	movw	r22, r16
    15d4:	86 5c       	subi	r24, 0xC6	; 198
    15d6:	96 4f       	sbci	r25, 0xF6	; 246
    15d8:	a0 d9       	rcall	.-3264   	; 0x91a <vListInsertEnd>
    15da:	e0 91 5e 09 	lds	r30, 0x095E
    15de:	f0 91 5f 09 	lds	r31, 0x095F
    15e2:	9e 89       	ldd	r25, Y+22	; 0x16
    15e4:	86 89       	ldd	r24, Z+22	; 0x16
    15e6:	98 17       	cp	r25, r24
    15e8:	08 f0       	brcs	.+2      	; 0x15ec <xTaskIncrementTick+0x114>
    15ea:	b4 cf       	rjmp	.-152    	; 0x1554 <xTaskIncrementTick+0x7c>
    15ec:	b4 cf       	rjmp	.-152    	; 0x1556 <xTaskIncrementTick+0x7e>
    15ee:	d1 2c       	mov	r13, r1
    15f0:	e0 91 5e 09 	lds	r30, 0x095E
    15f4:	f0 91 5f 09 	lds	r31, 0x095F
    15f8:	86 89       	ldd	r24, Z+22	; 0x16
    15fa:	90 e0       	ldi	r25, 0x00	; 0
    15fc:	fc 01       	movw	r30, r24
    15fe:	ee 0f       	add	r30, r30
    1600:	ff 1f       	adc	r31, r31
    1602:	ee 0f       	add	r30, r30
    1604:	ff 1f       	adc	r31, r31
    1606:	ee 0f       	add	r30, r30
    1608:	ff 1f       	adc	r31, r31
    160a:	8e 0f       	add	r24, r30
    160c:	9f 1f       	adc	r25, r31
    160e:	fc 01       	movw	r30, r24
    1610:	e6 5c       	subi	r30, 0xC6	; 198
    1612:	f6 4f       	sbci	r31, 0xF6	; 246
    1614:	80 81       	ld	r24, Z
    1616:	82 30       	cpi	r24, 0x02	; 2
    1618:	40 f4       	brcc	.+16     	; 0x162a <xTaskIncrementTick+0x152>
    161a:	09 c0       	rjmp	.+18     	; 0x162e <xTaskIncrementTick+0x156>
    161c:	80 91 0b 09 	lds	r24, 0x090B
    1620:	8f 5f       	subi	r24, 0xFF	; 255
    1622:	80 93 0b 09 	sts	0x090B, r24
    1626:	d1 2c       	mov	r13, r1
    1628:	02 c0       	rjmp	.+4      	; 0x162e <xTaskIncrementTick+0x156>
    162a:	dd 24       	eor	r13, r13
    162c:	d3 94       	inc	r13
    162e:	80 91 0a 09 	lds	r24, 0x090A
    1632:	88 23       	and	r24, r24
    1634:	11 f0       	breq	.+4      	; 0x163a <xTaskIncrementTick+0x162>
    1636:	dd 24       	eor	r13, r13
    1638:	d3 94       	inc	r13
    163a:	8d 2d       	mov	r24, r13
    163c:	df 91       	pop	r29
    163e:	cf 91       	pop	r28
    1640:	1f 91       	pop	r17
    1642:	0f 91       	pop	r16
    1644:	ff 90       	pop	r15
    1646:	ef 90       	pop	r14
    1648:	df 90       	pop	r13
    164a:	cf 90       	pop	r12
    164c:	08 95       	ret

0000164e <xTaskResumeAll>:
    164e:	df 92       	push	r13
    1650:	ef 92       	push	r14
    1652:	ff 92       	push	r15
    1654:	0f 93       	push	r16
    1656:	1f 93       	push	r17
    1658:	cf 93       	push	r28
    165a:	df 93       	push	r29
    165c:	0f b6       	in	r0, 0x3f	; 63
    165e:	f8 94       	cli
    1660:	0f 92       	push	r0
    1662:	80 91 07 09 	lds	r24, 0x0907
    1666:	81 50       	subi	r24, 0x01	; 1
    1668:	80 93 07 09 	sts	0x0907, r24
    166c:	80 91 07 09 	lds	r24, 0x0907
    1670:	81 11       	cpse	r24, r1
    1672:	5c c0       	rjmp	.+184    	; 0x172c <xTaskResumeAll+0xde>
    1674:	80 91 10 09 	lds	r24, 0x0910
    1678:	88 23       	and	r24, r24
    167a:	09 f4       	brne	.+2      	; 0x167e <xTaskResumeAll+0x30>
    167c:	59 c0       	rjmp	.+178    	; 0x1730 <xTaskResumeAll+0xe2>
    167e:	0f 2e       	mov	r0, r31
    1680:	fb e1       	ldi	r31, 0x1B	; 27
    1682:	ef 2e       	mov	r14, r31
    1684:	f9 e0       	ldi	r31, 0x09	; 9
    1686:	ff 2e       	mov	r15, r31
    1688:	f0 2d       	mov	r31, r0
    168a:	dd 24       	eor	r13, r13
    168c:	d3 94       	inc	r13
    168e:	2d c0       	rjmp	.+90     	; 0x16ea <xTaskResumeAll+0x9c>
    1690:	e0 91 20 09 	lds	r30, 0x0920
    1694:	f0 91 21 09 	lds	r31, 0x0921
    1698:	c6 81       	ldd	r28, Z+6	; 0x06
    169a:	d7 81       	ldd	r29, Z+7	; 0x07
    169c:	ce 01       	movw	r24, r28
    169e:	0c 96       	adiw	r24, 0x0c	; 12
    16a0:	8e d9       	rcall	.-3300   	; 0x9be <uxListRemove>
    16a2:	8e 01       	movw	r16, r28
    16a4:	0e 5f       	subi	r16, 0xFE	; 254
    16a6:	1f 4f       	sbci	r17, 0xFF	; 255
    16a8:	c8 01       	movw	r24, r16
    16aa:	89 d9       	rcall	.-3310   	; 0x9be <uxListRemove>
    16ac:	8e 89       	ldd	r24, Y+22	; 0x16
    16ae:	90 91 0d 09 	lds	r25, 0x090D
    16b2:	98 17       	cp	r25, r24
    16b4:	10 f4       	brcc	.+4      	; 0x16ba <xTaskResumeAll+0x6c>
    16b6:	80 93 0d 09 	sts	0x090D, r24
    16ba:	90 e0       	ldi	r25, 0x00	; 0
    16bc:	9c 01       	movw	r18, r24
    16be:	22 0f       	add	r18, r18
    16c0:	33 1f       	adc	r19, r19
    16c2:	22 0f       	add	r18, r18
    16c4:	33 1f       	adc	r19, r19
    16c6:	22 0f       	add	r18, r18
    16c8:	33 1f       	adc	r19, r19
    16ca:	82 0f       	add	r24, r18
    16cc:	93 1f       	adc	r25, r19
    16ce:	b8 01       	movw	r22, r16
    16d0:	86 5c       	subi	r24, 0xC6	; 198
    16d2:	96 4f       	sbci	r25, 0xF6	; 246
    16d4:	22 d9       	rcall	.-3516   	; 0x91a <vListInsertEnd>
    16d6:	e0 91 5e 09 	lds	r30, 0x095E
    16da:	f0 91 5f 09 	lds	r31, 0x095F
    16de:	9e 89       	ldd	r25, Y+22	; 0x16
    16e0:	86 89       	ldd	r24, Z+22	; 0x16
    16e2:	98 17       	cp	r25, r24
    16e4:	10 f0       	brcs	.+4      	; 0x16ea <xTaskResumeAll+0x9c>
    16e6:	d0 92 0a 09 	sts	0x090A, r13
    16ea:	f7 01       	movw	r30, r14
    16ec:	80 81       	ld	r24, Z
    16ee:	81 11       	cpse	r24, r1
    16f0:	cf cf       	rjmp	.-98     	; 0x1690 <xTaskResumeAll+0x42>
    16f2:	80 91 0b 09 	lds	r24, 0x090B
    16f6:	88 23       	and	r24, r24
    16f8:	91 f0       	breq	.+36     	; 0x171e <xTaskResumeAll+0xd0>
    16fa:	80 91 0b 09 	lds	r24, 0x090B
    16fe:	88 23       	and	r24, r24
    1700:	71 f0       	breq	.+28     	; 0x171e <xTaskResumeAll+0xd0>
    1702:	c1 e0       	ldi	r28, 0x01	; 1
    1704:	e9 de       	rcall	.-558    	; 0x14d8 <xTaskIncrementTick>
    1706:	81 11       	cpse	r24, r1
    1708:	c0 93 0a 09 	sts	0x090A, r28
    170c:	80 91 0b 09 	lds	r24, 0x090B
    1710:	81 50       	subi	r24, 0x01	; 1
    1712:	80 93 0b 09 	sts	0x090B, r24
    1716:	80 91 0b 09 	lds	r24, 0x090B
    171a:	81 11       	cpse	r24, r1
    171c:	f3 cf       	rjmp	.-26     	; 0x1704 <xTaskResumeAll+0xb6>
    171e:	80 91 0a 09 	lds	r24, 0x090A
    1722:	81 30       	cpi	r24, 0x01	; 1
    1724:	39 f4       	brne	.+14     	; 0x1734 <xTaskResumeAll+0xe6>
    1726:	97 dc       	rcall	.-1746   	; 0x1056 <vPortYield>
    1728:	81 e0       	ldi	r24, 0x01	; 1
    172a:	05 c0       	rjmp	.+10     	; 0x1736 <xTaskResumeAll+0xe8>
    172c:	80 e0       	ldi	r24, 0x00	; 0
    172e:	03 c0       	rjmp	.+6      	; 0x1736 <xTaskResumeAll+0xe8>
    1730:	80 e0       	ldi	r24, 0x00	; 0
    1732:	01 c0       	rjmp	.+2      	; 0x1736 <xTaskResumeAll+0xe8>
    1734:	80 e0       	ldi	r24, 0x00	; 0
    1736:	0f 90       	pop	r0
    1738:	0f be       	out	0x3f, r0	; 63
    173a:	df 91       	pop	r29
    173c:	cf 91       	pop	r28
    173e:	1f 91       	pop	r17
    1740:	0f 91       	pop	r16
    1742:	ff 90       	pop	r15
    1744:	ef 90       	pop	r14
    1746:	df 90       	pop	r13
    1748:	08 95       	ret

0000174a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    174a:	cf 93       	push	r28
    174c:	df 93       	push	r29
    174e:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    1750:	00 97       	sbiw	r24, 0x00	; 0
    1752:	91 f0       	breq	.+36     	; 0x1778 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    1754:	bb de       	rcall	.-650    	; 0x14cc <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1756:	80 91 0e 09 	lds	r24, 0x090E
    175a:	90 91 0f 09 	lds	r25, 0x090F
    175e:	c8 0f       	add	r28, r24
    1760:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1762:	80 91 5e 09 	lds	r24, 0x095E
    1766:	90 91 5f 09 	lds	r25, 0x095F
    176a:	02 96       	adiw	r24, 0x02	; 2
    176c:	28 d9       	rcall	.-3504   	; 0x9be <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    176e:	ce 01       	movw	r24, r28
    1770:	55 dd       	rcall	.-1366   	; 0x121c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1772:	6d df       	rcall	.-294    	; 0x164e <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1774:	81 11       	cpse	r24, r1
    1776:	01 c0       	rjmp	.+2      	; 0x177a <vTaskDelay+0x30>
		{
			portYIELD_WITHIN_API();
    1778:	6e dc       	rcall	.-1828   	; 0x1056 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    177a:	df 91       	pop	r29
    177c:	cf 91       	pop	r28
    177e:	08 95       	ret

00001780 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    1780:	0f 2e       	mov	r0, r31
    1782:	fa e3       	ldi	r31, 0x3A	; 58
    1784:	ef 2e       	mov	r14, r31
    1786:	f9 e0       	ldi	r31, 0x09	; 9
    1788:	ff 2e       	mov	r15, r31
    178a:	f0 2d       	mov	r31, r0
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    178c:	c2 e1       	ldi	r28, 0x12	; 18
    178e:	d9 e0       	ldi	r29, 0x09	; 9
    1790:	25 c0       	rjmp	.+74     	; 0x17dc <prvIdleTask+0x5c>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    1792:	9c de       	rcall	.-712    	; 0x14cc <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1794:	18 81       	ld	r17, Y
			}
			( void ) xTaskResumeAll();
    1796:	5b df       	rcall	.-330    	; 0x164e <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    1798:	11 23       	and	r17, r17
    179a:	01 f1       	breq	.+64     	; 0x17dc <prvIdleTask+0x5c>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    179c:	0f b6       	in	r0, 0x3f	; 63
    179e:	f8 94       	cli
    17a0:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    17a2:	e0 91 17 09 	lds	r30, 0x0917
    17a6:	f0 91 18 09 	lds	r31, 0x0918
    17aa:	06 81       	ldd	r16, Z+6	; 0x06
    17ac:	17 81       	ldd	r17, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    17ae:	c8 01       	movw	r24, r16
    17b0:	02 96       	adiw	r24, 0x02	; 2
    17b2:	05 d9       	rcall	.-3574   	; 0x9be <uxListRemove>
					--uxCurrentNumberOfTasks;
    17b4:	80 91 10 09 	lds	r24, 0x0910
    17b8:	81 50       	subi	r24, 0x01	; 1
    17ba:	80 93 10 09 	sts	0x0910, r24
					--uxTasksDeleted;
    17be:	80 91 11 09 	lds	r24, 0x0911
    17c2:	81 50       	subi	r24, 0x01	; 1
    17c4:	80 93 11 09 	sts	0x0911, r24
				}
				taskEXIT_CRITICAL();
    17c8:	0f 90       	pop	r0
    17ca:	0f be       	out	0x3f, r0	; 63
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
		vPortFreeAligned( pxTCB->pxStack );
    17cc:	f8 01       	movw	r30, r16
    17ce:	87 89       	ldd	r24, Z+23	; 0x17
    17d0:	90 8d       	ldd	r25, Z+24	; 0x18
    17d2:	0e 94 0c 03 	call	0x618	; 0x618 <vPortFree>
		vPortFree( pxTCB );
    17d6:	c8 01       	movw	r24, r16
    17d8:	0e 94 0c 03 	call	0x618	; 0x618 <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    17dc:	80 91 11 09 	lds	r24, 0x0911
    17e0:	81 11       	cpse	r24, r1
    17e2:	d7 cf       	rjmp	.-82     	; 0x1792 <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    17e4:	f7 01       	movw	r30, r14
    17e6:	80 81       	ld	r24, Z
    17e8:	82 30       	cpi	r24, 0x02	; 2
    17ea:	c0 f3       	brcs	.-16     	; 0x17dc <prvIdleTask+0x5c>
			{
				taskYIELD();
    17ec:	34 dc       	rcall	.-1944   	; 0x1056 <vPortYield>
    17ee:	f6 cf       	rjmp	.-20     	; 0x17dc <prvIdleTask+0x5c>

000017f0 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    17f0:	80 91 07 09 	lds	r24, 0x0907
    17f4:	88 23       	and	r24, r24
    17f6:	21 f0       	breq	.+8      	; 0x1800 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    17f8:	81 e0       	ldi	r24, 0x01	; 1
    17fa:	80 93 0a 09 	sts	0x090A, r24
    17fe:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    1800:	10 92 0a 09 	sts	0x090A, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    1804:	80 91 0d 09 	lds	r24, 0x090D
    1808:	90 e0       	ldi	r25, 0x00	; 0
    180a:	fc 01       	movw	r30, r24
    180c:	ee 0f       	add	r30, r30
    180e:	ff 1f       	adc	r31, r31
    1810:	ee 0f       	add	r30, r30
    1812:	ff 1f       	adc	r31, r31
    1814:	ee 0f       	add	r30, r30
    1816:	ff 1f       	adc	r31, r31
    1818:	8e 0f       	add	r24, r30
    181a:	9f 1f       	adc	r25, r31
    181c:	fc 01       	movw	r30, r24
    181e:	e6 5c       	subi	r30, 0xC6	; 198
    1820:	f6 4f       	sbci	r31, 0xF6	; 246
    1822:	80 81       	ld	r24, Z
    1824:	81 11       	cpse	r24, r1
    1826:	17 c0       	rjmp	.+46     	; 0x1856 <vTaskSwitchContext+0x66>
    1828:	80 91 0d 09 	lds	r24, 0x090D
    182c:	81 50       	subi	r24, 0x01	; 1
    182e:	80 93 0d 09 	sts	0x090D, r24
    1832:	80 91 0d 09 	lds	r24, 0x090D
    1836:	90 e0       	ldi	r25, 0x00	; 0
    1838:	fc 01       	movw	r30, r24
    183a:	ee 0f       	add	r30, r30
    183c:	ff 1f       	adc	r31, r31
    183e:	ee 0f       	add	r30, r30
    1840:	ff 1f       	adc	r31, r31
    1842:	ee 0f       	add	r30, r30
    1844:	ff 1f       	adc	r31, r31
    1846:	8e 0f       	add	r24, r30
    1848:	9f 1f       	adc	r25, r31
    184a:	fc 01       	movw	r30, r24
    184c:	e6 5c       	subi	r30, 0xC6	; 198
    184e:	f6 4f       	sbci	r31, 0xF6	; 246
    1850:	80 81       	ld	r24, Z
    1852:	88 23       	and	r24, r24
    1854:	49 f3       	breq	.-46     	; 0x1828 <vTaskSwitchContext+0x38>
    1856:	e0 91 0d 09 	lds	r30, 0x090D
    185a:	f0 e0       	ldi	r31, 0x00	; 0
    185c:	cf 01       	movw	r24, r30
    185e:	88 0f       	add	r24, r24
    1860:	99 1f       	adc	r25, r25
    1862:	88 0f       	add	r24, r24
    1864:	99 1f       	adc	r25, r25
    1866:	88 0f       	add	r24, r24
    1868:	99 1f       	adc	r25, r25
    186a:	e8 0f       	add	r30, r24
    186c:	f9 1f       	adc	r31, r25
    186e:	e6 5c       	subi	r30, 0xC6	; 198
    1870:	f6 4f       	sbci	r31, 0xF6	; 246
    1872:	a1 81       	ldd	r26, Z+1	; 0x01
    1874:	b2 81       	ldd	r27, Z+2	; 0x02
    1876:	12 96       	adiw	r26, 0x02	; 2
    1878:	0d 90       	ld	r0, X+
    187a:	bc 91       	ld	r27, X
    187c:	a0 2d       	mov	r26, r0
    187e:	b2 83       	std	Z+2, r27	; 0x02
    1880:	a1 83       	std	Z+1, r26	; 0x01
    1882:	cf 01       	movw	r24, r30
    1884:	03 96       	adiw	r24, 0x03	; 3
    1886:	a8 17       	cp	r26, r24
    1888:	b9 07       	cpc	r27, r25
    188a:	31 f4       	brne	.+12     	; 0x1898 <vTaskSwitchContext+0xa8>
    188c:	12 96       	adiw	r26, 0x02	; 2
    188e:	8d 91       	ld	r24, X+
    1890:	9c 91       	ld	r25, X
    1892:	13 97       	sbiw	r26, 0x03	; 3
    1894:	92 83       	std	Z+2, r25	; 0x02
    1896:	81 83       	std	Z+1, r24	; 0x01
    1898:	01 80       	ldd	r0, Z+1	; 0x01
    189a:	f2 81       	ldd	r31, Z+2	; 0x02
    189c:	e0 2d       	mov	r30, r0
    189e:	86 81       	ldd	r24, Z+6	; 0x06
    18a0:	97 81       	ldd	r25, Z+7	; 0x07
    18a2:	90 93 5f 09 	sts	0x095F, r25
    18a6:	80 93 5e 09 	sts	0x095E, r24
    18aa:	08 95       	ret

000018ac <twi_init>:
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    18ac:	10 92 cd 09 	sts	0x09CD, r1
    18b0:	81 e0       	ldi	r24, 0x01	; 1
    18b2:	80 93 cb 09 	sts	0x09CB, r24
    18b6:	10 92 ca 09 	sts	0x09CA, r1
    18ba:	61 e0       	ldi	r22, 0x01	; 1
    18bc:	84 e1       	ldi	r24, 0x14	; 20
    18be:	02 d7       	rcall	.+3588   	; 0x26c4 <digitalWrite>
    18c0:	61 e0       	ldi	r22, 0x01	; 1
    18c2:	85 e1       	ldi	r24, 0x15	; 21
    18c4:	ff d6       	rcall	.+3582   	; 0x26c4 <digitalWrite>
    18c6:	e9 eb       	ldi	r30, 0xB9	; 185
    18c8:	f0 e0       	ldi	r31, 0x00	; 0
    18ca:	80 81       	ld	r24, Z
    18cc:	8e 7f       	andi	r24, 0xFE	; 254
    18ce:	80 83       	st	Z, r24
    18d0:	80 81       	ld	r24, Z
    18d2:	8d 7f       	andi	r24, 0xFD	; 253
    18d4:	80 83       	st	Z, r24
    18d6:	88 e4       	ldi	r24, 0x48	; 72
    18d8:	80 93 b8 00 	sts	0x00B8, r24
    18dc:	85 e4       	ldi	r24, 0x45	; 69
    18de:	80 93 bc 00 	sts	0x00BC, r24
    18e2:	08 95       	ret

000018e4 <twi_readFrom>:
    18e4:	41 32       	cpi	r20, 0x21	; 33
    18e6:	08 f0       	brcs	.+2      	; 0x18ea <twi_readFrom+0x6>
    18e8:	45 c0       	rjmp	.+138    	; 0x1974 <twi_readFrom+0x90>
    18ea:	90 91 cd 09 	lds	r25, 0x09CD
    18ee:	91 11       	cpse	r25, r1
    18f0:	fc cf       	rjmp	.-8      	; 0x18ea <twi_readFrom+0x6>
    18f2:	91 e0       	ldi	r25, 0x01	; 1
    18f4:	90 93 cd 09 	sts	0x09CD, r25
    18f8:	20 93 cb 09 	sts	0x09CB, r18
    18fc:	2f ef       	ldi	r18, 0xFF	; 255
    18fe:	20 93 60 09 	sts	0x0960, r18
    1902:	10 92 a5 09 	sts	0x09A5, r1
    1906:	24 0f       	add	r18, r20
    1908:	20 93 a4 09 	sts	0x09A4, r18
    190c:	90 93 cc 09 	sts	0x09CC, r25
    1910:	90 91 cc 09 	lds	r25, 0x09CC
    1914:	88 0f       	add	r24, r24
    1916:	89 2b       	or	r24, r25
    1918:	80 93 cc 09 	sts	0x09CC, r24
    191c:	80 91 ca 09 	lds	r24, 0x09CA
    1920:	81 30       	cpi	r24, 0x01	; 1
    1922:	51 f4       	brne	.+20     	; 0x1938 <twi_readFrom+0x54>
    1924:	10 92 ca 09 	sts	0x09CA, r1
    1928:	80 91 cc 09 	lds	r24, 0x09CC
    192c:	80 93 bb 00 	sts	0x00BB, r24
    1930:	85 ec       	ldi	r24, 0xC5	; 197
    1932:	80 93 bc 00 	sts	0x00BC, r24
    1936:	03 c0       	rjmp	.+6      	; 0x193e <twi_readFrom+0x5a>
    1938:	85 ee       	ldi	r24, 0xE5	; 229
    193a:	80 93 bc 00 	sts	0x00BC, r24
    193e:	80 91 cd 09 	lds	r24, 0x09CD
    1942:	81 30       	cpi	r24, 0x01	; 1
    1944:	e1 f3       	breq	.-8      	; 0x193e <twi_readFrom+0x5a>
    1946:	80 91 a5 09 	lds	r24, 0x09A5
    194a:	84 17       	cp	r24, r20
    194c:	10 f4       	brcc	.+4      	; 0x1952 <twi_readFrom+0x6e>
    194e:	40 91 a5 09 	lds	r20, 0x09A5
    1952:	44 23       	and	r20, r20
    1954:	89 f0       	breq	.+34     	; 0x1978 <twi_readFrom+0x94>
    1956:	e6 ea       	ldi	r30, 0xA6	; 166
    1958:	f9 e0       	ldi	r31, 0x09	; 9
    195a:	a6 2f       	mov	r26, r22
    195c:	b7 2f       	mov	r27, r23
    195e:	2f ef       	ldi	r18, 0xFF	; 255
    1960:	24 0f       	add	r18, r20
    1962:	30 e0       	ldi	r19, 0x00	; 0
    1964:	29 55       	subi	r18, 0x59	; 89
    1966:	36 4f       	sbci	r19, 0xF6	; 246
    1968:	91 91       	ld	r25, Z+
    196a:	9d 93       	st	X+, r25
    196c:	e2 17       	cp	r30, r18
    196e:	f3 07       	cpc	r31, r19
    1970:	d9 f7       	brne	.-10     	; 0x1968 <twi_readFrom+0x84>
    1972:	04 c0       	rjmp	.+8      	; 0x197c <twi_readFrom+0x98>
    1974:	80 e0       	ldi	r24, 0x00	; 0
    1976:	08 95       	ret
    1978:	84 2f       	mov	r24, r20
    197a:	08 95       	ret
    197c:	84 2f       	mov	r24, r20
    197e:	08 95       	ret

00001980 <twi_writeTo>:
    1980:	0f 93       	push	r16
    1982:	41 32       	cpi	r20, 0x21	; 33
    1984:	08 f0       	brcs	.+2      	; 0x1988 <twi_writeTo+0x8>
    1986:	50 c0       	rjmp	.+160    	; 0x1a28 <twi_writeTo+0xa8>
    1988:	90 91 cd 09 	lds	r25, 0x09CD
    198c:	91 11       	cpse	r25, r1
    198e:	fc cf       	rjmp	.-8      	; 0x1988 <twi_writeTo+0x8>
    1990:	92 e0       	ldi	r25, 0x02	; 2
    1992:	90 93 cd 09 	sts	0x09CD, r25
    1996:	00 93 cb 09 	sts	0x09CB, r16
    199a:	9f ef       	ldi	r25, 0xFF	; 255
    199c:	90 93 60 09 	sts	0x0960, r25
    19a0:	10 92 a5 09 	sts	0x09A5, r1
    19a4:	40 93 a4 09 	sts	0x09A4, r20
    19a8:	44 23       	and	r20, r20
    19aa:	69 f0       	breq	.+26     	; 0x19c6 <twi_writeTo+0x46>
    19ac:	fb 01       	movw	r30, r22
    19ae:	a6 ea       	ldi	r26, 0xA6	; 166
    19b0:	b9 e0       	ldi	r27, 0x09	; 9
    19b2:	6f 5f       	subi	r22, 0xFF	; 255
    19b4:	7f 4f       	sbci	r23, 0xFF	; 255
    19b6:	41 50       	subi	r20, 0x01	; 1
    19b8:	64 0f       	add	r22, r20
    19ba:	71 1d       	adc	r23, r1
    19bc:	91 91       	ld	r25, Z+
    19be:	9d 93       	st	X+, r25
    19c0:	e6 17       	cp	r30, r22
    19c2:	f7 07       	cpc	r31, r23
    19c4:	d9 f7       	brne	.-10     	; 0x19bc <twi_writeTo+0x3c>
    19c6:	10 92 cc 09 	sts	0x09CC, r1
    19ca:	90 91 cc 09 	lds	r25, 0x09CC
    19ce:	88 0f       	add	r24, r24
    19d0:	89 2b       	or	r24, r25
    19d2:	80 93 cc 09 	sts	0x09CC, r24
    19d6:	80 91 ca 09 	lds	r24, 0x09CA
    19da:	81 30       	cpi	r24, 0x01	; 1
    19dc:	51 f4       	brne	.+20     	; 0x19f2 <twi_writeTo+0x72>
    19de:	10 92 ca 09 	sts	0x09CA, r1
    19e2:	80 91 cc 09 	lds	r24, 0x09CC
    19e6:	80 93 bb 00 	sts	0x00BB, r24
    19ea:	85 ec       	ldi	r24, 0xC5	; 197
    19ec:	80 93 bc 00 	sts	0x00BC, r24
    19f0:	03 c0       	rjmp	.+6      	; 0x19f8 <twi_writeTo+0x78>
    19f2:	85 ee       	ldi	r24, 0xE5	; 229
    19f4:	80 93 bc 00 	sts	0x00BC, r24
    19f8:	22 23       	and	r18, r18
    19fa:	41 f0       	breq	.+16     	; 0x1a0c <twi_writeTo+0x8c>
    19fc:	80 91 cd 09 	lds	r24, 0x09CD
    1a00:	82 30       	cpi	r24, 0x02	; 2
    1a02:	21 f4       	brne	.+8      	; 0x1a0c <twi_writeTo+0x8c>
    1a04:	80 91 cd 09 	lds	r24, 0x09CD
    1a08:	82 30       	cpi	r24, 0x02	; 2
    1a0a:	e1 f3       	breq	.-8      	; 0x1a04 <twi_writeTo+0x84>
    1a0c:	80 91 60 09 	lds	r24, 0x0960
    1a10:	8f 3f       	cpi	r24, 0xFF	; 255
    1a12:	61 f0       	breq	.+24     	; 0x1a2c <twi_writeTo+0xac>
    1a14:	80 91 60 09 	lds	r24, 0x0960
    1a18:	80 32       	cpi	r24, 0x20	; 32
    1a1a:	51 f0       	breq	.+20     	; 0x1a30 <twi_writeTo+0xb0>
    1a1c:	80 91 60 09 	lds	r24, 0x0960
    1a20:	80 33       	cpi	r24, 0x30	; 48
    1a22:	41 f4       	brne	.+16     	; 0x1a34 <twi_writeTo+0xb4>
    1a24:	83 e0       	ldi	r24, 0x03	; 3
    1a26:	07 c0       	rjmp	.+14     	; 0x1a36 <twi_writeTo+0xb6>
    1a28:	81 e0       	ldi	r24, 0x01	; 1
    1a2a:	05 c0       	rjmp	.+10     	; 0x1a36 <twi_writeTo+0xb6>
    1a2c:	80 e0       	ldi	r24, 0x00	; 0
    1a2e:	03 c0       	rjmp	.+6      	; 0x1a36 <twi_writeTo+0xb6>
    1a30:	82 e0       	ldi	r24, 0x02	; 2
    1a32:	01 c0       	rjmp	.+2      	; 0x1a36 <twi_writeTo+0xb6>
    1a34:	84 e0       	ldi	r24, 0x04	; 4
    1a36:	0f 91       	pop	r16
    1a38:	08 95       	ret

00001a3a <twi_transmit>:
    1a3a:	61 32       	cpi	r22, 0x21	; 33
    1a3c:	a8 f4       	brcc	.+42     	; 0x1a68 <twi_transmit+0x2e>
    1a3e:	20 91 cd 09 	lds	r18, 0x09CD
    1a42:	24 30       	cpi	r18, 0x04	; 4
    1a44:	99 f4       	brne	.+38     	; 0x1a6c <twi_transmit+0x32>
    1a46:	60 93 82 09 	sts	0x0982, r22
    1a4a:	66 23       	and	r22, r22
    1a4c:	89 f0       	breq	.+34     	; 0x1a70 <twi_transmit+0x36>
    1a4e:	fc 01       	movw	r30, r24
    1a50:	a4 e8       	ldi	r26, 0x84	; 132
    1a52:	b9 e0       	ldi	r27, 0x09	; 9
    1a54:	01 96       	adiw	r24, 0x01	; 1
    1a56:	61 50       	subi	r22, 0x01	; 1
    1a58:	86 0f       	add	r24, r22
    1a5a:	91 1d       	adc	r25, r1
    1a5c:	21 91       	ld	r18, Z+
    1a5e:	2d 93       	st	X+, r18
    1a60:	e8 17       	cp	r30, r24
    1a62:	f9 07       	cpc	r31, r25
    1a64:	d9 f7       	brne	.-10     	; 0x1a5c <twi_transmit+0x22>
    1a66:	06 c0       	rjmp	.+12     	; 0x1a74 <twi_transmit+0x3a>
    1a68:	81 e0       	ldi	r24, 0x01	; 1
    1a6a:	08 95       	ret
    1a6c:	82 e0       	ldi	r24, 0x02	; 2
    1a6e:	08 95       	ret
    1a70:	80 e0       	ldi	r24, 0x00	; 0
    1a72:	08 95       	ret
    1a74:	80 e0       	ldi	r24, 0x00	; 0
    1a76:	08 95       	ret

00001a78 <twi_stop>:
 * Output   none
 */
void twi_stop(void)
{
  // send stop condition
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);
    1a78:	85 ed       	ldi	r24, 0xD5	; 213
    1a7a:	80 93 bc 00 	sts	0x00BC, r24

  // wait for stop condition to be exectued on bus
  // TWINT is not set after a stop condition!
  while(TWCR & _BV(TWSTO)){
    1a7e:	ec eb       	ldi	r30, 0xBC	; 188
    1a80:	f0 e0       	ldi	r31, 0x00	; 0
    1a82:	80 81       	ld	r24, Z
    1a84:	84 fd       	sbrc	r24, 4
    1a86:	fd cf       	rjmp	.-6      	; 0x1a82 <twi_stop+0xa>
    continue;
  }

  // update twi state
  twi_state = TWI_READY;
    1a88:	10 92 cd 09 	sts	0x09CD, r1
    1a8c:	08 95       	ret

00001a8e <twi_releaseBus>:
 * Output   none
 */
void twi_releaseBus(void)
{
  // release bus
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);
    1a8e:	85 ec       	ldi	r24, 0xC5	; 197
    1a90:	80 93 bc 00 	sts	0x00BC, r24

  // update twi state
  twi_state = TWI_READY;
    1a94:	10 92 cd 09 	sts	0x09CD, r1
    1a98:	08 95       	ret

00001a9a <__vector_39>:
}

ISR(TWI_vect)
{
    1a9a:	1f 92       	push	r1
    1a9c:	0f 92       	push	r0
    1a9e:	0f b6       	in	r0, 0x3f	; 63
    1aa0:	0f 92       	push	r0
    1aa2:	11 24       	eor	r1, r1
    1aa4:	0b b6       	in	r0, 0x3b	; 59
    1aa6:	0f 92       	push	r0
    1aa8:	2f 93       	push	r18
    1aaa:	3f 93       	push	r19
    1aac:	4f 93       	push	r20
    1aae:	5f 93       	push	r21
    1ab0:	6f 93       	push	r22
    1ab2:	7f 93       	push	r23
    1ab4:	8f 93       	push	r24
    1ab6:	9f 93       	push	r25
    1ab8:	af 93       	push	r26
    1aba:	bf 93       	push	r27
    1abc:	ef 93       	push	r30
    1abe:	ff 93       	push	r31
  switch(TW_STATUS){
    1ac0:	80 91 b9 00 	lds	r24, 0x00B9
    1ac4:	88 7f       	andi	r24, 0xF8	; 248
    1ac6:	90 e0       	ldi	r25, 0x00	; 0
    1ac8:	89 3c       	cpi	r24, 0xC9	; 201
    1aca:	91 05       	cpc	r25, r1
    1acc:	08 f0       	brcs	.+2      	; 0x1ad0 <__vector_39+0x36>
    1ace:	ed c0       	rjmp	.+474    	; 0x1caa <__vector_39+0x210>
    1ad0:	fc 01       	movw	r30, r24
    1ad2:	ee 58       	subi	r30, 0x8E	; 142
    1ad4:	ff 4f       	sbci	r31, 0xFF	; 255
    1ad6:	71 c6       	rjmp	.+3298   	; 0x27ba <__tablejump2__>
    // All Master
    case TW_START:     // sent start condition
    case TW_REP_START: // sent repeated start condition
      // copy device address and r/w bit to output register and ack
      TWDR = twi_slarw;
    1ad8:	80 91 cc 09 	lds	r24, 0x09CC
    1adc:	80 93 bb 00 	sts	0x00BB, r24
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    1ae0:	85 ec       	ldi	r24, 0xC5	; 197
    1ae2:	80 93 bc 00 	sts	0x00BC, r24
    1ae6:	e1 c0       	rjmp	.+450    	; 0x1caa <__vector_39+0x210>

    // Master Transmitter
    case TW_MT_SLA_ACK:  // slave receiver acked address
    case TW_MT_DATA_ACK: // slave receiver acked data
      // if there is data to send, send it, otherwise stop 
      if(twi_masterBufferIndex < twi_masterBufferLength){
    1ae8:	90 91 a5 09 	lds	r25, 0x09A5
    1aec:	80 91 a4 09 	lds	r24, 0x09A4
    1af0:	98 17       	cp	r25, r24
    1af2:	80 f4       	brcc	.+32     	; 0x1b14 <__vector_39+0x7a>
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
    1af4:	e0 91 a5 09 	lds	r30, 0x09A5
    1af8:	81 e0       	ldi	r24, 0x01	; 1
    1afa:	8e 0f       	add	r24, r30
    1afc:	80 93 a5 09 	sts	0x09A5, r24
    1b00:	f0 e0       	ldi	r31, 0x00	; 0
    1b02:	ea 55       	subi	r30, 0x5A	; 90
    1b04:	f6 4f       	sbci	r31, 0xF6	; 246
    1b06:	80 81       	ld	r24, Z
    1b08:	80 93 bb 00 	sts	0x00BB, r24
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    1b0c:	85 ec       	ldi	r24, 0xC5	; 197
    1b0e:	80 93 bc 00 	sts	0x00BC, r24
    1b12:	cb c0       	rjmp	.+406    	; 0x1caa <__vector_39+0x210>
      if(twi_masterBufferIndex < twi_masterBufferLength){
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
        twi_reply(1);
      }else{
	if (twi_sendStop)
    1b14:	80 91 cb 09 	lds	r24, 0x09CB
    1b18:	88 23       	and	r24, r24
    1b1a:	11 f0       	breq	.+4      	; 0x1b20 <__vector_39+0x86>
          twi_stop();
    1b1c:	ad df       	rcall	.-166    	; 0x1a78 <twi_stop>
    1b1e:	c5 c0       	rjmp	.+394    	; 0x1caa <__vector_39+0x210>
	else {
	  twi_inRepStart = true;	// we're gonna send the START
    1b20:	81 e0       	ldi	r24, 0x01	; 1
    1b22:	80 93 ca 09 	sts	0x09CA, r24
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
    1b26:	84 ea       	ldi	r24, 0xA4	; 164
    1b28:	80 93 bc 00 	sts	0x00BC, r24
	  twi_state = TWI_READY;
    1b2c:	10 92 cd 09 	sts	0x09CD, r1
    1b30:	bc c0       	rjmp	.+376    	; 0x1caa <__vector_39+0x210>
	}
      }
      break;
    case TW_MT_SLA_NACK:  // address sent, nack received
      twi_error = TW_MT_SLA_NACK;
    1b32:	80 e2       	ldi	r24, 0x20	; 32
    1b34:	80 93 60 09 	sts	0x0960, r24
      twi_stop();
    1b38:	9f df       	rcall	.-194    	; 0x1a78 <twi_stop>
      break;
    1b3a:	b7 c0       	rjmp	.+366    	; 0x1caa <__vector_39+0x210>
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
    1b3c:	80 e3       	ldi	r24, 0x30	; 48
    1b3e:	80 93 60 09 	sts	0x0960, r24
      twi_stop();
    1b42:	9a df       	rcall	.-204    	; 0x1a78 <twi_stop>
      break;
    1b44:	b2 c0       	rjmp	.+356    	; 0x1caa <__vector_39+0x210>
    case TW_MT_ARB_LOST: // lost bus arbitration
      twi_error = TW_MT_ARB_LOST;
    1b46:	88 e3       	ldi	r24, 0x38	; 56
    1b48:	80 93 60 09 	sts	0x0960, r24
      twi_releaseBus();
    1b4c:	a0 df       	rcall	.-192    	; 0x1a8e <twi_releaseBus>
      break;
    1b4e:	ad c0       	rjmp	.+346    	; 0x1caa <__vector_39+0x210>

    // Master Receiver
    case TW_MR_DATA_ACK: // data received, ack sent
      // put byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
    1b50:	e0 91 a5 09 	lds	r30, 0x09A5
    1b54:	81 e0       	ldi	r24, 0x01	; 1
    1b56:	8e 0f       	add	r24, r30
    1b58:	80 93 a5 09 	sts	0x09A5, r24
    1b5c:	80 91 bb 00 	lds	r24, 0x00BB
    1b60:	f0 e0       	ldi	r31, 0x00	; 0
    1b62:	ea 55       	subi	r30, 0x5A	; 90
    1b64:	f6 4f       	sbci	r31, 0xF6	; 246
    1b66:	80 83       	st	Z, r24
    case TW_MR_SLA_ACK:  // address sent, ack received
      // ack if more bytes are expected, otherwise nack
      if(twi_masterBufferIndex < twi_masterBufferLength){
    1b68:	90 91 a5 09 	lds	r25, 0x09A5
    1b6c:	80 91 a4 09 	lds	r24, 0x09A4
    1b70:	98 17       	cp	r25, r24
    1b72:	20 f4       	brcc	.+8      	; 0x1b7c <__vector_39+0xe2>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    1b74:	85 ec       	ldi	r24, 0xC5	; 197
    1b76:	80 93 bc 00 	sts	0x00BC, r24
    1b7a:	97 c0       	rjmp	.+302    	; 0x1caa <__vector_39+0x210>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    1b7c:	85 e8       	ldi	r24, 0x85	; 133
    1b7e:	80 93 bc 00 	sts	0x00BC, r24
    1b82:	93 c0       	rjmp	.+294    	; 0x1caa <__vector_39+0x210>
        twi_reply(0);
      }
      break;
    case TW_MR_DATA_NACK: // data received, nack sent
      // put final byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
    1b84:	e0 91 a5 09 	lds	r30, 0x09A5
    1b88:	81 e0       	ldi	r24, 0x01	; 1
    1b8a:	8e 0f       	add	r24, r30
    1b8c:	80 93 a5 09 	sts	0x09A5, r24
    1b90:	80 91 bb 00 	lds	r24, 0x00BB
    1b94:	f0 e0       	ldi	r31, 0x00	; 0
    1b96:	ea 55       	subi	r30, 0x5A	; 90
    1b98:	f6 4f       	sbci	r31, 0xF6	; 246
    1b9a:	80 83       	st	Z, r24
	if (twi_sendStop)
    1b9c:	80 91 cb 09 	lds	r24, 0x09CB
    1ba0:	88 23       	and	r24, r24
    1ba2:	11 f0       	breq	.+4      	; 0x1ba8 <__vector_39+0x10e>
          twi_stop();
    1ba4:	69 df       	rcall	.-302    	; 0x1a78 <twi_stop>
    1ba6:	81 c0       	rjmp	.+258    	; 0x1caa <__vector_39+0x210>
	else {
	  twi_inRepStart = true;	// we're gonna send the START
    1ba8:	81 e0       	ldi	r24, 0x01	; 1
    1baa:	80 93 ca 09 	sts	0x09CA, r24
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
    1bae:	84 ea       	ldi	r24, 0xA4	; 164
    1bb0:	80 93 bc 00 	sts	0x00BC, r24
	  twi_state = TWI_READY;
    1bb4:	10 92 cd 09 	sts	0x09CD, r1
    1bb8:	78 c0       	rjmp	.+240    	; 0x1caa <__vector_39+0x210>
	}    
	break;
    case TW_MR_SLA_NACK: // address sent, nack received
      twi_stop();
    1bba:	5e df       	rcall	.-324    	; 0x1a78 <twi_stop>
      break;
    1bbc:	76 c0       	rjmp	.+236    	; 0x1caa <__vector_39+0x210>
    case TW_SR_SLA_ACK:   // addressed, returned ack
    case TW_SR_GCALL_ACK: // addressed generally, returned ack
    case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack
    case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack
      // enter slave receiver mode
      twi_state = TWI_SRX;
    1bbe:	83 e0       	ldi	r24, 0x03	; 3
    1bc0:	80 93 cd 09 	sts	0x09CD, r24
      // indicate that rx buffer can be overwritten and ack
      twi_rxBufferIndex = 0;
    1bc4:	10 92 61 09 	sts	0x0961, r1
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    1bc8:	85 ec       	ldi	r24, 0xC5	; 197
    1bca:	80 93 bc 00 	sts	0x00BC, r24
    1bce:	6d c0       	rjmp	.+218    	; 0x1caa <__vector_39+0x210>
      twi_reply(1);
      break;
    case TW_SR_DATA_ACK:       // data received, returned ack
    case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack
      // if there is still room in the rx buffer
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
    1bd0:	80 91 61 09 	lds	r24, 0x0961
    1bd4:	80 32       	cpi	r24, 0x20	; 32
    1bd6:	80 f4       	brcc	.+32     	; 0x1bf8 <__vector_39+0x15e>
        // put byte in buffer and ack
        twi_rxBuffer[twi_rxBufferIndex++] = TWDR;
    1bd8:	e0 91 61 09 	lds	r30, 0x0961
    1bdc:	81 e0       	ldi	r24, 0x01	; 1
    1bde:	8e 0f       	add	r24, r30
    1be0:	80 93 61 09 	sts	0x0961, r24
    1be4:	80 91 bb 00 	lds	r24, 0x00BB
    1be8:	f0 e0       	ldi	r31, 0x00	; 0
    1bea:	ee 59       	subi	r30, 0x9E	; 158
    1bec:	f6 4f       	sbci	r31, 0xF6	; 246
    1bee:	80 83       	st	Z, r24
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    1bf0:	85 ec       	ldi	r24, 0xC5	; 197
    1bf2:	80 93 bc 00 	sts	0x00BC, r24
    1bf6:	59 c0       	rjmp	.+178    	; 0x1caa <__vector_39+0x210>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    1bf8:	85 e8       	ldi	r24, 0x85	; 133
    1bfa:	80 93 bc 00 	sts	0x00BC, r24
    1bfe:	55 c0       	rjmp	.+170    	; 0x1caa <__vector_39+0x210>
        twi_reply(0);
      }
      break;
    case TW_SR_STOP: // stop or repeated start condition received
      // put a null char after data if there's room
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
    1c00:	80 91 61 09 	lds	r24, 0x0961
    1c04:	80 32       	cpi	r24, 0x20	; 32
    1c06:	30 f4       	brcc	.+12     	; 0x1c14 <__vector_39+0x17a>
        twi_rxBuffer[twi_rxBufferIndex] = '\0';
    1c08:	e0 91 61 09 	lds	r30, 0x0961
    1c0c:	f0 e0       	ldi	r31, 0x00	; 0
    1c0e:	ee 59       	subi	r30, 0x9E	; 158
    1c10:	f6 4f       	sbci	r31, 0xF6	; 246
    1c12:	10 82       	st	Z, r1
      }
      // sends ack and stops interface for clock stretching
      twi_stop();
    1c14:	31 df       	rcall	.-414    	; 0x1a78 <twi_stop>
      // callback to user defined callback
      twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);
    1c16:	60 91 61 09 	lds	r22, 0x0961
    1c1a:	70 e0       	ldi	r23, 0x00	; 0
    1c1c:	e0 91 c6 09 	lds	r30, 0x09C6
    1c20:	f0 91 c7 09 	lds	r31, 0x09C7
    1c24:	82 e6       	ldi	r24, 0x62	; 98
    1c26:	99 e0       	ldi	r25, 0x09	; 9
    1c28:	19 95       	eicall
      // since we submit rx buffer to "wire" library, we can reset it
      twi_rxBufferIndex = 0;
    1c2a:	10 92 61 09 	sts	0x0961, r1
      // ack future responses and leave slave receiver state
      twi_releaseBus();
    1c2e:	2f df       	rcall	.-418    	; 0x1a8e <twi_releaseBus>
      break;
    1c30:	3c c0       	rjmp	.+120    	; 0x1caa <__vector_39+0x210>
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    1c32:	85 e8       	ldi	r24, 0x85	; 133
    1c34:	80 93 bc 00 	sts	0x00BC, r24
    1c38:	38 c0       	rjmp	.+112    	; 0x1caa <__vector_39+0x210>
    
    // Slave Transmitter
    case TW_ST_SLA_ACK:          // addressed, returned ack
    case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack
      // enter slave transmitter mode
      twi_state = TWI_STX;
    1c3a:	84 e0       	ldi	r24, 0x04	; 4
    1c3c:	80 93 cd 09 	sts	0x09CD, r24
      // ready the tx buffer index for iteration
      twi_txBufferIndex = 0;
    1c40:	10 92 83 09 	sts	0x0983, r1
      // set tx buffer length to be zero, to verify if user changes it
      twi_txBufferLength = 0;
    1c44:	10 92 82 09 	sts	0x0982, r1
      // request for txBuffer to be filled and length to be set
      // note: user must call twi_transmit(bytes, length) to do this
      twi_onSlaveTransmit();
    1c48:	e0 91 c8 09 	lds	r30, 0x09C8
    1c4c:	f0 91 c9 09 	lds	r31, 0x09C9
    1c50:	19 95       	eicall
      // if they didn't change buffer & length, initialize it
      if(0 == twi_txBufferLength){
    1c52:	80 91 82 09 	lds	r24, 0x0982
    1c56:	81 11       	cpse	r24, r1
    1c58:	05 c0       	rjmp	.+10     	; 0x1c64 <__vector_39+0x1ca>
        twi_txBufferLength = 1;
    1c5a:	81 e0       	ldi	r24, 0x01	; 1
    1c5c:	80 93 82 09 	sts	0x0982, r24
        twi_txBuffer[0] = 0x00;
    1c60:	10 92 84 09 	sts	0x0984, r1
      }
      // transmit first byte from buffer, fall
    case TW_ST_DATA_ACK: // byte sent, ack returned
      // copy data to output register
      TWDR = twi_txBuffer[twi_txBufferIndex++];
    1c64:	e0 91 83 09 	lds	r30, 0x0983
    1c68:	81 e0       	ldi	r24, 0x01	; 1
    1c6a:	8e 0f       	add	r24, r30
    1c6c:	80 93 83 09 	sts	0x0983, r24
    1c70:	f0 e0       	ldi	r31, 0x00	; 0
    1c72:	ec 57       	subi	r30, 0x7C	; 124
    1c74:	f6 4f       	sbci	r31, 0xF6	; 246
    1c76:	80 81       	ld	r24, Z
    1c78:	80 93 bb 00 	sts	0x00BB, r24
      // if there is more to send, ack, otherwise nack
      if(twi_txBufferIndex < twi_txBufferLength){
    1c7c:	90 91 83 09 	lds	r25, 0x0983
    1c80:	80 91 82 09 	lds	r24, 0x0982
    1c84:	98 17       	cp	r25, r24
    1c86:	20 f4       	brcc	.+8      	; 0x1c90 <__vector_39+0x1f6>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    1c88:	85 ec       	ldi	r24, 0xC5	; 197
    1c8a:	80 93 bc 00 	sts	0x00BC, r24
    1c8e:	0d c0       	rjmp	.+26     	; 0x1caa <__vector_39+0x210>
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    1c90:	85 e8       	ldi	r24, 0x85	; 133
    1c92:	80 93 bc 00 	sts	0x00BC, r24
    1c96:	09 c0       	rjmp	.+18     	; 0x1caa <__vector_39+0x210>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    1c98:	85 ec       	ldi	r24, 0xC5	; 197
    1c9a:	80 93 bc 00 	sts	0x00BC, r24
    case TW_ST_DATA_NACK: // received nack, we are done 
    case TW_ST_LAST_DATA: // received ack, but we are done already!
      // ack future responses
      twi_reply(1);
      // leave slave receiver state
      twi_state = TWI_READY;
    1c9e:	10 92 cd 09 	sts	0x09CD, r1
      break;
    1ca2:	03 c0       	rjmp	.+6      	; 0x1caa <__vector_39+0x210>

    // All
    case TW_NO_INFO:   // no state information
      break;
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
    1ca4:	10 92 60 09 	sts	0x0960, r1
      twi_stop();
    1ca8:	e7 de       	rcall	.-562    	; 0x1a78 <twi_stop>
      break;
  }
}
    1caa:	ff 91       	pop	r31
    1cac:	ef 91       	pop	r30
    1cae:	bf 91       	pop	r27
    1cb0:	af 91       	pop	r26
    1cb2:	9f 91       	pop	r25
    1cb4:	8f 91       	pop	r24
    1cb6:	7f 91       	pop	r23
    1cb8:	6f 91       	pop	r22
    1cba:	5f 91       	pop	r21
    1cbc:	4f 91       	pop	r20
    1cbe:	3f 91       	pop	r19
    1cc0:	2f 91       	pop	r18
    1cc2:	0f 90       	pop	r0
    1cc4:	0b be       	out	0x3b, r0	; 59
    1cc6:	0f 90       	pop	r0
    1cc8:	0f be       	out	0x3f, r0	; 63
    1cca:	0f 90       	pop	r0
    1ccc:	1f 90       	pop	r1
    1cce:	18 95       	reti

00001cd0 <_ZN7TwoWire9availableEv>:
}

// sets function called on slave read
void TwoWire::onRequest( void (*function)(void) )
{
  user_onRequest = function;
    1cd0:	80 91 fe 09 	lds	r24, 0x09FE
    1cd4:	90 e0       	ldi	r25, 0x00	; 0
    1cd6:	20 91 ff 09 	lds	r18, 0x09FF
    1cda:	82 1b       	sub	r24, r18
    1cdc:	91 09       	sbc	r25, r1
    1cde:	08 95       	ret

00001ce0 <_ZN7TwoWire4readEv>:
    1ce0:	20 91 ff 09 	lds	r18, 0x09FF
    1ce4:	80 91 fe 09 	lds	r24, 0x09FE
    1ce8:	28 17       	cp	r18, r24
    1cea:	50 f4       	brcc	.+20     	; 0x1d00 <_ZN7TwoWire4readEv+0x20>
    1cec:	e2 2f       	mov	r30, r18
    1cee:	f0 e0       	ldi	r31, 0x00	; 0
    1cf0:	e0 50       	subi	r30, 0x00	; 0
    1cf2:	f6 4f       	sbci	r31, 0xF6	; 246
    1cf4:	80 81       	ld	r24, Z
    1cf6:	90 e0       	ldi	r25, 0x00	; 0
    1cf8:	2f 5f       	subi	r18, 0xFF	; 255
    1cfa:	20 93 ff 09 	sts	0x09FF, r18
    1cfe:	08 95       	ret
    1d00:	8f ef       	ldi	r24, 0xFF	; 255
    1d02:	9f ef       	ldi	r25, 0xFF	; 255
    1d04:	08 95       	ret

00001d06 <_ZN7TwoWire4peekEv>:
    1d06:	e0 91 ff 09 	lds	r30, 0x09FF
    1d0a:	80 91 fe 09 	lds	r24, 0x09FE
    1d0e:	e8 17       	cp	r30, r24
    1d10:	30 f4       	brcc	.+12     	; 0x1d1e <_ZN7TwoWire4peekEv+0x18>
    1d12:	f0 e0       	ldi	r31, 0x00	; 0
    1d14:	e0 50       	subi	r30, 0x00	; 0
    1d16:	f6 4f       	sbci	r31, 0xF6	; 246
    1d18:	80 81       	ld	r24, Z
    1d1a:	90 e0       	ldi	r25, 0x00	; 0
    1d1c:	08 95       	ret
    1d1e:	8f ef       	ldi	r24, 0xFF	; 255
    1d20:	9f ef       	ldi	r25, 0xFF	; 255
    1d22:	08 95       	ret

00001d24 <_ZN7TwoWire5flushEv>:
    1d24:	08 95       	ret

00001d26 <_ZN7TwoWire5writeEPKhj>:
    1d26:	cf 92       	push	r12
    1d28:	df 92       	push	r13
    1d2a:	ef 92       	push	r14
    1d2c:	ff 92       	push	r15
    1d2e:	0f 93       	push	r16
    1d30:	1f 93       	push	r17
    1d32:	cf 93       	push	r28
    1d34:	df 93       	push	r29
    1d36:	8c 01       	movw	r16, r24
    1d38:	7b 01       	movw	r14, r22
    1d3a:	6a 01       	movw	r12, r20
    1d3c:	80 91 da 09 	lds	r24, 0x09DA
    1d40:	88 23       	and	r24, r24
    1d42:	99 f0       	breq	.+38     	; 0x1d6a <_ZN7TwoWire5writeEPKhj+0x44>
    1d44:	41 15       	cp	r20, r1
    1d46:	51 05       	cpc	r21, r1
    1d48:	99 f0       	breq	.+38     	; 0x1d70 <_ZN7TwoWire5writeEPKhj+0x4a>
    1d4a:	eb 01       	movw	r28, r22
    1d4c:	e4 0e       	add	r14, r20
    1d4e:	f5 1e       	adc	r15, r21
    1d50:	69 91       	ld	r22, Y+
    1d52:	d8 01       	movw	r26, r16
    1d54:	ed 91       	ld	r30, X+
    1d56:	fc 91       	ld	r31, X
    1d58:	01 90       	ld	r0, Z+
    1d5a:	f0 81       	ld	r31, Z
    1d5c:	e0 2d       	mov	r30, r0
    1d5e:	c8 01       	movw	r24, r16
    1d60:	19 95       	eicall
    1d62:	ce 15       	cp	r28, r14
    1d64:	df 05       	cpc	r29, r15
    1d66:	a1 f7       	brne	.-24     	; 0x1d50 <_ZN7TwoWire5writeEPKhj+0x2a>
    1d68:	03 c0       	rjmp	.+6      	; 0x1d70 <_ZN7TwoWire5writeEPKhj+0x4a>
    1d6a:	64 2f       	mov	r22, r20
    1d6c:	c7 01       	movw	r24, r14
    1d6e:	65 de       	rcall	.-822    	; 0x1a3a <twi_transmit>
    1d70:	c6 01       	movw	r24, r12
    1d72:	df 91       	pop	r29
    1d74:	cf 91       	pop	r28
    1d76:	1f 91       	pop	r17
    1d78:	0f 91       	pop	r16
    1d7a:	ff 90       	pop	r15
    1d7c:	ef 90       	pop	r14
    1d7e:	df 90       	pop	r13
    1d80:	cf 90       	pop	r12
    1d82:	08 95       	ret

00001d84 <_ZN7TwoWire5writeEh>:
    1d84:	cf 93       	push	r28
    1d86:	df 93       	push	r29
    1d88:	1f 92       	push	r1
    1d8a:	cd b7       	in	r28, 0x3d	; 61
    1d8c:	de b7       	in	r29, 0x3e	; 62
    1d8e:	69 83       	std	Y+1, r22	; 0x01
    1d90:	20 91 da 09 	lds	r18, 0x09DA
    1d94:	22 23       	and	r18, r18
    1d96:	e1 f0       	breq	.+56     	; 0x1dd0 <_ZN7TwoWire5writeEh+0x4c>
    1d98:	20 91 db 09 	lds	r18, 0x09DB
    1d9c:	20 32       	cpi	r18, 0x20	; 32
    1d9e:	40 f0       	brcs	.+16     	; 0x1db0 <_ZN7TwoWire5writeEh+0x2c>
    1da0:	21 e0       	ldi	r18, 0x01	; 1
    1da2:	30 e0       	ldi	r19, 0x00	; 0
    1da4:	fc 01       	movw	r30, r24
    1da6:	33 83       	std	Z+3, r19	; 0x03
    1da8:	22 83       	std	Z+2, r18	; 0x02
    1daa:	80 e0       	ldi	r24, 0x00	; 0
    1dac:	90 e0       	ldi	r25, 0x00	; 0
    1dae:	16 c0       	rjmp	.+44     	; 0x1ddc <_ZN7TwoWire5writeEh+0x58>
    1db0:	80 91 dc 09 	lds	r24, 0x09DC
    1db4:	e8 2f       	mov	r30, r24
    1db6:	f0 e0       	ldi	r31, 0x00	; 0
    1db8:	e3 52       	subi	r30, 0x23	; 35
    1dba:	f6 4f       	sbci	r31, 0xF6	; 246
    1dbc:	99 81       	ldd	r25, Y+1	; 0x01
    1dbe:	90 83       	st	Z, r25
    1dc0:	8f 5f       	subi	r24, 0xFF	; 255
    1dc2:	80 93 dc 09 	sts	0x09DC, r24
    1dc6:	80 93 db 09 	sts	0x09DB, r24
    1dca:	81 e0       	ldi	r24, 0x01	; 1
    1dcc:	90 e0       	ldi	r25, 0x00	; 0
    1dce:	06 c0       	rjmp	.+12     	; 0x1ddc <_ZN7TwoWire5writeEh+0x58>
    1dd0:	61 e0       	ldi	r22, 0x01	; 1
    1dd2:	ce 01       	movw	r24, r28
    1dd4:	01 96       	adiw	r24, 0x01	; 1
    1dd6:	31 de       	rcall	.-926    	; 0x1a3a <twi_transmit>
    1dd8:	81 e0       	ldi	r24, 0x01	; 1
    1dda:	90 e0       	ldi	r25, 0x00	; 0
    1ddc:	0f 90       	pop	r0
    1dde:	df 91       	pop	r29
    1de0:	cf 91       	pop	r28
    1de2:	08 95       	ret

00001de4 <_ZN7TwoWireC1Ev>:
    1de4:	fc 01       	movw	r30, r24
    1de6:	13 82       	std	Z+3, r1	; 0x03
    1de8:	12 82       	std	Z+2, r1	; 0x02
    1dea:	48 ee       	ldi	r20, 0xE8	; 232
    1dec:	53 e0       	ldi	r21, 0x03	; 3
    1dee:	60 e0       	ldi	r22, 0x00	; 0
    1df0:	70 e0       	ldi	r23, 0x00	; 0
    1df2:	44 83       	std	Z+4, r20	; 0x04
    1df4:	55 83       	std	Z+5, r21	; 0x05
    1df6:	66 83       	std	Z+6, r22	; 0x06
    1df8:	77 83       	std	Z+7, r23	; 0x07
    1dfa:	8d e4       	ldi	r24, 0x4D	; 77
    1dfc:	92 e0       	ldi	r25, 0x02	; 2
    1dfe:	91 83       	std	Z+1, r25	; 0x01
    1e00:	80 83       	st	Z, r24
    1e02:	08 95       	ret

00001e04 <_ZN7TwoWire5beginEv>:
    1e04:	10 92 ff 09 	sts	0x09FF, r1
    1e08:	10 92 fe 09 	sts	0x09FE, r1
    1e0c:	10 92 dc 09 	sts	0x09DC, r1
    1e10:	10 92 db 09 	sts	0x09DB, r1
    1e14:	4b cd       	rjmp	.-1386   	; 0x18ac <twi_init>
    1e16:	08 95       	ret

00001e18 <_ZN7TwoWire11requestFromEhhh>:
    1e18:	86 2f       	mov	r24, r22
    1e1a:	41 32       	cpi	r20, 0x21	; 33
    1e1c:	08 f0       	brcs	.+2      	; 0x1e20 <_ZN7TwoWire11requestFromEhhh+0x8>
    1e1e:	40 e2       	ldi	r20, 0x20	; 32
    1e20:	60 e0       	ldi	r22, 0x00	; 0
    1e22:	7a e0       	ldi	r23, 0x0A	; 10
    1e24:	5f dd       	rcall	.-1346   	; 0x18e4 <twi_readFrom>
    1e26:	10 92 ff 09 	sts	0x09FF, r1
    1e2a:	80 93 fe 09 	sts	0x09FE, r24
    1e2e:	08 95       	ret

00001e30 <_ZN7TwoWire11requestFromEhh>:
    1e30:	21 e0       	ldi	r18, 0x01	; 1
    1e32:	f2 cf       	rjmp	.-28     	; 0x1e18 <_ZN7TwoWire11requestFromEhhh>
    1e34:	08 95       	ret

00001e36 <_ZN7TwoWire17beginTransmissionEh>:
    1e36:	81 e0       	ldi	r24, 0x01	; 1
    1e38:	80 93 da 09 	sts	0x09DA, r24
    1e3c:	60 93 fd 09 	sts	0x09FD, r22
    1e40:	10 92 dc 09 	sts	0x09DC, r1
    1e44:	10 92 db 09 	sts	0x09DB, r1
    1e48:	08 95       	ret

00001e4a <_ZN7TwoWire15endTransmissionEh>:
    1e4a:	0f 93       	push	r16
    1e4c:	06 2f       	mov	r16, r22
    1e4e:	21 e0       	ldi	r18, 0x01	; 1
    1e50:	40 91 db 09 	lds	r20, 0x09DB
    1e54:	6d ed       	ldi	r22, 0xDD	; 221
    1e56:	79 e0       	ldi	r23, 0x09	; 9
    1e58:	80 91 fd 09 	lds	r24, 0x09FD
    1e5c:	91 dd       	rcall	.-1246   	; 0x1980 <twi_writeTo>
    1e5e:	10 92 dc 09 	sts	0x09DC, r1
    1e62:	10 92 db 09 	sts	0x09DB, r1
    1e66:	10 92 da 09 	sts	0x09DA, r1
    1e6a:	0f 91       	pop	r16
    1e6c:	08 95       	ret

00001e6e <_ZN7TwoWire15endTransmissionEv>:
    1e6e:	61 e0       	ldi	r22, 0x01	; 1
    1e70:	ec cf       	rjmp	.-40     	; 0x1e4a <_ZN7TwoWire15endTransmissionEh>
    1e72:	08 95       	ret

00001e74 <_GLOBAL__sub_I__ZN7TwoWire8rxBufferE>:
}

// Preinstantiate Objects //////////////////////////////////////////////////////

TwoWire Wire = TwoWire();
    1e74:	8e ec       	ldi	r24, 0xCE	; 206
    1e76:	99 e0       	ldi	r25, 0x09	; 9
    1e78:	b5 cf       	rjmp	.-150    	; 0x1de4 <_ZN7TwoWireC1Ev>
    1e7a:	08 95       	ret

00001e7c <_ZN14HardwareSerial9availableEv>:
#endif
#if defined(HAVE_HWSERIAL2)
  if (Serial2_available && serialEvent2 && Serial2_available()) serialEvent2();
#endif
#if defined(HAVE_HWSERIAL3)
  if (Serial3_available && serialEvent3 && Serial3_available()) serialEvent3();
    1e7c:	fc 01       	movw	r30, r24
    1e7e:	81 8d       	ldd	r24, Z+25	; 0x19
    1e80:	22 8d       	ldd	r18, Z+26	; 0x1a
    1e82:	90 e0       	ldi	r25, 0x00	; 0
    1e84:	80 5c       	subi	r24, 0xC0	; 192
    1e86:	9f 4f       	sbci	r25, 0xFF	; 255
    1e88:	82 1b       	sub	r24, r18
    1e8a:	91 09       	sbc	r25, r1
    1e8c:	8f 73       	andi	r24, 0x3F	; 63
    1e8e:	99 27       	eor	r25, r25
    1e90:	08 95       	ret

00001e92 <_ZN14HardwareSerial4peekEv>:
    1e92:	fc 01       	movw	r30, r24
    1e94:	91 8d       	ldd	r25, Z+25	; 0x19
    1e96:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e98:	98 17       	cp	r25, r24
    1e9a:	31 f0       	breq	.+12     	; 0x1ea8 <_ZN14HardwareSerial4peekEv+0x16>
    1e9c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e9e:	e8 0f       	add	r30, r24
    1ea0:	f1 1d       	adc	r31, r1
    1ea2:	85 8d       	ldd	r24, Z+29	; 0x1d
    1ea4:	90 e0       	ldi	r25, 0x00	; 0
    1ea6:	08 95       	ret
    1ea8:	8f ef       	ldi	r24, 0xFF	; 255
    1eaa:	9f ef       	ldi	r25, 0xFF	; 255
    1eac:	08 95       	ret

00001eae <_ZN14HardwareSerial4readEv>:
    1eae:	fc 01       	movw	r30, r24
    1eb0:	91 8d       	ldd	r25, Z+25	; 0x19
    1eb2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1eb4:	98 17       	cp	r25, r24
    1eb6:	61 f0       	breq	.+24     	; 0x1ed0 <_ZN14HardwareSerial4readEv+0x22>
    1eb8:	82 8d       	ldd	r24, Z+26	; 0x1a
    1eba:	df 01       	movw	r26, r30
    1ebc:	a8 0f       	add	r26, r24
    1ebe:	b1 1d       	adc	r27, r1
    1ec0:	5d 96       	adiw	r26, 0x1d	; 29
    1ec2:	8c 91       	ld	r24, X
    1ec4:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ec6:	9f 5f       	subi	r25, 0xFF	; 255
    1ec8:	9f 73       	andi	r25, 0x3F	; 63
    1eca:	92 8f       	std	Z+26, r25	; 0x1a
    1ecc:	90 e0       	ldi	r25, 0x00	; 0
    1ece:	08 95       	ret
    1ed0:	8f ef       	ldi	r24, 0xFF	; 255
    1ed2:	9f ef       	ldi	r25, 0xFF	; 255
    1ed4:	08 95       	ret

00001ed6 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
}

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
    1ed6:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
    1ed8:	84 8d       	ldd	r24, Z+28	; 0x1c
    1eda:	df 01       	movw	r26, r30
    1edc:	a8 0f       	add	r26, r24
    1ede:	b1 1d       	adc	r27, r1
    1ee0:	a3 5a       	subi	r26, 0xA3	; 163
    1ee2:	bf 4f       	sbci	r27, 0xFF	; 255
    1ee4:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
    1ee6:	84 8d       	ldd	r24, Z+28	; 0x1c
    1ee8:	90 e0       	ldi	r25, 0x00	; 0
    1eea:	01 96       	adiw	r24, 0x01	; 1
    1eec:	8f 73       	andi	r24, 0x3F	; 63
    1eee:	90 78       	andi	r25, 0x80	; 128
    1ef0:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
    1ef2:	a6 89       	ldd	r26, Z+22	; 0x16
    1ef4:	b7 89       	ldd	r27, Z+23	; 0x17
    1ef6:	2c 93       	st	X, r18

  // clear the TXC bit -- "can be cleared by writing a one to its bit
  // location". This makes sure flush() won't return until the bytes
  // actually got written
  sbi(*_ucsra, TXC0);
    1ef8:	a0 89       	ldd	r26, Z+16	; 0x10
    1efa:	b1 89       	ldd	r27, Z+17	; 0x11
    1efc:	8c 91       	ld	r24, X
    1efe:	80 64       	ori	r24, 0x40	; 64
    1f00:	8c 93       	st	X, r24

  if (_tx_buffer_head == _tx_buffer_tail) {
    1f02:	93 8d       	ldd	r25, Z+27	; 0x1b
    1f04:	84 8d       	ldd	r24, Z+28	; 0x1c
    1f06:	98 13       	cpse	r25, r24
    1f08:	06 c0       	rjmp	.+12     	; 0x1f16 <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x40>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
    1f0a:	02 88       	ldd	r0, Z+18	; 0x12
    1f0c:	f3 89       	ldd	r31, Z+19	; 0x13
    1f0e:	e0 2d       	mov	r30, r0
    1f10:	80 81       	ld	r24, Z
    1f12:	8f 7d       	andi	r24, 0xDF	; 223
    1f14:	80 83       	st	Z, r24
    1f16:	08 95       	ret

00001f18 <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
    1f18:	cf 93       	push	r28
    1f1a:	df 93       	push	r29
    1f1c:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    1f1e:	88 8d       	ldd	r24, Y+24	; 0x18
    1f20:	81 11       	cpse	r24, r1
    1f22:	0a c0       	rjmp	.+20     	; 0x1f38 <_ZN14HardwareSerial5flushEv+0x20>
    1f24:	1a c0       	rjmp	.+52     	; 0x1f5a <_ZN14HardwareSerial5flushEv+0x42>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
    1f26:	0f b6       	in	r0, 0x3f	; 63
    1f28:	07 fc       	sbrc	r0, 7
    1f2a:	08 c0       	rjmp	.+16     	; 0x1f3c <_ZN14HardwareSerial5flushEv+0x24>
    1f2c:	80 81       	ld	r24, Z
    1f2e:	85 ff       	sbrs	r24, 5
    1f30:	05 c0       	rjmp	.+10     	; 0x1f3c <_ZN14HardwareSerial5flushEv+0x24>
    1f32:	0d c0       	rjmp	.+26     	; 0x1f4e <_ZN14HardwareSerial5flushEv+0x36>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
	  _tx_udr_empty_irq();
    1f34:	ce 01       	movw	r24, r28
    1f36:	cf df       	rcall	.-98     	; 0x1ed6 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    1f38:	ea 89       	ldd	r30, Y+18	; 0x12
    1f3a:	fb 89       	ldd	r31, Y+19	; 0x13
    1f3c:	80 81       	ld	r24, Z
    1f3e:	85 fd       	sbrc	r24, 5
    1f40:	f2 cf       	rjmp	.-28     	; 0x1f26 <_ZN14HardwareSerial5flushEv+0xe>
    1f42:	a8 89       	ldd	r26, Y+16	; 0x10
    1f44:	b9 89       	ldd	r27, Y+17	; 0x11
    1f46:	8c 91       	ld	r24, X
    1f48:	86 ff       	sbrs	r24, 6
    1f4a:	ed cf       	rjmp	.-38     	; 0x1f26 <_ZN14HardwareSerial5flushEv+0xe>
    1f4c:	06 c0       	rjmp	.+12     	; 0x1f5a <_ZN14HardwareSerial5flushEv+0x42>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
    1f4e:	a8 89       	ldd	r26, Y+16	; 0x10
    1f50:	b9 89       	ldd	r27, Y+17	; 0x11
    1f52:	8c 91       	ld	r24, X
    1f54:	85 ff       	sbrs	r24, 5
    1f56:	f2 cf       	rjmp	.-28     	; 0x1f3c <_ZN14HardwareSerial5flushEv+0x24>
    1f58:	ed cf       	rjmp	.-38     	; 0x1f34 <_ZN14HardwareSerial5flushEv+0x1c>
	  _tx_udr_empty_irq();
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
    1f5a:	df 91       	pop	r29
    1f5c:	cf 91       	pop	r28
    1f5e:	08 95       	ret

00001f60 <_ZN14HardwareSerial5writeEh>:

size_t HardwareSerial::write(uint8_t c)
{
    1f60:	0f 93       	push	r16
    1f62:	1f 93       	push	r17
    1f64:	cf 93       	push	r28
    1f66:	df 93       	push	r29
    1f68:	ec 01       	movw	r28, r24
    1f6a:	16 2f       	mov	r17, r22
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    1f6c:	9b 8d       	ldd	r25, Y+27	; 0x1b
    1f6e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1f70:	98 13       	cpse	r25, r24
    1f72:	23 c0       	rjmp	.+70     	; 0x1fba <_ZN14HardwareSerial5writeEh+0x5a>
    1f74:	e8 89       	ldd	r30, Y+16	; 0x10
    1f76:	f9 89       	ldd	r31, Y+17	; 0x11
    1f78:	80 81       	ld	r24, Z
    1f7a:	85 fd       	sbrc	r24, 5
    1f7c:	25 c0       	rjmp	.+74     	; 0x1fc8 <_ZN14HardwareSerial5writeEh+0x68>
    1f7e:	1d c0       	rjmp	.+58     	; 0x1fba <_ZN14HardwareSerial5writeEh+0x5a>
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    if (bit_is_clear(SREG, SREG_I)) {
    1f80:	0f b6       	in	r0, 0x3f	; 63
    1f82:	07 fc       	sbrc	r0, 7
    1f84:	07 c0       	rjmp	.+14     	; 0x1f94 <_ZN14HardwareSerial5writeEh+0x34>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
    1f86:	e8 89       	ldd	r30, Y+16	; 0x10
    1f88:	f9 89       	ldd	r31, Y+17	; 0x11
    1f8a:	80 81       	ld	r24, Z
    1f8c:	85 ff       	sbrs	r24, 5
    1f8e:	02 c0       	rjmp	.+4      	; 0x1f94 <_ZN14HardwareSerial5writeEh+0x34>
	_tx_udr_empty_irq();
    1f90:	ce 01       	movw	r24, r28
    1f92:	a1 df       	rcall	.-190    	; 0x1ed6 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    1f94:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1f96:	09 17       	cp	r16, r25
    1f98:	99 f3       	breq	.-26     	; 0x1f80 <_ZN14HardwareSerial5writeEh+0x20>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
    1f9a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1f9c:	fe 01       	movw	r30, r28
    1f9e:	e8 0f       	add	r30, r24
    1fa0:	f1 1d       	adc	r31, r1
    1fa2:	e3 5a       	subi	r30, 0xA3	; 163
    1fa4:	ff 4f       	sbci	r31, 0xFF	; 255
    1fa6:	10 83       	st	Z, r17
  _tx_buffer_head = i;
    1fa8:	0b 8f       	std	Y+27, r16	; 0x1b
	
  sbi(*_ucsrb, UDRIE0);
    1faa:	ea 89       	ldd	r30, Y+18	; 0x12
    1fac:	fb 89       	ldd	r31, Y+19	; 0x13
    1fae:	80 81       	ld	r24, Z
    1fb0:	80 62       	ori	r24, 0x20	; 32
    1fb2:	80 83       	st	Z, r24
  _written = true;
    1fb4:	81 e0       	ldi	r24, 0x01	; 1
    1fb6:	88 8f       	std	Y+24, r24	; 0x18
  
  return 1;
    1fb8:	0f c0       	rjmp	.+30     	; 0x1fd8 <_ZN14HardwareSerial5writeEh+0x78>
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    *_udr = c;
    sbi(*_ucsra, TXC0);
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
    1fba:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1fbc:	90 e0       	ldi	r25, 0x00	; 0
    1fbe:	01 96       	adiw	r24, 0x01	; 1
    1fc0:	8f 73       	andi	r24, 0x3F	; 63
    1fc2:	90 78       	andi	r25, 0x80	; 128
    1fc4:	08 2f       	mov	r16, r24
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    1fc6:	e6 cf       	rjmp	.-52     	; 0x1f94 <_ZN14HardwareSerial5writeEh+0x34>
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    *_udr = c;
    1fc8:	ee 89       	ldd	r30, Y+22	; 0x16
    1fca:	ff 89       	ldd	r31, Y+23	; 0x17
    1fcc:	60 83       	st	Z, r22
    sbi(*_ucsra, TXC0);
    1fce:	e8 89       	ldd	r30, Y+16	; 0x10
    1fd0:	f9 89       	ldd	r31, Y+17	; 0x11
    1fd2:	80 81       	ld	r24, Z
    1fd4:	80 64       	ori	r24, 0x40	; 64
    1fd6:	80 83       	st	Z, r24
	
  sbi(*_ucsrb, UDRIE0);
  _written = true;
  
  return 1;
}
    1fd8:	81 e0       	ldi	r24, 0x01	; 1
    1fda:	90 e0       	ldi	r25, 0x00	; 0
    1fdc:	df 91       	pop	r29
    1fde:	cf 91       	pop	r28
    1fe0:	1f 91       	pop	r17
    1fe2:	0f 91       	pop	r16
    1fe4:	08 95       	ret

00001fe6 <_ZN14HardwareSerial5beginEmh>:
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
    1fe6:	cf 92       	push	r12
    1fe8:	df 92       	push	r13
    1fea:	ef 92       	push	r14
    1fec:	ff 92       	push	r15
    1fee:	1f 93       	push	r17
    1ff0:	cf 93       	push	r28
    1ff2:	df 93       	push	r29
    1ff4:	ec 01       	movw	r28, r24
    1ff6:	6a 01       	movw	r12, r20
    1ff8:	7b 01       	movw	r14, r22
    1ffa:	12 2f       	mov	r17, r18
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
    1ffc:	e8 89       	ldd	r30, Y+16	; 0x10
    1ffe:	f9 89       	ldd	r31, Y+17	; 0x11
    2000:	82 e0       	ldi	r24, 0x02	; 2
    2002:	80 83       	st	Z, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    2004:	41 15       	cp	r20, r1
    2006:	81 ee       	ldi	r24, 0xE1	; 225
    2008:	58 07       	cpc	r21, r24
    200a:	61 05       	cpc	r22, r1
    200c:	71 05       	cpc	r23, r1
    200e:	a9 f0       	breq	.+42     	; 0x203a <_ZN14HardwareSerial5beginEmh+0x54>
// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
    2010:	60 e0       	ldi	r22, 0x00	; 0
    2012:	79 e0       	ldi	r23, 0x09	; 9
    2014:	8d e3       	ldi	r24, 0x3D	; 61
    2016:	90 e0       	ldi	r25, 0x00	; 0
    2018:	a7 01       	movw	r20, r14
    201a:	96 01       	movw	r18, r12
    201c:	ac d3       	rcall	.+1880   	; 0x2776 <__udivmodsi4>
    201e:	ba 01       	movw	r22, r20
    2020:	a9 01       	movw	r20, r18
    2022:	41 50       	subi	r20, 0x01	; 1
    2024:	51 09       	sbc	r21, r1
    2026:	61 09       	sbc	r22, r1
    2028:	71 09       	sbc	r23, r1
    202a:	76 95       	lsr	r23
    202c:	67 95       	ror	r22
    202e:	57 95       	ror	r21
    2030:	47 95       	ror	r20
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    2032:	41 15       	cp	r20, r1
    2034:	80 e1       	ldi	r24, 0x10	; 16
    2036:	58 07       	cpc	r21, r24
    2038:	a0 f0       	brcs	.+40     	; 0x2062 <_ZN14HardwareSerial5beginEmh+0x7c>
  {
    *_ucsra = 0;
    203a:	e8 89       	ldd	r30, Y+16	; 0x10
    203c:	f9 89       	ldd	r31, Y+17	; 0x11
    203e:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
    2040:	60 e8       	ldi	r22, 0x80	; 128
    2042:	74 e8       	ldi	r23, 0x84	; 132
    2044:	8e e1       	ldi	r24, 0x1E	; 30
    2046:	90 e0       	ldi	r25, 0x00	; 0
    2048:	a7 01       	movw	r20, r14
    204a:	96 01       	movw	r18, r12
    204c:	94 d3       	rcall	.+1832   	; 0x2776 <__udivmodsi4>
    204e:	ba 01       	movw	r22, r20
    2050:	a9 01       	movw	r20, r18
    2052:	41 50       	subi	r20, 0x01	; 1
    2054:	51 09       	sbc	r21, r1
    2056:	61 09       	sbc	r22, r1
    2058:	71 09       	sbc	r23, r1
    205a:	76 95       	lsr	r23
    205c:	67 95       	ror	r22
    205e:	57 95       	ror	r21
    2060:	47 95       	ror	r20
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
    2062:	ec 85       	ldd	r30, Y+12	; 0x0c
    2064:	fd 85       	ldd	r31, Y+13	; 0x0d
    2066:	50 83       	st	Z, r21
  *_ubrrl = baud_setting;
    2068:	ee 85       	ldd	r30, Y+14	; 0x0e
    206a:	ff 85       	ldd	r31, Y+15	; 0x0f
    206c:	40 83       	st	Z, r20

  _written = false;
    206e:	18 8e       	std	Y+24, r1	; 0x18

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
    2070:	ec 89       	ldd	r30, Y+20	; 0x14
    2072:	fd 89       	ldd	r31, Y+21	; 0x15
    2074:	10 83       	st	Z, r17
  
  sbi(*_ucsrb, RXEN0);
    2076:	ea 89       	ldd	r30, Y+18	; 0x12
    2078:	fb 89       	ldd	r31, Y+19	; 0x13
    207a:	80 81       	ld	r24, Z
    207c:	80 61       	ori	r24, 0x10	; 16
    207e:	80 83       	st	Z, r24
  sbi(*_ucsrb, TXEN0);
    2080:	ea 89       	ldd	r30, Y+18	; 0x12
    2082:	fb 89       	ldd	r31, Y+19	; 0x13
    2084:	80 81       	ld	r24, Z
    2086:	88 60       	ori	r24, 0x08	; 8
    2088:	80 83       	st	Z, r24
  sbi(*_ucsrb, RXCIE0);
    208a:	ea 89       	ldd	r30, Y+18	; 0x12
    208c:	fb 89       	ldd	r31, Y+19	; 0x13
    208e:	80 81       	ld	r24, Z
    2090:	80 68       	ori	r24, 0x80	; 128
    2092:	80 83       	st	Z, r24
  cbi(*_ucsrb, UDRIE0);
    2094:	ea 89       	ldd	r30, Y+18	; 0x12
    2096:	fb 89       	ldd	r31, Y+19	; 0x13
    2098:	80 81       	ld	r24, Z
    209a:	8f 7d       	andi	r24, 0xDF	; 223
    209c:	80 83       	st	Z, r24
}
    209e:	df 91       	pop	r29
    20a0:	cf 91       	pop	r28
    20a2:	1f 91       	pop	r17
    20a4:	ff 90       	pop	r15
    20a6:	ef 90       	pop	r14
    20a8:	df 90       	pop	r13
    20aa:	cf 90       	pop	r12
    20ac:	08 95       	ret

000020ae <__vector_25>:

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
}
    20ae:	1f 92       	push	r1
    20b0:	0f 92       	push	r0
    20b2:	0f b6       	in	r0, 0x3f	; 63
    20b4:	0f 92       	push	r0
    20b6:	11 24       	eor	r1, r1
    20b8:	0b b6       	in	r0, 0x3b	; 59
    20ba:	0f 92       	push	r0
    20bc:	2f 93       	push	r18
    20be:	8f 93       	push	r24
    20c0:	9f 93       	push	r25
    20c2:	af 93       	push	r26
    20c4:	bf 93       	push	r27
    20c6:	ef 93       	push	r30
    20c8:	ff 93       	push	r31
    20ca:	e0 91 30 0a 	lds	r30, 0x0A30
    20ce:	f0 91 31 0a 	lds	r31, 0x0A31
    20d2:	80 81       	ld	r24, Z
    20d4:	82 fd       	sbrc	r24, 2
    20d6:	17 c0       	rjmp	.+46     	; 0x2106 <__vector_25+0x58>
    20d8:	e0 91 36 0a 	lds	r30, 0x0A36
    20dc:	f0 91 37 0a 	lds	r31, 0x0A37
    20e0:	20 81       	ld	r18, Z
    20e2:	80 91 39 0a 	lds	r24, 0x0A39
    20e6:	8f 5f       	subi	r24, 0xFF	; 255
    20e8:	8f 73       	andi	r24, 0x3F	; 63
    20ea:	90 91 3a 0a 	lds	r25, 0x0A3A
    20ee:	89 17       	cp	r24, r25
    20f0:	79 f0       	breq	.+30     	; 0x2110 <__vector_25+0x62>
    20f2:	e9 e3       	ldi	r30, 0x39	; 57
    20f4:	fa e0       	ldi	r31, 0x0A	; 10
    20f6:	a0 81       	ld	r26, Z
    20f8:	b0 e0       	ldi	r27, 0x00	; 0
    20fa:	a0 5e       	subi	r26, 0xE0	; 224
    20fc:	b5 4f       	sbci	r27, 0xF5	; 245
    20fe:	5d 96       	adiw	r26, 0x1d	; 29
    2100:	2c 93       	st	X, r18
    2102:	80 83       	st	Z, r24
    2104:	05 c0       	rjmp	.+10     	; 0x2110 <__vector_25+0x62>
    2106:	e0 91 36 0a 	lds	r30, 0x0A36
    210a:	f0 91 37 0a 	lds	r31, 0x0A37
    210e:	80 81       	ld	r24, Z
    2110:	ff 91       	pop	r31
    2112:	ef 91       	pop	r30
    2114:	bf 91       	pop	r27
    2116:	af 91       	pop	r26
    2118:	9f 91       	pop	r25
    211a:	8f 91       	pop	r24
    211c:	2f 91       	pop	r18
    211e:	0f 90       	pop	r0
    2120:	0b be       	out	0x3b, r0	; 59
    2122:	0f 90       	pop	r0
    2124:	0f be       	out	0x3f, r0	; 63
    2126:	0f 90       	pop	r0
    2128:	1f 90       	pop	r1
    212a:	18 95       	reti

0000212c <__vector_26>:
    212c:	1f 92       	push	r1
    212e:	0f 92       	push	r0
    2130:	0f b6       	in	r0, 0x3f	; 63
    2132:	0f 92       	push	r0
    2134:	11 24       	eor	r1, r1
    2136:	0b b6       	in	r0, 0x3b	; 59
    2138:	0f 92       	push	r0
    213a:	2f 93       	push	r18
    213c:	3f 93       	push	r19
    213e:	4f 93       	push	r20
    2140:	5f 93       	push	r21
    2142:	6f 93       	push	r22
    2144:	7f 93       	push	r23
    2146:	8f 93       	push	r24
    2148:	9f 93       	push	r25
    214a:	af 93       	push	r26
    214c:	bf 93       	push	r27
    214e:	ef 93       	push	r30
    2150:	ff 93       	push	r31
    2152:	80 e2       	ldi	r24, 0x20	; 32
    2154:	9a e0       	ldi	r25, 0x0A	; 10
    2156:	bf de       	rcall	.-642    	; 0x1ed6 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    2158:	ff 91       	pop	r31
    215a:	ef 91       	pop	r30
    215c:	bf 91       	pop	r27
    215e:	af 91       	pop	r26
    2160:	9f 91       	pop	r25
    2162:	8f 91       	pop	r24
    2164:	7f 91       	pop	r23
    2166:	6f 91       	pop	r22
    2168:	5f 91       	pop	r21
    216a:	4f 91       	pop	r20
    216c:	3f 91       	pop	r19
    216e:	2f 91       	pop	r18
    2170:	0f 90       	pop	r0
    2172:	0b be       	out	0x3b, r0	; 59
    2174:	0f 90       	pop	r0
    2176:	0f be       	out	0x3f, r0	; 63
    2178:	0f 90       	pop	r0
    217a:	1f 90       	pop	r1
    217c:	18 95       	reti

0000217e <_GLOBAL__sub_I___vector_25>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
    217e:	10 92 23 0a 	sts	0x0A23, r1
    2182:	10 92 22 0a 	sts	0x0A22, r1
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
    2186:	88 ee       	ldi	r24, 0xE8	; 232
    2188:	93 e0       	ldi	r25, 0x03	; 3
    218a:	a0 e0       	ldi	r26, 0x00	; 0
    218c:	b0 e0       	ldi	r27, 0x00	; 0
    218e:	80 93 24 0a 	sts	0x0A24, r24
    2192:	90 93 25 0a 	sts	0x0A25, r25
    2196:	a0 93 26 0a 	sts	0x0A26, r26
    219a:	b0 93 27 0a 	sts	0x0A27, r27
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
    219e:	8d e5       	ldi	r24, 0x5D	; 93
    21a0:	92 e0       	ldi	r25, 0x02	; 2
    21a2:	90 93 21 0a 	sts	0x0A21, r25
    21a6:	80 93 20 0a 	sts	0x0A20, r24
    21aa:	85 ec       	ldi	r24, 0xC5	; 197
    21ac:	90 e0       	ldi	r25, 0x00	; 0
    21ae:	90 93 2d 0a 	sts	0x0A2D, r25
    21b2:	80 93 2c 0a 	sts	0x0A2C, r24
    21b6:	84 ec       	ldi	r24, 0xC4	; 196
    21b8:	90 e0       	ldi	r25, 0x00	; 0
    21ba:	90 93 2f 0a 	sts	0x0A2F, r25
    21be:	80 93 2e 0a 	sts	0x0A2E, r24
    21c2:	80 ec       	ldi	r24, 0xC0	; 192
    21c4:	90 e0       	ldi	r25, 0x00	; 0
    21c6:	90 93 31 0a 	sts	0x0A31, r25
    21ca:	80 93 30 0a 	sts	0x0A30, r24
    21ce:	81 ec       	ldi	r24, 0xC1	; 193
    21d0:	90 e0       	ldi	r25, 0x00	; 0
    21d2:	90 93 33 0a 	sts	0x0A33, r25
    21d6:	80 93 32 0a 	sts	0x0A32, r24
    21da:	82 ec       	ldi	r24, 0xC2	; 194
    21dc:	90 e0       	ldi	r25, 0x00	; 0
    21de:	90 93 35 0a 	sts	0x0A35, r25
    21e2:	80 93 34 0a 	sts	0x0A34, r24
    21e6:	86 ec       	ldi	r24, 0xC6	; 198
    21e8:	90 e0       	ldi	r25, 0x00	; 0
    21ea:	90 93 37 0a 	sts	0x0A37, r25
    21ee:	80 93 36 0a 	sts	0x0A36, r24
    21f2:	10 92 39 0a 	sts	0x0A39, r1
    21f6:	10 92 3a 0a 	sts	0x0A3A, r1
    21fa:	10 92 3b 0a 	sts	0x0A3B, r1
    21fe:	10 92 3c 0a 	sts	0x0A3C, r1
    2202:	08 95       	ret

00002204 <_ZN5Print5writeEPKhj>:
size_t Print::println(long num, int base)
{
  size_t n = print(num, base);
  n += println();
  return n;
}
    2204:	cf 92       	push	r12
    2206:	df 92       	push	r13
    2208:	ef 92       	push	r14
    220a:	ff 92       	push	r15
    220c:	0f 93       	push	r16
    220e:	1f 93       	push	r17
    2210:	cf 93       	push	r28
    2212:	df 93       	push	r29
    2214:	6c 01       	movw	r12, r24
    2216:	41 15       	cp	r20, r1
    2218:	51 05       	cpc	r21, r1
    221a:	b1 f0       	breq	.+44     	; 0x2248 <_ZN5Print5writeEPKhj+0x44>
    221c:	06 2f       	mov	r16, r22
    221e:	17 2f       	mov	r17, r23
    2220:	ea 01       	movw	r28, r20
    2222:	e1 2c       	mov	r14, r1
    2224:	f1 2c       	mov	r15, r1
    2226:	d8 01       	movw	r26, r16
    2228:	6d 91       	ld	r22, X+
    222a:	8d 01       	movw	r16, r26
    222c:	d6 01       	movw	r26, r12
    222e:	ed 91       	ld	r30, X+
    2230:	fc 91       	ld	r31, X
    2232:	01 90       	ld	r0, Z+
    2234:	f0 81       	ld	r31, Z
    2236:	e0 2d       	mov	r30, r0
    2238:	c6 01       	movw	r24, r12
    223a:	19 95       	eicall
    223c:	e8 0e       	add	r14, r24
    223e:	f9 1e       	adc	r15, r25
    2240:	21 97       	sbiw	r28, 0x01	; 1
    2242:	20 97       	sbiw	r28, 0x00	; 0
    2244:	81 f7       	brne	.-32     	; 0x2226 <_ZN5Print5writeEPKhj+0x22>
    2246:	02 c0       	rjmp	.+4      	; 0x224c <_ZN5Print5writeEPKhj+0x48>
    2248:	e1 2c       	mov	r14, r1
    224a:	f1 2c       	mov	r15, r1
    224c:	c7 01       	movw	r24, r14
    224e:	df 91       	pop	r29
    2250:	cf 91       	pop	r28
    2252:	1f 91       	pop	r17
    2254:	0f 91       	pop	r16
    2256:	ff 90       	pop	r15
    2258:	ef 90       	pop	r14
    225a:	df 90       	pop	r13
    225c:	cf 90       	pop	r12
    225e:	08 95       	ret

00002260 <_ZN5Print5printEc>:
    2260:	dc 01       	movw	r26, r24
    2262:	ed 91       	ld	r30, X+
    2264:	fc 91       	ld	r31, X
    2266:	01 90       	ld	r0, Z+
    2268:	f0 81       	ld	r31, Z
    226a:	e0 2d       	mov	r30, r0
    226c:	19 95       	eicall
    226e:	08 95       	ret

00002270 <_ZN5Print7printlnEv>:
    2270:	0f 93       	push	r16
    2272:	1f 93       	push	r17
    2274:	cf 93       	push	r28
    2276:	df 93       	push	r29
    2278:	ec 01       	movw	r28, r24
    227a:	6d e0       	ldi	r22, 0x0D	; 13
    227c:	f1 df       	rcall	.-30     	; 0x2260 <_ZN5Print5printEc>
    227e:	8c 01       	movw	r16, r24
    2280:	6a e0       	ldi	r22, 0x0A	; 10
    2282:	ce 01       	movw	r24, r28
    2284:	ed df       	rcall	.-38     	; 0x2260 <_ZN5Print5printEc>
    2286:	80 0f       	add	r24, r16
    2288:	91 1f       	adc	r25, r17
    228a:	df 91       	pop	r29
    228c:	cf 91       	pop	r28
    228e:	1f 91       	pop	r17
    2290:	0f 91       	pop	r16
    2292:	08 95       	ret

00002294 <_ZN5Print11printNumberEmh>:
    2294:	6f 92       	push	r6
    2296:	7f 92       	push	r7
    2298:	8f 92       	push	r8
    229a:	9f 92       	push	r9
    229c:	af 92       	push	r10
    229e:	bf 92       	push	r11
    22a0:	cf 92       	push	r12
    22a2:	df 92       	push	r13
    22a4:	ef 92       	push	r14
    22a6:	ff 92       	push	r15
    22a8:	0f 93       	push	r16
    22aa:	1f 93       	push	r17
    22ac:	cf 93       	push	r28
    22ae:	df 93       	push	r29
    22b0:	cd b7       	in	r28, 0x3d	; 61
    22b2:	de b7       	in	r29, 0x3e	; 62
    22b4:	a1 97       	sbiw	r28, 0x21	; 33
    22b6:	0f b6       	in	r0, 0x3f	; 63
    22b8:	f8 94       	cli
    22ba:	de bf       	out	0x3e, r29	; 62
    22bc:	0f be       	out	0x3f, r0	; 63
    22be:	cd bf       	out	0x3d, r28	; 61
    22c0:	6c 01       	movw	r12, r24
    22c2:	74 2e       	mov	r7, r20
    22c4:	35 2f       	mov	r19, r21
    22c6:	86 2f       	mov	r24, r22
    22c8:	97 2f       	mov	r25, r23
    22ca:	62 2e       	mov	r6, r18
    22cc:	19 a2       	std	Y+33, r1	; 0x21
    22ce:	21 e0       	ldi	r18, 0x01	; 1
    22d0:	26 15       	cp	r18, r6
    22d2:	20 f0       	brcs	.+8      	; 0x22dc <_ZN5Print11printNumberEmh+0x48>
    22d4:	0f 2e       	mov	r0, r31
    22d6:	fa e0       	ldi	r31, 0x0A	; 10
    22d8:	6f 2e       	mov	r6, r31
    22da:	f0 2d       	mov	r31, r0
    22dc:	7e 01       	movw	r14, r28
    22de:	a1 e2       	ldi	r26, 0x21	; 33
    22e0:	ea 0e       	add	r14, r26
    22e2:	f1 1c       	adc	r15, r1
    22e4:	86 2c       	mov	r8, r6
    22e6:	91 2c       	mov	r9, r1
    22e8:	a1 2c       	mov	r10, r1
    22ea:	b1 2c       	mov	r11, r1
    22ec:	67 2d       	mov	r22, r7
    22ee:	73 2f       	mov	r23, r19
    22f0:	a5 01       	movw	r20, r10
    22f2:	94 01       	movw	r18, r8
    22f4:	40 d2       	rcall	.+1152   	; 0x2776 <__udivmodsi4>
    22f6:	e2 2f       	mov	r30, r18
    22f8:	73 2f       	mov	r23, r19
    22fa:	02 2f       	mov	r16, r18
    22fc:	13 2f       	mov	r17, r19
    22fe:	24 2f       	mov	r18, r20
    2300:	35 2f       	mov	r19, r21
    2302:	f7 2d       	mov	r31, r7
    2304:	6e 9e       	mul	r6, r30
    2306:	f0 19       	sub	r31, r0
    2308:	11 24       	eor	r1, r1
    230a:	b1 e0       	ldi	r27, 0x01	; 1
    230c:	eb 1a       	sub	r14, r27
    230e:	f1 08       	sbc	r15, r1
    2310:	fa 30       	cpi	r31, 0x0A	; 10
    2312:	10 f4       	brcc	.+4      	; 0x2318 <_ZN5Print11printNumberEmh+0x84>
    2314:	f0 5d       	subi	r31, 0xD0	; 208
    2316:	01 c0       	rjmp	.+2      	; 0x231a <_ZN5Print11printNumberEmh+0x86>
    2318:	f9 5c       	subi	r31, 0xC9	; 201
    231a:	d7 01       	movw	r26, r14
    231c:	fc 93       	st	X, r31
    231e:	01 2b       	or	r16, r17
    2320:	02 2b       	or	r16, r18
    2322:	03 2b       	or	r16, r19
    2324:	29 f0       	breq	.+10     	; 0x2330 <_ZN5Print11printNumberEmh+0x9c>
    2326:	7e 2e       	mov	r7, r30
    2328:	37 2f       	mov	r19, r23
    232a:	84 2f       	mov	r24, r20
    232c:	95 2f       	mov	r25, r21
    232e:	de cf       	rjmp	.-68     	; 0x22ec <_ZN5Print11printNumberEmh+0x58>
    2330:	e1 14       	cp	r14, r1
    2332:	f1 04       	cpc	r15, r1
    2334:	91 f0       	breq	.+36     	; 0x235a <_ZN5Print11printNumberEmh+0xc6>
    2336:	f7 01       	movw	r30, r14
    2338:	01 90       	ld	r0, Z+
    233a:	00 20       	and	r0, r0
    233c:	e9 f7       	brne	.-6      	; 0x2338 <_ZN5Print11printNumberEmh+0xa4>
    233e:	31 97       	sbiw	r30, 0x01	; 1
    2340:	af 01       	movw	r20, r30
    2342:	4e 19       	sub	r20, r14
    2344:	5f 09       	sbc	r21, r15
    2346:	d6 01       	movw	r26, r12
    2348:	ed 91       	ld	r30, X+
    234a:	fc 91       	ld	r31, X
    234c:	02 80       	ldd	r0, Z+2	; 0x02
    234e:	f3 81       	ldd	r31, Z+3	; 0x03
    2350:	e0 2d       	mov	r30, r0
    2352:	b7 01       	movw	r22, r14
    2354:	c6 01       	movw	r24, r12
    2356:	19 95       	eicall
    2358:	02 c0       	rjmp	.+4      	; 0x235e <_ZN5Print11printNumberEmh+0xca>
    235a:	80 e0       	ldi	r24, 0x00	; 0
    235c:	90 e0       	ldi	r25, 0x00	; 0
    235e:	a1 96       	adiw	r28, 0x21	; 33
    2360:	0f b6       	in	r0, 0x3f	; 63
    2362:	f8 94       	cli
    2364:	de bf       	out	0x3e, r29	; 62
    2366:	0f be       	out	0x3f, r0	; 63
    2368:	cd bf       	out	0x3d, r28	; 61
    236a:	df 91       	pop	r29
    236c:	cf 91       	pop	r28
    236e:	1f 91       	pop	r17
    2370:	0f 91       	pop	r16
    2372:	ff 90       	pop	r15
    2374:	ef 90       	pop	r14
    2376:	df 90       	pop	r13
    2378:	cf 90       	pop	r12
    237a:	bf 90       	pop	r11
    237c:	af 90       	pop	r10
    237e:	9f 90       	pop	r9
    2380:	8f 90       	pop	r8
    2382:	7f 90       	pop	r7
    2384:	6f 90       	pop	r6
    2386:	08 95       	ret

00002388 <_ZN5Print5printEli>:
    2388:	cf 92       	push	r12
    238a:	df 92       	push	r13
    238c:	ef 92       	push	r14
    238e:	ff 92       	push	r15
    2390:	0f 93       	push	r16
    2392:	1f 93       	push	r17
    2394:	cf 93       	push	r28
    2396:	df 93       	push	r29
    2398:	ec 01       	movw	r28, r24
    239a:	6a 01       	movw	r12, r20
    239c:	7b 01       	movw	r14, r22
    239e:	21 15       	cp	r18, r1
    23a0:	31 05       	cpc	r19, r1
    23a2:	41 f4       	brne	.+16     	; 0x23b4 <_ZN5Print5printEli+0x2c>
    23a4:	e8 81       	ld	r30, Y
    23a6:	f9 81       	ldd	r31, Y+1	; 0x01
    23a8:	01 90       	ld	r0, Z+
    23aa:	f0 81       	ld	r31, Z
    23ac:	e0 2d       	mov	r30, r0
    23ae:	64 2f       	mov	r22, r20
    23b0:	19 95       	eicall
    23b2:	19 c0       	rjmp	.+50     	; 0x23e6 <_ZN5Print5printEli+0x5e>
    23b4:	2a 30       	cpi	r18, 0x0A	; 10
    23b6:	31 05       	cpc	r19, r1
    23b8:	a9 f4       	brne	.+42     	; 0x23e4 <_ZN5Print5printEli+0x5c>
    23ba:	77 23       	and	r23, r23
    23bc:	84 f4       	brge	.+32     	; 0x23de <_ZN5Print5printEli+0x56>
    23be:	6d e2       	ldi	r22, 0x2D	; 45
    23c0:	4f df       	rcall	.-354    	; 0x2260 <_ZN5Print5printEc>
    23c2:	8c 01       	movw	r16, r24
    23c4:	44 27       	eor	r20, r20
    23c6:	55 27       	eor	r21, r21
    23c8:	ba 01       	movw	r22, r20
    23ca:	4c 19       	sub	r20, r12
    23cc:	5d 09       	sbc	r21, r13
    23ce:	6e 09       	sbc	r22, r14
    23d0:	7f 09       	sbc	r23, r15
    23d2:	2a e0       	ldi	r18, 0x0A	; 10
    23d4:	ce 01       	movw	r24, r28
    23d6:	5e df       	rcall	.-324    	; 0x2294 <_ZN5Print11printNumberEmh>
    23d8:	80 0f       	add	r24, r16
    23da:	91 1f       	adc	r25, r17
    23dc:	04 c0       	rjmp	.+8      	; 0x23e6 <_ZN5Print5printEli+0x5e>
    23de:	2a e0       	ldi	r18, 0x0A	; 10
    23e0:	59 df       	rcall	.-334    	; 0x2294 <_ZN5Print11printNumberEmh>
    23e2:	01 c0       	rjmp	.+2      	; 0x23e6 <_ZN5Print5printEli+0x5e>
    23e4:	57 df       	rcall	.-338    	; 0x2294 <_ZN5Print11printNumberEmh>
    23e6:	df 91       	pop	r29
    23e8:	cf 91       	pop	r28
    23ea:	1f 91       	pop	r17
    23ec:	0f 91       	pop	r16
    23ee:	ff 90       	pop	r15
    23f0:	ef 90       	pop	r14
    23f2:	df 90       	pop	r13
    23f4:	cf 90       	pop	r12
    23f6:	08 95       	ret

000023f8 <_ZN5Print7printlnEii>:
  n += println();
  return n;
}

size_t Print::println(int num, int base)
{
    23f8:	0f 93       	push	r16
    23fa:	1f 93       	push	r17
    23fc:	cf 93       	push	r28
    23fe:	df 93       	push	r29
    2400:	ec 01       	movw	r28, r24
    2402:	9a 01       	movw	r18, r20
  return print((unsigned long) b, base);
}

size_t Print::print(int n, int base)
{
  return print((long) n, base);
    2404:	ab 01       	movw	r20, r22
    2406:	66 27       	eor	r22, r22
    2408:	57 fd       	sbrc	r21, 7
    240a:	60 95       	com	r22
    240c:	76 2f       	mov	r23, r22
    240e:	bc df       	rcall	.-136    	; 0x2388 <_ZN5Print5printEli>
    2410:	8c 01       	movw	r16, r24
}

size_t Print::println(int num, int base)
{
  size_t n = print(num, base);
  n += println();
    2412:	ce 01       	movw	r24, r28
    2414:	2d df       	rcall	.-422    	; 0x2270 <_ZN5Print7printlnEv>
  return n;
}
    2416:	80 0f       	add	r24, r16
    2418:	91 1f       	adc	r25, r17
    241a:	df 91       	pop	r29
    241c:	cf 91       	pop	r28
    241e:	1f 91       	pop	r17
    2420:	0f 91       	pop	r16
    2422:	08 95       	ret

00002424 <__vector_23>:
	// we can't subtract any more than this or we'd overflow w/ small delays.
	us--;
#endif

	// busy wait
	__asm__ __volatile__ (
    2424:	1f 92       	push	r1
    2426:	0f 92       	push	r0
    2428:	0f b6       	in	r0, 0x3f	; 63
    242a:	0f 92       	push	r0
    242c:	11 24       	eor	r1, r1
    242e:	2f 93       	push	r18
    2430:	3f 93       	push	r19
    2432:	8f 93       	push	r24
    2434:	9f 93       	push	r25
    2436:	af 93       	push	r26
    2438:	bf 93       	push	r27
    243a:	80 91 be 0a 	lds	r24, 0x0ABE
    243e:	90 91 bf 0a 	lds	r25, 0x0ABF
    2442:	a0 91 c0 0a 	lds	r26, 0x0AC0
    2446:	b0 91 c1 0a 	lds	r27, 0x0AC1
    244a:	30 91 bd 0a 	lds	r19, 0x0ABD
    244e:	23 e0       	ldi	r18, 0x03	; 3
    2450:	23 0f       	add	r18, r19
    2452:	2d 37       	cpi	r18, 0x7D	; 125
    2454:	20 f4       	brcc	.+8      	; 0x245e <__vector_23+0x3a>
    2456:	01 96       	adiw	r24, 0x01	; 1
    2458:	a1 1d       	adc	r26, r1
    245a:	b1 1d       	adc	r27, r1
    245c:	05 c0       	rjmp	.+10     	; 0x2468 <__vector_23+0x44>
    245e:	26 e8       	ldi	r18, 0x86	; 134
    2460:	23 0f       	add	r18, r19
    2462:	02 96       	adiw	r24, 0x02	; 2
    2464:	a1 1d       	adc	r26, r1
    2466:	b1 1d       	adc	r27, r1
    2468:	20 93 bd 0a 	sts	0x0ABD, r18
    246c:	80 93 be 0a 	sts	0x0ABE, r24
    2470:	90 93 bf 0a 	sts	0x0ABF, r25
    2474:	a0 93 c0 0a 	sts	0x0AC0, r26
    2478:	b0 93 c1 0a 	sts	0x0AC1, r27
    247c:	80 91 c2 0a 	lds	r24, 0x0AC2
    2480:	90 91 c3 0a 	lds	r25, 0x0AC3
    2484:	a0 91 c4 0a 	lds	r26, 0x0AC4
    2488:	b0 91 c5 0a 	lds	r27, 0x0AC5
    248c:	01 96       	adiw	r24, 0x01	; 1
    248e:	a1 1d       	adc	r26, r1
    2490:	b1 1d       	adc	r27, r1
    2492:	80 93 c2 0a 	sts	0x0AC2, r24
    2496:	90 93 c3 0a 	sts	0x0AC3, r25
    249a:	a0 93 c4 0a 	sts	0x0AC4, r26
    249e:	b0 93 c5 0a 	sts	0x0AC5, r27
    24a2:	bf 91       	pop	r27
    24a4:	af 91       	pop	r26
    24a6:	9f 91       	pop	r25
    24a8:	8f 91       	pop	r24
    24aa:	3f 91       	pop	r19
    24ac:	2f 91       	pop	r18
    24ae:	0f 90       	pop	r0
    24b0:	0f be       	out	0x3f, r0	; 63
    24b2:	0f 90       	pop	r0
    24b4:	1f 90       	pop	r1
    24b6:	18 95       	reti

000024b8 <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
    24b8:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
    24ba:	84 b5       	in	r24, 0x24	; 36
    24bc:	82 60       	ori	r24, 0x02	; 2
    24be:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
    24c0:	84 b5       	in	r24, 0x24	; 36
    24c2:	81 60       	ori	r24, 0x01	; 1
    24c4:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
    24c6:	85 b5       	in	r24, 0x25	; 37
    24c8:	82 60       	ori	r24, 0x02	; 2
    24ca:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
    24cc:	85 b5       	in	r24, 0x25	; 37
    24ce:	81 60       	ori	r24, 0x01	; 1
    24d0:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
    24d2:	ee e6       	ldi	r30, 0x6E	; 110
    24d4:	f0 e0       	ldi	r31, 0x00	; 0
    24d6:	80 81       	ld	r24, Z
    24d8:	81 60       	ori	r24, 0x01	; 1
    24da:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
    24dc:	e1 e8       	ldi	r30, 0x81	; 129
    24de:	f0 e0       	ldi	r31, 0x00	; 0
    24e0:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
    24e2:	80 81       	ld	r24, Z
    24e4:	82 60       	ori	r24, 0x02	; 2
    24e6:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
    24e8:	80 81       	ld	r24, Z
    24ea:	81 60       	ori	r24, 0x01	; 1
    24ec:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
    24ee:	e0 e8       	ldi	r30, 0x80	; 128
    24f0:	f0 e0       	ldi	r31, 0x00	; 0
    24f2:	80 81       	ld	r24, Z
    24f4:	81 60       	ori	r24, 0x01	; 1
    24f6:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
    24f8:	e1 eb       	ldi	r30, 0xB1	; 177
    24fa:	f0 e0       	ldi	r31, 0x00	; 0
    24fc:	80 81       	ld	r24, Z
    24fe:	84 60       	ori	r24, 0x04	; 4
    2500:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
    2502:	e0 eb       	ldi	r30, 0xB0	; 176
    2504:	f0 e0       	ldi	r31, 0x00	; 0
    2506:	80 81       	ld	r24, Z
    2508:	81 60       	ori	r24, 0x01	; 1
    250a:	80 83       	st	Z, r24
#else
	#warning Timer 2 not finished (may not be present on this CPU)
#endif

#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
    250c:	e1 e9       	ldi	r30, 0x91	; 145
    250e:	f0 e0       	ldi	r31, 0x00	; 0
    2510:	80 81       	ld	r24, Z
    2512:	82 60       	ori	r24, 0x02	; 2
    2514:	80 83       	st	Z, r24
	sbi(TCCR3B, CS30);
    2516:	80 81       	ld	r24, Z
    2518:	81 60       	ori	r24, 0x01	; 1
    251a:	80 83       	st	Z, r24
	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
    251c:	e0 e9       	ldi	r30, 0x90	; 144
    251e:	f0 e0       	ldi	r31, 0x00	; 0
    2520:	80 81       	ld	r24, Z
    2522:	81 60       	ori	r24, 0x01	; 1
    2524:	80 83       	st	Z, r24
	sbi(TCCR4D, WGM40);		// put timer 4 in phase- and frequency-correct PWM mode	
	sbi(TCCR4A, PWM4A);		// enable PWM mode for comparator OCR4A
	sbi(TCCR4C, PWM4D);		// enable PWM mode for comparator OCR4D
#else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */
#if defined(TCCR4B) && defined(CS41) && defined(WGM40)
	sbi(TCCR4B, CS41);		// set timer 4 prescale factor to 64
    2526:	e1 ea       	ldi	r30, 0xA1	; 161
    2528:	f0 e0       	ldi	r31, 0x00	; 0
    252a:	80 81       	ld	r24, Z
    252c:	82 60       	ori	r24, 0x02	; 2
    252e:	80 83       	st	Z, r24
	sbi(TCCR4B, CS40);
    2530:	80 81       	ld	r24, Z
    2532:	81 60       	ori	r24, 0x01	; 1
    2534:	80 83       	st	Z, r24
	sbi(TCCR4A, WGM40);		// put timer 4 in 8-bit phase correct pwm mode
    2536:	e0 ea       	ldi	r30, 0xA0	; 160
    2538:	f0 e0       	ldi	r31, 0x00	; 0
    253a:	80 81       	ld	r24, Z
    253c:	81 60       	ori	r24, 0x01	; 1
    253e:	80 83       	st	Z, r24
#endif
#endif /* end timer4 block for ATMEGA1280/2560 and similar */	

#if defined(TCCR5B) && defined(CS51) && defined(WGM50)
	sbi(TCCR5B, CS51);		// set timer 5 prescale factor to 64
    2540:	e1 e2       	ldi	r30, 0x21	; 33
    2542:	f1 e0       	ldi	r31, 0x01	; 1
    2544:	80 81       	ld	r24, Z
    2546:	82 60       	ori	r24, 0x02	; 2
    2548:	80 83       	st	Z, r24
	sbi(TCCR5B, CS50);
    254a:	80 81       	ld	r24, Z
    254c:	81 60       	ori	r24, 0x01	; 1
    254e:	80 83       	st	Z, r24
	sbi(TCCR5A, WGM50);		// put timer 5 in 8-bit phase correct pwm mode
    2550:	e0 e2       	ldi	r30, 0x20	; 32
    2552:	f1 e0       	ldi	r31, 0x01	; 1
    2554:	80 81       	ld	r24, Z
    2556:	81 60       	ori	r24, 0x01	; 1
    2558:	80 83       	st	Z, r24
#if defined(ADCSRA)
	// set a2d prescale factor to 128
	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
	// XXX: this will not work properly for other clock speeds, and
	// this code should use F_CPU to determine the prescale factor.
	sbi(ADCSRA, ADPS2);
    255a:	ea e7       	ldi	r30, 0x7A	; 122
    255c:	f0 e0       	ldi	r31, 0x00	; 0
    255e:	80 81       	ld	r24, Z
    2560:	84 60       	ori	r24, 0x04	; 4
    2562:	80 83       	st	Z, r24
	sbi(ADCSRA, ADPS1);
    2564:	80 81       	ld	r24, Z
    2566:	82 60       	ori	r24, 0x02	; 2
    2568:	80 83       	st	Z, r24
	sbi(ADCSRA, ADPS0);
    256a:	80 81       	ld	r24, Z
    256c:	81 60       	ori	r24, 0x01	; 1
    256e:	80 83       	st	Z, r24

	// enable a2d conversions
	sbi(ADCSRA, ADEN);
    2570:	80 81       	ld	r24, Z
    2572:	80 68       	ori	r24, 0x80	; 128
    2574:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
    2576:	10 92 c1 00 	sts	0x00C1, r1
    257a:	08 95       	ret

0000257c <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
    257c:	90 e0       	ldi	r25, 0x00	; 0
    257e:	fc 01       	movw	r30, r24
    2580:	31 97       	sbiw	r30, 0x01	; 1
    2582:	e2 31       	cpi	r30, 0x12	; 18
    2584:	f1 05       	cpc	r31, r1
    2586:	08 f0       	brcs	.+2      	; 0x258a <turnOffPWM+0xe>
    2588:	5e c0       	rjmp	.+188    	; 0x2646 <turnOffPWM+0xca>
    258a:	e5 5c       	subi	r30, 0xC5	; 197
    258c:	fe 4f       	sbci	r31, 0xFE	; 254
    258e:	15 c1       	rjmp	.+554    	; 0x27ba <__tablejump2__>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
    2590:	e0 e8       	ldi	r30, 0x80	; 128
    2592:	f0 e0       	ldi	r31, 0x00	; 0
    2594:	80 81       	ld	r24, Z
    2596:	8f 77       	andi	r24, 0x7F	; 127
    2598:	80 83       	st	Z, r24
    259a:	08 95       	ret
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    259c:	e0 e8       	ldi	r30, 0x80	; 128
    259e:	f0 e0       	ldi	r31, 0x00	; 0
    25a0:	80 81       	ld	r24, Z
    25a2:	8f 7d       	andi	r24, 0xDF	; 223
    25a4:	80 83       	st	Z, r24
    25a6:	08 95       	ret
		#endif
		#if defined(TCCR1A) && defined(COM1C1)
		case TIMER1C:   cbi(TCCR1A, COM1C1);    break;
    25a8:	e0 e8       	ldi	r30, 0x80	; 128
    25aa:	f0 e0       	ldi	r31, 0x00	; 0
    25ac:	80 81       	ld	r24, Z
    25ae:	87 7f       	andi	r24, 0xF7	; 247
    25b0:	80 83       	st	Z, r24
    25b2:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
    25b4:	84 b5       	in	r24, 0x24	; 36
    25b6:	8f 77       	andi	r24, 0x7F	; 127
    25b8:	84 bd       	out	0x24, r24	; 36
    25ba:	08 95       	ret
		#endif
		
		#if defined(TIMER0B) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
    25bc:	84 b5       	in	r24, 0x24	; 36
    25be:	8f 7d       	andi	r24, 0xDF	; 223
    25c0:	84 bd       	out	0x24, r24	; 36
    25c2:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
    25c4:	e0 eb       	ldi	r30, 0xB0	; 176
    25c6:	f0 e0       	ldi	r31, 0x00	; 0
    25c8:	80 81       	ld	r24, Z
    25ca:	8f 77       	andi	r24, 0x7F	; 127
    25cc:	80 83       	st	Z, r24
    25ce:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
    25d0:	e0 eb       	ldi	r30, 0xB0	; 176
    25d2:	f0 e0       	ldi	r31, 0x00	; 0
    25d4:	80 81       	ld	r24, Z
    25d6:	8f 7d       	andi	r24, 0xDF	; 223
    25d8:	80 83       	st	Z, r24
    25da:	08 95       	ret
		#endif
		
		#if defined(TCCR3A) && defined(COM3A1)
		case  TIMER3A:  cbi(TCCR3A, COM3A1);    break;
    25dc:	e0 e9       	ldi	r30, 0x90	; 144
    25de:	f0 e0       	ldi	r31, 0x00	; 0
    25e0:	80 81       	ld	r24, Z
    25e2:	8f 77       	andi	r24, 0x7F	; 127
    25e4:	80 83       	st	Z, r24
    25e6:	08 95       	ret
		#endif
		#if defined(TCCR3A) && defined(COM3B1)
		case  TIMER3B:  cbi(TCCR3A, COM3B1);    break;
    25e8:	e0 e9       	ldi	r30, 0x90	; 144
    25ea:	f0 e0       	ldi	r31, 0x00	; 0
    25ec:	80 81       	ld	r24, Z
    25ee:	8f 7d       	andi	r24, 0xDF	; 223
    25f0:	80 83       	st	Z, r24
    25f2:	08 95       	ret
		#endif
		#if defined(TCCR3A) && defined(COM3C1)
		case  TIMER3C:  cbi(TCCR3A, COM3C1);    break;
    25f4:	e0 e9       	ldi	r30, 0x90	; 144
    25f6:	f0 e0       	ldi	r31, 0x00	; 0
    25f8:	80 81       	ld	r24, Z
    25fa:	87 7f       	andi	r24, 0xF7	; 247
    25fc:	80 83       	st	Z, r24
    25fe:	08 95       	ret
		#endif

		#if defined(TCCR4A) && defined(COM4A1)
		case  TIMER4A:  cbi(TCCR4A, COM4A1);    break;
    2600:	e0 ea       	ldi	r30, 0xA0	; 160
    2602:	f0 e0       	ldi	r31, 0x00	; 0
    2604:	80 81       	ld	r24, Z
    2606:	8f 77       	andi	r24, 0x7F	; 127
    2608:	80 83       	st	Z, r24
    260a:	08 95       	ret
		#endif					
		#if defined(TCCR4A) && defined(COM4B1)
		case  TIMER4B:  cbi(TCCR4A, COM4B1);    break;
    260c:	e0 ea       	ldi	r30, 0xA0	; 160
    260e:	f0 e0       	ldi	r31, 0x00	; 0
    2610:	80 81       	ld	r24, Z
    2612:	8f 7d       	andi	r24, 0xDF	; 223
    2614:	80 83       	st	Z, r24
    2616:	08 95       	ret
		#endif
		#if defined(TCCR4A) && defined(COM4C1)
		case  TIMER4C:  cbi(TCCR4A, COM4C1);    break;
    2618:	e0 ea       	ldi	r30, 0xA0	; 160
    261a:	f0 e0       	ldi	r31, 0x00	; 0
    261c:	80 81       	ld	r24, Z
    261e:	87 7f       	andi	r24, 0xF7	; 247
    2620:	80 83       	st	Z, r24
    2622:	08 95       	ret
		#if defined(TCCR4C) && defined(COM4D1)
		case TIMER4D:	cbi(TCCR4C, COM4D1);	break;
		#endif			
			
		#if defined(TCCR5A)
		case  TIMER5A:  cbi(TCCR5A, COM5A1);    break;
    2624:	e0 e2       	ldi	r30, 0x20	; 32
    2626:	f1 e0       	ldi	r31, 0x01	; 1
    2628:	80 81       	ld	r24, Z
    262a:	8f 77       	andi	r24, 0x7F	; 127
    262c:	80 83       	st	Z, r24
    262e:	08 95       	ret
		case  TIMER5B:  cbi(TCCR5A, COM5B1);    break;
    2630:	e0 e2       	ldi	r30, 0x20	; 32
    2632:	f1 e0       	ldi	r31, 0x01	; 1
    2634:	80 81       	ld	r24, Z
    2636:	8f 7d       	andi	r24, 0xDF	; 223
    2638:	80 83       	st	Z, r24
    263a:	08 95       	ret
		case  TIMER5C:  cbi(TCCR5A, COM5C1);    break;
    263c:	e0 e2       	ldi	r30, 0x20	; 32
    263e:	f1 e0       	ldi	r31, 0x01	; 1
    2640:	80 81       	ld	r24, Z
    2642:	87 7f       	andi	r24, 0xF7	; 247
    2644:	80 83       	st	Z, r24
    2646:	08 95       	ret

00002648 <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
    2648:	cf 93       	push	r28
    264a:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
    264c:	90 e0       	ldi	r25, 0x00	; 0
    264e:	fc 01       	movw	r30, r24
    2650:	e0 52       	subi	r30, 0x20	; 32
    2652:	fd 4f       	sbci	r31, 0xFD	; 253
    2654:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
    2656:	fc 01       	movw	r30, r24
    2658:	ea 5d       	subi	r30, 0xDA	; 218
    265a:	fc 4f       	sbci	r31, 0xFC	; 252
    265c:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
    265e:	88 23       	and	r24, r24
    2660:	71 f1       	breq	.+92     	; 0x26be <pinMode+0x76>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
    2662:	90 e0       	ldi	r25, 0x00	; 0
    2664:	88 0f       	add	r24, r24
    2666:	99 1f       	adc	r25, r25
    2668:	fc 01       	movw	r30, r24
    266a:	e0 56       	subi	r30, 0x60	; 96
    266c:	fc 4f       	sbci	r31, 0xFC	; 252
    266e:	a5 91       	lpm	r26, Z+
    2670:	b4 91       	lpm	r27, Z
	out = portOutputRegister(port);
    2672:	8a 57       	subi	r24, 0x7A	; 122
    2674:	9c 4f       	sbci	r25, 0xFC	; 252
    2676:	fc 01       	movw	r30, r24
    2678:	c5 91       	lpm	r28, Z+
    267a:	d4 91       	lpm	r29, Z

	if (mode == INPUT) { 
    267c:	61 11       	cpse	r22, r1
    267e:	0b c0       	rjmp	.+22     	; 0x2696 <pinMode+0x4e>
		uint8_t oldSREG = SREG;
    2680:	8f b7       	in	r24, 0x3f	; 63
                cli();
    2682:	f8 94       	cli
		*reg &= ~bit;
    2684:	9c 91       	ld	r25, X
    2686:	20 95       	com	r18
    2688:	92 23       	and	r25, r18
    268a:	9c 93       	st	X, r25
		*out &= ~bit;
    268c:	e8 81       	ld	r30, Y
    268e:	2e 23       	and	r18, r30
    2690:	28 83       	st	Y, r18
		SREG = oldSREG;
    2692:	8f bf       	out	0x3f, r24	; 63
    2694:	14 c0       	rjmp	.+40     	; 0x26be <pinMode+0x76>
	} else if (mode == INPUT_PULLUP) {
    2696:	62 30       	cpi	r22, 0x02	; 2
    2698:	61 f4       	brne	.+24     	; 0x26b2 <pinMode+0x6a>
		uint8_t oldSREG = SREG;
    269a:	8f b7       	in	r24, 0x3f	; 63
                cli();
    269c:	f8 94       	cli
		*reg &= ~bit;
    269e:	3c 91       	ld	r19, X
    26a0:	92 2f       	mov	r25, r18
    26a2:	90 95       	com	r25
    26a4:	93 23       	and	r25, r19
    26a6:	9c 93       	st	X, r25
		*out |= bit;
    26a8:	e8 81       	ld	r30, Y
    26aa:	2e 2b       	or	r18, r30
    26ac:	28 83       	st	Y, r18
		SREG = oldSREG;
    26ae:	8f bf       	out	0x3f, r24	; 63
    26b0:	06 c0       	rjmp	.+12     	; 0x26be <pinMode+0x76>
	} else {
		uint8_t oldSREG = SREG;
    26b2:	8f b7       	in	r24, 0x3f	; 63
                cli();
    26b4:	f8 94       	cli
		*reg |= bit;
    26b6:	ec 91       	ld	r30, X
    26b8:	2e 2b       	or	r18, r30
    26ba:	2c 93       	st	X, r18
		SREG = oldSREG;
    26bc:	8f bf       	out	0x3f, r24	; 63
	}
}
    26be:	df 91       	pop	r29
    26c0:	cf 91       	pop	r28
    26c2:	08 95       	ret

000026c4 <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
    26c4:	1f 93       	push	r17
    26c6:	cf 93       	push	r28
    26c8:	df 93       	push	r29
    26ca:	c6 2f       	mov	r28, r22
	uint8_t timer = digitalPinToTimer(pin);
    26cc:	28 2f       	mov	r18, r24
    26ce:	30 e0       	ldi	r19, 0x00	; 0
    26d0:	f9 01       	movw	r30, r18
    26d2:	e6 56       	subi	r30, 0x66	; 102
    26d4:	fd 4f       	sbci	r31, 0xFD	; 253
    26d6:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
    26d8:	f9 01       	movw	r30, r18
    26da:	e0 52       	subi	r30, 0x20	; 32
    26dc:	fd 4f       	sbci	r31, 0xFD	; 253
    26de:	14 91       	lpm	r17, Z
	uint8_t port = digitalPinToPort(pin);
    26e0:	f9 01       	movw	r30, r18
    26e2:	ea 5d       	subi	r30, 0xDA	; 218
    26e4:	fc 4f       	sbci	r31, 0xFC	; 252
    26e6:	d4 91       	lpm	r29, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
    26e8:	dd 23       	and	r29, r29
    26ea:	c1 f0       	breq	.+48     	; 0x271c <digitalWrite+0x58>

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    26ec:	81 11       	cpse	r24, r1
    26ee:	46 df       	rcall	.-372    	; 0x257c <turnOffPWM>

	out = portOutputRegister(port);
    26f0:	2d 2f       	mov	r18, r29
    26f2:	30 e0       	ldi	r19, 0x00	; 0
    26f4:	f9 01       	movw	r30, r18
    26f6:	ee 0f       	add	r30, r30
    26f8:	ff 1f       	adc	r31, r31
    26fa:	ea 57       	subi	r30, 0x7A	; 122
    26fc:	fc 4f       	sbci	r31, 0xFC	; 252
    26fe:	a5 91       	lpm	r26, Z+
    2700:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
    2702:	8f b7       	in	r24, 0x3f	; 63
	cli();
    2704:	f8 94       	cli

	if (val == LOW) {
    2706:	c1 11       	cpse	r28, r1
    2708:	05 c0       	rjmp	.+10     	; 0x2714 <digitalWrite+0x50>
		*out &= ~bit;
    270a:	ec 91       	ld	r30, X
    270c:	10 95       	com	r17
    270e:	1e 23       	and	r17, r30
    2710:	1c 93       	st	X, r17
    2712:	03 c0       	rjmp	.+6      	; 0x271a <digitalWrite+0x56>
	} else {
		*out |= bit;
    2714:	ec 91       	ld	r30, X
    2716:	1e 2b       	or	r17, r30
    2718:	1c 93       	st	X, r17
	}

	SREG = oldSREG;
    271a:	8f bf       	out	0x3f, r24	; 63
}
    271c:	df 91       	pop	r29
    271e:	cf 91       	pop	r28
    2720:	1f 91       	pop	r17
    2722:	08 95       	ret

00002724 <digitalRead>:

int digitalRead(uint8_t pin)
{
    2724:	cf 93       	push	r28
    2726:	df 93       	push	r29
	uint8_t timer = digitalPinToTimer(pin);
    2728:	28 2f       	mov	r18, r24
    272a:	30 e0       	ldi	r19, 0x00	; 0
    272c:	f9 01       	movw	r30, r18
    272e:	e6 56       	subi	r30, 0x66	; 102
    2730:	fd 4f       	sbci	r31, 0xFD	; 253
    2732:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
    2734:	f9 01       	movw	r30, r18
    2736:	e0 52       	subi	r30, 0x20	; 32
    2738:	fd 4f       	sbci	r31, 0xFD	; 253
    273a:	d4 91       	lpm	r29, Z
	uint8_t port = digitalPinToPort(pin);
    273c:	f9 01       	movw	r30, r18
    273e:	ea 5d       	subi	r30, 0xDA	; 218
    2740:	fc 4f       	sbci	r31, 0xFC	; 252
    2742:	c4 91       	lpm	r28, Z

	if (port == NOT_A_PIN) return LOW;
    2744:	cc 23       	and	r28, r28
    2746:	91 f0       	breq	.+36     	; 0x276c <digitalRead+0x48>

	// If the pin that support PWM output, we need to turn it off
	// before getting a digital reading.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    2748:	81 11       	cpse	r24, r1
    274a:	18 df       	rcall	.-464    	; 0x257c <turnOffPWM>

	if (*portInputRegister(port) & bit) return HIGH;
    274c:	2c 2f       	mov	r18, r28
    274e:	30 e0       	ldi	r19, 0x00	; 0
    2750:	f9 01       	movw	r30, r18
    2752:	ee 0f       	add	r30, r30
    2754:	ff 1f       	adc	r31, r31
    2756:	e4 59       	subi	r30, 0x94	; 148
    2758:	fc 4f       	sbci	r31, 0xFC	; 252
    275a:	a5 91       	lpm	r26, Z+
    275c:	b4 91       	lpm	r27, Z
    275e:	ec 91       	ld	r30, X
    2760:	de 23       	and	r29, r30
    2762:	81 e0       	ldi	r24, 0x01	; 1
    2764:	90 e0       	ldi	r25, 0x00	; 0
    2766:	21 f4       	brne	.+8      	; 0x2770 <digitalRead+0x4c>
    2768:	80 e0       	ldi	r24, 0x00	; 0
    276a:	02 c0       	rjmp	.+4      	; 0x2770 <digitalRead+0x4c>
{
	uint8_t timer = digitalPinToTimer(pin);
	uint8_t bit = digitalPinToBitMask(pin);
	uint8_t port = digitalPinToPort(pin);

	if (port == NOT_A_PIN) return LOW;
    276c:	80 e0       	ldi	r24, 0x00	; 0
    276e:	90 e0       	ldi	r25, 0x00	; 0
	// before getting a digital reading.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	if (*portInputRegister(port) & bit) return HIGH;
	return LOW;
}
    2770:	df 91       	pop	r29
    2772:	cf 91       	pop	r28
    2774:	08 95       	ret

00002776 <__udivmodsi4>:
    2776:	a1 e2       	ldi	r26, 0x21	; 33
    2778:	1a 2e       	mov	r1, r26
    277a:	aa 1b       	sub	r26, r26
    277c:	bb 1b       	sub	r27, r27
    277e:	fd 01       	movw	r30, r26
    2780:	0d c0       	rjmp	.+26     	; 0x279c <__udivmodsi4_ep>

00002782 <__udivmodsi4_loop>:
    2782:	aa 1f       	adc	r26, r26
    2784:	bb 1f       	adc	r27, r27
    2786:	ee 1f       	adc	r30, r30
    2788:	ff 1f       	adc	r31, r31
    278a:	a2 17       	cp	r26, r18
    278c:	b3 07       	cpc	r27, r19
    278e:	e4 07       	cpc	r30, r20
    2790:	f5 07       	cpc	r31, r21
    2792:	20 f0       	brcs	.+8      	; 0x279c <__udivmodsi4_ep>
    2794:	a2 1b       	sub	r26, r18
    2796:	b3 0b       	sbc	r27, r19
    2798:	e4 0b       	sbc	r30, r20
    279a:	f5 0b       	sbc	r31, r21

0000279c <__udivmodsi4_ep>:
    279c:	66 1f       	adc	r22, r22
    279e:	77 1f       	adc	r23, r23
    27a0:	88 1f       	adc	r24, r24
    27a2:	99 1f       	adc	r25, r25
    27a4:	1a 94       	dec	r1
    27a6:	69 f7       	brne	.-38     	; 0x2782 <__udivmodsi4_loop>
    27a8:	60 95       	com	r22
    27aa:	70 95       	com	r23
    27ac:	80 95       	com	r24
    27ae:	90 95       	com	r25
    27b0:	9b 01       	movw	r18, r22
    27b2:	ac 01       	movw	r20, r24
    27b4:	bd 01       	movw	r22, r26
    27b6:	cf 01       	movw	r24, r30
    27b8:	08 95       	ret

000027ba <__tablejump2__>:
    27ba:	ee 0f       	add	r30, r30
    27bc:	ff 1f       	adc	r31, r31

000027be <__tablejump__>:
    27be:	05 90       	lpm	r0, Z+
    27c0:	f4 91       	lpm	r31, Z
    27c2:	e0 2d       	mov	r30, r0
    27c4:	19 94       	eijmp

000027c6 <__tablejump_elpm__>:
    27c6:	07 90       	elpm	r0, Z+
    27c8:	f6 91       	elpm	r31, Z
    27ca:	e0 2d       	mov	r30, r0
    27cc:	19 94       	eijmp

000027ce <_exit>:
    27ce:	f8 94       	cli

000027d0 <__stop_program>:
    27d0:	ff cf       	rjmp	.-2      	; 0x27d0 <__stop_program>
